{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 5,
          "max": 16,
          "average": 26.2,
          "sum": 131
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 1,
          "suggestion": 4,
          "ignore": 0,
          "total": 5
        },
        "syntax_errors": 39,
        "lines_of_code": 926,
        "homplexity_lines_of_code": 1156,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "92MB",
          "runtime": "1.17 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_90/pre_refactor/Setup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 2,
          "homplexity_lines_of_code": 3,
          "code_quality_score": 97.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 3,
            "homplexity_output": "Info:/tmp/project_90/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_90/pre_refactor/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_90/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_90/pre_refactor/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_90/pre_refactor/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_90/pre_refactor/Setup.hs\" 2 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Distribution.Simple\nmain = defaultMain\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_90/static_refactored/Setup.hs",
            "llm_only_refactored_file": "/tmp/project_90/llm_only_refactored/Setup.hs",
            "hybrid_refactored_file": "/tmp/project_90/hybrid_refactored/Setup.hs"
          }
        },
        {
          "file_name": "/tmp/project_90/pre_refactor/app/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.5,
            "sum": 18
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 136,
          "homplexity_lines_of_code": 192,
          "code_quality_score": 44.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.5,
              "sum": 18
            },
            "homplexity_loc": 192,
            "homplexity_output": "Info:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 1 1: module Main has 112 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 19 13: data Opts has record fields count of 4 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 26 20: data HardDropOpt has record fields count of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 28 1: type signature for opts has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 28 1: type signature for opts has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 29 1: function opts has 14 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 29 1: function opts has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 29 1: function opts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 44 1: type signature for toggle has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 44 1: type signature for toggle has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 45 1: function toggle has 6 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 45 1: function toggle has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 45 1: function toggle has cyclomatic complexity of 3 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 52 1: type signature for hardDropOpt has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 52 1: type signature for hardDropOpt has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 53 1: function hardDropOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 53 1: function hardDropOpt has 16 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 53 1: function hardDropOpt has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 71 1: type signature for fullopts has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 71 1: type signature for fullopts has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 72 1: function fullopts has 3 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 72 1: function fullopts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 72 1: function fullopts has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 76 1: type signature for twoChar has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 76 1: type signature for twoChar has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 77 1: function twoChar has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 77 1: function twoChar has 5 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 77 1: function twoChar has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 83 1: type signature for hdOptStr has 2 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 83 1: type signature for hdOptStr has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 84 1: function hdOptStr has 3 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 84 1: function hdOptStr has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 84 1: function hdOptStr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 88 1: type signature for main has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 88 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 89 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 89 1: function main has 9 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 89 1: function main has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 103 1: type signature for handleEndGame has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 103 1: type signature for handleEndGame has 2 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 104 1: function handleEndGame has 9 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 104 1: function handleEndGame has cyclomatic complexity of 3 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 104 1: function handleEndGame has branching depth of 2 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 115 1: type signature for printM has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 115 1: type signature for printM has 2 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 116 1: function printM has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 116 1: function printM has 2 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 116 1: function printM has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 119 1: type signature for getHighScore has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 119 1: type signature for getHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 120 1: function getHighScore has 6 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 120 1: function getHighScore has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 120 1: function getHighScore has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 127 1: type signature for setHighScore has 2 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 127 1: type signature for setHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 128 1: function setHighScore has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 128 1: function setHighScore has 3 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 128 1: function setHighScore has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 132 1: type signature for getLeaderboardFile has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 132 1: type signature for getLeaderboardFile has 1 arguments \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 133 1: function getLeaderboardFile has 4 lines of code \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 133 1: function getLeaderboardFile has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_90/pre_refactor/app/Main.hs\" 133 1: function getLeaderboardFile has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\nmodule Main where\n\nimport Control.Monad (when)\nimport System.Exit (exitSuccess)\nimport Text.Read (readMaybe)\nimport Data.Char (toLower)\nimport Data.Functor.Identity\n\nimport Options.Applicative\nimport qualified System.Directory as D\nimport System.FilePath ((</>))\n\nimport Tetris (Game(..))\nimport UI.PickLevel (configureLeveling, LevelConfig'(..))\nimport UI.Game (playGame)\n\ndata Opts = Opts\n  { hardDrop :: HardDropOpt\n  , level :: Maybe Int\n  , progression :: Maybe Bool\n  , score :: Bool\n  }\n\ndata HardDropOpt = None | AsciiOnly | CustomChars String\n\nopts :: Parser Opts\nopts = Opts\n  <$> hardDropOpt\n  <*> optional (option auto\n    (  long \"level\"\n    <> short 'l'\n    <> metavar \"LEVEL\"\n    <> help \"Specify level (unspecified results in prompt)\" ))\n  <*> optional (option toggle\n    (  long \"progression\"\n    <> metavar \"BOOL\"\n    <> help \"Turn level progression ON/OFF (unspecified results in prompt)\" ))\n  <*> switch\n    (  long \"high-score\"\n    <> help \"Print high score and exit\" )\n\ntoggle :: ReadM Bool\ntoggle = do\n  s <- str\n  case toLower <$> s of\n    y | y `elem` [\"y\", \"yes\", \"on\", \"t\", \"true\"] -> return True\n    n | n `elem` [\"n\", \"no\", \"off\", \"f\", \"false\"] -> return False\n    _   -> readerError \"Must be 'Y' or 'N'\"\n\nhardDropOpt :: Parser HardDropOpt\nhardDropOpt = noneOpt <|> asciiOpt <|> custOpt\n  where\n    noneOpt = flag' None\n      (  long \"no-preview\"\n      <> short 'n'\n      <> help \"Don't show preview cell\" )\n    asciiOpt = flag' AsciiOnly\n      (  long \"ascii-only\"\n      <> short 'a'\n      <> help \"Use '[]' as hard drop preview cell\" )\n    custOpt = CustomChars <$> option twoChar\n      (  long \"preview-chars\"\n      <> short 'p'\n      <> metavar \"CHARS\"\n      <> value \"\u25e4\u25e2\"\n      <> showDefaultWith (const \"\u25e4\u25e2\")\n      <> help \"Customize two character preview cell\" )\n\nfullopts :: ParserInfo Opts\nfullopts = info (helper <*> opts)\n  (  fullDesc\n  <> header \"tetris - the iconic game right in your terminal\" )\n\ntwoChar :: ReadM String\ntwoChar = do\n  cs <- str\n  if length cs /= 2\n     then readerError \"Preview must be two characters long\"\n     else return cs\n\nhdOptStr :: HardDropOpt -> Maybe String\nhdOptStr None            = Nothing\nhdOptStr AsciiOnly       = Just \"[]\"\nhdOptStr (CustomChars s) = Just s\n\nmain :: IO ()\nmain = do\n  (Opts {..}) <- execParser fullopts\n  -- show high score and exit\n  when score (getHighScore >>= printM >> exitSuccess)\n  -- pick level prompt if necessary\n  levelConfig <- configureLeveling level progression\n  -- play game\n  g <- playGame\n    (runIdentity levelConfig.level)\n    (runIdentity levelConfig.progression)\n    (hdOptStr hardDrop)\n  -- save & print score\n  handleEndGame (_score g)\n\nhandleEndGame :: Int -> IO ()\nhandleEndGame s = do\n  mhs <- getHighScore\n  case mhs of\n    Nothing -> newHighScore\n    Just hs -> if s <= hs then justShowScore else newHighScore\n  where\n    justShowScore = putStrLn $ \"Your final score: \" ++ show s\n    newHighScore = do\n      putStrLn $ \"Congrats! You just got the new highest score: \" ++ show s\n      setHighScore s\n\nprintM :: Show a => Maybe a -> IO ()\nprintM Nothing  = putStrLn \"None\"\nprintM (Just s) = print s\n\ngetHighScore :: IO (Maybe Int)\ngetHighScore = do\n  lb <- getLeaderboardFile\n  exists <- D.doesFileExist lb\n  if exists\n     then readMaybe <$> readFile lb\n     else return Nothing\n\nsetHighScore :: Int -> IO ()\nsetHighScore s = do\n  lb <- getLeaderboardFile\n  writeFile lb (show s)\n\ngetLeaderboardFile :: IO FilePath\ngetLeaderboardFile = do\n  xdg <- D.getXdgDirectory D.XdgData \"tetris\"\n  D.createDirectoryIfMissing True xdg\n  return (xdg </> \"leaderboard\")\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_90/static_refactored/app/Main.hs",
            "llm_only_refactored_file": "/tmp/project_90/llm_only_refactored/app/Main.hs",
            "hybrid_refactored_file": "/tmp/project_90/hybrid_refactored/app/Main.hs"
          }
        },
        {
          "file_name": "/tmp/project_90/pre_refactor/src/Tetris.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 7,
            "average": 2,
            "sum": 49
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 11,
          "lines_of_code": 338,
          "homplexity_lines_of_code": 338,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 7,
              "average": 2,
              "sum": 49
            },
            "homplexity_loc": 338,
            "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"evalTetris\": 1,\n    \"initBlock\": 1,\n    \"relCells\": 7,\n    \"rotateRaw\": 3,\n    \"coords\": 1,\n    \"bagFourTetriminoEach\": 2,\n    \"initGame\": 1,\n    \"nextLevel\": 1,\n    \"isGameOver\": 2,\n    \"timeStep\": 2,\n    \"gravitate\": 1,\n    \"clearFullRows\": 1,\n    \"updateScore\": 2,\n    \"levelFinished\": 2,\n    \"rotate\": 1,\n    \"blockStopped\": 1,\n    \"isStopped\": 1,\n    \"hardDrop\": 1,\n    \"hardDroppedBlock\": 1,\n    \"freezeBlock\": 1,\n    \"nextBlock\": 1,\n    \"shift\": 2,\n    \"isFree\": 1,\n    \"isInBounds\": 3,\n    \"isValidBlockPosition\": 1,\n    \"shuffle\": 3,\n    \"v2\": 1,\n    \"translateBy_Coord\": 3,\n    \"translateBy_Block\": 1,\n    \"min\": 1,\n    \"max\": 7,\n    \"average\": 1.6896551724,\n    \"sum\": 49\n  },\n  \"homplexity_loc\": 338,\n  \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Tetris\n  (\n  -- Game state modifiers\n    initGame\n  , timeStep\n  , shift\n  , rotate\n  , hardDrop\n  -- Game state handlers\n  , evalTetris\n  -- Game state queries\n  , isGameOver\n  , hardDroppedBlock\n  , coords\n  -- Types\n  , Block(..)\n  , Coord\n  , Direction(..)\n  , Game(..)\n  , Tetrimino(..)\n  , Tetris\n  -- Lenses\n  , block, board, level, nextShape, score, shape, linesCleared, progression\n  -- Constants\n  , boardHeight, boardWidth, relCells\n  ) where\n\nimport Prelude hiding (Left, Right, lines)\nimport Control.Applicative ((<|>))\nimport Control.Monad (forM_, mfilter, when, (<=<))\nimport Control.Monad.Extra (whenM, andM)\n\nimport Control.Monad.IO.Class (MonadIO(..), liftIO)\nimport Control.Monad.State.Class (MonadState, gets)\nimport Control.Monad.Trans.State (evalStateT)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Sequence (Seq(..), (><))\nimport qualified Data.Sequence as Seq\nimport Control.Lens hiding (Empty)\nimport Linear.V2 (V2(..), _y)\nimport qualified Linear.V2 as LV\nimport System.Random (getStdRandom, randomR)\n\n-- Types and instances\n\n-- | Tetris shape types\ndata Tetrimino = I | O | T | S | Z | J | L\n  deriving (Eq, Show, Enum)\n\n-- | Coordinates\ntype Coord = V2 Int\n\n-- | Tetris shape in location context\ndata Block = Block\n  { _shape  :: Tetrimino -- ^ block type\n  , _origin :: Coord -- ^ origin\n  , _extra  :: [Coord] -- ^ extraneous cells\n  } deriving (Eq, Show)\n\nmakeLenses ''Block\n\ndata Direction = Left | Right | Down\n  deriving (Eq, Show)\n\n-- | Board\n--\n-- If coordinate not present in map, yet in bounds, then it is empty,\n-- otherwise its value is the type of tetrimino occupying it.\ntype Board = Map Coord Tetrimino\n\n-- | Game state\ndata Game = Game\n  { _level        :: Int\n  , _block        :: Block\n  , _nextShape    :: Tetrimino\n  , _nextShapeBag :: Seq.Seq Tetrimino\n  , _linesCleared :: Int\n  , _score        :: Int\n  , _board        :: Board\n  , _progression  :: Bool\n  } deriving (Eq)\nmakeLenses ''Game\n\nevalTetris :: Tetris a -> Game -> a\nevalTetris m = runIdentity . evalStateT m\n\ntype Tetris a = forall m. MonadState Game m => m a\n\n-- Translate class for direct translations, without concern for boundaries\n-- 'shift' concerns safe translations with boundaries\nclass Translatable s where\n  translate :: Direction -> s -> s\n  translate = translateBy 1\n  translateBy :: Int -> Direction -> s -> s\n\ninstance Translatable Coord where\n  translateBy n Left (V2 x y)  = V2 (x-n) y\n  translateBy n Right (V2 x y) = V2 (x+n) y\n  translateBy n Down (V2 x y)  = V2 x (y-n)\n\ninstance Translatable Block where\n  translateBy n d b =\n    b & origin %~ translateBy n d\n      & extra  %~ fmap (translateBy n d)\n\n-- Low level functions on blocks and coordinates\n\ninitBlock :: Tetrimino -> Block\ninitBlock t = Block t startOrigin . fmap (+ startOrigin) . relCells $ t\n\nrelCells :: Tetrimino -> [Coord]\nrelCells I = map v2 [(-2, 0), (-1, 0), (1, 0)]\nrelCells O = map v2 [(-1, 0), (-1, -1), (0, -1)]\nrelCells S = map v2 [(-1, -1), (0, -1), (1, 0)]\nrelCells Z = map v2 [(-1, 0), (0, -1), (1, -1)]\nrelCells L = map v2 [(-1, -1), (-1, 0), (1, 0)]\nrelCells J = map v2 [(-1, 0), (1, 0), (1, -1)]\nrelCells T = map v2 [(-1, 0), (0, -1), (1, 0)]\n\n-- | Visible, active board size\nboardWidth, boardHeight :: Int\nboardWidth = 10\nboardHeight = 20\n\n-- | Starting block origin\nstartOrigin :: Coord\nstartOrigin = V2 6 22\n\n-- | Rotate block counter clockwise about origin\n-- *Note*: Strict unsafe rotation not respecting boundaries\n-- Safety can only be assured within Game context\nrotateRaw :: Block -> Block\nrotateRaw b@(Block s o@(V2 xo yo) cs)\n  | -- O doesn't need rotation\n    s == O                             = b\n  | -- I only has two orientations\n    s == I && V2 xo (yo + 1) `elem` cs = rotateWith clockwise\n  | otherwise                          = rotateWith counterclockwise\n where\n  clockwise        = (+ o) . cwperp . subtract o\n  counterclockwise = (+ o) . LV.perp . subtract o\n  rotateWith dir = b & extra %~ fmap dir\n  cwperp (V2 x y) = V2 y (-x)\n\n-- | Get coordinates of entire block\ncoords :: Block -> [Coord]\ncoords b = b ^. origin : b ^. extra\n\n-- Higher level functions on game and board\n\n-- | Facilitates cycling through at least 4 occurences of each shape\n-- before next bag (random permutation of 4*each tetrimino) is created. If input is empty,\n-- generates new bag, otherwise just unshifts the first value and returns pair.\nbagFourTetriminoEach :: Seq.Seq Tetrimino -> IO (Tetrimino, Seq.Seq Tetrimino)\nbagFourTetriminoEach (t :<| ts) = pure (t, ts)\nbagFourTetriminoEach Empty =\n  bagFourTetriminoEach <=< shuffle . Seq.fromList . take 28 $ cycle [I ..]\n\n-- | Initialize a game with a given level\ninitGame :: Int -> Bool -> IO Game \ninitGame lvl prog = do\n  (s1, bag1) <- bagFourTetriminoEach mempty\n  (s2, bag2) <- bagFourTetriminoEach bag1\n  pure $ Game\n    { _level        = lvl\n    , _block        = initBlock s1\n    , _nextShape    = s2\n    , _nextShapeBag = bag2\n    , _score        = 0\n    , _linesCleared = 0\n    , _board        = mempty\n    , _progression  = prog  \n    }\n\n-- | Increment level\nnextLevel :: (MonadIO m, MonadState Game m) => m ()\nnextLevel = do\n  level %= (+ 1)\n\nisGameOver :: Game -> Bool\nisGameOver g = blockStopped g && g ^. (block . origin) == startOrigin\n\n-- | The main game execution, this is executed at each discrete time step\ntimeStep :: (MonadIO m, MonadState Game m) => m ()\ntimeStep = do\n  gets blockStopped >>= \\case\n    False -> gravitate\n    True -> do\n      freezeBlock\n      clearFullRows >>= updateScore\n      whenM (andM [use progression, levelFinished]) nextLevel\n      nextBlock\n\n-- | Gravitate current block, i.e. shift down\ngravitate :: MonadState Game m => m ()\ngravitate = shift Down\n\n-- | If necessary: clear full rows and return the count\nclearFullRows :: MonadState Game m => m Int\nclearFullRows = do\n  brd <- use board\n  let rowSize r = length $ M.filterWithKey (\\(V2 _ y) _ -> r == y) brd\n      fullRows = filter (\\r -> boardWidth == rowSize r) [1 .. boardHeight]\n  -- Clear cells in full rows\n  modifying board $ M.filterWithKey $ \\(V2 _ y) _ -> y `notElem` fullRows\n  -- Shift cells above full rows\n  modifying board $ M.mapKeysMonotonic $ over _y $ \\y ->\n    y - length (filter (< y) fullRows)\n  let clearedLines = length fullRows\n  linesCleared %= (+ clearedLines)\n  pure clearedLines\n\n-- | This updates game points with respect to the provided number of cleared\n-- lines.\n--\n-- See https://tetris.fandom.com/wiki/Scoring\nupdateScore :: (MonadState Game m, MonadIO m) => Int -> m ()\nupdateScore 0 = pure ()\nupdateScore lines = do\n  lvl <- use level\n  let newPoints = (lvl + 1) * points lines\n  score %= (+ newPoints)\n  where\n    -- Translate row line clears to points\n    points 0 = 0\n    points 1 = 40\n    points 2 = 100\n    points 3 = 300\n    points _ = 1200\n\n-- | Using the fixed-goal system described here: https://tetris.wiki/Marathon\nlevelFinished :: (MonadState Game m, MonadIO m) => m Bool\nlevelFinished = do\n  lvl <- use level\n  lc <- use linesCleared\n  pure $ lvl < 15 && lc >= 10 * (lvl + 1)\n\n-- | Handle counterclockwise block rotation (if possible)\n-- Allows wallkicks: http://tetris.wikia.com/wiki/TGM_rotation\nrotate :: MonadState Game m => m ()\nrotate = do\n  blk <- use block\n  brd <- use board\n  let mblk = foldr (<|>) Nothing\n        $   mfilter (isValidBlockPosition brd)\n        .   pure\n        .   ($ blk)\n        <$> [ rotateRaw\n            , rotateRaw . translate Left\n            , rotateRaw . translate Right\n            ]\n  forM_ mblk $ assign block\n\nblockStopped :: Game -> Bool\nblockStopped g = isStopped (g ^. board) (g ^. block)\n\n-- | Check if a block on a board is stopped from further gravitation\nisStopped :: Board -> Block -> Bool\nisStopped brd = any stopped . coords\n where\n  stopped = (||) <$> atBottom <*> (`M.member` brd) . translate Down\n  atBottom = (== 1) . view _y\n\nhardDrop :: MonadState Game m => m ()\nhardDrop = hardDroppedBlock >>= assign block\n\nhardDroppedBlock :: MonadState Game m => m Block\nhardDroppedBlock = do\n  boardCoords <- M.keys <$> use board\n  blockCoords <- coords <$> use block\n  let diffs =\n        [ y - yo\n        | (V2 xo yo) <- boardCoords\n        , (V2 x  y ) <- blockCoords\n        , xo == x\n        , yo < y\n        ]\n      minY = minimum $ view _y <$> blockCoords\n      dist = minimum $ subtract 1 <$> (minY : diffs)\n  translateBy dist Down <$> use block\n\n-- | Freeze current block\nfreezeBlock :: MonadState Game m => m ()\nfreezeBlock = do\n  blk <- use block\n  modifying board $ M.union $ M.fromList [ (c, _shape blk) | c <- coords blk ]\n\n-- | Replace block with next block\nnextBlock :: (MonadIO m, MonadState Game m) => m ()\nnextBlock = do\n  bag <- use nextShapeBag\n  (t, ts) <- liftIO $ bagFourTetriminoEach bag\n  use nextShape >>= \\s -> block .= initBlock s\n  nextShape .= t\n  nextShapeBag .= ts\n\n-- | Try to shift current block; if shifting not possible, leave block where it is\nshift :: MonadState Game m => Direction -> m ()\nshift dir = do\n  brd <- use board\n  blk <- use block\n  let candidate = translate dir blk\n  when (isValidBlockPosition brd candidate) $\n    block .= candidate\n\n-- | Check if coordinate is already occupied or free in board\nisFree :: Board -> Coord -> Bool\nisFree = flip M.notMember\n\n-- | Check if coordinate is in or out of bounds\nisInBounds :: Coord -> Bool\nisInBounds (V2 x y) = 1 <= x && x <= boardWidth && 1 <= y\n\n-- | Checks if block's potential new location is valid\nisValidBlockPosition :: Board -> Block -> Bool\nisValidBlockPosition brd = all validCoord . coords\n  where validCoord = (&&) <$> isFree brd <*> isInBounds\n\n-- General utilities\n\n-- | Shuffle a sequence (random permutation)\nshuffle :: Seq.Seq a -> IO (Seq.Seq a)\nshuffle xs\n  | null xs = mempty\n  | otherwise = do\n    randomPosition <- getStdRandom (randomR (0, length xs - 1))\n    case Seq.splitAt randomPosition xs of\n      (left, y :<| ys) ->  fmap (y <|) (shuffle $ left >< ys)\n      _ -> error \"impossible\"\n\nv2 :: (a, a) -> V2 a\nv2 (x, y) = V2 x y\n",
          "suggestions": [
            {
              "module": [
                "Tetris"
              ],
              "decl": [
                "rotate"
              ],
              "severity": "Suggestion",
              "hint": "Fuse foldr/<$>",
              "file": "/tmp/project_90/pre_refactor/src/Tetris.hs",
              "startLine": 250,
              "startColumn": 14,
              "endLine": 257,
              "endColumn": 14,
              "from": "foldr (<|>) Nothing\n  $ mfilter (isValidBlockPosition brd) . pure . ($ blk)\n      <$>\n        [rotateRaw, rotateRaw . translate Left,\n         rotateRaw . translate Right]",
              "to": "foldr\n  ((<|>) . mfilter (isValidBlockPosition brd) . pure . ($ blk))\n  Nothing\n  [rotateRaw, rotateRaw . translate Left,\n   rotateRaw . translate Right]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 250, startCol = 14, endLine = 257, endCol = 14}, subts = [(\"f\",SrcSpan {startLine = 250, startCol = 20, endLine = 250, endCol = 25}),(\"g\",SrcSpan {startLine = 251, startCol = 13, endLine = 253, endCol = 20}),(\"x\",SrcSpan {startLine = 254, startCol = 13, endLine = 257, endCol = 14}),(\"z\",SrcSpan {startLine = 250, startCol = 26, endLine = 250, endCol = 33})], orig = \"foldr ((f) . g) z x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_90/static_refactored/src/Tetris.hs",
            "llm_only_refactored_file": "/tmp/project_90/llm_only_refactored/src/Tetris.hs",
            "hybrid_refactored_file": "/tmp/project_90/hybrid_refactored/src/Tetris.hs"
          }
        },
        {
          "file_name": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.2222222222222223,
            "sum": 11
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 6,
          "lines_of_code": 101,
          "homplexity_lines_of_code": 135,
          "code_quality_score": 64.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.2222222222222223,
              "sum": 11
            },
            "homplexity_loc": 135,
            "homplexity_output": "Info:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 1 1: module UI.PickLevel has 82 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 24 23: data LevelConfig' has record fields count of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 29 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 29 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 30 1: function app has 7 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 30 1: function app has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 30 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 40 1: type signature for selectedAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 40 1: type signature for selectedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 41 1: function selectedAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 41 1: function selectedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 41 1: function selectedAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 43 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 43 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 44 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 44 1: function drawUI has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 44 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 46 1: type signature for ui has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 46 1: type signature for ui has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 47 1: function ui has 14 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 47 1: function ui has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 47 1: function ui has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 63 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 63 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 64 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 64 1: function handleEvent has 12 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 64 1: function handleEvent has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 77 1: type signature for pickLevel has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 77 1: type signature for pickLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 78 1: function pickLevel has 5 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 78 1: function pickLevel has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 78 1: function pickLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 84 1: type signature for pickProgression has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 84 1: type signature for pickProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 85 1: function pickProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 85 1: function pickProgression has 4 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 85 1: function pickProgression has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 90 1: type signature for pickingLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 90 1: type signature for pickingLevel has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 91 1: function pickingLevel has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 91 1: function pickingLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 91 1: function pickingLevel has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 93 1: type signature for configureLeveling has 3 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 93 1: type signature for configureLeveling has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 94 1: function configureLeveling has 8 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 94 1: function configureLeveling has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/PickLevel.hs\" 94 1: function configureLeveling has branching depth of 2 \n"
          },
          "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n\nmodule UI.PickLevel\n  ( configureLeveling\n  , LevelConfig'(..)\n  ) where\n\nimport System.Exit\nimport Control.Monad\nimport Control.Monad.Extra\nimport Data.Functor.Identity\nimport Data.Maybe\n\nimport Brick\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport qualified Graphics.Vty as V\n\ntype LevelConfig = LevelConfig' Identity\ntype LevelConfigMaybe = LevelConfig' Maybe\n\ndata LevelConfig' t = LevelConfig\n  { level :: t Int\n  , progression :: t Bool\n  }\n\napp :: App LevelConfigMaybe e ()\napp = App\n  { appDraw         = drawUI\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const $ attrMap V.defAttr\n      [ (selectedAttr, V.black `on` V.white)\n      ]\n  , appChooseCursor = neverShowCursor\n  }\n\nselectedAttr :: AttrName\nselectedAttr = attrName \"selected\"\n\ndrawUI :: LevelConfigMaybe -> [Widget ()]\ndrawUI ps = [ui ps]\n\nui :: LevelConfigMaybe -> Widget ()\nui ps =\n  padLeft (Pad 19)\n    $ padRight (Pad 21)\n    $ C.center\n    $ vLimit 22\n    $ hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ C.center\n    $ if (isNothing ps.level)\n        then str \"Choose Level (0-9)\"\n        else vBox\n        [ C.hCenter $ str \"Level Progression?\"\n        , C.hCenter $ str \"([Y]/N)\"\n        ]\n\nhandleEvent :: BrickEvent () e -> EventM () LevelConfigMaybe ()\nhandleEvent (VtyEvent (V.EvKey V.KEsc        _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'N') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'n') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey V.KEnter []))     = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar d) [])) =\n  when (d `elem` ['0' .. '9']) $ pickLevel $ read [d]\nhandleEvent _ = pure ()\n\npickLevel :: Int -> EventM () LevelConfigMaybe ()\npickLevel n = do\n  whenM pickingLevel $ do\n    modify $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) $ do\n      halt\n\npickProgression :: Bool -> EventM () LevelConfigMaybe ()\npickProgression b = do\n  unlessM pickingLevel $ do\n    modify $ \\s -> s { progression = Just b }\n    halt\n\npickingLevel :: EventM () LevelConfigMaybe Bool\npickingLevel = gets (isNothing . level)\n\nconfigureLeveling :: Maybe Int -> Maybe Bool -> IO LevelConfig\nconfigureLeveling (Just l) (Just p) = pure $ LevelConfig (Identity l) (Identity p)\nconfigureLeveling ml mp = do\n  result <- defaultMain app $ LevelConfig ml mp\n  case result of\n    (LevelConfig {level = Just l, progression = Just p}) ->\n      pure $ LevelConfig (Identity l) (Identity p)\n    _ ->\n      exitSuccess\n",
          "suggestions": [
            {
              "module": [
                "UI.PickLevel"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 33,
              "from": "{-# LANGUAGE RecordWildCards #-}",
              "to": "",
              "note": [
                "may require `{-# LANGUAGE DisambiguateRecordFields #-}` adding to the top of the file"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 33}, newComment = \"\"}]"
            },
            {
              "module": [
                "UI.PickLevel"
              ],
              "decl": [
                "ui"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
              "startLine": 56,
              "startColumn": 10,
              "endLine": 56,
              "endColumn": 30,
              "from": "if (isNothing ps.level) then\n    str \"Choose Level (0-9)\"\nelse\n    vBox\n      [C.hCenter $ str \"Level Progression?\", C.hCenter $ str \"([Y]/N)\"]",
              "to": "if isNothing ps.level then\n    str \"Choose Level (0-9)\"\nelse\n    vBox\n      [C.hCenter $ str \"Level Progression?\", C.hCenter $ str \"([Y]/N)\"]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 56, startCol = 10, endLine = 56, endCol = 30}, subts = [(\"x\",SrcSpan {startLine = 56, startCol = 11, endLine = 56, endCol = 29})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_90/static_refactored/src/UI/PickLevel.hs",
            "llm_only_refactored_file": "/tmp/project_90/llm_only_refactored/src/UI/PickLevel.hs",
            "hybrid_refactored_file": "/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs"
          }
        },
        {
          "file_name": "/tmp/project_90/pre_refactor/src/UI/Game.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.1304347826086956,
            "sum": 52
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 2,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 15,
          "lines_of_code": 349,
          "homplexity_lines_of_code": 488,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.1304347826086956,
              "sum": 52
            },
            "homplexity_loc": 488,
            "homplexity_output": "Info:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 1 1: module UI.Game has 282 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 32 11: data UI has record fields count of 6 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 44 13: data Tick has record fields count of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 50 5: data VisualBlock has record fields count of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 55 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 55 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 56 1: function app has 6 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 56 1: function app has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 56 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 64 1: type signature for playGame has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 64 1: type signature for playGame has 4 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 69 1: function playGame has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 69 1: function playGame has 18 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 69 1: function playGame has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 89 1: type signature for levelToDelay has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 89 1: type signature for levelToDelay has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 90 1: function levelToDelay has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 90 1: function levelToDelay has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 90 1: function levelToDelay has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 94 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 94 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 95 1: function handleEvent has cyclomatic complexity of 1 \nWarning:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 95 1: function handleEvent has 27 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 95 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 127 1: type signature for exec has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 127 1: type signature for exec has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 128 1: function exec has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 128 1: function exec has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 128 1: function exec has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 131 1: type signature for restart has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 131 1: type signature for restart has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 132 1: function restart has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 132 1: function restart has 6 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 132 1: function restart has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 139 1: type signature for toggleProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 139 1: type signature for toggleProgression has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 140 1: function toggleProgression has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 140 1: function toggleProgression has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 140 1: function toggleProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 144 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 144 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 145 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 145 1: function drawUI has 5 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 145 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 153 1: type signature for drawGrid has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 153 1: type signature for drawGrid has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 154 1: function drawGrid has 18 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 154 1: function drawGrid has cyclomatic complexity of 3 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 154 1: function drawGrid has branching depth of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 175 1: type signature for emptyCellMap has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 175 1: type signature for emptyCellMap has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 176 1: function emptyCellMap has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 176 1: function emptyCellMap has 2 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 176 1: function emptyCellMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 179 1: type signature for emptyGridCellW has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 179 1: type signature for emptyGridCellW has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 180 1: function emptyGridCellW has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 180 1: function emptyGridCellW has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 180 1: function emptyGridCellW has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 182 1: type signature for emptyNextShapeCellW has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 182 1: type signature for emptyNextShapeCellW has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 183 1: function emptyNextShapeCellW has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 183 1: function emptyNextShapeCellW has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 183 1: function emptyNextShapeCellW has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 185 1: type signature for drawBlockCell has 3 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 185 1: type signature for drawBlockCell has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 186 1: function drawBlockCell has 2 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 186 1: function drawBlockCell has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 186 1: function drawBlockCell has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 189 1: type signature for tToAttr has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 189 1: type signature for tToAttr has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 190 1: function tToAttr has 7 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 190 1: function tToAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 190 1: function tToAttr has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 198 1: type signature for tToAttrH has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 198 1: type signature for tToAttrH has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 199 1: function tToAttrH has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 199 1: function tToAttrH has 7 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 199 1: function tToAttrH has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 207 1: type signature for cw has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 207 1: type signature for cw has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 208 1: function cw has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 208 1: function cw has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 208 1: function cw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 210 1: type signature for ecw has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 210 1: type signature for ecw has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 211 1: function ecw has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 211 1: function ecw has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 211 1: function ecw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 213 1: type signature for drawStats has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 213 1: type signature for drawStats has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 214 1: function drawStats has 10 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 214 1: function drawStats has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 214 1: function drawStats has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 226 1: type signature for drawProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 226 1: type signature for drawProgression has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 227 1: function drawProgression has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 227 1: function drawProgression has 5 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 227 1: function drawProgression has cyclomatic complexity of 3 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 233 1: type signature for drawStat has 3 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 233 1: type signature for drawStat has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 234 1: function drawStat has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 234 1: function drawStat has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 234 1: function drawStat has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 236 1: type signature for drawLeaderBoard has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 236 1: type signature for drawLeaderBoard has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 237 1: function drawLeaderBoard has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 237 1: function drawLeaderBoard has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 237 1: function drawLeaderBoard has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 239 1: type signature for drawInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 239 1: type signature for drawInfo has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 240 1: function drawInfo has 5 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 240 1: function drawInfo has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 240 1: function drawInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 247 1: type signature for drawNextShape has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 247 1: type signature for drawNextShape has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 248 1: function drawNextShape has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 248 1: function drawNextShape has 13 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 248 1: function drawNextShape has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 263 1: type signature for drawHelp has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 263 1: type signature for drawHelp has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 264 1: function drawHelp has 15 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 264 1: function drawHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 264 1: function drawHelp has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 281 1: type signature for drawKeyInfo has 3 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 281 1: type signature for drawKeyInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 282 1: function drawKeyInfo has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 282 1: function drawKeyInfo has 3 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 282 1: function drawKeyInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 286 1: type signature for drawGameOver has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 286 1: type signature for drawGameOver has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 287 1: function drawGameOver has 4 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 287 1: function drawGameOver has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 287 1: function drawGameOver has cyclomatic complexity of 2 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 292 1: type signature for theMap has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 292 1: type signature for theMap has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 293 1: function theMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 293 1: function theMap has 19 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 293 1: function theMap has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 314 1: type signature for tToColor has 2 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 314 1: type signature for tToColor has type constructor nesting of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 315 1: function tToColor has 7 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 315 1: function tToColor has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 315 1: function tToColor has branching depth of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 323 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 323 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 324 1: function iAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 324 1: function iAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 324 1: function iAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 325 1: function oAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 325 1: function oAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 325 1: function oAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 326 1: function tAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 326 1: function tAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 326 1: function tAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 327 1: function sAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 327 1: function sAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 327 1: function sAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 328 1: function zAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 328 1: function zAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 328 1: function zAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 329 1: function jAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 329 1: function jAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 329 1: function jAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 330 1: function lAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 330 1: function lAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 330 1: function lAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 332 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 332 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 333 1: function ihAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 333 1: function ihAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 333 1: function ihAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 334 1: function ohAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 334 1: function ohAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 334 1: function ohAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 335 1: function thAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 335 1: function thAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 335 1: function thAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 336 1: function shAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 336 1: function shAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 336 1: function shAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 337 1: function zhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 337 1: function zhAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 337 1: function zhAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 338 1: function jhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 338 1: function jhAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 338 1: function jhAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 339 1: function lhAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 339 1: function lhAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 339 1: function lhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 341 1: type signature for emptyAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 341 1: type signature for emptyAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 342 1: function emptyAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 342 1: function emptyAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 342 1: function emptyAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 344 1: type signature for gameOverAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 344 1: type signature for gameOverAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 345 1: function gameOverAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 345 1: function gameOverAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 345 1: function gameOverAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 347 1: type signature for progressionAttr, fixedAttr has 1 arguments \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 347 1: type signature for progressionAttr, fixedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 348 1: function progressionAttr has branching depth of 0 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 348 1: function progressionAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 348 1: function progressionAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 349 1: function fixedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 349 1: function fixedAttr has 1 lines of code \nInfo:/tmp/project_90/pre_refactor/src/UI/Game.hs:SrcLoc \"/tmp/project_90/pre_refactor/src/UI/Game.hs\" 349 1: function fixedAttr has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\nmodule UI.Game\n  ( playGame\n  ) where\n\nimport Control.Concurrent (threadDelay, forkIO)\nimport Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, writeTVar, atomically)\nimport Control.Monad (void, forever)\nimport Prelude hiding (Left, Right)\n\nimport Brick hiding (Down)\nimport Brick.BChan\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport Control.Lens hiding (preview, op, zoom)\nimport Control.Monad.Extra (orM, unlessM)\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Graphics.Vty as V\nimport qualified Graphics.Vty.CrossPlatform\nimport qualified Graphics.Vty.Config\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Linear.V2 (V2(..))\n\nimport Tetris\n\ndata UI = UI\n  { _game      :: Game\n  , _initLevel :: Int\n  , _currLevel :: TVar Int\n  , _preview   :: Maybe String\n  , _locked    :: Bool\n  , _paused    :: Bool\n  }\n\nmakeLenses ''UI\n\n-- | Ticks mark passing of time\ndata Tick = Tick\n\n-- | Named resources\ntype Name = ()\n\ndata VisualBlock\n  = NormalBlock\n  | HardDropBlock String\n\n-- App definition and execution\n\napp :: App UI Tick Name\napp = App\n  { appDraw         = drawUI\n  , appChooseCursor = neverShowCursor\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const theMap\n  }\n\nplayGame\n  :: Int          -- ^ Starting level\n  -> Bool         -- ^ Enable level progression\n  -> Maybe String -- ^ Preview cell (Nothing == no preview)\n  -> IO Game\nplayGame lvl prog mp = do\n  chan <- newBChan 10   -- share the current level with the thread so it can adjust speed\n  tv <- newTVarIO lvl\n  void . forkIO $ forever $ do\n    writeBChan chan Tick\n    lvl' <- readTVarIO tv\n    threadDelay $ levelToDelay lvl'\n  initialGame <- initGame lvl prog  -- Pass the progression parameter\n  let buildVty = Graphics.Vty.CrossPlatform.mkVty Graphics.Vty.Config.defaultConfig\n  initialVty <- buildVty\n  ui <- customMain initialVty buildVty (Just chan) app $ UI\n    { _game      = initialGame\n    , _initLevel = lvl\n    , _currLevel = tv\n    , _preview   = mp\n    , _locked    = False\n    , _paused    = False\n    }\n  return $ ui ^. game\n\nlevelToDelay :: Int -> Int\nlevelToDelay n = floor $ 400000 * (0.85 :: Double) ^ (2 * n)\n\n-- Handling events\n\nhandleEvent :: BrickEvent Name Tick -> EventM Name UI ()\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'r') [])) = restart\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') [])) = halt\nhandleEvent (VtyEvent (V.EvKey V.KEsc        [])) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'm') [])) = exec toggleProgression\nhandleEvent (VtyEvent (V.EvKey V.KRight      [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey V.KLeft       [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey V.KDown       [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'l') [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'h') [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'j') [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey V.KUp         [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'k') [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') [])) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game hardDrop\n    assign locked True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'p') [])) =\n  unlessM (orM [use locked, use (game . to isGameOver)]) $ do\n    modifying paused not\nhandleEvent (AppEvent Tick                      ) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game timeStep\n    -- Keep level in sync with ticker (gross)\n    lvl <- use $ game . level\n    tv <- use $ currLevel\n    liftIO . atomically $ writeTVar tv lvl\n    assign locked False\nhandleEvent _ = pure ()\n\n-- | This common execution function is used for all game user input except hard\n-- drop and pause. If paused or locked (from hard drop) do nothing, else\n-- execute the state computation.\nexec :: Tetris () -> EventM Name UI ()\nexec = unlessM (orM [use paused, use locked, use (game . to isGameOver)]) . zoom game\n\n-- | Restart game at the initially chosen level\nrestart :: EventM Name UI ()\nrestart = do\n  lvl <- use initLevel\n  prog <- use (game . progression)  -- Get current progression setting\n  g <- liftIO $ initGame lvl prog   -- Use it when restarting\n  assign game g\n  assign locked False\n\ntoggleProgression :: Tetris ()\ntoggleProgression = modifying progression not\n\n-- Drawing\n\ndrawUI :: UI -> [Widget Name]\ndrawUI ui =\n  [ C.vCenter $ vLimit 22 $ hBox\n      [ padLeft Max $ padRight (Pad 2) $ drawStats (ui ^. game)\n      , drawGrid ui\n      , padRight Max $ padLeft (Pad 2) $ drawInfo (ui ^. game)\n      ]\n  ]\n\ndrawGrid :: UI -> Widget Name\ndrawGrid ui =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ case ui ^. paused of\n        True  -> C.center $ str \"Paused\"\n        False -> vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r ->\n          foldr (<+>) emptyWidget\n            . M.filterWithKey (\\(V2 _ y) _ -> r == y)\n            $ mconcat\n                [ drawBlockCell NormalBlock <$> ui ^. (game . board)\n                , blockMap NormalBlock (ui ^. (game . block))\n                , case ui ^. preview of\n                    Nothing -> M.empty\n                    Just s  -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game))\n                , emptyCellMap\n                ]\n where\n  blockMap v b =\n    M.fromList $ [ (c, drawBlockCell v (b ^. shape)) | c <- coords b ]\n\nemptyCellMap :: Map Coord (Widget Name)\nemptyCellMap = M.fromList\n  [ (V2 x y, emptyGridCellW) | x <- [1 .. boardWidth], y <- [1 .. boardHeight] ]\n\nemptyGridCellW :: Widget Name\nemptyGridCellW = withAttr emptyAttr cw\n\nemptyNextShapeCellW :: Widget Name\nemptyNextShapeCellW = withAttr emptyAttr ecw\n\ndrawBlockCell :: VisualBlock -> Tetrimino -> Widget Name\ndrawBlockCell NormalBlock       t = withAttr (tToAttr t) cw\ndrawBlockCell (HardDropBlock s) t = withAttr (tToAttrH t) (str s)\n\ntToAttr :: Tetrimino -> AttrName\ntToAttr I = iAttr\ntToAttr O = oAttr\ntToAttr T = tAttr\ntToAttr S = sAttr\ntToAttr Z = zAttr\ntToAttr J = jAttr\ntToAttr L = lAttr\n\ntToAttrH :: Tetrimino -> AttrName\ntToAttrH I = ihAttr\ntToAttrH O = ohAttr\ntToAttrH T = thAttr\ntToAttrH S = shAttr\ntToAttrH Z = zhAttr\ntToAttrH J = jhAttr\ntToAttrH L = lhAttr\n\ncw :: Widget Name\ncw = str \" .\"\n\necw :: Widget Name\necw = str \"  \"\n\ndrawStats :: Game -> Widget Name\ndrawStats g =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Stats\")\n    $ vBox\n        [ drawStat \"Score\" $ g ^. score\n        , padTop (Pad 1) $ drawStat \"Lines\" $ g ^. linesCleared\n        , padTop (Pad 1) $ drawStat \"Level\" $ g ^. level\n        , padTop (Pad 1) $ drawProgression (g ^. progression)\n        , drawLeaderBoard g\n        ]\n\ndrawProgression :: Bool -> Widget Name\ndrawProgression enabled =\n  let attr = if enabled then progressionAttr else fixedAttr\n      text = if enabled then \"On\" else \"Off\"\n  in padLeftRight 1 $ str \"Leveling \"\n      <+> withAttr attr (padLeft Max $ str text)\n\ndrawStat :: String -> Int -> Widget Name\ndrawStat s n = padLeftRight 1 $ str s <+> padLeft Max (str $ show n)\n\ndrawLeaderBoard :: Game -> Widget Name\ndrawLeaderBoard _ = emptyWidget\n\ndrawInfo :: Game -> Widget Name\ndrawInfo g = hLimit 18 -- size of next piece box\n  $ vBox\n    [ drawNextShape (g ^. nextShape)\n    , padTop (Pad 1) drawHelp\n    , padTop (Pad 1) (drawGameOver g)\n    ]\n\ndrawNextShape :: Tetrimino -> Widget Name\ndrawNextShape t =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Next\")\n    $ padTopBottom 1\n    $ padLeftRight 4\n    $ vLimit 4\n    $ vBox\n    $ [0, -1] <&> \\y ->\n      hBox [ if V2 x y `elem` coords blk\n             then drawBlockCell NormalBlock t\n             else emptyNextShapeCellW\n           | x <- [-2 .. 1]\n           ]\n  where blk = Block t (V2 0 0) (relCells t)\n\ndrawHelp :: Widget Name\ndrawHelp =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Help\")\n    $ padTopBottom 1\n    $ vBox\n    $ map (uncurry drawKeyInfo)\n      [ (\"Left\"   , \"h, \u2190\")\n      , (\"Right\"  , \"l, \u2192\")\n      , (\"Down\"   , \"j, \u2193\")\n      , (\"Rotate\" , \"k, \u2191\")\n      , (\"Drop\"   , \"space\")\n      , (\"Mode\"   , \"m\")\n      , (\"Restart\", \"r\")\n      , (\"Pause\"  , \"p\")\n      , (\"Quit\"   , \"q\")\n      ]\n\ndrawKeyInfo :: String -> String -> Widget Name\ndrawKeyInfo action keys =\n  padRight Max (padLeft (Pad 1) $ str action)\n    <+> padLeft Max (padRight (Pad 1) $ str keys)\n\ndrawGameOver :: Game -> Widget Name\ndrawGameOver g =\n  if isGameOver g\n  then padLeftRight 4 $ withAttr gameOverAttr $ str \"GAME OVER\"\n  else emptyWidget\n\ntheMap :: AttrMap\ntheMap = attrMap\n  V.defAttr\n  [ (iAttr          , tToColor I `on` tToColor I)\n  , (oAttr          , tToColor O `on` tToColor O)\n  , (tAttr          , tToColor T `on` tToColor T)\n  , (sAttr          , tToColor S `on` tToColor S)\n  , (zAttr          , tToColor Z `on` tToColor Z)\n  , (jAttr          , tToColor J `on` tToColor J)\n  , (lAttr          , tToColor L `on` tToColor L)\n  , (ihAttr         , fg $ tToColor I)\n  , (ohAttr         , fg $ tToColor O)\n  , (thAttr         , fg $ tToColor T)\n  , (shAttr         , fg $ tToColor S)\n  , (zhAttr         , fg $ tToColor Z)\n  , (jhAttr         , fg $ tToColor J)\n  , (lhAttr         , fg $ tToColor L)\n  , (gameOverAttr   , fg V.red `V.withStyle` V.bold)\n  , (progressionAttr, fg V.green `V.withStyle` V.bold)\n  , (fixedAttr      , fg V.blue `V.withStyle` V.bold)\n  ]\n\ntToColor :: Tetrimino -> V.Color\ntToColor I = V.cyan\ntToColor O = V.yellow\ntToColor T = V.magenta\ntToColor S = V.green\ntToColor Z = V.red\ntToColor J = V.blue\ntToColor L = V.white\n\niAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr :: AttrName\niAttr = attrName \"I\"\noAttr = attrName \"O\"\ntAttr = attrName \"T\"\nsAttr = attrName \"S\"\nzAttr = attrName \"Z\"\njAttr = attrName \"J\"\nlAttr = attrName \"L\"\n\nihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr :: AttrName\nihAttr = attrName \"Ih\"\nohAttr = attrName \"Oh\"\nthAttr = attrName \"Th\"\nshAttr = attrName \"Sh\"\nzhAttr = attrName \"Zh\"\njhAttr = attrName \"Jh\"\nlhAttr = attrName \"Lh\"\n\nemptyAttr :: AttrName\nemptyAttr = attrName \"empty\"\n\ngameOverAttr :: AttrName\ngameOverAttr = attrName \"gameOver\"\n\nprogressionAttr, fixedAttr :: AttrName\nprogressionAttr = attrName \"progression\"\nfixedAttr = attrName \"fixed\"\n",
          "suggestions": [
            {
              "module": [
                "UI.Game"
              ],
              "decl": [
                "handleEvent"
              ],
              "severity": "Suggestion",
              "hint": "Redundant $",
              "file": "/tmp/project_90/pre_refactor/src/UI/Game.hs",
              "startLine": 119,
              "startColumn": 15,
              "endLine": 119,
              "endColumn": 16,
              "from": "use $ currLevel",
              "to": "use currLevel",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 119, startCol = 11, endLine = 119, endCol = 26}, subts = [(\"a\",SrcSpan {startLine = 119, startCol = 11, endLine = 119, endCol = 14}),(\"b\",SrcSpan {startLine = 119, startCol = 17, endLine = 119, endCol = 26})], orig = \"a b\"}]"
            },
            {
              "module": [
                "UI.Game"
              ],
              "decl": [
                "drawGrid"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_90/pre_refactor/src/UI/Game.hs",
              "startLine": 158,
              "startColumn": 7,
              "endLine": 170,
              "endColumn": 18,
              "from": "case ui ^. paused of\n  True -> C.center $ str \"Paused\"\n  False\n    -> vBox\n         $ [boardHeight, boardHeight - 1 .. 1]\n             <&>\n               \\ r\n                 -> foldr (<+>) emptyWidget\n                      . M.filterWithKey (\\ (V2 _ y) _ -> r == y)\n                      $ mconcat\n                          [drawBlockCell NormalBlock <$> ui ^. (game . board),\n                           blockMap NormalBlock (ui ^. (game . block)),\n                           case ui ^. preview of\n                             Nothing -> M.empty\n                             Just s\n                               -> blockMap\n                                    (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),\n                           emptyCellMap]",
              "to": "(if ui ^. paused then\n     C.center $ str \"Paused\"\n else\n     vBox\n       $ [boardHeight, boardHeight - 1 .. 1]\n           <&>\n             \\ r\n               -> foldr (<+>) emptyWidget\n                    . M.filterWithKey (\\ (V2 _ y) _ -> r == y)\n                    $ mconcat\n                        [drawBlockCell NormalBlock <$> ui ^. (game . board),\n                         blockMap NormalBlock (ui ^. (game . block)),\n                         case ui ^. preview of\n                           Nothing -> M.empty\n                           Just s\n                             -> blockMap\n                                  (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),\n                         emptyCellMap])",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 158, startCol = 7, endLine = 170, endCol = 18}, subts = [(\"a\",SrcSpan {startLine = 158, startCol = 12, endLine = 158, endCol = 24}),(\"f\",SrcSpan {startLine = 160, startCol = 18, endLine = 170, endCol = 18}),(\"t\",SrcSpan {startLine = 159, startCol = 18, endLine = 159, endCol = 41})], orig = \"(if a then t else f)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_90/static_refactored/src/UI/Game.hs",
            "llm_only_refactored_file": "/tmp/project_90/llm_only_refactored/src/UI/Game.hs",
            "hybrid_refactored_file": "/tmp/project_90/hybrid_refactored/src/UI/Game.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 5,
              "max": 16,
              "average": 29.0,
              "sum": 145
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 1,
              "suggestion": 1,
              "ignore": 0,
              "total": 2
            },
            "syntax_errors": 39,
            "lines_of_code": 922,
            "homplexity_lines_of_code": 1155,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_90/pre_refactor/Setup.hs",
              "refactored_file_name": "/tmp/project_90/static_refactored/Setup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 2,
              "homplexity_lines_of_code": 3,
              "code_quality_score": 97.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 3,
                "homplexity_output": "Info:/tmp/project_90/static_refactored/Setup.hs:SrcLoc \"/tmp/project_90/static_refactored/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_90/static_refactored/Setup.hs:SrcLoc \"/tmp/project_90/static_refactored/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_90/static_refactored/Setup.hs:SrcLoc \"/tmp/project_90/static_refactored/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/Setup.hs:SrcLoc \"/tmp/project_90/static_refactored/Setup.hs\" 2 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Distribution.Simple\nmain = defaultMain\n",
              "suggestions": [
                {
                  "location": "/tmp/project_90/pre_refactor/Setup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Distribution.Simple\nmain = defaultMain\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/app/Main.hs",
              "refactored_file_name": "/tmp/project_90/static_refactored/app/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.5,
                "sum": 18
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 136,
              "homplexity_lines_of_code": 192,
              "code_quality_score": 44.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.5,
                  "sum": 18
                },
                "homplexity_loc": 192,
                "homplexity_output": "Info:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 1 1: module Main has 112 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 19 13: data Opts has record fields count of 4 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 26 20: data HardDropOpt has record fields count of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 28 1: type signature for opts has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 28 1: type signature for opts has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 29 1: function opts has 14 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 29 1: function opts has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 29 1: function opts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 44 1: type signature for toggle has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 44 1: type signature for toggle has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 45 1: function toggle has 6 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 45 1: function toggle has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 45 1: function toggle has cyclomatic complexity of 3 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 52 1: type signature for hardDropOpt has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 52 1: type signature for hardDropOpt has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 53 1: function hardDropOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 53 1: function hardDropOpt has 16 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 53 1: function hardDropOpt has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 71 1: type signature for fullopts has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 71 1: type signature for fullopts has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 72 1: function fullopts has 3 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 72 1: function fullopts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 72 1: function fullopts has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 76 1: type signature for twoChar has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 76 1: type signature for twoChar has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 77 1: function twoChar has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 77 1: function twoChar has 5 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 77 1: function twoChar has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 83 1: type signature for hdOptStr has 2 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 83 1: type signature for hdOptStr has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 84 1: function hdOptStr has 3 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 84 1: function hdOptStr has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 84 1: function hdOptStr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 88 1: type signature for main has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 88 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 89 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 89 1: function main has 9 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 89 1: function main has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 103 1: type signature for handleEndGame has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 103 1: type signature for handleEndGame has 2 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 104 1: function handleEndGame has 9 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 104 1: function handleEndGame has cyclomatic complexity of 3 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 104 1: function handleEndGame has branching depth of 2 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 115 1: type signature for printM has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 115 1: type signature for printM has 2 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 116 1: function printM has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 116 1: function printM has 2 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 116 1: function printM has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 119 1: type signature for getHighScore has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 119 1: type signature for getHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 120 1: function getHighScore has 6 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 120 1: function getHighScore has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 120 1: function getHighScore has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 127 1: type signature for setHighScore has 2 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 127 1: type signature for setHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 128 1: function setHighScore has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 128 1: function setHighScore has 3 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 128 1: function setHighScore has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 132 1: type signature for getLeaderboardFile has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 132 1: type signature for getLeaderboardFile has 1 arguments \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 133 1: function getLeaderboardFile has 4 lines of code \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 133 1: function getLeaderboardFile has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/static_refactored/app/Main.hs\" 133 1: function getLeaderboardFile has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\nmodule Main where\n\nimport Control.Monad (when)\nimport System.Exit (exitSuccess)\nimport Text.Read (readMaybe)\nimport Data.Char (toLower)\nimport Data.Functor.Identity\n\nimport Options.Applicative\nimport qualified System.Directory as D\nimport System.FilePath ((</>))\n\nimport Tetris (Game(..))\nimport UI.PickLevel (configureLeveling, LevelConfig'(..))\nimport UI.Game (playGame)\n\ndata Opts = Opts\n  { hardDrop :: HardDropOpt\n  , level :: Maybe Int\n  , progression :: Maybe Bool\n  , score :: Bool\n  }\n\ndata HardDropOpt = None | AsciiOnly | CustomChars String\n\nopts :: Parser Opts\nopts = Opts\n  <$> hardDropOpt\n  <*> optional (option auto\n    (  long \"level\"\n    <> short 'l'\n    <> metavar \"LEVEL\"\n    <> help \"Specify level (unspecified results in prompt)\" ))\n  <*> optional (option toggle\n    (  long \"progression\"\n    <> metavar \"BOOL\"\n    <> help \"Turn level progression ON/OFF (unspecified results in prompt)\" ))\n  <*> switch\n    (  long \"high-score\"\n    <> help \"Print high score and exit\" )\n\ntoggle :: ReadM Bool\ntoggle = do\n  s <- str\n  case toLower <$> s of\n    y | y `elem` [\"y\", \"yes\", \"on\", \"t\", \"true\"] -> return True\n    n | n `elem` [\"n\", \"no\", \"off\", \"f\", \"false\"] -> return False\n    _   -> readerError \"Must be 'Y' or 'N'\"\n\nhardDropOpt :: Parser HardDropOpt\nhardDropOpt = noneOpt <|> asciiOpt <|> custOpt\n  where\n    noneOpt = flag' None\n      (  long \"no-preview\"\n      <> short 'n'\n      <> help \"Don't show preview cell\" )\n    asciiOpt = flag' AsciiOnly\n      (  long \"ascii-only\"\n      <> short 'a'\n      <> help \"Use '[]' as hard drop preview cell\" )\n    custOpt = CustomChars <$> option twoChar\n      (  long \"preview-chars\"\n      <> short 'p'\n      <> metavar \"CHARS\"\n      <> value \"\u25e4\u25e2\"\n      <> showDefaultWith (const \"\u25e4\u25e2\")\n      <> help \"Customize two character preview cell\" )\n\nfullopts :: ParserInfo Opts\nfullopts = info (helper <*> opts)\n  (  fullDesc\n  <> header \"tetris - the iconic game right in your terminal\" )\n\ntwoChar :: ReadM String\ntwoChar = do\n  cs <- str\n  if length cs /= 2\n     then readerError \"Preview must be two characters long\"\n     else return cs\n\nhdOptStr :: HardDropOpt -> Maybe String\nhdOptStr None            = Nothing\nhdOptStr AsciiOnly       = Just \"[]\"\nhdOptStr (CustomChars s) = Just s\n\nmain :: IO ()\nmain = do\n  (Opts {..}) <- execParser fullopts\n  -- show high score and exit\n  when score (getHighScore >>= printM >> exitSuccess)\n  -- pick level prompt if necessary\n  levelConfig <- configureLeveling level progression\n  -- play game\n  g <- playGame\n    (runIdentity levelConfig.level)\n    (runIdentity levelConfig.progression)\n    (hdOptStr hardDrop)\n  -- save & print score\n  handleEndGame (_score g)\n\nhandleEndGame :: Int -> IO ()\nhandleEndGame s = do\n  mhs <- getHighScore\n  case mhs of\n    Nothing -> newHighScore\n    Just hs -> if s <= hs then justShowScore else newHighScore\n  where\n    justShowScore = putStrLn $ \"Your final score: \" ++ show s\n    newHighScore = do\n      putStrLn $ \"Congrats! You just got the new highest score: \" ++ show s\n      setHighScore s\n\nprintM :: Show a => Maybe a -> IO ()\nprintM Nothing  = putStrLn \"None\"\nprintM (Just s) = print s\n\ngetHighScore :: IO (Maybe Int)\ngetHighScore = do\n  lb <- getLeaderboardFile\n  exists <- D.doesFileExist lb\n  if exists\n     then readMaybe <$> readFile lb\n     else return Nothing\n\nsetHighScore :: Int -> IO ()\nsetHighScore s = do\n  lb <- getLeaderboardFile\n  writeFile lb (show s)\n\ngetLeaderboardFile :: IO FilePath\ngetLeaderboardFile = do\n  xdg <- D.getXdgDirectory D.XdgData \"tetris\"\n  D.createDirectoryIfMissing True xdg\n  return (xdg </> \"leaderboard\")\n",
              "suggestions": [
                {
                  "location": "/tmp/project_90/pre_refactor/app/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\nmodule Main where\n\nimport Control.Monad (when)\nimport System.Exit (exitSuccess)\nimport Text.Read (readMaybe)\nimport Data.Char (toLower)\nimport Data.Functor.Identity\n\nimport Options.Applicative\nimport qualified System.Directory as D\nimport System.FilePath ((</>))\n\nimport Tetris (Game(..))\nimport UI.PickLevel (configureLeveling, LevelConfig'(..))\nimport UI.Game (playGame)\n\ndata Opts = Opts\n  { hardDrop :: HardDropOpt\n  , level :: Maybe Int\n  , progression :: Maybe Bool\n  , score :: Bool\n  }\n\ndata HardDropOpt = None | AsciiOnly | CustomChars String\n\nopts :: Parser Opts\nopts = Opts\n  <$> hardDropOpt\n  <*> optional (option auto\n    (  long \"level\"\n    <> short 'l'\n    <> metavar \"LEVEL\"\n    <> help \"Specify level (unspecified results in prompt)\" ))\n  <*> optional (option toggle\n    (  long \"progression\"\n    <> metavar \"BOOL\"\n    <> help \"Turn level progression ON/OFF (unspecified results in prompt)\" ))\n  <*> switch\n    (  long \"high-score\"\n    <> help \"Print high score and exit\" )\n\ntoggle :: ReadM Bool\ntoggle = do\n  s <- str\n  case toLower <$> s of\n    y | y `elem` [\"y\", \"yes\", \"on\", \"t\", \"true\"] -> return True\n    n | n `elem` [\"n\", \"no\", \"off\", \"f\", \"false\"] -> return False\n    _   -> readerError \"Must be 'Y' or 'N'\"\n\nhardDropOpt :: Parser HardDropOpt\nhardDropOpt = noneOpt <|> asciiOpt <|> custOpt\n  where\n    noneOpt = flag' None\n      (  long \"no-preview\"\n      <> short 'n'\n      <> help \"Don't show preview cell\" )\n    asciiOpt = flag' AsciiOnly\n      (  long \"ascii-only\"\n      <> short 'a'\n      <> help \"Use '[]' as hard drop preview cell\" )\n    custOpt = CustomChars <$> option twoChar\n      (  long \"preview-chars\"\n      <> short 'p'\n      <> metavar \"CHARS\"\n      <> value \"\u25e4\u25e2\"\n      <> showDefaultWith (const \"\u25e4\u25e2\")\n      <> help \"Customize two character preview cell\" )\n\nfullopts :: ParserInfo Opts\nfullopts = info (helper <*> opts)\n  (  fullDesc\n  <> header \"tetris - the iconic game right in your terminal\" )\n\ntwoChar :: ReadM String\ntwoChar = do\n  cs <- str\n  if length cs /= 2\n     then readerError \"Preview must be two characters long\"\n     else return cs\n\nhdOptStr :: HardDropOpt -> Maybe String\nhdOptStr None            = Nothing\nhdOptStr AsciiOnly       = Just \"[]\"\nhdOptStr (CustomChars s) = Just s\n\nmain :: IO ()\nmain = do\n  (Opts {..}) <- execParser fullopts\n  -- show high score and exit\n  when score (getHighScore >>= printM >> exitSuccess)\n  -- pick level prompt if necessary\n  levelConfig <- configureLeveling level progression\n  -- play game\n  g <- playGame\n    (runIdentity levelConfig.level)\n    (runIdentity levelConfig.progression)\n    (hdOptStr hardDrop)\n  -- save & print score\n  handleEndGame (_score g)\n\nhandleEndGame :: Int -> IO ()\nhandleEndGame s = do\n  mhs <- getHighScore\n  case mhs of\n    Nothing -> newHighScore\n    Just hs -> if s <= hs then justShowScore else newHighScore\n  where\n    justShowScore = putStrLn $ \"Your final score: \" ++ show s\n    newHighScore = do\n      putStrLn $ \"Congrats! You just got the new highest score: \" ++ show s\n      setHighScore s\n\nprintM :: Show a => Maybe a -> IO ()\nprintM Nothing  = putStrLn \"None\"\nprintM (Just s) = print s\n\ngetHighScore :: IO (Maybe Int)\ngetHighScore = do\n  lb <- getLeaderboardFile\n  exists <- D.doesFileExist lb\n  if exists\n     then readMaybe <$> readFile lb\n     else return Nothing\n\nsetHighScore :: Int -> IO ()\nsetHighScore s = do\n  lb <- getLeaderboardFile\n  writeFile lb (show s)\n\ngetLeaderboardFile :: IO FilePath\ngetLeaderboardFile = do\n  xdg <- D.getXdgDirectory D.XdgData \"tetris\"\n  D.createDirectoryIfMissing True xdg\n  return (xdg </> \"leaderboard\")\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/Tetris.hs",
              "refactored_file_name": "/tmp/project_90/static_refactored/src/Tetris.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 7,
                "average": 2,
                "sum": 63
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 11,
              "lines_of_code": 336,
              "homplexity_lines_of_code": 342,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 7,
                  "average": 2,
                  "sum": 63
                },
                "homplexity_loc": 342,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"evalTetris\": 1,\n    \"translateBy_Coord\": 3,\n    \"translateBy_Block\": 1,\n    \"initBlock\": 1,\n    \"relCells\": 7,\n    \"rotateRaw\": 3,\n    \"coords\": 1,\n    \"bagFourTetriminoEach\": 2,\n    \"initGame\": 1,\n    \"nextLevel\": 1,\n    \"isGameOver\": 2,\n    \"timeStep\": 3,\n    \"gravitate\": 1,\n    \"clearFullRows\": 1,\n    \"updateScore\": 2,\n    \"updateScore.points\": 5,\n    \"levelFinished\": 2,\n    \"rotate\": 3,\n    \"blockStopped\": 1,\n    \"isStopped\": 2,\n    \"hardDrop\": 1,\n    \"hardDroppedBlock\": 3,\n    \"freezeBlock\": 1,\n    \"nextBlock\": 1,\n    \"shift\": 2,\n    \"isFree\": 1,\n    \"isInBounds\": 3,\n    \"isValidBlockPosition\": 2,\n    \"shuffle\": 3,\n    \"v2\": 1,\n    \"isValidBlockPosition_2\": 2,\n    \"min\": 1,\n    \"max\": 7,\n    \"average\": 2.03,\n    \"sum\": 63\n  },\n  \"homplexity_loc\": 342,\n  \"homplexity_output\": \"evalTetris:1, translateBy_Coord:3, translateBy_Block:1, initBlock:1, relCells:7, rotateRaw:3, coords:1, bagFourTetriminoEach:2, initGame:1, nextLevel:1, isGameOver:2, timeStep:3, gravitate:1, clearFullRows:1, updateScore:2, updateScore.points:5, levelFinished:2, rotate:3, blockStopped:1, isStopped:2, hardDrop:1, hardDroppedBlock:3, freezeBlock:1, nextBlock:1, shift:2, isFree:1, isInBounds:3, isValidBlockPosition:2, shuffle:3, v2:1, isValidBlockPosition_2:2\"\n}"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Tetris\n  (\n  -- Game state modifiers\n    initGame\n  , timeStep\n  , shift\n  , rotate\n  , hardDrop\n  -- Game state handlers\n  , evalTetris\n  -- Game state queries\n  , isGameOver\n  , hardDroppedBlock\n  , coords\n  -- Types\n  , Block(..)\n  , Coord\n  , Direction(..)\n  , Game(..)\n  , Tetrimino(..)\n  , Tetris\n  -- Lenses\n  , block, board, level, nextShape, score, shape, linesCleared, progression\n  -- Constants\n  , boardHeight, boardWidth, relCells\n  ) where\n\nimport Prelude hiding (Left, Right, lines)\nimport Control.Applicative ((<|>))\nimport Control.Monad (forM_, mfilter, when, (<=<))\nimport Control.Monad.Extra (whenM, andM)\n\nimport Control.Monad.IO.Class (MonadIO(..), liftIO)\nimport Control.Monad.State.Class (MonadState, gets)\nimport Control.Monad.Trans.State (evalStateT)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Sequence (Seq(..), (><))\nimport qualified Data.Sequence as Seq\nimport Control.Lens hiding (Empty)\nimport Linear.V2 (V2(..), _y)\nimport qualified Linear.V2 as LV\nimport System.Random (getStdRandom, randomR)\n\n-- Types and instances\n\n-- | Tetris shape types\ndata Tetrimino = I | O | T | S | Z | J | L\n  deriving (Eq, Show, Enum)\n\n-- | Coordinates\ntype Coord = V2 Int\n\n-- | Tetris shape in location context\ndata Block = Block\n  { _shape  :: Tetrimino -- ^ block type\n  , _origin :: Coord -- ^ origin\n  , _extra  :: [Coord] -- ^ extraneous cells\n  } deriving (Eq, Show)\n\nmakeLenses ''Block\n\ndata Direction = Left | Right | Down\n  deriving (Eq, Show)\n\n-- | Board\n--\n-- If coordinate not present in map, yet in bounds, then it is empty,\n-- otherwise its value is the type of tetrimino occupying it.\ntype Board = Map Coord Tetrimino\n\n-- | Game state\ndata Game = Game\n  { _level        :: Int\n  , _block        :: Block\n  , _nextShape    :: Tetrimino\n  , _nextShapeBag :: Seq.Seq Tetrimino\n  , _linesCleared :: Int\n  , _score        :: Int\n  , _board        :: Board\n  , _progression  :: Bool\n  } deriving (Eq)\nmakeLenses ''Game\n\nevalTetris :: Tetris a -> Game -> a\nevalTetris m = runIdentity . evalStateT m\n\ntype Tetris a = forall m. MonadState Game m => m a\n\n-- Translate class for direct translations, without concern for boundaries\n-- 'shift' concerns safe translations with boundaries\nclass Translatable s where\n  translate :: Direction -> s -> s\n  translate = translateBy 1\n  translateBy :: Int -> Direction -> s -> s\n\ninstance Translatable Coord where\n  translateBy n Left (V2 x y)  = V2 (x-n) y\n  translateBy n Right (V2 x y) = V2 (x+n) y\n  translateBy n Down (V2 x y)  = V2 x (y-n)\n\ninstance Translatable Block where\n  translateBy n d b =\n    b & origin %~ translateBy n d\n      & extra  %~ fmap (translateBy n d)\n\n-- Low level functions on blocks and coordinates\n\ninitBlock :: Tetrimino -> Block\ninitBlock t = Block t startOrigin . fmap (+ startOrigin) . relCells $ t\n\nrelCells :: Tetrimino -> [Coord]\nrelCells I = map v2 [(-2, 0), (-1, 0), (1, 0)]\nrelCells O = map v2 [(-1, 0), (-1, -1), (0, -1)]\nrelCells S = map v2 [(-1, -1), (0, -1), (1, 0)]\nrelCells Z = map v2 [(-1, 0), (0, -1), (1, -1)]\nrelCells L = map v2 [(-1, -1), (-1, 0), (1, 0)]\nrelCells J = map v2 [(-1, 0), (1, 0), (1, -1)]\nrelCells T = map v2 [(-1, 0), (0, -1), (1, 0)]\n\n-- | Visible, active board size\nboardWidth, boardHeight :: Int\nboardWidth = 10\nboardHeight = 20\n\n-- | Starting block origin\nstartOrigin :: Coord\nstartOrigin = V2 6 22\n\n-- | Rotate block counter clockwise about origin\n-- *Note*: Strict unsafe rotation not respecting boundaries\n-- Safety can only be assured within Game context\nrotateRaw :: Block -> Block\nrotateRaw b@(Block s o@(V2 xo yo) cs)\n  | -- O doesn't need rotation\n    s == O                             = b\n  | -- I only has two orientations\n    s == I && V2 xo (yo + 1) `elem` cs = rotateWith clockwise\n  | otherwise                          = rotateWith counterclockwise\n where\n  clockwise        = (+ o) . cwperp . subtract o\n  counterclockwise = (+ o) . LV.perp . subtract o\n  rotateWith dir = b & extra %~ fmap dir\n  cwperp (V2 x y) = V2 y (-x)\n\n-- | Get coordinates of entire block\ncoords :: Block -> [Coord]\ncoords b = b ^. origin : b ^. extra\n\n-- Higher level functions on game and board\n\n-- | Facilitates cycling through at least 4 occurences of each shape\n-- before next bag (random permutation of 4*each tetrimino) is created. If input is empty,\n-- generates new bag, otherwise just unshifts the first value and returns pair.\nbagFourTetriminoEach :: Seq.Seq Tetrimino -> IO (Tetrimino, Seq.Seq Tetrimino)\nbagFourTetriminoEach (t :<| ts) = pure (t, ts)\nbagFourTetriminoEach Empty =\n  bagFourTetriminoEach <=< shuffle . Seq.fromList . take 28 $ cycle [I ..]\n\n-- | Initialize a game with a given level\ninitGame :: Int -> Bool -> IO Game \ninitGame lvl prog = do\n  (s1, bag1) <- bagFourTetriminoEach mempty\n  (s2, bag2) <- bagFourTetriminoEach bag1\n  pure $ Game\n    { _level        = lvl\n    , _block        = initBlock s1\n    , _nextShape    = s2\n    , _nextShapeBag = bag2\n    , _score        = 0\n    , _linesCleared = 0\n    , _board        = mempty\n    , _progression  = prog  \n    }\n\n-- | Increment level\nnextLevel :: (MonadIO m, MonadState Game m) => m ()\nnextLevel = do\n  level %= (+ 1)\n\nisGameOver :: Game -> Bool\nisGameOver g = blockStopped g && g ^. (block . origin) == startOrigin\n\n-- | The main game execution, this is executed at each discrete time step\ntimeStep :: (MonadIO m, MonadState Game m) => m ()\ntimeStep = do\n  gets blockStopped >>= \\case\n    False -> gravitate\n    True -> do\n      freezeBlock\n      clearFullRows >>= updateScore\n      whenM (andM [use progression, levelFinished]) nextLevel\n      nextBlock\n\n-- | Gravitate current block, i.e. shift down\ngravitate :: MonadState Game m => m ()\ngravitate = shift Down\n\n-- | If necessary: clear full rows and return the count\nclearFullRows :: MonadState Game m => m Int\nclearFullRows = do\n  brd <- use board\n  let rowSize r = length $ M.filterWithKey (\\(V2 _ y) _ -> r == y) brd\n      fullRows = filter (\\r -> boardWidth == rowSize r) [1 .. boardHeight]\n  -- Clear cells in full rows\n  modifying board $ M.filterWithKey $ \\(V2 _ y) _ -> y `notElem` fullRows\n  -- Shift cells above full rows\n  modifying board $ M.mapKeysMonotonic $ over _y $ \\y ->\n    y - length (filter (< y) fullRows)\n  let clearedLines = length fullRows\n  linesCleared %= (+ clearedLines)\n  pure clearedLines\n\n-- | This updates game points with respect to the provided number of cleared\n-- lines.\n--\n-- See https://tetris.fandom.com/wiki/Scoring\nupdateScore :: (MonadState Game m, MonadIO m) => Int -> m ()\nupdateScore 0 = pure ()\nupdateScore lines = do\n  lvl <- use level\n  let newPoints = (lvl + 1) * points lines\n  score %= (+ newPoints)\n  where\n    -- Translate row line clears to points\n    points 0 = 0\n    points 1 = 40\n    points 2 = 100\n    points 3 = 300\n    points _ = 1200\n\n-- | Using the fixed-goal system described here: https://tetris.wiki/Marathon\nlevelFinished :: (MonadState Game m, MonadIO m) => m Bool\nlevelFinished = do\n  lvl <- use level\n  lc <- use linesCleared\n  pure $ lvl < 15 && lc >= 10 * (lvl + 1)\n\n-- | Handle counterclockwise block rotation (if possible)\n-- Allows wallkicks: http://tetris.wikia.com/wiki/TGM_rotation\nrotate :: MonadState Game m => m ()\nrotate = do\n  blk <- use block\n  brd <- use board\n  let mblk = foldr (<|>) Nothing\n        $   mfilter (isValidBlockPosition brd)\n        .   pure\n        .   ($ blk)\n        <$> [ rotateRaw\n            , rotateRaw . translate Left\n            , rotateRaw . translate Right\n            ]\n  forM_ mblk $ assign block\n\nblockStopped :: Game -> Bool\nblockStopped g = isStopped (g ^. board) (g ^. block)\n\n-- | Check if a block on a board is stopped from further gravitation\nisStopped :: Board -> Block -> Bool\nisStopped brd = any stopped . coords\n where\n  stopped = (||) <$> atBottom <*> (`M.member` brd) . translate Down\n  atBottom = (== 1) . view _y\n\nhardDrop :: MonadState Game m => m ()\nhardDrop = hardDroppedBlock >>= assign block\n\nhardDroppedBlock :: MonadState Game m => m Block\nhardDroppedBlock = do\n  boardCoords <- M.keys <$> use board\n  blockCoords <- coords <$> use block\n  let diffs =\n        [ y - yo\n        | (V2 xo yo) <- boardCoords\n        , (V2 x  y ) <- blockCoords\n        , xo == x\n        , yo < y\n        ]\n      minY = minimum $ view _y <$> blockCoords\n      dist = minimum $ subtract 1 <$> (minY : diffs)\n  translateBy dist Down <$> use block\n\n-- | Freeze current block\nfreezeBlock :: MonadState Game m => m ()\nfreezeBlock = do\n  blk <- use block\n  modifying board $ M.union $ M.fromList [ (c, _shape blk) | c <- coords blk ]\n\n-- | Replace block with next block\nnextBlock :: (MonadIO m, MonadState Game m) => m ()\nnextBlock = do\n  bag <- use nextShapeBag\n  (t, ts) <- liftIO $ bagFourTetriminoEach bag\n  use nextShape >>= \\s -> block .= initBlock s\n  nextShape .= t\n  nextShapeBag .= ts\n\n-- | Try to shift current block; if shifting not possible, leave block where it is\nshift :: MonadState Game m => Direction -> m ()\nshift dir = do\n  brd <- use board\n  blk <- use block\n  let candidate = translate dir blk\n  when (isValidBlockPosition brd candidate) $\n    block .= candidate\n\n-- | Check if coordinate is already occupied or free in board\nisFree :: Board -> Coord -> Bool\nisFree = flip M.notMember\n\n-- | Check if coordinate is in or out of bounds\nisInBounds :: Coord -> Bool\nisInBounds (V2 x y) = 1 <= x && x <= boardWidth && 1 <= y\n\n-- | Checks if block's potential new location is valid\nisValidBlockPosition :: Board -> Block -> Bool\nisValidBlockPosition brd = all validCoord . coords\n  where validCoord = (&&) <$> isFree brd <*> isInBounds\n\n-- General utilities\n\n-- | Shuffle a sequence (random permutation)\nshuffle :: Seq.Seq a -> IO (Seq.Seq a)\nshuffle xs\n  | null xs = mempty\n  | otherwise = do\n    randomPosition <- getStdRandom (randomR (0, length xs - 1))\n    case Seq.splitAt randomPosition xs of\n      (left, y :<| ys) ->  fmap (y <|) (shuffle $ left >< ys)\n      _ -> error \"impossible\"\n\nv2 :: (a, a) -> V2 a\nv2 (x, y) = V2 x y\n",
              "suggestions": [
                {
                  "location": "/tmp/project_90/pre_refactor/src/Tetris.hs:(250,14)-(257,13)",
                  "suggestion_title": "Fuse foldr/<$>",
                  "found_block": [
                    "  foldr (<|>) Nothing",
                    "    $ mfilter (isValidBlockPosition brd) . pure . ($ blk)",
                    "        <$>",
                    "          [rotateRaw, rotateRaw . translate Left,",
                    "           rotateRaw . translate Right]"
                  ],
                  "perhaps_block": [
                    "  foldr",
                    "    ((<|>) . mfilter (isValidBlockPosition brd) . pure . ($ blk))",
                    "    Nothing",
                    "    [rotateRaw, rotateRaw . translate Left,",
                    "     rotateRaw . translate Right]"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Tetris\n  (\n  -- Game state modifiers\n    initGame\n  , timeStep\n  , shift\n  , rotate\n  , hardDrop\n  -- Game state handlers\n  , evalTetris\n  -- Game state queries\n  , isGameOver\n  , hardDroppedBlock\n  , coords\n  -- Types\n  , Block(..)\n  , Coord\n  , Direction(..)\n  , Game(..)\n  , Tetrimino(..)\n  , Tetris\n  -- Lenses\n  , block, board, level, nextShape, score, shape, linesCleared, progression\n  -- Constants\n  , boardHeight, boardWidth, relCells\n  ) where\n\nimport Prelude hiding (Left, Right, lines)\nimport Control.Applicative ((<|>))\nimport Control.Monad (forM_, mfilter, when, (<=<))\nimport Control.Monad.Extra (whenM, andM)\n\nimport Control.Monad.IO.Class (MonadIO(..), liftIO)\nimport Control.Monad.State.Class (MonadState, gets)\nimport Control.Monad.Trans.State (evalStateT)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Sequence (Seq(..), (><))\nimport qualified Data.Sequence as Seq\nimport Control.Lens hiding (Empty)\nimport Linear.V2 (V2(..), _y)\nimport qualified Linear.V2 as LV\nimport System.Random (getStdRandom, randomR)\n\n-- Types and instances\n\n-- | Tetris shape types\ndata Tetrimino = I | O | T | S | Z | J | L\n  deriving (Eq, Show, Enum)\n\n-- | Coordinates\ntype Coord = V2 Int\n\n-- | Tetris shape in location context\ndata Block = Block\n  { _shape  :: Tetrimino -- ^ block type\n  , _origin :: Coord -- ^ origin\n  , _extra  :: [Coord] -- ^ extraneous cells\n  } deriving (Eq, Show)\n\nmakeLenses ''Block\n\ndata Direction = Left | Right | Down\n  deriving (Eq, Show)\n\n-- | Board\n--\n-- If coordinate not present in map, yet in bounds, then it is empty,\n-- otherwise its value is the type of tetrimino occupying it.\ntype Board = Map Coord Tetrimino\n\n-- | Game state\ndata Game = Game\n  { _level        :: Int\n  , _block        :: Block\n  , _nextShape    :: Tetrimino\n  , _nextShapeBag :: Seq.Seq Tetrimino\n  , _linesCleared :: Int\n  , _score        :: Int\n  , _board        :: Board\n  , _progression  :: Bool\n  } deriving (Eq)\nmakeLenses ''Game\n\nevalTetris :: Tetris a -> Game -> a\nevalTetris m = runIdentity . evalStateT m\n\ntype Tetris a = forall m. MonadState Game m => m a\n\n-- Translate class for direct translations, without concern for boundaries\n-- 'shift' concerns safe translations with boundaries\nclass Translatable s where\n  translate :: Direction -> s -> s\n  translate = translateBy 1\n  translateBy :: Int -> Direction -> s -> s\n\ninstance Translatable Coord where\n  translateBy n Left (V2 x y)  = V2 (x-n) y\n  translateBy n Right (V2 x y) = V2 (x+n) y\n  translateBy n Down (V2 x y)  = V2 x (y-n)\n\ninstance Translatable Block where\n  translateBy n d b =\n    b & origin %~ translateBy n d\n      & extra  %~ fmap (translateBy n d)\n\n-- Low level functions on blocks and coordinates\n\ninitBlock :: Tetrimino -> Block\ninitBlock t = Block t startOrigin . fmap (+ startOrigin) . relCells $ t\n\nrelCells :: Tetrimino -> [Coord]\nrelCells I = map v2 [(-2, 0), (-1, 0), (1, 0)]\nrelCells O = map v2 [(-1, 0), (-1, -1), (0, -1)]\nrelCells S = map v2 [(-1, -1), (0, -1), (1, 0)]\nrelCells Z = map v2 [(-1, 0), (0, -1), (1, -1)]\nrelCells L = map v2 [(-1, -1), (-1, 0), (1, 0)]\nrelCells J = map v2 [(-1, 0), (1, 0), (1, -1)]\nrelCells T = map v2 [(-1, 0), (0, -1), (1, 0)]\n\n-- | Visible, active board size\nboardWidth, boardHeight :: Int\nboardWidth = 10\nboardHeight = 20\n\n-- | Starting block origin\nstartOrigin :: Coord\nstartOrigin = V2 6 22\n\n-- | Rotate block counter clockwise about origin\n-- *Note*: Strict unsafe rotation not respecting boundaries\n-- Safety can only be assured within Game context\nrotateRaw :: Block -> Block\nrotateRaw b@(Block s o@(V2 xo yo) cs)\n  | -- O doesn't need rotation\n    s == O                             = b\n  | -- I only has two orientations\n    s == I && V2 xo (yo + 1) `elem` cs = rotateWith clockwise\n  | otherwise                          = rotateWith counterclockwise\n where\n  clockwise        = (+ o) . cwperp . subtract o\n  counterclockwise = (+ o) . LV.perp . subtract o\n  rotateWith dir = b & extra %~ fmap dir\n  cwperp (V2 x y) = V2 y (-x)\n\n-- | Get coordinates of entire block\ncoords :: Block -> [Coord]\ncoords b = b ^. origin : b ^. extra\n\n-- Higher level functions on game and board\n\n-- | Facilitates cycling through at least 4 occurences of each shape\n-- before next bag (random permutation of 4*each tetrimino) is created. If input is empty,\n-- generates new bag, otherwise just unshifts the first value and returns pair.\nbagFourTetriminoEach :: Seq.Seq Tetrimino -> IO (Tetrimino, Seq.Seq Tetrimino)\nbagFourTetriminoEach (t :<| ts) = pure (t, ts)\nbagFourTetriminoEach Empty =\n  bagFourTetriminoEach <=< shuffle . Seq.fromList . take 28 $ cycle [I ..]\n\n-- | Initialize a game with a given level\ninitGame :: Int -> Bool -> IO Game\ninitGame lvl prog = do\n  (s1, bag1) <- bagFourTetriminoEach mempty\n  (s2, bag2) <- bagFourTetriminoEach bag1\n  pure $ Game\n    { _level        = lvl\n    , _block        = initBlock s1\n    , _nextShape    = s2\n    , _nextShapeBag = bag2\n    , _score        = 0\n    , _linesCleared = 0\n    , _board        = mempty\n    , _progression  = prog\n    }\n\n-- | Increment level\nnextLevel :: (MonadIO m, MonadState Game m) => m ()\nnextLevel = do\n  level %= (+ 1)\n\nisGameOver :: Game -> Bool\nisGameOver g = blockStopped g && g ^. (block . origin) == startOrigin\n\n-- | The main game execution, this is executed at each discrete time step\ntimeStep :: (MonadIO m, MonadState Game m) => m ()\ntimeStep = do\n  gets blockStopped >>= \\case\n    False -> gravitate\n    True -> do\n      freezeBlock\n      clearFullRows >>= updateScore\n      whenM (andM [use progression, levelFinished]) nextLevel\n      nextBlock\n\n-- | Gravitate current block, i.e. shift down\ngravitate :: MonadState Game m => m ()\ngravitate = shift Down\n\n-- | If necessary: clear full rows and return the count\nclearFullRows :: MonadState Game m => m Int\nclearFullRows = do\n  brd <- use board\n  let rowSize r = length $ M.filterWithKey (\\(V2 _ y) _ -> r == y) brd\n      fullRows = filter (\\r -> boardWidth == rowSize r) [1 .. boardHeight]\n  -- Clear cells in full rows\n  modifying board $ M.filterWithKey $ \\(V2 _ y) _ -> y `notElem` fullRows\n  -- Shift cells above full rows\n  modifying board $ M.mapKeysMonotonic $ over _y $ \\y ->\n    y - length (filter (< y) fullRows)\n  let clearedLines = length fullRows\n  linesCleared %= (+ clearedLines)\n  pure clearedLines\n\n-- | This updates game points with respect to the provided number of cleared\n-- lines.\n--\n-- See https://tetris.fandom.com/wiki/Scoring\nupdateScore :: (MonadState Game m, MonadIO m) => Int -> m ()\nupdateScore 0 = pure ()\nupdateScore lines = do\n  lvl <- use level\n  let newPoints = (lvl + 1) * points lines\n  score %= (+ newPoints)\n  where\n    -- Translate row line clears to points\n    points 0 = 0\n    points 1 = 40\n    points 2 = 100\n    points 3 = 300\n    points _ = 1200\n\n-- | Using the fixed-goal system described here: https://tetris.wiki/Marathon\nlevelFinished :: (MonadState Game m, MonadIO m) => m Bool\nlevelFinished = do\n  lvl <- use level\n  lc <- use linesCleared\n  pure $ lvl < 15 && lc >= 10 * (lvl + 1)\n\n-- | Handle counterclockwise block rotation (if possible)\n-- Allows wallkicks: http://tetris.wikia.com/wiki/TGM_rotation\nrotate :: MonadState Game m => m ()\nrotate = do\n  blk <- use block\n  brd <- use board\n  let mblk = foldr (((<|>)) . mfilter (isValidBlockPosition brd)\n        .   pure\n        .   ($ blk)) Nothing [ rotateRaw\n            , rotateRaw . translate Left\n            , rotateRaw . translate Right\n            ]\n  forM_ mblk $ assign block\n\nblockStopped :: Game -> Bool\nblockStopped g = isStopped (g ^. board) (g ^. block)\n\n-- | Check if a block on a board is stopped from further gravitation\nisStopped :: Board -> Block -> Bool\nisStopped brd = any stopped . coords\n where\n  stopped = (||) <$> atBottom <*> (`M.member` brd) . translate Down\n  atBottom = (== 1) . view _y\n\nhardDrop :: MonadState Game m => m ()\nhardDrop = hardDroppedBlock >>= assign block\n\nhardDroppedBlock :: MonadState Game m => m Block\nhardDroppedBlock = do\n  boardCoords <- M.keys <$> use board\n  blockCoords <- coords <$> use block\n  let diffs =\n        [ y - yo\n        | (V2 xo yo) <- boardCoords\n        , (V2 x  y ) <- blockCoords\n        , xo == x\n        , yo < y\n        ]\n      minY = minimum $ view _y <$> blockCoords\n      dist = minimum $ subtract 1 <$> (minY : diffs)\n  translateBy dist Down <$> use block\n\n-- | Freeze current block\nfreezeBlock :: MonadState Game m => m ()\nfreezeBlock = do\n  blk <- use block\n  modifying board $ M.union $ M.fromList [ (c, _shape blk) | c <- coords blk ]\n\n-- | Replace block with next block\nnextBlock :: (MonadIO m, MonadState Game m) => m ()\nnextBlock = do\n  bag <- use nextShapeBag\n  (t, ts) <- liftIO $ bagFourTetriminoEach bag\n  use nextShape >>= \\s -> block .= initBlock s\n  nextShape .= t\n  nextShapeBag .= ts\n\n-- | Try to shift current block; if shifting not possible, leave block where it is\nshift :: MonadState Game m => Direction -> m ()\nshift dir = do\n  brd <- use board\n  blk <- use block\n  let candidate = translate dir blk\n  when (isValidBlockPosition brd candidate) $\n    block .= candidate\n\n-- | Check if coordinate is already occupied or free in board\nisFree :: Board -> Coord -> Bool\nisFree = flip M.notMember\n\n-- | Check if coordinate is in or out of bounds\nisInBounds :: Coord -> Bool\nisInBounds (V2 x y) = 1 <= x && x <= boardWidth && 1 <= y\n\n-- | Checks if block's potential new location is valid\nisValidBlockPosition :: Board -> Block -> Bool\nisValidBlockPosition brd = all validCoord . coords\n  where validCoord = (&&) <$> isFree brd <*> isInBounds\n\n-- General utilities\n\n-- | Shuffle a sequence (random permutation)\nshuffle :: Seq.Seq a -> IO (Seq.Seq a)\nshuffle xs\n  | null xs = mempty\n  | otherwise = do\n    randomPosition <- getStdRandom (randomR (0, length xs - 1))\n    case Seq.splitAt randomPosition xs of\n      (left, y :<| ys) ->  fmap (y <|) (shuffle $ left >< ys)\n      _ -> error \"impossible\"\n\nv2 :: (a, a) -> V2 a\nv2 (x, y) = V2 x y\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
              "refactored_file_name": "/tmp/project_90/static_refactored/src/UI/PickLevel.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.2222222222222223,
                "sum": 11
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 101,
              "homplexity_lines_of_code": 134,
              "code_quality_score": 64.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.2222222222222223,
                  "sum": 11
                },
                "homplexity_loc": 134,
                "homplexity_output": "Info:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 2 1: module UI.PickLevel has 81 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 24 23: data LevelConfig' has record fields count of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 29 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 29 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 30 1: function app has 7 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 30 1: function app has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 30 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 40 1: type signature for selectedAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 40 1: type signature for selectedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 41 1: function selectedAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 41 1: function selectedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 41 1: function selectedAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 43 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 43 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 44 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 44 1: function drawUI has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 44 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 46 1: type signature for ui has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 46 1: type signature for ui has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 47 1: function ui has 14 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 47 1: function ui has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 47 1: function ui has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 63 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 63 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 64 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 64 1: function handleEvent has 12 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 64 1: function handleEvent has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 77 1: type signature for pickLevel has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 77 1: type signature for pickLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 78 1: function pickLevel has 5 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 78 1: function pickLevel has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 78 1: function pickLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 84 1: type signature for pickProgression has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 84 1: type signature for pickProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 85 1: function pickProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 85 1: function pickProgression has 4 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 85 1: function pickProgression has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 90 1: type signature for pickingLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 90 1: type signature for pickingLevel has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 91 1: function pickingLevel has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 91 1: function pickingLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 91 1: function pickingLevel has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 93 1: type signature for configureLeveling has 3 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 93 1: type signature for configureLeveling has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 94 1: function configureLeveling has 8 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 94 1: function configureLeveling has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/PickLevel.hs\" 94 1: function configureLeveling has branching depth of 2 \n"
              },
              "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n\nmodule UI.PickLevel\n  ( configureLeveling\n  , LevelConfig'(..)\n  ) where\n\nimport System.Exit\nimport Control.Monad\nimport Control.Monad.Extra\nimport Data.Functor.Identity\nimport Data.Maybe\n\nimport Brick\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport qualified Graphics.Vty as V\n\ntype LevelConfig = LevelConfig' Identity\ntype LevelConfigMaybe = LevelConfig' Maybe\n\ndata LevelConfig' t = LevelConfig\n  { level :: t Int\n  , progression :: t Bool\n  }\n\napp :: App LevelConfigMaybe e ()\napp = App\n  { appDraw         = drawUI\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const $ attrMap V.defAttr\n      [ (selectedAttr, V.black `on` V.white)\n      ]\n  , appChooseCursor = neverShowCursor\n  }\n\nselectedAttr :: AttrName\nselectedAttr = attrName \"selected\"\n\ndrawUI :: LevelConfigMaybe -> [Widget ()]\ndrawUI ps = [ui ps]\n\nui :: LevelConfigMaybe -> Widget ()\nui ps =\n  padLeft (Pad 19)\n    $ padRight (Pad 21)\n    $ C.center\n    $ vLimit 22\n    $ hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ C.center\n    $ if (isNothing ps.level)\n        then str \"Choose Level (0-9)\"\n        else vBox\n        [ C.hCenter $ str \"Level Progression?\"\n        , C.hCenter $ str \"([Y]/N)\"\n        ]\n\nhandleEvent :: BrickEvent () e -> EventM () LevelConfigMaybe ()\nhandleEvent (VtyEvent (V.EvKey V.KEsc        _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'N') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'n') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey V.KEnter []))     = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar d) [])) =\n  when (d `elem` ['0' .. '9']) $ pickLevel $ read [d]\nhandleEvent _ = pure ()\n\npickLevel :: Int -> EventM () LevelConfigMaybe ()\npickLevel n = do\n  whenM pickingLevel $ do\n    modify $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) $ do\n      halt\n\npickProgression :: Bool -> EventM () LevelConfigMaybe ()\npickProgression b = do\n  unlessM pickingLevel $ do\n    modify $ \\s -> s { progression = Just b }\n    halt\n\npickingLevel :: EventM () LevelConfigMaybe Bool\npickingLevel = gets (isNothing . level)\n\nconfigureLeveling :: Maybe Int -> Maybe Bool -> IO LevelConfig\nconfigureLeveling (Just l) (Just p) = pure $ LevelConfig (Identity l) (Identity p)\nconfigureLeveling ml mp = do\n  result <- defaultMain app $ LevelConfig ml mp\n  case result of\n    (LevelConfig {level = Just l, progression = Just p}) ->\n      pure $ LevelConfig (Identity l) (Identity p)\n    _ ->\n      exitSuccess\n",
              "suggestions": [
                {
                  "location": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE OverloadedRecordDot #-}\n\nmodule UI.PickLevel\n  ( configureLeveling\n  , LevelConfig'(..)\n  ) where\n\nimport System.Exit\nimport Control.Monad\nimport Control.Monad.Extra\nimport Data.Functor.Identity\nimport Data.Maybe\n\nimport Brick\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport qualified Graphics.Vty as V\n\ntype LevelConfig = LevelConfig' Identity\ntype LevelConfigMaybe = LevelConfig' Maybe\n\ndata LevelConfig' t = LevelConfig\n  { level :: t Int\n  , progression :: t Bool\n  }\n\napp :: App LevelConfigMaybe e ()\napp = App\n  { appDraw         = drawUI\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const $ attrMap V.defAttr\n      [ (selectedAttr, V.black `on` V.white)\n      ]\n  , appChooseCursor = neverShowCursor\n  }\n\nselectedAttr :: AttrName\nselectedAttr = attrName \"selected\"\n\ndrawUI :: LevelConfigMaybe -> [Widget ()]\ndrawUI ps = [ui ps]\n\nui :: LevelConfigMaybe -> Widget ()\nui ps =\n  padLeft (Pad 19)\n    $ padRight (Pad 21)\n    $ C.center\n    $ vLimit 22\n    $ hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ C.center\n    $ if isNothing ps.level\n        then str \"Choose Level (0-9)\"\n        else vBox\n        [ C.hCenter $ str \"Level Progression?\"\n        , C.hCenter $ str \"([Y]/N)\"\n        ]\n\nhandleEvent :: BrickEvent () e -> EventM () LevelConfigMaybe ()\nhandleEvent (VtyEvent (V.EvKey V.KEsc        _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'N') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'n') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey V.KEnter []))     = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar d) [])) =\n  when (d `elem` ['0' .. '9']) $ pickLevel $ read [d]\nhandleEvent _ = pure ()\n\npickLevel :: Int -> EventM () LevelConfigMaybe ()\npickLevel n = do\n  whenM pickingLevel $ do\n    modify $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) $ do\n      halt\n\npickProgression :: Bool -> EventM () LevelConfigMaybe ()\npickProgression b = do\n  unlessM pickingLevel $ do\n    modify $ \\s -> s { progression = Just b }\n    halt\n\npickingLevel :: EventM () LevelConfigMaybe Bool\npickingLevel = gets (isNothing . level)\n\nconfigureLeveling :: Maybe Int -> Maybe Bool -> IO LevelConfig\nconfigureLeveling (Just l) (Just p) = pure $ LevelConfig (Identity l) (Identity p)\nconfigureLeveling ml mp = do\n  result <- defaultMain app $ LevelConfig ml mp\n  case result of\n    (LevelConfig {level = Just l, progression = Just p}) ->\n      pure $ LevelConfig (Identity l) (Identity p)\n    _ ->\n      exitSuccess\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/UI/Game.hs",
              "refactored_file_name": "/tmp/project_90/static_refactored/src/UI/Game.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.1304347826086956,
                "sum": 52
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 15,
              "lines_of_code": 347,
              "homplexity_lines_of_code": 484,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.1304347826086956,
                  "sum": 52
                },
                "homplexity_loc": 484,
                "homplexity_output": "Info:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 1 1: module UI.Game has 280 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 32 11: data UI has record fields count of 6 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 44 13: data Tick has record fields count of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 50 5: data VisualBlock has record fields count of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 55 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 55 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 56 1: function app has 6 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 56 1: function app has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 56 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 64 1: type signature for playGame has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 64 1: type signature for playGame has 4 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 69 1: function playGame has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 69 1: function playGame has 18 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 69 1: function playGame has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 89 1: type signature for levelToDelay has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 89 1: type signature for levelToDelay has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 94 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 94 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 95 1: function handleEvent has cyclomatic complexity of 1 \nWarning:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 95 1: function handleEvent has 27 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 95 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 127 1: type signature for exec has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 127 1: type signature for exec has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 128 1: function exec has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 128 1: function exec has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 128 1: function exec has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 131 1: type signature for restart has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 131 1: type signature for restart has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 132 1: function restart has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 132 1: function restart has 6 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 132 1: function restart has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 139 1: type signature for toggleProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 139 1: type signature for toggleProgression has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 144 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 144 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 145 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 145 1: function drawUI has 5 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 145 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 153 1: type signature for drawGrid has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 153 1: type signature for drawGrid has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 154 1: function drawGrid has 16 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 154 1: function drawGrid has cyclomatic complexity of 3 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 154 1: function drawGrid has branching depth of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 173 1: type signature for emptyCellMap has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 173 1: type signature for emptyCellMap has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 174 1: function emptyCellMap has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 174 1: function emptyCellMap has 2 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 174 1: function emptyCellMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 177 1: type signature for emptyGridCellW has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 177 1: type signature for emptyGridCellW has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 178 1: function emptyGridCellW has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 178 1: function emptyGridCellW has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 178 1: function emptyGridCellW has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 180 1: type signature for emptyNextShapeCellW has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 180 1: type signature for emptyNextShapeCellW has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 181 1: function emptyNextShapeCellW has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 181 1: function emptyNextShapeCellW has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 181 1: function emptyNextShapeCellW has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 183 1: type signature for drawBlockCell has 3 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 183 1: type signature for drawBlockCell has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 184 1: function drawBlockCell has 2 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 184 1: function drawBlockCell has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 184 1: function drawBlockCell has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 187 1: type signature for tToAttr has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 187 1: type signature for tToAttr has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 188 1: function tToAttr has 7 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 188 1: function tToAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 188 1: function tToAttr has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 196 1: type signature for tToAttrH has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 196 1: type signature for tToAttrH has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 197 1: function tToAttrH has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 197 1: function tToAttrH has 7 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 197 1: function tToAttrH has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 205 1: type signature for cw has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 205 1: type signature for cw has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 206 1: function cw has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 206 1: function cw has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 206 1: function cw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 208 1: type signature for ecw has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 208 1: type signature for ecw has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 209 1: function ecw has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 209 1: function ecw has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 209 1: function ecw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 211 1: type signature for drawStats has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 211 1: type signature for drawStats has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 212 1: function drawStats has 10 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 212 1: function drawStats has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 212 1: function drawStats has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 224 1: type signature for drawProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 224 1: type signature for drawProgression has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 225 1: function drawProgression has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 225 1: function drawProgression has 5 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 225 1: function drawProgression has cyclomatic complexity of 3 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 231 1: type signature for drawStat has 3 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 231 1: type signature for drawStat has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 232 1: function drawStat has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 232 1: function drawStat has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 232 1: function drawStat has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 234 1: type signature for drawLeaderBoard has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 234 1: type signature for drawLeaderBoard has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 235 1: function drawLeaderBoard has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 235 1: function drawLeaderBoard has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 235 1: function drawLeaderBoard has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 237 1: type signature for drawInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 237 1: type signature for drawInfo has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 238 1: function drawInfo has 5 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 238 1: function drawInfo has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 238 1: function drawInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 245 1: type signature for drawNextShape has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 245 1: type signature for drawNextShape has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 246 1: function drawNextShape has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 246 1: function drawNextShape has 13 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 246 1: function drawNextShape has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 261 1: type signature for drawHelp has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 261 1: type signature for drawHelp has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 262 1: function drawHelp has 15 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 262 1: function drawHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 262 1: function drawHelp has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 279 1: type signature for drawKeyInfo has 3 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 279 1: type signature for drawKeyInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 280 1: function drawKeyInfo has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 280 1: function drawKeyInfo has 3 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 280 1: function drawKeyInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 284 1: type signature for drawGameOver has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 284 1: type signature for drawGameOver has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 285 1: function drawGameOver has 4 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 285 1: function drawGameOver has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 285 1: function drawGameOver has cyclomatic complexity of 2 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 290 1: type signature for theMap has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 290 1: type signature for theMap has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 291 1: function theMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 291 1: function theMap has 19 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 291 1: function theMap has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 312 1: type signature for tToColor has 2 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 312 1: type signature for tToColor has type constructor nesting of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 313 1: function tToColor has 7 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 313 1: function tToColor has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 313 1: function tToColor has branching depth of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 321 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 321 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 322 1: function iAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 322 1: function iAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 322 1: function iAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 323 1: function oAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 323 1: function oAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 323 1: function oAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 324 1: function tAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 324 1: function tAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 324 1: function tAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 325 1: function sAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 325 1: function sAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 325 1: function sAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 326 1: function zAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 326 1: function zAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 326 1: function zAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 327 1: function jAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 327 1: function jAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 327 1: function jAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 328 1: function lAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 328 1: function lAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 328 1: function lAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 330 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 330 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 331 1: function ihAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 331 1: function ihAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 331 1: function ihAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 332 1: function ohAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 332 1: function ohAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 332 1: function ohAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 333 1: function thAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 333 1: function thAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 333 1: function thAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 334 1: function shAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 334 1: function shAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 334 1: function shAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 335 1: function zhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 335 1: function zhAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 335 1: function zhAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 336 1: function jhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 336 1: function jhAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 336 1: function jhAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 337 1: function lhAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 337 1: function lhAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 337 1: function lhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 339 1: type signature for emptyAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 339 1: type signature for emptyAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 340 1: function emptyAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 340 1: function emptyAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 340 1: function emptyAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 342 1: type signature for gameOverAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 342 1: type signature for gameOverAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 343 1: function gameOverAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 343 1: function gameOverAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 343 1: function gameOverAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 345 1: type signature for progressionAttr, fixedAttr has 1 arguments \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 345 1: type signature for progressionAttr, fixedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 346 1: function progressionAttr has branching depth of 0 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 346 1: function progressionAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 346 1: function progressionAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 347 1: function fixedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 347 1: function fixedAttr has 1 lines of code \nInfo:/tmp/project_90/static_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/static_refactored/src/UI/Game.hs\" 347 1: function fixedAttr has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\nmodule UI.Game\n  ( playGame\n  ) where\n\nimport Control.Concurrent (threadDelay, forkIO)\nimport Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, writeTVar, atomically)\nimport Control.Monad (void, forever)\nimport Prelude hiding (Left, Right)\n\nimport Brick hiding (Down)\nimport Brick.BChan\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport Control.Lens hiding (preview, op, zoom)\nimport Control.Monad.Extra (orM, unlessM)\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Graphics.Vty as V\nimport qualified Graphics.Vty.CrossPlatform\nimport qualified Graphics.Vty.Config\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Linear.V2 (V2(..))\n\nimport Tetris\n\ndata UI = UI\n  { _game      :: Game\n  , _initLevel :: Int\n  , _currLevel :: TVar Int\n  , _preview   :: Maybe String\n  , _locked    :: Bool\n  , _paused    :: Bool\n  }\n\nmakeLenses ''UI\n\n-- | Ticks mark passing of time\ndata Tick = Tick\n\n-- | Named resources\ntype Name = ()\n\ndata VisualBlock\n  = NormalBlock\n  | HardDropBlock String\n\n-- App definition and execution\n\napp :: App UI Tick Name\napp = App\n  { appDraw         = drawUI\n  , appChooseCursor = neverShowCursor\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const theMap\n  }\n\nplayGame\n  :: Int          -- ^ Starting level\n  -> Bool         -- ^ Enable level progression\n  -> Maybe String -- ^ Preview cell (Nothing == no preview)\n  -> IO Game\nplayGame lvl prog mp = do\n  chan <- newBChan 10   -- share the current level with the thread so it can adjust speed\n  tv <- newTVarIO lvl\n  void . forkIO $ forever $ do\n    writeBChan chan Tick\n    lvl' <- readTVarIO tv\n    threadDelay $ levelToDelay lvl'\n  initialGame <- initGame lvl prog  -- Pass the progression parameter\n  let buildVty = Graphics.Vty.CrossPlatform.mkVty Graphics.Vty.Config.defaultConfig\n  initialVty <- buildVty\n  ui <- customMain initialVty buildVty (Just chan) app $ UI\n    { _game      = initialGame\n    , _initLevel = lvl\n    , _currLevel = tv\n    , _preview   = mp\n    , _locked    = False\n    , _paused    = False\n    }\n  return $ ui ^. game\n\nlevelToDelay :: Int -> Int\nlevelToDelay n = floor $ 400000 * (0.85 :: Double) ^ (2 * n)\n\n-- Handling events\n\nhandleEvent :: BrickEvent Name Tick -> EventM Name UI ()\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'r') [])) = restart\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') [])) = halt\nhandleEvent (VtyEvent (V.EvKey V.KEsc        [])) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'm') [])) = exec toggleProgression\nhandleEvent (VtyEvent (V.EvKey V.KRight      [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey V.KLeft       [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey V.KDown       [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'l') [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'h') [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'j') [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey V.KUp         [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'k') [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') [])) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game hardDrop\n    assign locked True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'p') [])) =\n  unlessM (orM [use locked, use (game . to isGameOver)]) $ do\n    modifying paused not\nhandleEvent (AppEvent Tick                      ) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game timeStep\n    -- Keep level in sync with ticker (gross)\n    lvl <- use $ game . level\n    tv <- use $ currLevel\n    liftIO . atomically $ writeTVar tv lvl\n    assign locked False\nhandleEvent _ = pure ()\n\n-- | This common execution function is used for all game user input except hard\n-- drop and pause. If paused or locked (from hard drop) do nothing, else\n-- execute the state computation.\nexec :: Tetris () -> EventM Name UI ()\nexec = unlessM (orM [use paused, use locked, use (game . to isGameOver)]) . zoom game\n\n-- | Restart game at the initially chosen level\nrestart :: EventM Name UI ()\nrestart = do\n  lvl <- use initLevel\n  prog <- use (game . progression)  -- Get current progression setting\n  g <- liftIO $ initGame lvl prog   -- Use it when restarting\n  assign game g\n  assign locked False\n\ntoggleProgression :: Tetris ()\ntoggleProgression = modifying progression not\n\n-- Drawing\n\ndrawUI :: UI -> [Widget Name]\ndrawUI ui =\n  [ C.vCenter $ vLimit 22 $ hBox\n      [ padLeft Max $ padRight (Pad 2) $ drawStats (ui ^. game)\n      , drawGrid ui\n      , padRight Max $ padLeft (Pad 2) $ drawInfo (ui ^. game)\n      ]\n  ]\n\ndrawGrid :: UI -> Widget Name\ndrawGrid ui =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ case ui ^. paused of\n        True  -> C.center $ str \"Paused\"\n        False -> vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r ->\n          foldr (<+>) emptyWidget\n            . M.filterWithKey (\\(V2 _ y) _ -> r == y)\n            $ mconcat\n                [ drawBlockCell NormalBlock <$> ui ^. (game . board)\n                , blockMap NormalBlock (ui ^. (game . block))\n                , case ui ^. preview of\n                    Nothing -> M.empty\n                    Just s  -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game))\n                , emptyCellMap\n                ]\n where\n  blockMap v b =\n    M.fromList $ [ (c, drawBlockCell v (b ^. shape)) | c <- coords b ]\n\nemptyCellMap :: Map Coord (Widget Name)\nemptyCellMap = M.fromList\n  [ (V2 x y, emptyGridCellW) | x <- [1 .. boardWidth], y <- [1 .. boardHeight] ]\n\nemptyGridCellW :: Widget Name\nemptyGridCellW = withAttr emptyAttr cw\n\nemptyNextShapeCellW :: Widget Name\nemptyNextShapeCellW = withAttr emptyAttr ecw\n\ndrawBlockCell :: VisualBlock -> Tetrimino -> Widget Name\ndrawBlockCell NormalBlock       t = withAttr (tToAttr t) cw\ndrawBlockCell (HardDropBlock s) t = withAttr (tToAttrH t) (str s)\n\ntToAttr :: Tetrimino -> AttrName\ntToAttr I = iAttr\ntToAttr O = oAttr\ntToAttr T = tAttr\ntToAttr S = sAttr\ntToAttr Z = zAttr\ntToAttr J = jAttr\ntToAttr L = lAttr\n\ntToAttrH :: Tetrimino -> AttrName\ntToAttrH I = ihAttr\ntToAttrH O = ohAttr\ntToAttrH T = thAttr\ntToAttrH S = shAttr\ntToAttrH Z = zhAttr\ntToAttrH J = jhAttr\ntToAttrH L = lhAttr\n\ncw :: Widget Name\ncw = str \" .\"\n\necw :: Widget Name\necw = str \"  \"\n\ndrawStats :: Game -> Widget Name\ndrawStats g =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Stats\")\n    $ vBox\n        [ drawStat \"Score\" $ g ^. score\n        , padTop (Pad 1) $ drawStat \"Lines\" $ g ^. linesCleared\n        , padTop (Pad 1) $ drawStat \"Level\" $ g ^. level\n        , padTop (Pad 1) $ drawProgression (g ^. progression)\n        , drawLeaderBoard g\n        ]\n\ndrawProgression :: Bool -> Widget Name\ndrawProgression enabled =\n  let attr = if enabled then progressionAttr else fixedAttr\n      text = if enabled then \"On\" else \"Off\"\n  in padLeftRight 1 $ str \"Leveling \"\n      <+> withAttr attr (padLeft Max $ str text)\n\ndrawStat :: String -> Int -> Widget Name\ndrawStat s n = padLeftRight 1 $ str s <+> padLeft Max (str $ show n)\n\ndrawLeaderBoard :: Game -> Widget Name\ndrawLeaderBoard _ = emptyWidget\n\ndrawInfo :: Game -> Widget Name\ndrawInfo g = hLimit 18 -- size of next piece box\n  $ vBox\n    [ drawNextShape (g ^. nextShape)\n    , padTop (Pad 1) drawHelp\n    , padTop (Pad 1) (drawGameOver g)\n    ]\n\ndrawNextShape :: Tetrimino -> Widget Name\ndrawNextShape t =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Next\")\n    $ padTopBottom 1\n    $ padLeftRight 4\n    $ vLimit 4\n    $ vBox\n    $ [0, -1] <&> \\y ->\n      hBox [ if V2 x y `elem` coords blk\n             then drawBlockCell NormalBlock t\n             else emptyNextShapeCellW\n           | x <- [-2 .. 1]\n           ]\n  where blk = Block t (V2 0 0) (relCells t)\n\ndrawHelp :: Widget Name\ndrawHelp =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Help\")\n    $ padTopBottom 1\n    $ vBox\n    $ map (uncurry drawKeyInfo)\n      [ (\"Left\"   , \"h, \u2190\")\n      , (\"Right\"  , \"l, \u2192\")\n      , (\"Down\"   , \"j, \u2193\")\n      , (\"Rotate\" , \"k, \u2191\")\n      , (\"Drop\"   , \"space\")\n      , (\"Mode\"   , \"m\")\n      , (\"Restart\", \"r\")\n      , (\"Pause\"  , \"p\")\n      , (\"Quit\"   , \"q\")\n      ]\n\ndrawKeyInfo :: String -> String -> Widget Name\ndrawKeyInfo action keys =\n  padRight Max (padLeft (Pad 1) $ str action)\n    <+> padLeft Max (padRight (Pad 1) $ str keys)\n\ndrawGameOver :: Game -> Widget Name\ndrawGameOver g =\n  if isGameOver g\n  then padLeftRight 4 $ withAttr gameOverAttr $ str \"GAME OVER\"\n  else emptyWidget\n\ntheMap :: AttrMap\ntheMap = attrMap\n  V.defAttr\n  [ (iAttr          , tToColor I `on` tToColor I)\n  , (oAttr          , tToColor O `on` tToColor O)\n  , (tAttr          , tToColor T `on` tToColor T)\n  , (sAttr          , tToColor S `on` tToColor S)\n  , (zAttr          , tToColor Z `on` tToColor Z)\n  , (jAttr          , tToColor J `on` tToColor J)\n  , (lAttr          , tToColor L `on` tToColor L)\n  , (ihAttr         , fg $ tToColor I)\n  , (ohAttr         , fg $ tToColor O)\n  , (thAttr         , fg $ tToColor T)\n  , (shAttr         , fg $ tToColor S)\n  , (zhAttr         , fg $ tToColor Z)\n  , (jhAttr         , fg $ tToColor J)\n  , (lhAttr         , fg $ tToColor L)\n  , (gameOverAttr   , fg V.red `V.withStyle` V.bold)\n  , (progressionAttr, fg V.green `V.withStyle` V.bold)\n  , (fixedAttr      , fg V.blue `V.withStyle` V.bold)\n  ]\n\ntToColor :: Tetrimino -> V.Color\ntToColor I = V.cyan\ntToColor O = V.yellow\ntToColor T = V.magenta\ntToColor S = V.green\ntToColor Z = V.red\ntToColor J = V.blue\ntToColor L = V.white\n\niAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr :: AttrName\niAttr = attrName \"I\"\noAttr = attrName \"O\"\ntAttr = attrName \"T\"\nsAttr = attrName \"S\"\nzAttr = attrName \"Z\"\njAttr = attrName \"J\"\nlAttr = attrName \"L\"\n\nihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr :: AttrName\nihAttr = attrName \"Ih\"\nohAttr = attrName \"Oh\"\nthAttr = attrName \"Th\"\nshAttr = attrName \"Sh\"\nzhAttr = attrName \"Zh\"\njhAttr = attrName \"Jh\"\nlhAttr = attrName \"Lh\"\n\nemptyAttr :: AttrName\nemptyAttr = attrName \"empty\"\n\ngameOverAttr :: AttrName\ngameOverAttr = attrName \"gameOver\"\n\nprogressionAttr, fixedAttr :: AttrName\nprogressionAttr = attrName \"progression\"\nfixedAttr = attrName \"fixed\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_90/pre_refactor/src/UI/Game.hs:(158,7)-(170,17)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case ui ^. paused of",
                    "    True -> C.center $ str \"Paused\"",
                    "    False",
                    "      -> vBox",
                    "           $ [boardHeight, boardHeight - 1 .. 1]",
                    "               <&>",
                    "                 \\ r",
                    "                   -> foldr (<+>) emptyWidget",
                    "                        . M.filterWithKey (\\ (V2 _ y) _ -> r == y)",
                    "                        $ mconcat",
                    "                            [drawBlockCell NormalBlock <$> ui ^. (game . board),",
                    "                             blockMap NormalBlock (ui ^. (game . block)),",
                    "                             case ui ^. preview of",
                    "                               Nothing -> M.empty",
                    "                               Just s",
                    "                                 -> blockMap",
                    "                                      (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),",
                    "                             emptyCellMap]"
                  ],
                  "perhaps_block": [
                    "  (if ui ^. paused then",
                    "       C.center $ str \"Paused\"",
                    "   else",
                    "       vBox",
                    "         $ [boardHeight, boardHeight - 1 .. 1]",
                    "             <&>",
                    "               \\ r",
                    "                 -> foldr (<+>) emptyWidget",
                    "                      . M.filterWithKey (\\ (V2 _ y) _ -> r == y)",
                    "                      $ mconcat",
                    "                          [drawBlockCell NormalBlock <$> ui ^. (game . board),",
                    "                           blockMap NormalBlock (ui ^. (game . block)),",
                    "                           case ui ^. preview of",
                    "                             Nothing -> M.empty",
                    "                             Just s",
                    "                               -> blockMap",
                    "                                    (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),",
                    "                           emptyCellMap])"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\nmodule UI.Game\n  ( playGame\n  ) where\n\nimport Control.Concurrent (threadDelay, forkIO)\nimport Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, writeTVar, atomically)\nimport Control.Monad (void, forever)\nimport Prelude hiding (Left, Right)\n\nimport Brick hiding (Down)\nimport Brick.BChan\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport Control.Lens hiding (preview, op, zoom)\nimport Control.Monad.Extra (orM, unlessM)\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Graphics.Vty as V\nimport qualified Graphics.Vty.CrossPlatform\nimport qualified Graphics.Vty.Config\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Linear.V2 (V2(..))\n\nimport Tetris\n\ndata UI = UI\n  { _game      :: Game\n  , _initLevel :: Int\n  , _currLevel :: TVar Int\n  , _preview   :: Maybe String\n  , _locked    :: Bool\n  , _paused    :: Bool\n  }\n\nmakeLenses ''UI\n\n-- | Ticks mark passing of time\ndata Tick = Tick\n\n-- | Named resources\ntype Name = ()\n\ndata VisualBlock\n  = NormalBlock\n  | HardDropBlock String\n\n-- App definition and execution\n\napp :: App UI Tick Name\napp = App\n  { appDraw         = drawUI\n  , appChooseCursor = neverShowCursor\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const theMap\n  }\n\nplayGame\n  :: Int          -- ^ Starting level\n  -> Bool         -- ^ Enable level progression\n  -> Maybe String -- ^ Preview cell (Nothing == no preview)\n  -> IO Game\nplayGame lvl prog mp = do\n  chan <- newBChan 10   -- share the current level with the thread so it can adjust speed\n  tv <- newTVarIO lvl\n  void . forkIO $ forever $ do\n    writeBChan chan Tick\n    lvl' <- readTVarIO tv\n    threadDelay $ levelToDelay lvl'\n  initialGame <- initGame lvl prog  -- Pass the progression parameter\n  let buildVty = Graphics.Vty.CrossPlatform.mkVty Graphics.Vty.Config.defaultConfig\n  initialVty <- buildVty\n  ui <- customMain initialVty buildVty (Just chan) app $ UI\n    { _game      = initialGame\n    , _initLevel = lvl\n    , _currLevel = tv\n    , _preview   = mp\n    , _locked    = False\n    , _paused    = False\n    }\n  return $ ui ^. game\n\nlevelToDelay :: Int -> Int\nlevelToDelay n = floor $ 400000 * (0.85 :: Double) ^ (2 * n)\n\n-- Handling events\n\nhandleEvent :: BrickEvent Name Tick -> EventM Name UI ()\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'r') [])) = restart\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') [])) = halt\nhandleEvent (VtyEvent (V.EvKey V.KEsc        [])) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'm') [])) = exec toggleProgression\nhandleEvent (VtyEvent (V.EvKey V.KRight      [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey V.KLeft       [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey V.KDown       [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'l') [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'h') [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'j') [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey V.KUp         [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'k') [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') [])) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game hardDrop\n    assign locked True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'p') [])) =\n  unlessM (orM [use locked, use (game . to isGameOver)]) $ do\n    modifying paused not\nhandleEvent (AppEvent Tick                      ) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game timeStep\n    -- Keep level in sync with ticker (gross)\n    lvl <- use $ game . level\n    tv <- use currLevel\n    liftIO . atomically $ writeTVar tv lvl\n    assign locked False\nhandleEvent _ = pure ()\n\n-- | This common execution function is used for all game user input except hard\n-- drop and pause. If paused or locked (from hard drop) do nothing, else\n-- execute the state computation.\nexec :: Tetris () -> EventM Name UI ()\nexec = unlessM (orM [use paused, use locked, use (game . to isGameOver)]) . zoom game\n\n-- | Restart game at the initially chosen level\nrestart :: EventM Name UI ()\nrestart = do\n  lvl <- use initLevel\n  prog <- use (game . progression)  -- Get current progression setting\n  g <- liftIO $ initGame lvl prog   -- Use it when restarting\n  assign game g\n  assign locked False\n\ntoggleProgression :: Tetris ()\ntoggleProgression = modifying progression not\n\n-- Drawing\n\ndrawUI :: UI -> [Widget Name]\ndrawUI ui =\n  [ C.vCenter $ vLimit 22 $ hBox\n      [ padLeft Max $ padRight (Pad 2) $ drawStats (ui ^. game)\n      , drawGrid ui\n      , padRight Max $ padLeft (Pad 2) $ drawInfo (ui ^. game)\n      ]\n  ]\n\ndrawGrid :: UI -> Widget Name\ndrawGrid ui =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ (if ui ^. paused then C.center $ str \"Paused\" else vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r ->\n  foldr (<+>) emptyWidget\n    . M.filterWithKey (\\(V2 _ y) _ -> r == y)\n    $ mconcat\n        [ drawBlockCell NormalBlock <$> ui ^. (game . board)\n        , blockMap NormalBlock (ui ^. (game . block))\n        , case ui ^. preview of\n            Nothing -> M.empty\n            Just s  -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game))\n        , emptyCellMap\n        ])\n where\n  blockMap v b =\n    M.fromList $ [ (c, drawBlockCell v (b ^. shape)) | c <- coords b ]\n\nemptyCellMap :: Map Coord (Widget Name)\nemptyCellMap = M.fromList\n  [ (V2 x y, emptyGridCellW) | x <- [1 .. boardWidth], y <- [1 .. boardHeight] ]\n\nemptyGridCellW :: Widget Name\nemptyGridCellW = withAttr emptyAttr cw\n\nemptyNextShapeCellW :: Widget Name\nemptyNextShapeCellW = withAttr emptyAttr ecw\n\ndrawBlockCell :: VisualBlock -> Tetrimino -> Widget Name\ndrawBlockCell NormalBlock       t = withAttr (tToAttr t) cw\ndrawBlockCell (HardDropBlock s) t = withAttr (tToAttrH t) (str s)\n\ntToAttr :: Tetrimino -> AttrName\ntToAttr I = iAttr\ntToAttr O = oAttr\ntToAttr T = tAttr\ntToAttr S = sAttr\ntToAttr Z = zAttr\ntToAttr J = jAttr\ntToAttr L = lAttr\n\ntToAttrH :: Tetrimino -> AttrName\ntToAttrH I = ihAttr\ntToAttrH O = ohAttr\ntToAttrH T = thAttr\ntToAttrH S = shAttr\ntToAttrH Z = zhAttr\ntToAttrH J = jhAttr\ntToAttrH L = lhAttr\n\ncw :: Widget Name\ncw = str \" .\"\n\necw :: Widget Name\necw = str \"  \"\n\ndrawStats :: Game -> Widget Name\ndrawStats g =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Stats\")\n    $ vBox\n        [ drawStat \"Score\" $ g ^. score\n        , padTop (Pad 1) $ drawStat \"Lines\" $ g ^. linesCleared\n        , padTop (Pad 1) $ drawStat \"Level\" $ g ^. level\n        , padTop (Pad 1) $ drawProgression (g ^. progression)\n        , drawLeaderBoard g\n        ]\n\ndrawProgression :: Bool -> Widget Name\ndrawProgression enabled =\n  let attr = if enabled then progressionAttr else fixedAttr\n      text = if enabled then \"On\" else \"Off\"\n  in padLeftRight 1 $ str \"Leveling \"\n      <+> withAttr attr (padLeft Max $ str text)\n\ndrawStat :: String -> Int -> Widget Name\ndrawStat s n = padLeftRight 1 $ str s <+> padLeft Max (str $ show n)\n\ndrawLeaderBoard :: Game -> Widget Name\ndrawLeaderBoard _ = emptyWidget\n\ndrawInfo :: Game -> Widget Name\ndrawInfo g = hLimit 18 -- size of next piece box\n  $ vBox\n    [ drawNextShape (g ^. nextShape)\n    , padTop (Pad 1) drawHelp\n    , padTop (Pad 1) (drawGameOver g)\n    ]\n\ndrawNextShape :: Tetrimino -> Widget Name\ndrawNextShape t =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Next\")\n    $ padTopBottom 1\n    $ padLeftRight 4\n    $ vLimit 4\n    $ vBox\n    $ [0, -1] <&> \\y ->\n      hBox [ if V2 x y `elem` coords blk\n             then drawBlockCell NormalBlock t\n             else emptyNextShapeCellW\n           | x <- [-2 .. 1]\n           ]\n  where blk = Block t (V2 0 0) (relCells t)\n\ndrawHelp :: Widget Name\ndrawHelp =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Help\")\n    $ padTopBottom 1\n    $ vBox\n    $ map (uncurry drawKeyInfo)\n      [ (\"Left\"   , \"h, \u2190\")\n      , (\"Right\"  , \"l, \u2192\")\n      , (\"Down\"   , \"j, \u2193\")\n      , (\"Rotate\" , \"k, \u2191\")\n      , (\"Drop\"   , \"space\")\n      , (\"Mode\"   , \"m\")\n      , (\"Restart\", \"r\")\n      , (\"Pause\"  , \"p\")\n      , (\"Quit\"   , \"q\")\n      ]\n\ndrawKeyInfo :: String -> String -> Widget Name\ndrawKeyInfo action keys =\n  padRight Max (padLeft (Pad 1) $ str action)\n    <+> padLeft Max (padRight (Pad 1) $ str keys)\n\ndrawGameOver :: Game -> Widget Name\ndrawGameOver g =\n  if isGameOver g\n  then padLeftRight 4 $ withAttr gameOverAttr $ str \"GAME OVER\"\n  else emptyWidget\n\ntheMap :: AttrMap\ntheMap = attrMap\n  V.defAttr\n  [ (iAttr          , tToColor I `on` tToColor I)\n  , (oAttr          , tToColor O `on` tToColor O)\n  , (tAttr          , tToColor T `on` tToColor T)\n  , (sAttr          , tToColor S `on` tToColor S)\n  , (zAttr          , tToColor Z `on` tToColor Z)\n  , (jAttr          , tToColor J `on` tToColor J)\n  , (lAttr          , tToColor L `on` tToColor L)\n  , (ihAttr         , fg $ tToColor I)\n  , (ohAttr         , fg $ tToColor O)\n  , (thAttr         , fg $ tToColor T)\n  , (shAttr         , fg $ tToColor S)\n  , (zhAttr         , fg $ tToColor Z)\n  , (jhAttr         , fg $ tToColor J)\n  , (lhAttr         , fg $ tToColor L)\n  , (gameOverAttr   , fg V.red `V.withStyle` V.bold)\n  , (progressionAttr, fg V.green `V.withStyle` V.bold)\n  , (fixedAttr      , fg V.blue `V.withStyle` V.bold)\n  ]\n\ntToColor :: Tetrimino -> V.Color\ntToColor I = V.cyan\ntToColor O = V.yellow\ntToColor T = V.magenta\ntToColor S = V.green\ntToColor Z = V.red\ntToColor J = V.blue\ntToColor L = V.white\n\niAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr :: AttrName\niAttr = attrName \"I\"\noAttr = attrName \"O\"\ntAttr = attrName \"T\"\nsAttr = attrName \"S\"\nzAttr = attrName \"Z\"\njAttr = attrName \"J\"\nlAttr = attrName \"L\"\n\nihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr :: AttrName\nihAttr = attrName \"Ih\"\nohAttr = attrName \"Oh\"\nthAttr = attrName \"Th\"\nshAttr = attrName \"Sh\"\nzhAttr = attrName \"Zh\"\njhAttr = attrName \"Jh\"\nlhAttr = attrName \"Lh\"\n\nemptyAttr :: AttrName\nemptyAttr = attrName \"empty\"\n\ngameOverAttr :: AttrName\ngameOverAttr = attrName \"gameOver\"\n\nprogressionAttr, fixedAttr :: AttrName\nprogressionAttr = attrName \"progression\"\nfixedAttr = attrName \"fixed\"\n"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 4,
              "max": 15,
              "average": 32.0,
              "sum": 128
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 3,
              "suggestion": 4,
              "ignore": 0,
              "total": 7
            },
            "syntax_errors": 38,
            "lines_of_code": 922,
            "homplexity_lines_of_code": 1127,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "91.89MB",
              "runtime": "1 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_90/pre_refactor/app/Main.hs",
              "refactored_file_name": "/tmp/project_90/hybrid_refactored/app/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.5454545454545454,
                "sum": 17
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 0,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 6,
              "lines_of_code": 135,
              "homplexity_lines_of_code": 186,
              "code_quality_score": 47.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.5454545454545454,
                  "sum": 17
                },
                "homplexity_loc": 186,
                "homplexity_output": "Info:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 1 1: module Main has 108 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 19 13: data Opts has record fields count of 4 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 26 20: data HardDropOpt has record fields count of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 28 1: type signature for opts has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 28 1: type signature for opts has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 29 1: function opts has 14 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 29 1: function opts has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 29 1: function opts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 44 1: type signature for toggle has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 44 1: type signature for toggle has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 45 1: function toggle has 6 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 45 1: function toggle has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 45 1: function toggle has cyclomatic complexity of 3 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 52 1: type signature for hardDropOpt has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 52 1: type signature for hardDropOpt has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 53 1: function hardDropOpt has 16 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 53 1: function hardDropOpt has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 53 1: function hardDropOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 71 1: type signature for fullopts has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 71 1: type signature for fullopts has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 72 1: function fullopts has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 72 1: function fullopts has 3 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 72 1: function fullopts has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 76 1: type signature for twoChar has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 76 1: type signature for twoChar has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 77 1: function twoChar has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 77 1: function twoChar has 5 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 77 1: function twoChar has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 83 1: type signature for hdOptStr has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 83 1: type signature for hdOptStr has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 84 1: function hdOptStr has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 84 1: function hdOptStr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 84 1: function hdOptStr has 3 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 88 1: type signature for main has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 88 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 89 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 89 1: function main has 9 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 89 1: function main has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 103 1: type signature for handleEndGame has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 103 1: type signature for handleEndGame has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 104 1: function handleEndGame has cyclomatic complexity of 3 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 104 1: function handleEndGame has branching depth of 2 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 104 1: function handleEndGame has 9 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 118 1: type signature for getHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 118 1: type signature for getHighScore has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 119 1: function getHighScore has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 119 1: function getHighScore has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 119 1: function getHighScore has 6 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 126 1: type signature for setHighScore has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 126 1: type signature for setHighScore has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 127 1: function setHighScore has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 127 1: function setHighScore has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 127 1: function setHighScore has 3 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 131 1: type signature for getLeaderboardFile has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 131 1: type signature for getLeaderboardFile has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 132 1: function getLeaderboardFile has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 132 1: function getLeaderboardFile has 4 lines of code \nInfo:/tmp/project_90/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/app/Main.hs\" 132 1: function getLeaderboardFile has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\nmodule Main where\n\nimport Control.Monad (when)\nimport System.Exit (exitSuccess)\nimport Text.Read (readMaybe)\nimport Data.Char (toLower)\nimport Data.Functor.Identity\n\nimport Options.Applicative\nimport qualified System.Directory as D\nimport System.FilePath ((</>))\n\nimport Tetris (Game(..))\nimport UI.PickLevel (configureLeveling, LevelConfig'(..))\nimport UI.Game (playGame)\n\ndata Opts = Opts\n  { hardDrop :: HardDropOpt\n  , level :: Maybe Int\n  , progression :: Maybe Bool\n  , score :: Bool\n  }\n\ndata HardDropOpt = None | AsciiOnly | CustomChars String\n\nopts :: Parser Opts\nopts = Opts\n  <$> hardDropOpt\n  <*> optional (option auto\n    (  long \"level\"\n    <> short 'l'\n    <> metavar \"LEVEL\"\n    <> help \"Specify level (unspecified results in prompt)\" ))\n  <*> optional (option toggle\n    (  long \"progression\"\n    <> metavar \"BOOL\"\n    <> help \"Turn level progression ON/OFF (unspecified results in prompt)\" ))\n  <*> switch\n    (  long \"high-score\"\n    <> help \"Print high score and exit\" )\n\ntoggle :: ReadM Bool\ntoggle = do\n  s <- str\n  case toLower <$> s of\n    y | y `elem` [\"y\", \"yes\", \"on\", \"t\", \"true\"] -> return True\n    n | n `elem` [\"n\", \"no\", \"off\", \"f\", \"false\"] -> return False\n    _   -> readerError \"Must be 'Y' or 'N'\"\n\nhardDropOpt :: Parser HardDropOpt\nhardDropOpt = noneOpt <|> asciiOpt <|> custOpt\n  where\n    noneOpt = flag' None\n      (  long \"no-preview\"\n      <> short 'n'\n      <> help \"Don't show preview cell\" )\n    asciiOpt = flag' AsciiOnly\n      (  long \"ascii-only\"\n      <> short 'a'\n      <> help \"Use '[]' as hard drop preview cell\" )\n    custOpt = CustomChars <$> option twoChar\n      (  long \"preview-chars\"\n      <> short 'p'\n      <> metavar \"CHARS\"\n      <> value \"\u25e4\u25e2\"\n      <> showDefaultWith (const \"\u25e4\u25e2\")\n      <> help \"Customize two character preview cell\" )\n\nfullopts :: ParserInfo Opts\nfullopts = info (helper <*> opts)\n  (  fullDesc\n  <> header \"tetris - the iconic game right in your terminal\" )\n\ntwoChar :: ReadM String\ntwoChar = do\n  cs <- str\n  if length cs /= 2\n     then readerError \"Preview must be two characters long\"\n     else return cs\n\nhdOptStr :: HardDropOpt -> Maybe String\nhdOptStr None            = Nothing\nhdOptStr AsciiOnly       = Just \"[]\"\nhdOptStr (CustomChars s) = Just s\n\nmain :: IO ()\nmain = do\n  (Opts {..}) <- execParser fullopts\n  -- show high score and exit\n  when score (getHighScore >>= printM >> exitSuccess)\n  -- pick level prompt if necessary\n  levelConfig <- configureLeveling level progression\n  -- play game\n  g <- playGame\n    (runIdentity levelConfig.level)\n    (runIdentity levelConfig.progression)\n    (hdOptStr hardDrop)\n  -- save & print score\n  handleEndGame (_score g)\n\nhandleEndGame :: Int -> IO ()\nhandleEndGame s = do\n  mhs <- getHighScore\n  case mhs of\n    Nothing -> newHighScore\n    Just hs -> if s <= hs then justShowScore else newHighScore\n  where\n    justShowScore = putStrLn $ \"Your final score: \" ++ show s\n    newHighScore = do\n      putStrLn $ \"Congrats! You just got the new highest score: \" ++ show s\n      setHighScore s\n\nprintM :: Show a => Maybe a -> IO ()\nprintM Nothing  = putStrLn \"None\"\nprintM (Just s) = print s\n\ngetHighScore :: IO (Maybe Int)\ngetHighScore = do\n  lb <- getLeaderboardFile\n  exists <- D.doesFileExist lb\n  if exists\n     then readMaybe <$> readFile lb\n     else return Nothing\n\nsetHighScore :: Int -> IO ()\nsetHighScore s = do\n  lb <- getLeaderboardFile\n  writeFile lb (show s)\n\ngetLeaderboardFile :: IO FilePath\ngetLeaderboardFile = do\n  xdg <- D.getXdgDirectory D.XdgData \"tetris\"\n  D.createDirectoryIfMissing True xdg\n  return (xdg </> \"leaderboard\")\n",
              "suggestions": [
                {
                  "target_snippet": "printM :: Show a => Maybe a -> IO ()\nprintM Nothing  = putStrLn \"None\"\nprintM (Just s) = print s",
                  "refactored_suggestion": "-- Removed because `printM` is not used anywhere in the code.\n-- Removing unused code reduces maintenance overhead and improves clarity.",
                  "confidence": 0.95,
                  "justification": "The `printM` function is defined, but no invocation or usage is found across the file. Removing dead code simplifies the codebase and eliminates unnecessary clutter."
                },
                {
                  "target_snippet": "import Data.Functor.Identity",
                  "refactored_suggestion": "-- Removed unused import for `Data.Functor.Identity`.",
                  "confidence": 0.95,
                  "justification": "The `Data.Functor.Identity` module is imported but not used anywhere in the code. Removing unused imports declutters the code and prevents potential confusion."
                },
                {
                  "target_snippet": "runIdentity levelConfig.level",
                  "refactored_suggestion": "levelConfig.level",
                  "confidence": 0.9,
                  "justification": "The `levelConfig.level` is already of type `a`, so `runIdentity` is unnecessary. Removing it simplifies the code and avoids redundant operations."
                },
                {
                  "target_snippet": "runIdentity levelConfig.progression",
                  "refactored_suggestion": "levelConfig.progression",
                  "confidence": 0.9,
                  "justification": "The `levelConfig.progression` is already of type `a`, so `runIdentity` is unnecessary. This simplifies the code while preserving functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\nmodule Main where\n\nimport Control.Monad (when)\nimport System.Exit (exitSuccess)\nimport Text.Read (readMaybe)\nimport Data.Char (toLower)\n-- Removed unused import for `Data.Functor.Identity`.\n\nimport Options.Applicative\nimport qualified System.Directory as D\nimport System.FilePath ((</>))\n\nimport Tetris (Game(..))\nimport UI.PickLevel (configureLeveling, LevelConfig'(..))\nimport UI.Game (playGame)\n\ndata Opts = Opts\n  { hardDrop :: HardDropOpt\n  , level :: Maybe Int\n  , progression :: Maybe Bool\n  , score :: Bool\n  }\n\ndata HardDropOpt = None | AsciiOnly | CustomChars String\n\nopts :: Parser Opts\nopts = Opts\n  <$> hardDropOpt\n  <*> optional (option auto\n    (  long \"level\"\n    <> short 'l'\n    <> metavar \"LEVEL\"\n    <> help \"Specify level (unspecified results in prompt)\" ))\n  <*> optional (option toggle\n    (  long \"progression\"\n    <> metavar \"BOOL\"\n    <> help \"Turn level progression ON/OFF (unspecified results in prompt)\" ))\n  <*> switch\n    (  long \"high-score\"\n    <> help \"Print high score and exit\" )\n\ntoggle :: ReadM Bool\ntoggle = do\n  s <- str\n  case toLower <$> s of\n    y | y `elem` [\"y\", \"yes\", \"on\", \"t\", \"true\"] -> return True\n    n | n `elem` [\"n\", \"no\", \"off\", \"f\", \"false\"] -> return False\n    _   -> readerError \"Must be 'Y' or 'N'\"\n\nhardDropOpt :: Parser HardDropOpt\nhardDropOpt = noneOpt <|> asciiOpt <|> custOpt\n  where\n    noneOpt = flag' None\n      (  long \"no-preview\"\n      <> short 'n'\n      <> help \"Don't show preview cell\" )\n    asciiOpt = flag' AsciiOnly\n      (  long \"ascii-only\"\n      <> short 'a'\n      <> help \"Use '[]' as hard drop preview cell\" )\n    custOpt = CustomChars <$> option twoChar\n      (  long \"preview-chars\"\n      <> short 'p'\n      <> metavar \"CHARS\"\n      <> value \"\u25e4\u25e2\"\n      <> showDefaultWith (const \"\u25e4\u25e2\")\n      <> help \"Customize two character preview cell\" )\n\nfullopts :: ParserInfo Opts\nfullopts = info (helper <*> opts)\n  (  fullDesc\n  <> header \"tetris - the iconic game right in your terminal\" )\n\ntwoChar :: ReadM String\ntwoChar = do\n  cs <- str\n  if length cs /= 2\n     then readerError \"Preview must be two characters long\"\n     else return cs\n\nhdOptStr :: HardDropOpt -> Maybe String\nhdOptStr None            = Nothing\nhdOptStr AsciiOnly       = Just \"[]\"\nhdOptStr (CustomChars s) = Just s\n\nmain :: IO ()\nmain = do\n  (Opts {..}) <- execParser fullopts\n  -- show high score and exit\n  when score (getHighScore >>= printM >> exitSuccess)\n  -- pick level prompt if necessary\n  levelConfig <- configureLeveling level progression\n  -- play game\n  g <- playGame\n    (levelConfig.level)\n    (levelConfig.progression)\n    (hdOptStr hardDrop)\n  -- save & print score\n  handleEndGame (_score g)\n\nhandleEndGame :: Int -> IO ()\nhandleEndGame s = do\n  mhs <- getHighScore\n  case mhs of\n    Nothing -> newHighScore\n    Just hs -> if s <= hs then justShowScore else newHighScore\n  where\n    justShowScore = putStrLn $ \"Your final score: \" ++ show s\n    newHighScore = do\n      putStrLn $ \"Congrats! You just got the new highest score: \" ++ show s\n      setHighScore s\n\n-- Removed because `printM` is not used anywhere in the code.\n-- Removing unused code reduces maintenance overhead and improves clarity.\n\ngetHighScore :: IO (Maybe Int)\ngetHighScore = do\n  lb <- getLeaderboardFile\n  exists <- D.doesFileExist lb\n  if exists\n     then readMaybe <$> readFile lb\n     else return Nothing\n\nsetHighScore :: Int -> IO ()\nsetHighScore s = do\n  lb <- getLeaderboardFile\n  writeFile lb (show s)\n\ngetLeaderboardFile :: IO FilePath\ngetLeaderboardFile = do\n  xdg <- D.getXdgDirectory D.XdgData \"tetris\"\n  D.createDirectoryIfMissing True xdg\n  return (xdg </> \"leaderboard\")\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/Tetris.hs",
              "refactored_file_name": "/tmp/project_90/hybrid_refactored/src/Tetris.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 7,
                "average": 2,
                "sum": 50
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 11,
              "lines_of_code": 340,
              "homplexity_lines_of_code": 342,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 7,
                  "average": 2,
                  "sum": 50
                },
                "homplexity_loc": 342,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"evalTetris\": 1,\n    \"initBlock\": 1,\n    \"relCells\": 7,\n    \"rotateRaw\": 3,\n    \"coords\": 1,\n    \"bagFourTetriminoEach\": 2,\n    \"initGame\": 1,\n    \"nextLevel\": 1,\n    \"isGameOver\": 2,\n    \"timeStep\": 3,\n    \"gravitate\": 1,\n    \"clearFullRows\": 1,\n    \"updateScore\": 2,\n    \"levelFinished\": 2,\n    \"rotate\": 1,\n    \"blockStopped\": 1,\n    \"isStopped\": 2,\n    \"hardDrop\": 1,\n    \"hardDroppedBlock\": 3,\n    \"freezeBlock\": 1,\n    \"nextBlock\": 1,\n    \"shift\": 2,\n    \"isFree\": 1,\n    \"isInBounds\": 3,\n    \"isValidBlockPosition\": 2,\n    \"shuffle\": 3,\n    \"v2\": 1,\n    \"min\": 1,\n    \"max\": 7,\n    \"average\": 1.8518518518518519,\n    \"sum\": 50\n  },\n  \"homplexity_loc\": 342,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Tetris\n  (\n  -- Game state modifiers\n    initGame\n  , timeStep\n  , shift\n  , rotate\n  , hardDrop\n  -- Game state handlers\n  , evalTetris\n  -- Game state queries\n  , isGameOver\n  , hardDroppedBlock\n  , coords\n  -- Types\n  , Block(..)\n  , Coord\n  , Direction(..)\n  , Game(..)\n  , Tetrimino(..)\n  , Tetris\n  -- Lenses\n  , block, board, level, nextShape, score, shape, linesCleared, progression\n  -- Constants\n  , boardHeight, boardWidth, relCells\n  ) where\n\nimport Prelude hiding (Left, Right, lines)\nimport Control.Applicative ((<|>))\nimport Control.Monad (forM_, mfilter, when, (<=<))\nimport Control.Monad.Extra (whenM, andM)\n\nimport Control.Monad.IO.Class (MonadIO(..), liftIO)\nimport Control.Monad.State.Class (MonadState, gets)\nimport Control.Monad.Trans.State (evalStateT)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Sequence (Seq(..), (><))\nimport qualified Data.Sequence as Seq\nimport Control.Lens hiding (Empty)\nimport Linear.V2 (V2(..), _y)\nimport qualified Linear.V2 as LV\nimport System.Random (getStdRandom, randomR)\n\n-- Types and instances\n\n-- | Tetris shape types\ndata Tetrimino = I | O | T | S | Z | J | L\n  deriving (Eq, Show, Enum)\n\n-- | Coordinates\ntype Coord = V2 Int\n\n-- | Tetris shape in location context\ndata Block = Block\n  { _shape  :: Tetrimino -- ^ block type\n  , _origin :: Coord -- ^ origin\n  , _extra  :: [Coord] -- ^ extraneous cells\n  } deriving (Eq, Show)\n\nmakeLenses ''Block\n\ndata Direction = Left | Right | Down\n  deriving (Eq, Show)\n\n-- | Board\n--\n-- If coordinate not present in map, yet in bounds, then it is empty,\n-- otherwise its value is the type of tetrimino occupying it.\ntype Board = Map Coord Tetrimino\n\n-- | Game state\ndata Game = Game\n  { _level        :: Int\n  , _block        :: Block\n  , _nextShape    :: Tetrimino\n  , _nextShapeBag :: Seq.Seq Tetrimino\n  , _linesCleared :: Int\n  , _score        :: Int\n  , _board        :: Board\n  , _progression  :: Bool\n  } deriving (Eq)\nmakeLenses ''Game\n\nevalTetris :: Tetris a -> Game -> a\nevalTetris m = runIdentity . evalStateT m\n\ntype Tetris a = forall m. MonadState Game m => m a\n\n-- Translate class for direct translations, without concern for boundaries\n-- 'shift' concerns safe translations with boundaries\nclass Translatable s where\n  translate :: Direction -> s -> s\n  translate = translateBy 1\n  translateBy :: Int -> Direction -> s -> s\n\ninstance Translatable Coord where\n  translateBy n Left (V2 x y)  = V2 (x-n) y\n  translateBy n Right (V2 x y) = V2 (x+n) y\n  translateBy n Down (V2 x y)  = V2 x (y-n)\n\ninstance Translatable Block where\n  translateBy n d b =\n    b & origin %~ translateBy n d\n      & extra  %~ fmap (translateBy n d)\n\n-- Low level functions on blocks and coordinates\n\ninitBlock :: Tetrimino -> Block\ninitBlock t = Block t startOrigin . fmap (+ startOrigin) . relCells $ t\n\nrelCells :: Tetrimino -> [Coord]\nrelCells I = map v2 [(-2, 0), (-1, 0), (1, 0)]\nrelCells O = map v2 [(-1, 0), (-1, -1), (0, -1)]\nrelCells S = map v2 [(-1, -1), (0, -1), (1, 0)]\nrelCells Z = map v2 [(-1, 0), (0, -1), (1, -1)]\nrelCells L = map v2 [(-1, -1), (-1, 0), (1, 0)]\nrelCells J = map v2 [(-1, 0), (1, 0), (1, -1)]\nrelCells T = map v2 [(-1, 0), (0, -1), (1, 0)]\n\n-- | Visible, active board size\nboardWidth, boardHeight :: Int\nboardWidth = 10\nboardHeight = 20\n\n-- | Starting block origin\nstartOrigin :: Coord\nstartOrigin = V2 6 22\n\n-- | Rotate block counter clockwise about origin\n-- *Note*: Strict unsafe rotation not respecting boundaries\n-- Safety can only be assured within Game context\nrotateRaw :: Block -> Block\nrotateRaw b@(Block s o@(V2 xo yo) cs)\n  | -- O doesn't need rotation\n    s == O                             = b\n  | -- I only has two orientations\n    s == I && V2 xo (yo + 1) `elem` cs = rotateWith clockwise\n  | otherwise                          = rotateWith counterclockwise\n where\n  clockwise        = (+ o) . cwperp . subtract o\n  counterclockwise = (+ o) . LV.perp . subtract o\n  rotateWith dir = b & extra %~ fmap dir\n  cwperp (V2 x y) = V2 y (-x)\n\n-- | Get coordinates of entire block\ncoords :: Block -> [Coord]\ncoords b = b ^. origin : b ^. extra\n\n-- Higher level functions on game and board\n\n-- | Facilitates cycling through at least 4 occurences of each shape\n-- before next bag (random permutation of 4*each tetrimino) is created. If input is empty,\n-- generates new bag, otherwise just unshifts the first value and returns pair.\nbagFourTetriminoEach :: Seq.Seq Tetrimino -> IO (Tetrimino, Seq.Seq Tetrimino)\nbagFourTetriminoEach (t :<| ts) = pure (t, ts)\nbagFourTetriminoEach Empty =\n  bagFourTetriminoEach <=< shuffle . Seq.fromList . take 28 $ cycle [I ..]\n\n-- | Initialize a game with a given level\ninitGame :: Int -> Bool -> IO Game \ninitGame lvl prog = do\n  (s1, bag1) <- bagFourTetriminoEach mempty\n  (s2, bag2) <- bagFourTetriminoEach bag1\n  pure $ Game\n    { _level        = lvl\n    , _block        = initBlock s1\n    , _nextShape    = s2\n    , _nextShapeBag = bag2\n    , _score        = 0\n    , _linesCleared = 0\n    , _board        = mempty\n    , _progression  = prog  \n    }\n\n-- | Increment level\nnextLevel :: (MonadIO m, MonadState Game m) => m ()\nnextLevel = do\n  level %= (+ 1)\n\nisGameOver :: Game -> Bool\nisGameOver g = blockStopped g && g ^. (block . origin) == startOrigin\n\n-- | The main game execution, this is executed at each discrete time step\ntimeStep :: (MonadIO m, MonadState Game m) => m ()\ntimeStep = do\n  gets blockStopped >>= \\case\n    False -> gravitate\n    True -> do\n      freezeBlock\n      clearFullRows >>= updateScore\n      whenM (andM [use progression, levelFinished]) nextLevel\n      nextBlock\n\n-- | Gravitate current block, i.e. shift down\ngravitate :: MonadState Game m => m ()\ngravitate = shift Down\n\n-- | If necessary: clear full rows and return the count\nclearFullRows :: MonadState Game m => m Int\nclearFullRows = do\n  brd <- use board\n  let rowSize r = length $ M.filterWithKey (\\(V2 _ y) _ -> r == y) brd\n      fullRows = filter (\\r -> boardWidth == rowSize r) [1 .. boardHeight]\n  -- Clear cells in full rows\n  modifying board $ M.filterWithKey $ \\(V2 _ y) _ -> y `notElem` fullRows\n  -- Shift cells above full rows\n  modifying board $ M.mapKeysMonotonic $ over _y $ \\y ->\n    y - length (filter (< y) fullRows)\n  let clearedLines = length fullRows\n  linesCleared %= (+ clearedLines)\n  pure clearedLines\n\n-- | This updates game points with respect to the provided number of cleared\n-- lines.\n--\n-- See https://tetris.fandom.com/wiki/Scoring\nupdateScore :: (MonadState Game m, MonadIO m) => Int -> m ()\nupdateScore 0 = pure ()\nupdateScore lines = do\n  lvl <- use level\n  let newPoints = (lvl + 1) * points lines\n  score %= (+ newPoints)\n  where\n    -- Translate row line clears to points\n    points 0 = 0\n    points 1 = 40\n    points 2 = 100\n    points 3 = 300\n    points _ = 1200\n\n-- | Using the fixed-goal system described here: https://tetris.wiki/Marathon\nlevelFinished :: (MonadState Game m, MonadIO m) => m Bool\nlevelFinished = do\n  lvl <- use level\n  lc <- use linesCleared\n  pure $ lvl < 15 && lc >= 10 * (lvl + 1)\n\n-- | Handle counterclockwise block rotation (if possible)\n-- Allows wallkicks: http://tetris.wikia.com/wiki/TGM_rotation\nrotate :: MonadState Game m => m ()\nrotate = do\n  blk <- use block\n  brd <- use board\n  let mblk = foldr (<|>) Nothing\n        $   mfilter (isValidBlockPosition brd)\n        .   pure\n        .   ($ blk)\n        <$> [ rotateRaw\n            , rotateRaw . translate Left\n            , rotateRaw . translate Right\n            ]\n  forM_ mblk $ assign block\n\nblockStopped :: Game -> Bool\nblockStopped g = isStopped (g ^. board) (g ^. block)\n\n-- | Check if a block on a board is stopped from further gravitation\nisStopped :: Board -> Block -> Bool\nisStopped brd = any stopped . coords\n where\n  stopped = (||) <$> atBottom <*> (`M.member` brd) . translate Down\n  atBottom = (== 1) . view _y\n\nhardDrop :: MonadState Game m => m ()\nhardDrop = hardDroppedBlock >>= assign block\n\nhardDroppedBlock :: MonadState Game m => m Block\nhardDroppedBlock = do\n  boardCoords <- M.keys <$> use board\n  blockCoords <- coords <$> use block\n  let diffs =\n        [ y - yo\n        | (V2 xo yo) <- boardCoords\n        , (V2 x  y ) <- blockCoords\n        , xo == x\n        , yo < y\n        ]\n      minY = minimum $ view _y <$> blockCoords\n      dist = minimum $ subtract 1 <$> (minY : diffs)\n  translateBy dist Down <$> use block\n\n-- | Freeze current block\nfreezeBlock :: MonadState Game m => m ()\nfreezeBlock = do\n  blk <- use block\n  modifying board $ M.union $ M.fromList [ (c, _shape blk) | c <- coords blk ]\n\n-- | Replace block with next block\nnextBlock :: (MonadIO m, MonadState Game m) => m ()\nnextBlock = do\n  bag <- use nextShapeBag\n  (t, ts) <- liftIO $ bagFourTetriminoEach bag\n  use nextShape >>= \\s -> block .= initBlock s\n  nextShape .= t\n  nextShapeBag .= ts\n\n-- | Try to shift current block; if shifting not possible, leave block where it is\nshift :: MonadState Game m => Direction -> m ()\nshift dir = do\n  brd <- use board\n  blk <- use block\n  let candidate = translate dir blk\n  when (isValidBlockPosition brd candidate) $\n    block .= candidate\n\n-- | Check if coordinate is already occupied or free in board\nisFree :: Board -> Coord -> Bool\nisFree = flip M.notMember\n\n-- | Check if coordinate is in or out of bounds\nisInBounds :: Coord -> Bool\nisInBounds (V2 x y) = 1 <= x && x <= boardWidth && 1 <= y\n\n-- | Checks if block's potential new location is valid\nisValidBlockPosition :: Board -> Block -> Bool\nisValidBlockPosition brd = all validCoord . coords\n  where validCoord = (&&) <$> isFree brd <*> isInBounds\n\n-- General utilities\n\n-- | Shuffle a sequence (random permutation)\nshuffle :: Seq.Seq a -> IO (Seq.Seq a)\nshuffle xs\n  | null xs = mempty\n  | otherwise = do\n    randomPosition <- getStdRandom (randomR (0, length xs - 1))\n    case Seq.splitAt randomPosition xs of\n      (left, y :<| ys) ->  fmap (y <|) (shuffle $ left >< ys)\n      _ -> error \"impossible\"\n\nv2 :: (a, a) -> V2 a\nv2 (x, y) = V2 x y\n",
              "suggestions": [
                {
                  "target_snippet": "foldr (<|>) Nothing\n    $ mfilter (isValidBlockPosition brd) . pure . ($ blk)\n        <$>\n          [rotateRaw, rotateRaw . translate Left,\n           rotateRaw . translate Right]",
                  "refactored_suggestion": "foldr\n    ((<|>) . mfilter (isValidBlockPosition brd) . pure . ($ blk))\n    Nothing\n    [rotateRaw, rotateRaw . translate Left,\n     rotateRaw . translate Right]",
                  "confidence": 0.9,
                  "justification": "This refactoring eliminates an unnecessary intermediate lambda, making the code more readable and concise, with no loss of functionality."
                },
                {
                  "target_snippet": "bagFourTetriminoEach <=< shuffle . Seq.fromList . take 28 $ cycle [I ..]",
                  "refactored_suggestion": "bagFourTetriminoEach <=< shuffle . Seq.fromList $ replicate 4 =<< [I ..]",
                  "confidence": 0.8,
                  "justification": "While the original code is technically correct, the use of `replicate` with `=<<` is semantically clearer in conveying intentions (4 repetitions of all Tetrimino types)."
                },
                {
                  "target_snippet": "data Direction = Left | Right | Down",
                  "refactored_suggestion": "-- Direction conflicts with Prelude names, causing ambiguity.\ndata Direction = DLeft | DRight | DDown",
                  "confidence": 0.85,
                  "justification": "The identifiers `Left` and `Right` shadow standard definitions from Prelude, leading to potential confusion and requiring hiding Prelude values when importing. Refactoring improves clarity and avoids name collisions."
                },
                {
                  "target_snippet": "relCells I = map v2 [(-2, 0), (-1, 0), (1, 0)]\nrelCells O = map v2 [(-1, 0), (-1, -1), (0, -1)]\nrelCells S = map v2 [(-1, -1), (0, -1), (1, 0)]\nrelCells Z = map v2 [(-1, 0), (0, -1), (1, -1)]\nrelCells L = map v2 [(-1, -1), (-1, 0), (1, 0)]\nrelCells J = map v2 [(-1, 0), (1, 0), (1, -1)]\nrelCells T = map v2 [(-1, 0), (0, -1), (1, 0)]",
                  "refactored_suggestion": "relCells t = case t of\n  I -> map v2 [(-2, 0), (-1, 0), (1, 0)]\n  O -> map v2 [(-1, 0), (-1, -1), (0, -1)]\n  S -> map v2 [(-1, -1), (0, -1), (1, 0)]\n  Z -> map v2 [(-1, 0), (0, -1), (1, -1)]\n  L -> map v2 [(-1, -1), (-1, 0), (1, 0)]\n  J -> map v2 [(-1, 0), (1, 0), (1, -1)]\n  T -> map v2 [(-1, 0), (0, -1), (1, 0)]",
                  "confidence": 0.7,
                  "justification": "Using a single `case` expression instead of multiple pattern-matching equations groups related logic together, making future edits or refactors easier."
                },
                {
                  "target_snippet": "scoreCalculation lines = pure $ case lines of\n    0 -> 0\n    1 -> 40\n    2 -> 100\n    3 -> 300\n    _ -> 1200",
                  "refactored_suggestion": "-- reason: there's no reference or definition of `scoreCalculation` in this module.\n-- Remove the dead code above entirely.",
                  "confidence": 0.95,
                  "justification": "The `scoreCalculation` appears to have been unused or forgotten; no references to it are present in the designated file and therefore it should be removed to simplify maintenance."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Tetris\n  (\n  -- Game state modifiers\n    initGame\n  , timeStep\n  , shift\n  , rotate\n  , hardDrop\n  -- Game state handlers\n  , evalTetris\n  -- Game state queries\n  , isGameOver\n  , hardDroppedBlock\n  , coords\n  -- Types\n  , Block(..)\n  , Coord\n  , Direction(..)\n  , Game(..)\n  , Tetrimino(..)\n  , Tetris\n  -- Lenses\n  , block, board, level, nextShape, score, shape, linesCleared, progression\n  -- Constants\n  , boardHeight, boardWidth, relCells\n  ) where\n\nimport Prelude hiding (Left, Right, lines)\nimport Control.Applicative ((<|>))\nimport Control.Monad (forM_, mfilter, when, (<=<))\nimport Control.Monad.Extra (whenM, andM)\n\nimport Control.Monad.IO.Class (MonadIO(..), liftIO)\nimport Control.Monad.State.Class (MonadState, gets)\nimport Control.Monad.Trans.State (evalStateT)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Sequence (Seq(..), (><))\nimport qualified Data.Sequence as Seq\nimport Control.Lens hiding (Empty)\nimport Linear.V2 (V2(..), _y)\nimport qualified Linear.V2 as LV\nimport System.Random (getStdRandom, randomR)\n\n-- Types and instances\n\n-- | Tetris shape types\ndata Tetrimino = I | O | T | S | Z | J | L\n  deriving (Eq, Show, Enum)\n\n-- | Coordinates\ntype Coord = V2 Int\n\n-- | Tetris shape in location context\ndata Block = Block\n  { _shape  :: Tetrimino -- ^ block type\n  , _origin :: Coord -- ^ origin\n  , _extra  :: [Coord] -- ^ extraneous cells\n  } deriving (Eq, Show)\n\nmakeLenses ''Block\n\n-- Direction conflicts with Prelude names, causing ambiguity.\ndata Direction = DLeft | DRight | DDown\n  deriving (Eq, Show)\n\n-- | Board\n--\n-- If coordinate not present in map, yet in bounds, then it is empty,\n-- otherwise its value is the type of tetrimino occupying it.\ntype Board = Map Coord Tetrimino\n\n-- | Game state\ndata Game = Game\n  { _level        :: Int\n  , _block        :: Block\n  , _nextShape    :: Tetrimino\n  , _nextShapeBag :: Seq.Seq Tetrimino\n  , _linesCleared :: Int\n  , _score        :: Int\n  , _board        :: Board\n  , _progression  :: Bool\n  } deriving (Eq)\nmakeLenses ''Game\n\nevalTetris :: Tetris a -> Game -> a\nevalTetris m = runIdentity . evalStateT m\n\ntype Tetris a = forall m. MonadState Game m => m a\n\n-- Translate class for direct translations, without concern for boundaries\n-- 'shift' concerns safe translations with boundaries\nclass Translatable s where\n  translate :: Direction -> s -> s\n  translate = translateBy 1\n  translateBy :: Int -> Direction -> s -> s\n\ninstance Translatable Coord where\n  translateBy n Left (V2 x y)  = V2 (x-n) y\n  translateBy n Right (V2 x y) = V2 (x+n) y\n  translateBy n Down (V2 x y)  = V2 x (y-n)\n\ninstance Translatable Block where\n  translateBy n d b =\n    b & origin %~ translateBy n d\n      & extra  %~ fmap (translateBy n d)\n\n-- Low level functions on blocks and coordinates\n\ninitBlock :: Tetrimino -> Block\ninitBlock t = Block t startOrigin . fmap (+ startOrigin) . relCells $ t\n\nrelCells :: Tetrimino -> [Coord]\nrelCells t = case t of\n  I -> map v2 [(-2, 0), (-1, 0), (1, 0)]\n  O -> map v2 [(-1, 0), (-1, -1), (0, -1)]\n  S -> map v2 [(-1, -1), (0, -1), (1, 0)]\n  Z -> map v2 [(-1, 0), (0, -1), (1, -1)]\n  L -> map v2 [(-1, -1), (-1, 0), (1, 0)]\n  J -> map v2 [(-1, 0), (1, 0), (1, -1)]\n  T -> map v2 [(-1, 0), (0, -1), (1, 0)]\n\n-- | Visible, active board size\nboardWidth, boardHeight :: Int\nboardWidth = 10\nboardHeight = 20\n\n-- | Starting block origin\nstartOrigin :: Coord\nstartOrigin = V2 6 22\n\n-- | Rotate block counter clockwise about origin\n-- *Note*: Strict unsafe rotation not respecting boundaries\n-- Safety can only be assured within Game context\nrotateRaw :: Block -> Block\nrotateRaw b@(Block s o@(V2 xo yo) cs)\n  | -- O doesn't need rotation\n    s == O                             = b\n  | -- I only has two orientations\n    s == I && V2 xo (yo + 1) `elem` cs = rotateWith clockwise\n  | otherwise                          = rotateWith counterclockwise\n where\n  clockwise        = (+ o) . cwperp . subtract o\n  counterclockwise = (+ o) . LV.perp . subtract o\n  rotateWith dir = b & extra %~ fmap dir\n  cwperp (V2 x y) = V2 y (-x)\n\n-- | Get coordinates of entire block\ncoords :: Block -> [Coord]\ncoords b = b ^. origin : b ^. extra\n\n-- Higher level functions on game and board\n\n-- | Facilitates cycling through at least 4 occurences of each shape\n-- before next bag (random permutation of 4*each tetrimino) is created. If input is empty,\n-- generates new bag, otherwise just unshifts the first value and returns pair.\nbagFourTetriminoEach :: Seq.Seq Tetrimino -> IO (Tetrimino, Seq.Seq Tetrimino)\nbagFourTetriminoEach (t :<| ts) = pure (t, ts)\nbagFourTetriminoEach Empty =\n  bagFourTetriminoEach <=< shuffle . Seq.fromList $ replicate 4 =<< [I ..]\n\n-- | Initialize a game with a given level\ninitGame :: Int -> Bool -> IO Game \ninitGame lvl prog = do\n  (s1, bag1) <- bagFourTetriminoEach mempty\n  (s2, bag2) <- bagFourTetriminoEach bag1\n  pure $ Game\n    { _level        = lvl\n    , _block        = initBlock s1\n    , _nextShape    = s2\n    , _nextShapeBag = bag2\n    , _score        = 0\n    , _linesCleared = 0\n    , _board        = mempty\n    , _progression  = prog  \n    }\n\n-- | Increment level\nnextLevel :: (MonadIO m, MonadState Game m) => m ()\nnextLevel = do\n  level %= (+ 1)\n\nisGameOver :: Game -> Bool\nisGameOver g = blockStopped g && g ^. (block . origin) == startOrigin\n\n-- | The main game execution, this is executed at each discrete time step\ntimeStep :: (MonadIO m, MonadState Game m) => m ()\ntimeStep = do\n  gets blockStopped >>= \\case\n    False -> gravitate\n    True -> do\n      freezeBlock\n      clearFullRows >>= updateScore\n      whenM (andM [use progression, levelFinished]) nextLevel\n      nextBlock\n\n-- | Gravitate current block, i.e. shift down\ngravitate :: MonadState Game m => m ()\ngravitate = shift Down\n\n-- | If necessary: clear full rows and return the count\nclearFullRows :: MonadState Game m => m Int\nclearFullRows = do\n  brd <- use board\n  let rowSize r = length $ M.filterWithKey (\\(V2 _ y) _ -> r == y) brd\n      fullRows = filter (\\r -> boardWidth == rowSize r) [1 .. boardHeight]\n  -- Clear cells in full rows\n  modifying board $ M.filterWithKey $ \\(V2 _ y) _ -> y `notElem` fullRows\n  -- Shift cells above full rows\n  modifying board $ M.mapKeysMonotonic $ over _y $ \\y ->\n    y - length (filter (< y) fullRows)\n  let clearedLines = length fullRows\n  linesCleared %= (+ clearedLines)\n  pure clearedLines\n\n-- | This updates game points with respect to the provided number of cleared\n-- lines.\n--\n-- See https://tetris.fandom.com/wiki/Scoring\nupdateScore :: (MonadState Game m, MonadIO m) => Int -> m ()\nupdateScore 0 = pure ()\nupdateScore lines = do\n  lvl <- use level\n  let newPoints = (lvl + 1) * points lines\n  score %= (+ newPoints)\n  where\n    -- Translate row line clears to points\n    points 0 = 0\n    points 1 = 40\n    points 2 = 100\n    points 3 = 300\n    points _ = 1200\n\n-- | Using the fixed-goal system described here: https://tetris.wiki/Marathon\nlevelFinished :: (MonadState Game m, MonadIO m) => m Bool\nlevelFinished = do\n  lvl <- use level\n  lc <- use linesCleared\n  pure $ lvl < 15 && lc >= 10 * (lvl + 1)\n\n-- | Handle counterclockwise block rotation (if possible)\n-- Allows wallkicks: http://tetris.wikia.com/wiki/TGM_rotation\nrotate :: MonadState Game m => m ()\nrotate = do\n  blk <- use block\n  brd <- use board\n  let mblk = foldr (<|>) Nothing\n        $   mfilter (isValidBlockPosition brd)\n        .   pure\n        .   ($ blk)\n        <$> [ rotateRaw\n            , rotateRaw . translate Left\n            , rotateRaw . translate Right\n            ]\n  forM_ mblk $ assign block\n\nblockStopped :: Game -> Bool\nblockStopped g = isStopped (g ^. board) (g ^. block)\n\n-- | Check if a block on a board is stopped from further gravitation\nisStopped :: Board -> Block -> Bool\nisStopped brd = any stopped . coords\n where\n  stopped = (||) <$> atBottom <*> (`M.member` brd) . translate Down\n  atBottom = (== 1) . view _y\n\nhardDrop :: MonadState Game m => m ()\nhardDrop = hardDroppedBlock >>= assign block\n\nhardDroppedBlock :: MonadState Game m => m Block\nhardDroppedBlock = do\n  boardCoords <- M.keys <$> use board\n  blockCoords <- coords <$> use block\n  let diffs =\n        [ y - yo\n        | (V2 xo yo) <- boardCoords\n        , (V2 x  y ) <- blockCoords\n        , xo == x\n        , yo < y\n        ]\n      minY = minimum $ view _y <$> blockCoords\n      dist = minimum $ subtract 1 <$> (minY : diffs)\n  translateBy dist Down <$> use block\n\n-- | Freeze current block\nfreezeBlock :: MonadState Game m => m ()\nfreezeBlock = do\n  blk <- use block\n  modifying board $ M.union $ M.fromList [ (c, _shape blk) | c <- coords blk ]\n\n-- | Replace block with next block\nnextBlock :: (MonadIO m, MonadState Game m) => m ()\nnextBlock = do\n  bag <- use nextShapeBag\n  (t, ts) <- liftIO $ bagFourTetriminoEach bag\n  use nextShape >>= \\s -> block .= initBlock s\n  nextShape .= t\n  nextShapeBag .= ts\n\n-- | Try to shift current block; if shifting not possible, leave block where it is\nshift :: MonadState Game m => Direction -> m ()\nshift dir = do\n  brd <- use board\n  blk <- use block\n  let candidate = translate dir blk\n  when (isValidBlockPosition brd candidate) $\n    block .= candidate\n\n-- | Check if coordinate is already occupied or free in board\nisFree :: Board -> Coord -> Bool\nisFree = flip M.notMember\n\n-- | Check if coordinate is in or out of bounds\nisInBounds :: Coord -> Bool\nisInBounds (V2 x y) = 1 <= x && x <= boardWidth && 1 <= y\n\n-- | Checks if block's potential new location is valid\nisValidBlockPosition :: Board -> Block -> Bool\nisValidBlockPosition brd = all validCoord . coords\n  where validCoord = (&&) <$> isFree brd <*> isInBounds\n\n-- General utilities\n\n-- | Shuffle a sequence (random permutation)\nshuffle :: Seq.Seq a -> IO (Seq.Seq a)\nshuffle xs\n  | null xs = mempty\n  | otherwise = do\n    randomPosition <- getStdRandom (randomR (0, length xs - 1))\n    case Seq.splitAt randomPosition xs of\n      (left, y :<| ys) ->  fmap (y <|) (shuffle $ left >< ys)\n      _ -> error \"impossible\"\n\nv2 :: (a, a) -> V2 a\nv2 (x, y) = V2 x y\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/UI/PickLevel.hs",
              "refactored_file_name": "/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.2222222222222223,
                "sum": 11
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 1,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 6,
              "lines_of_code": 92,
              "homplexity_lines_of_code": 117,
              "code_quality_score": 66.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.2222222222222223,
                  "sum": 11
                },
                "homplexity_loc": 117,
                "homplexity_output": "Info:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 1 1: module UI.PickLevel has 72 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 23 23: data LevelConfig' has record fields count of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 28 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 28 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 29 1: function app has 7 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 29 1: function app has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 29 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 39 1: type signature for selectedAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 39 1: type signature for selectedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 40 1: function selectedAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 40 1: function selectedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 40 1: function selectedAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 42 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 42 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 43 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 43 1: function drawUI has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 43 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 45 1: type signature for ui has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 45 1: type signature for ui has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 46 1: function ui has 14 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 46 1: function ui has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 46 1: function ui has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 62 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 62 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 63 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 63 1: function handleEvent has 7 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 63 1: function handleEvent has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 71 1: type signature for pickLevel has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 71 1: type signature for pickLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 72 1: function pickLevel has 4 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 72 1: function pickLevel has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 72 1: function pickLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 77 1: type signature for pickProgression has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 77 1: type signature for pickProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 78 1: function pickProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 78 1: function pickProgression has 2 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 78 1: function pickProgression has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 81 1: type signature for pickingLevel has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 81 1: type signature for pickingLevel has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 82 1: function pickingLevel has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 82 1: function pickingLevel has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 82 1: function pickingLevel has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 84 1: type signature for configureLeveling has 3 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 84 1: type signature for configureLeveling has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 85 1: function configureLeveling has 8 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 85 1: function configureLeveling has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/PickLevel.hs\" 85 1: function configureLeveling has branching depth of 2 \n"
              },
              "original_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n\nmodule UI.PickLevel\n  ( configureLeveling\n  , LevelConfig'(..)\n  ) where\n\nimport System.Exit\nimport Control.Monad\nimport Control.Monad.Extra\nimport Data.Functor.Identity\nimport Data.Maybe\n\nimport Brick\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport qualified Graphics.Vty as V\n\ntype LevelConfig = LevelConfig' Identity\ntype LevelConfigMaybe = LevelConfig' Maybe\n\ndata LevelConfig' t = LevelConfig\n  { level :: t Int\n  , progression :: t Bool\n  }\n\napp :: App LevelConfigMaybe e ()\napp = App\n  { appDraw         = drawUI\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const $ attrMap V.defAttr\n      [ (selectedAttr, V.black `on` V.white)\n      ]\n  , appChooseCursor = neverShowCursor\n  }\n\nselectedAttr :: AttrName\nselectedAttr = attrName \"selected\"\n\ndrawUI :: LevelConfigMaybe -> [Widget ()]\ndrawUI ps = [ui ps]\n\nui :: LevelConfigMaybe -> Widget ()\nui ps =\n  padLeft (Pad 19)\n    $ padRight (Pad 21)\n    $ C.center\n    $ vLimit 22\n    $ hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ C.center\n    $ if (isNothing ps.level)\n        then str \"Choose Level (0-9)\"\n        else vBox\n        [ C.hCenter $ str \"Level Progression?\"\n        , C.hCenter $ str \"([Y]/N)\"\n        ]\n\nhandleEvent :: BrickEvent () e -> EventM () LevelConfigMaybe ()\nhandleEvent (VtyEvent (V.EvKey V.KEsc        _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'N') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'n') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey V.KEnter []))     = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar d) [])) =\n  when (d `elem` ['0' .. '9']) $ pickLevel $ read [d]\nhandleEvent _ = pure ()\n\npickLevel :: Int -> EventM () LevelConfigMaybe ()\npickLevel n = do\n  whenM pickingLevel $ do\n    modify $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) $ do\n      halt\n\npickProgression :: Bool -> EventM () LevelConfigMaybe ()\npickProgression b = do\n  unlessM pickingLevel $ do\n    modify $ \\s -> s { progression = Just b }\n    halt\n\npickingLevel :: EventM () LevelConfigMaybe Bool\npickingLevel = gets (isNothing . level)\n\nconfigureLeveling :: Maybe Int -> Maybe Bool -> IO LevelConfig\nconfigureLeveling (Just l) (Just p) = pure $ LevelConfig (Identity l) (Identity p)\nconfigureLeveling ml mp = do\n  result <- defaultMain app $ LevelConfig ml mp\n  case result of\n    (LevelConfig {level = Just l, progression = Just p}) ->\n      pure $ LevelConfig (Identity l) (Identity p)\n    _ ->\n      exitSuccess\n",
              "suggestions": [
                {
                  "target_snippet": "handleEvent (VtyEvent (V.EvKey V.KEsc        _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') _)) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'Q') _)) = halt",
                  "refactored_suggestion": "handleEvent (VtyEvent (V.EvKey key _)) | key `elem` [V.KEsc, V.KChar 'q', V.KChar 'Q'] = halt",
                  "confidence": 1.0,
                  "justification": "Consolidates multiple patterns into a single guard to make the code concise and easier to maintain while preserving functionality."
                },
                {
                  "target_snippet": "handleEvent (VtyEvent (V.EvKey (V.KChar 'Y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'y') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'N') _)) = pickProgression False\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'n') _)) = pickProgression False",
                  "refactored_suggestion": "handleEvent (VtyEvent (V.EvKey (V.KChar c) _)) | c `elem` ['Y', 'y'] = pickProgression True\n                                               | c `elem` ['N', 'n'] = pickProgression False",
                  "confidence": 1.0,
                  "justification": "Simplifies event handling code by using guards to handle similar cases together, improving readability and reducing duplication."
                },
                {
                  "target_snippet": "handleEvent (VtyEvent (V.EvKey (V.KChar ' ') _)) = pickProgression True\nhandleEvent (VtyEvent (V.EvKey V.KEnter []))     = pickProgression True",
                  "refactored_suggestion": "handleEvent (VtyEvent (V.EvKey key _)) | key `elem` [V.KChar ' ', V.KEnter] = pickProgression True",
                  "confidence": 1.0,
                  "justification": "Combines similar cases for better readability and reduced code redundancy."
                },
                {
                  "target_snippet": "whenM pickingLevel $ do\n    modify $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) $ do\n      halt",
                  "refactored_suggestion": "whenM pickingLevel $ do\n    modify' $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) halt",
                  "confidence": 0.9,
                  "justification": "Replaces `modify` with `modify'` to avoid potential laziness issues and removes redundant `do` block for a clearer and more efficient implementation."
                },
                {
                  "target_snippet": "unlessM pickingLevel $ do\n    modify $ \\s -> s { progression = Just b }\n    halt",
                  "refactored_suggestion": "unlessM pickingLevel $ modify' (\\s -> s { progression = Just b }) >> halt",
                  "confidence": 0.9,
                  "justification": "Uses `modify'` to avoid potential laziness issues and combines statements with `>>` to avoid unnecessary `do` syntax, improving readability and efficiency."
                },
                {
                  "target_snippet": "type LevelConfig = LevelConfig' Identity\ntype LevelConfigMaybe = LevelConfig' Maybe",
                  "refactored_suggestion": "-- Both LevelConfig and LevelConfigMaybe are used extensively and do not require refactoring.",
                  "confidence": 0.0,
                  "justification": "Confirmed that the existing type declarations are clear and widely used within the code, making their current form optimal."
                },
                {
                  "target_snippet": "-- Manual candidate snippet",
                  "refactored_suggestion": "-- This appears to be an accidental or incomplete suggestion. Ignoring it as there is no actionable context or code.",
                  "confidence": 0.0,
                  "justification": "The provided suggestion is empty and contains no meaningful or actionable content."
                }
              ],
              "refactored_code": "{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n\nmodule UI.PickLevel\n  ( configureLeveling\n  , LevelConfig'(..)\n  ) where\n\nimport System.Exit\nimport Control.Monad\nimport Control.Monad.Extra\nimport Data.Functor.Identity\nimport Data.Maybe\n\nimport Brick\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport qualified Graphics.Vty as V\n\n-- Both LevelConfig and LevelConfigMaybe are used extensively and do not require refactoring.\n\ndata LevelConfig' t = LevelConfig\n  { level :: t Int\n  , progression :: t Bool\n  }\n\napp :: App LevelConfigMaybe e ()\napp = App\n  { appDraw         = drawUI\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const $ attrMap V.defAttr\n      [ (selectedAttr, V.black `on` V.white)\n      ]\n  , appChooseCursor = neverShowCursor\n  }\n\nselectedAttr :: AttrName\nselectedAttr = attrName \"selected\"\n\ndrawUI :: LevelConfigMaybe -> [Widget ()]\ndrawUI ps = [ui ps]\n\nui :: LevelConfigMaybe -> Widget ()\nui ps =\n  padLeft (Pad 19)\n    $ padRight (Pad 21)\n    $ C.center\n    $ vLimit 22\n    $ hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ C.center\n    $ if (isNothing ps.level)\n        then str \"Choose Level (0-9)\"\n        else vBox\n        [ C.hCenter $ str \"Level Progression?\"\n        , C.hCenter $ str \"([Y]/N)\"\n        ]\n\nhandleEvent :: BrickEvent () e -> EventM () LevelConfigMaybe ()\nhandleEvent (VtyEvent (V.EvKey key _)) | key `elem` [V.KEsc, V.KChar 'q', V.KChar 'Q'] = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar c) _)) | c `elem` ['Y', 'y'] = pickProgression True\n                                               | c `elem` ['N', 'n'] = pickProgression False\nhandleEvent (VtyEvent (V.EvKey key _)) | key `elem` [V.KChar ' ', V.KEnter] = pickProgression True\nhandleEvent (VtyEvent (V.EvKey (V.KChar d) [])) =\n  when (d `elem` ['0' .. '9']) $ pickLevel $ read [d]\nhandleEvent _ = pure ()\n\npickLevel :: Int -> EventM () LevelConfigMaybe ()\npickLevel n = do\n  whenM pickingLevel $ do\n    modify' $ \\s -> s { level = Just n }\n    whenM (gets (isJust . progression)) halt\n\npickProgression :: Bool -> EventM () LevelConfigMaybe ()\npickProgression b = do\n  unlessM pickingLevel $ modify' (\\s -> s { progression = Just b }) >> halt\n\npickingLevel :: EventM () LevelConfigMaybe Bool\npickingLevel = gets (isNothing . level)\n\nconfigureLeveling :: Maybe Int -> Maybe Bool -> IO LevelConfig\nconfigureLeveling (Just l) (Just p) = pure $ LevelConfig (Identity l) (Identity p)\nconfigureLeveling ml mp = do\n  result <- defaultMain app $ LevelConfig ml mp\n  case result of\n    (LevelConfig {level = Just l, progression = Just p}) ->\n      pure $ LevelConfig (Identity l) (Identity p)\n    _ ->\n      exitSuccess\n"
            },
            {
              "file_name": "/tmp/project_90/pre_refactor/src/UI/Game.hs",
              "refactored_file_name": "/tmp/project_90/hybrid_refactored/src/UI/Game.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.1363636363636365,
                "sum": 50
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 2,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 15,
              "lines_of_code": 355,
              "homplexity_lines_of_code": 482,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.1363636363636365,
                  "sum": 50
                },
                "homplexity_loc": 482,
                "homplexity_output": "Info:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 1 1: module UI.Game has 278 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 32 11: data UI has record fields count of 6 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 44 13: data Tick has record fields count of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 50 5: data VisualBlock has record fields count of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 55 1: type signature for app has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 55 1: type signature for app has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 56 1: function app has 6 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 56 1: function app has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 56 1: function app has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 64 1: type signature for playGame has 4 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 64 1: type signature for playGame has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 69 1: function playGame has 18 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 69 1: function playGame has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 69 1: function playGame has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 89 1: type signature for levelToDelay has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 89 1: type signature for levelToDelay has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 90 1: function levelToDelay has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 94 1: type signature for handleEvent has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 94 1: type signature for handleEvent has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 95 1: function handleEvent has cyclomatic complexity of 1 \nWarning:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 95 1: function handleEvent has 27 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 95 1: function handleEvent has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 127 1: type signature for exec has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 127 1: type signature for exec has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 128 1: function exec has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 128 1: function exec has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 128 1: function exec has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 131 1: type signature for restart has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 131 1: type signature for restart has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 132 1: function restart has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 132 1: function restart has 6 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 132 1: function restart has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 139 1: type signature for toggleProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 139 1: type signature for toggleProgression has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 140 1: function toggleProgression has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 144 1: type signature for drawUI has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 144 1: type signature for drawUI has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 145 1: function drawUI has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 145 1: function drawUI has 5 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 145 1: function drawUI has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 153 1: type signature for drawGrid has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 153 1: type signature for drawGrid has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 154 1: function drawGrid has 18 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 154 1: function drawGrid has cyclomatic complexity of 3 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 154 1: function drawGrid has branching depth of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 175 1: type signature for emptyCellMap has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 175 1: type signature for emptyCellMap has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 176 1: function emptyCellMap has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 176 1: function emptyCellMap has 2 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 176 1: function emptyCellMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 179 1: type signature for emptyGridCellW has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 179 1: type signature for emptyGridCellW has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 180 1: function emptyGridCellW has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 180 1: function emptyGridCellW has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 180 1: function emptyGridCellW has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 189 1: type signature for drawBlockCell has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 189 1: type signature for drawBlockCell has 3 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 190 1: function drawBlockCell has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 190 1: function drawBlockCell has 2 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 190 1: function drawBlockCell has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 193 1: type signature for tToAttr has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 193 1: type signature for tToAttr has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 194 1: function tToAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 194 1: function tToAttr has 7 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 194 1: function tToAttr has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 202 1: type signature for tToAttrH has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 202 1: type signature for tToAttrH has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 203 1: function tToAttrH has 7 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 203 1: function tToAttrH has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 203 1: function tToAttrH has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 211 1: type signature for cw has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 211 1: type signature for cw has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 212 1: function cw has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 212 1: function cw has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 212 1: function cw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 214 1: type signature for ecw has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 214 1: type signature for ecw has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 215 1: function ecw has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 215 1: function ecw has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 215 1: function ecw has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 217 1: type signature for drawStats has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 217 1: type signature for drawStats has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 218 1: function drawStats has 10 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 218 1: function drawStats has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 218 1: function drawStats has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 230 1: type signature for drawProgression has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 230 1: type signature for drawProgression has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 231 1: function drawProgression has cyclomatic complexity of 3 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 231 1: function drawProgression has 5 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 231 1: function drawProgression has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 237 1: type signature for drawStat has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 237 1: type signature for drawStat has 3 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 238 1: function drawStat has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 238 1: function drawStat has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 238 1: function drawStat has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 245 1: type signature for drawInfo has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 245 1: type signature for drawInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 246 1: function drawInfo has 5 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 246 1: function drawInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 246 1: function drawInfo has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 253 1: type signature for drawNextShape has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 253 1: type signature for drawNextShape has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 254 1: function drawNextShape has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 254 1: function drawNextShape has 13 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 254 1: function drawNextShape has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 269 1: type signature for drawHelp has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 269 1: type signature for drawHelp has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 270 1: function drawHelp has 15 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 270 1: function drawHelp has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 270 1: function drawHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 287 1: type signature for drawKeyInfo has 3 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 287 1: type signature for drawKeyInfo has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 288 1: function drawKeyInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 288 1: function drawKeyInfo has 3 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 288 1: function drawKeyInfo has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 292 1: type signature for drawGameOver has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 292 1: type signature for drawGameOver has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 293 1: function drawGameOver has 4 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 293 1: function drawGameOver has cyclomatic complexity of 2 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 293 1: function drawGameOver has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 298 1: type signature for theMap has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 298 1: type signature for theMap has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 299 1: function theMap has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 299 1: function theMap has 19 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 299 1: function theMap has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 320 1: type signature for tToColor has 2 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 320 1: type signature for tToColor has type constructor nesting of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 321 1: function tToColor has 7 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 321 1: function tToColor has branching depth of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 321 1: function tToColor has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 329 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 329 1: type signature for iAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 330 1: function iAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 330 1: function iAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 330 1: function iAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 331 1: function oAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 331 1: function oAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 331 1: function oAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 332 1: function tAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 332 1: function tAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 332 1: function tAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 333 1: function sAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 333 1: function sAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 333 1: function sAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 334 1: function zAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 334 1: function zAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 334 1: function zAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 335 1: function jAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 335 1: function jAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 335 1: function jAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 336 1: function lAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 336 1: function lAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 336 1: function lAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 338 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 338 1: type signature for ihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 339 1: function ihAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 339 1: function ihAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 339 1: function ihAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 340 1: function ohAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 340 1: function ohAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 340 1: function ohAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 341 1: function thAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 341 1: function thAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 341 1: function thAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 342 1: function shAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 342 1: function shAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 342 1: function shAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 343 1: function zhAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 343 1: function zhAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 343 1: function zhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 344 1: function jhAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 344 1: function jhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 344 1: function jhAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 345 1: function lhAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 345 1: function lhAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 345 1: function lhAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 347 1: type signature for emptyAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 347 1: type signature for emptyAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 348 1: function emptyAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 348 1: function emptyAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 348 1: function emptyAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 350 1: type signature for gameOverAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 350 1: type signature for gameOverAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 351 1: function gameOverAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 351 1: function gameOverAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 351 1: function gameOverAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 353 1: type signature for progressionAttr, fixedAttr has 1 arguments \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 353 1: type signature for progressionAttr, fixedAttr has type constructor nesting of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 354 1: function progressionAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 354 1: function progressionAttr has 1 lines of code \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 354 1: function progressionAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 355 1: function fixedAttr has branching depth of 0 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 355 1: function fixedAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_90/hybrid_refactored/src/UI/Game.hs:SrcLoc \"/tmp/project_90/hybrid_refactored/src/UI/Game.hs\" 355 1: function fixedAttr has 1 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\nmodule UI.Game\n  ( playGame\n  ) where\n\nimport Control.Concurrent (threadDelay, forkIO)\nimport Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, writeTVar, atomically)\nimport Control.Monad (void, forever)\nimport Prelude hiding (Left, Right)\n\nimport Brick hiding (Down)\nimport Brick.BChan\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport Control.Lens hiding (preview, op, zoom)\nimport Control.Monad.Extra (orM, unlessM)\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Graphics.Vty as V\nimport qualified Graphics.Vty.CrossPlatform\nimport qualified Graphics.Vty.Config\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Linear.V2 (V2(..))\n\nimport Tetris\n\ndata UI = UI\n  { _game      :: Game\n  , _initLevel :: Int\n  , _currLevel :: TVar Int\n  , _preview   :: Maybe String\n  , _locked    :: Bool\n  , _paused    :: Bool\n  }\n\nmakeLenses ''UI\n\n-- | Ticks mark passing of time\ndata Tick = Tick\n\n-- | Named resources\ntype Name = ()\n\ndata VisualBlock\n  = NormalBlock\n  | HardDropBlock String\n\n-- App definition and execution\n\napp :: App UI Tick Name\napp = App\n  { appDraw         = drawUI\n  , appChooseCursor = neverShowCursor\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const theMap\n  }\n\nplayGame\n  :: Int          -- ^ Starting level\n  -> Bool         -- ^ Enable level progression\n  -> Maybe String -- ^ Preview cell (Nothing == no preview)\n  -> IO Game\nplayGame lvl prog mp = do\n  chan <- newBChan 10   -- share the current level with the thread so it can adjust speed\n  tv <- newTVarIO lvl\n  void . forkIO $ forever $ do\n    writeBChan chan Tick\n    lvl' <- readTVarIO tv\n    threadDelay $ levelToDelay lvl'\n  initialGame <- initGame lvl prog  -- Pass the progression parameter\n  let buildVty = Graphics.Vty.CrossPlatform.mkVty Graphics.Vty.Config.defaultConfig\n  initialVty <- buildVty\n  ui <- customMain initialVty buildVty (Just chan) app $ UI\n    { _game      = initialGame\n    , _initLevel = lvl\n    , _currLevel = tv\n    , _preview   = mp\n    , _locked    = False\n    , _paused    = False\n    }\n  return $ ui ^. game\n\nlevelToDelay :: Int -> Int\nlevelToDelay n = floor $ 400000 * (0.85 :: Double) ^ (2 * n)\n\n-- Handling events\n\nhandleEvent :: BrickEvent Name Tick -> EventM Name UI ()\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'r') [])) = restart\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') [])) = halt\nhandleEvent (VtyEvent (V.EvKey V.KEsc        [])) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'm') [])) = exec toggleProgression\nhandleEvent (VtyEvent (V.EvKey V.KRight      [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey V.KLeft       [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey V.KDown       [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'l') [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'h') [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'j') [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey V.KUp         [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'k') [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') [])) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game hardDrop\n    assign locked True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'p') [])) =\n  unlessM (orM [use locked, use (game . to isGameOver)]) $ do\n    modifying paused not\nhandleEvent (AppEvent Tick                      ) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game timeStep\n    -- Keep level in sync with ticker (gross)\n    lvl <- use $ game . level\n    tv <- use $ currLevel\n    liftIO . atomically $ writeTVar tv lvl\n    assign locked False\nhandleEvent _ = pure ()\n\n-- | This common execution function is used for all game user input except hard\n-- drop and pause. If paused or locked (from hard drop) do nothing, else\n-- execute the state computation.\nexec :: Tetris () -> EventM Name UI ()\nexec = unlessM (orM [use paused, use locked, use (game . to isGameOver)]) . zoom game\n\n-- | Restart game at the initially chosen level\nrestart :: EventM Name UI ()\nrestart = do\n  lvl <- use initLevel\n  prog <- use (game . progression)  -- Get current progression setting\n  g <- liftIO $ initGame lvl prog   -- Use it when restarting\n  assign game g\n  assign locked False\n\ntoggleProgression :: Tetris ()\ntoggleProgression = modifying progression not\n\n-- Drawing\n\ndrawUI :: UI -> [Widget Name]\ndrawUI ui =\n  [ C.vCenter $ vLimit 22 $ hBox\n      [ padLeft Max $ padRight (Pad 2) $ drawStats (ui ^. game)\n      , drawGrid ui\n      , padRight Max $ padLeft (Pad 2) $ drawInfo (ui ^. game)\n      ]\n  ]\n\ndrawGrid :: UI -> Widget Name\ndrawGrid ui =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ case ui ^. paused of\n        True  -> C.center $ str \"Paused\"\n        False -> vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r ->\n          foldr (<+>) emptyWidget\n            . M.filterWithKey (\\(V2 _ y) _ -> r == y)\n            $ mconcat\n                [ drawBlockCell NormalBlock <$> ui ^. (game . board)\n                , blockMap NormalBlock (ui ^. (game . block))\n                , case ui ^. preview of\n                    Nothing -> M.empty\n                    Just s  -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game))\n                , emptyCellMap\n                ]\n where\n  blockMap v b =\n    M.fromList $ [ (c, drawBlockCell v (b ^. shape)) | c <- coords b ]\n\nemptyCellMap :: Map Coord (Widget Name)\nemptyCellMap = M.fromList\n  [ (V2 x y, emptyGridCellW) | x <- [1 .. boardWidth], y <- [1 .. boardHeight] ]\n\nemptyGridCellW :: Widget Name\nemptyGridCellW = withAttr emptyAttr cw\n\nemptyNextShapeCellW :: Widget Name\nemptyNextShapeCellW = withAttr emptyAttr ecw\n\ndrawBlockCell :: VisualBlock -> Tetrimino -> Widget Name\ndrawBlockCell NormalBlock       t = withAttr (tToAttr t) cw\ndrawBlockCell (HardDropBlock s) t = withAttr (tToAttrH t) (str s)\n\ntToAttr :: Tetrimino -> AttrName\ntToAttr I = iAttr\ntToAttr O = oAttr\ntToAttr T = tAttr\ntToAttr S = sAttr\ntToAttr Z = zAttr\ntToAttr J = jAttr\ntToAttr L = lAttr\n\ntToAttrH :: Tetrimino -> AttrName\ntToAttrH I = ihAttr\ntToAttrH O = ohAttr\ntToAttrH T = thAttr\ntToAttrH S = shAttr\ntToAttrH Z = zhAttr\ntToAttrH J = jhAttr\ntToAttrH L = lhAttr\n\ncw :: Widget Name\ncw = str \" .\"\n\necw :: Widget Name\necw = str \"  \"\n\ndrawStats :: Game -> Widget Name\ndrawStats g =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Stats\")\n    $ vBox\n        [ drawStat \"Score\" $ g ^. score\n        , padTop (Pad 1) $ drawStat \"Lines\" $ g ^. linesCleared\n        , padTop (Pad 1) $ drawStat \"Level\" $ g ^. level\n        , padTop (Pad 1) $ drawProgression (g ^. progression)\n        , drawLeaderBoard g\n        ]\n\ndrawProgression :: Bool -> Widget Name\ndrawProgression enabled =\n  let attr = if enabled then progressionAttr else fixedAttr\n      text = if enabled then \"On\" else \"Off\"\n  in padLeftRight 1 $ str \"Leveling \"\n      <+> withAttr attr (padLeft Max $ str text)\n\ndrawStat :: String -> Int -> Widget Name\ndrawStat s n = padLeftRight 1 $ str s <+> padLeft Max (str $ show n)\n\ndrawLeaderBoard :: Game -> Widget Name\ndrawLeaderBoard _ = emptyWidget\n\ndrawInfo :: Game -> Widget Name\ndrawInfo g = hLimit 18 -- size of next piece box\n  $ vBox\n    [ drawNextShape (g ^. nextShape)\n    , padTop (Pad 1) drawHelp\n    , padTop (Pad 1) (drawGameOver g)\n    ]\n\ndrawNextShape :: Tetrimino -> Widget Name\ndrawNextShape t =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Next\")\n    $ padTopBottom 1\n    $ padLeftRight 4\n    $ vLimit 4\n    $ vBox\n    $ [0, -1] <&> \\y ->\n      hBox [ if V2 x y `elem` coords blk\n             then drawBlockCell NormalBlock t\n             else emptyNextShapeCellW\n           | x <- [-2 .. 1]\n           ]\n  where blk = Block t (V2 0 0) (relCells t)\n\ndrawHelp :: Widget Name\ndrawHelp =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Help\")\n    $ padTopBottom 1\n    $ vBox\n    $ map (uncurry drawKeyInfo)\n      [ (\"Left\"   , \"h, \u2190\")\n      , (\"Right\"  , \"l, \u2192\")\n      , (\"Down\"   , \"j, \u2193\")\n      , (\"Rotate\" , \"k, \u2191\")\n      , (\"Drop\"   , \"space\")\n      , (\"Mode\"   , \"m\")\n      , (\"Restart\", \"r\")\n      , (\"Pause\"  , \"p\")\n      , (\"Quit\"   , \"q\")\n      ]\n\ndrawKeyInfo :: String -> String -> Widget Name\ndrawKeyInfo action keys =\n  padRight Max (padLeft (Pad 1) $ str action)\n    <+> padLeft Max (padRight (Pad 1) $ str keys)\n\ndrawGameOver :: Game -> Widget Name\ndrawGameOver g =\n  if isGameOver g\n  then padLeftRight 4 $ withAttr gameOverAttr $ str \"GAME OVER\"\n  else emptyWidget\n\ntheMap :: AttrMap\ntheMap = attrMap\n  V.defAttr\n  [ (iAttr          , tToColor I `on` tToColor I)\n  , (oAttr          , tToColor O `on` tToColor O)\n  , (tAttr          , tToColor T `on` tToColor T)\n  , (sAttr          , tToColor S `on` tToColor S)\n  , (zAttr          , tToColor Z `on` tToColor Z)\n  , (jAttr          , tToColor J `on` tToColor J)\n  , (lAttr          , tToColor L `on` tToColor L)\n  , (ihAttr         , fg $ tToColor I)\n  , (ohAttr         , fg $ tToColor O)\n  , (thAttr         , fg $ tToColor T)\n  , (shAttr         , fg $ tToColor S)\n  , (zhAttr         , fg $ tToColor Z)\n  , (jhAttr         , fg $ tToColor J)\n  , (lhAttr         , fg $ tToColor L)\n  , (gameOverAttr   , fg V.red `V.withStyle` V.bold)\n  , (progressionAttr, fg V.green `V.withStyle` V.bold)\n  , (fixedAttr      , fg V.blue `V.withStyle` V.bold)\n  ]\n\ntToColor :: Tetrimino -> V.Color\ntToColor I = V.cyan\ntToColor O = V.yellow\ntToColor T = V.magenta\ntToColor S = V.green\ntToColor Z = V.red\ntToColor J = V.blue\ntToColor L = V.white\n\niAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr :: AttrName\niAttr = attrName \"I\"\noAttr = attrName \"O\"\ntAttr = attrName \"T\"\nsAttr = attrName \"S\"\nzAttr = attrName \"Z\"\njAttr = attrName \"J\"\nlAttr = attrName \"L\"\n\nihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr :: AttrName\nihAttr = attrName \"Ih\"\nohAttr = attrName \"Oh\"\nthAttr = attrName \"Th\"\nshAttr = attrName \"Sh\"\nzhAttr = attrName \"Zh\"\njhAttr = attrName \"Jh\"\nlhAttr = attrName \"Lh\"\n\nemptyAttr :: AttrName\nemptyAttr = attrName \"empty\"\n\ngameOverAttr :: AttrName\ngameOverAttr = attrName \"gameOver\"\n\nprogressionAttr, fixedAttr :: AttrName\nprogressionAttr = attrName \"progression\"\nfixedAttr = attrName \"fixed\"\n",
              "suggestions": [
                {
                  "target_snippet": "case ui ^. paused of\n    True -> C.center $ str \"Paused\"\n    False\n      -> vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r -> foldr (<+>) emptyWidget . M.filterWithKey (\\(V2 _ y) _ -> r == y) $ mconcat [\n                        drawBlockCell NormalBlock <$> ui ^. (game . board),\n                        blockMap NormalBlock (ui ^. (game . block)),\n                        case ui ^. preview of\n                          Nothing -> M.empty\n                          Just s -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),\n                        emptyCellMap]",
                  "refactored_suggestion": "if ui ^. paused\n  then C.center $ str \"Paused\"\n  else vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r -> foldr (<+>) emptyWidget . M.filterWithKey (\\(V2 _ y) _ -> r == y) $ mconcat [\n                      drawBlockCell NormalBlock <$> ui ^. (game . board),\n                      blockMap NormalBlock (ui ^. (game . block)),\n                      case ui ^. preview of\n                        Nothing -> M.empty\n                        Just s -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game)),\n                      emptyCellMap]",
                  "confidence": 1.0,
                  "justification": "Replacing the case expression with an if-then-else improves conciseness and readability while maintaining the same logic."
                },
                {
                  "target_snippet": "emptyNextShapeCellW :: Widget Name\nemptyNextShapeCellW = withAttr emptyAttr ecw",
                  "refactored_suggestion": "-- emptyNextShapeCellW is dead code and can safely be removed, along with its dependency ecw.\n\n-- reason for removal: 'emptyNextShapeCellW' function is defined but not used anywhere in the program.\n-- The associated 'ecw' (cell widget) definition will also be removed as it's a dependent entity.\n\n",
                  "confidence": 1.0,
                  "justification": "This function and its dependency are completely unused in the current codebase. Removing unused definitions reduces cognitive load and improves maintainability."
                },
                {
                  "target_snippet": "drawLeaderBoard :: Game -> Widget Name\ndrawLeaderBoard _ = emptyWidget",
                  "refactored_suggestion": "-- drawLeaderBoard is effectively a placeholder and seems unnecessary in the current state of the codebase.\n-- reason for removal: Since it only returns an emptyWidget and is not utilized in the existing logic, it can safely be removed for simplicity.\n\n",
                  "confidence": 1.0,
                  "justification": "The `drawLeaderBoard` function does not contribute any functionality and acts as a no-op. Removing it clears dead code."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\nmodule UI.Game\n  ( playGame\n  ) where\n\nimport Control.Concurrent (threadDelay, forkIO)\nimport Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, writeTVar, atomically)\nimport Control.Monad (void, forever)\nimport Prelude hiding (Left, Right)\n\nimport Brick hiding (Down)\nimport Brick.BChan\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Border.Style as BS\nimport qualified Brick.Widgets.Center as C\nimport Control.Lens hiding (preview, op, zoom)\nimport Control.Monad.Extra (orM, unlessM)\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Graphics.Vty as V\nimport qualified Graphics.Vty.CrossPlatform\nimport qualified Graphics.Vty.Config\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Linear.V2 (V2(..))\n\nimport Tetris\n\ndata UI = UI\n  { _game      :: Game\n  , _initLevel :: Int\n  , _currLevel :: TVar Int\n  , _preview   :: Maybe String\n  , _locked    :: Bool\n  , _paused    :: Bool\n  }\n\nmakeLenses ''UI\n\n-- | Ticks mark passing of time\ndata Tick = Tick\n\n-- | Named resources\ntype Name = ()\n\ndata VisualBlock\n  = NormalBlock\n  | HardDropBlock String\n\n-- App definition and execution\n\napp :: App UI Tick Name\napp = App\n  { appDraw         = drawUI\n  , appChooseCursor = neverShowCursor\n  , appHandleEvent  = handleEvent\n  , appStartEvent   = pure ()\n  , appAttrMap      = const theMap\n  }\n\nplayGame\n  :: Int          -- ^ Starting level\n  -> Bool         -- ^ Enable level progression\n  -> Maybe String -- ^ Preview cell (Nothing == no preview)\n  -> IO Game\nplayGame lvl prog mp = do\n  chan <- newBChan 10   -- share the current level with the thread so it can adjust speed\n  tv <- newTVarIO lvl\n  void . forkIO $ forever $ do\n    writeBChan chan Tick\n    lvl' <- readTVarIO tv\n    threadDelay $ levelToDelay lvl'\n  initialGame <- initGame lvl prog  -- Pass the progression parameter\n  let buildVty = Graphics.Vty.CrossPlatform.mkVty Graphics.Vty.Config.defaultConfig\n  initialVty <- buildVty\n  ui <- customMain initialVty buildVty (Just chan) app $ UI\n    { _game      = initialGame\n    , _initLevel = lvl\n    , _currLevel = tv\n    , _preview   = mp\n    , _locked    = False\n    , _paused    = False\n    }\n  return $ ui ^. game\n\nlevelToDelay :: Int -> Int\nlevelToDelay n = floor $ 400000 * (0.85 :: Double) ^ (2 * n)\n\n-- Handling events\n\nhandleEvent :: BrickEvent Name Tick -> EventM Name UI ()\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'r') [])) = restart\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'q') [])) = halt\nhandleEvent (VtyEvent (V.EvKey V.KEsc        [])) = halt\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'm') [])) = exec toggleProgression\nhandleEvent (VtyEvent (V.EvKey V.KRight      [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey V.KLeft       [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey V.KDown       [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'l') [])) = exec (shift Right)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'h') [])) = exec (shift Left)\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'j') [])) = exec (shift Down)\nhandleEvent (VtyEvent (V.EvKey V.KUp         [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'k') [])) = exec rotate\nhandleEvent (VtyEvent (V.EvKey (V.KChar ' ') [])) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game hardDrop\n    assign locked True\nhandleEvent (VtyEvent (V.EvKey (V.KChar 'p') [])) =\n  unlessM (orM [use locked, use (game . to isGameOver)]) $ do\n    modifying paused not\nhandleEvent (AppEvent Tick                      ) =\n  unlessM (orM [use paused, use (game . to isGameOver)]) $ do\n    zoom game timeStep\n    -- Keep level in sync with ticker (gross)\n    lvl <- use $ game . level\n    tv <- use $ currLevel\n    liftIO . atomically $ writeTVar tv lvl\n    assign locked False\nhandleEvent _ = pure ()\n\n-- | This common execution function is used for all game user input except hard\n-- drop and pause. If paused or locked (from hard drop) do nothing, else\n-- execute the state computation.\nexec :: Tetris () -> EventM Name UI ()\nexec = unlessM (orM [use paused, use locked, use (game . to isGameOver)]) . zoom game\n\n-- | Restart game at the initially chosen level\nrestart :: EventM Name UI ()\nrestart = do\n  lvl <- use initLevel\n  prog <- use (game . progression)  -- Get current progression setting\n  g <- liftIO $ initGame lvl prog   -- Use it when restarting\n  assign game g\n  assign locked False\n\ntoggleProgression :: Tetris ()\ntoggleProgression = modifying progression not\n\n-- Drawing\n\ndrawUI :: UI -> [Widget Name]\ndrawUI ui =\n  [ C.vCenter $ vLimit 22 $ hBox\n      [ padLeft Max $ padRight (Pad 2) $ drawStats (ui ^. game)\n      , drawGrid ui\n      , padRight Max $ padLeft (Pad 2) $ drawInfo (ui ^. game)\n      ]\n  ]\n\ndrawGrid :: UI -> Widget Name\ndrawGrid ui =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Tetris\")\n    $ case ui ^. paused of\n        True  -> C.center $ str \"Paused\"\n        False -> vBox $ [boardHeight, boardHeight - 1 .. 1] <&> \\r ->\n          foldr (<+>) emptyWidget\n            . M.filterWithKey (\\(V2 _ y) _ -> r == y)\n            $ mconcat\n                [ drawBlockCell NormalBlock <$> ui ^. (game . board)\n                , blockMap NormalBlock (ui ^. (game . block))\n                , case ui ^. preview of\n                    Nothing -> M.empty\n                    Just s  -> blockMap (HardDropBlock s) (evalTetris hardDroppedBlock (ui ^. game))\n                , emptyCellMap\n                ]\n where\n  blockMap v b =\n    M.fromList $ [ (c, drawBlockCell v (b ^. shape)) | c <- coords b ]\n\nemptyCellMap :: Map Coord (Widget Name)\nemptyCellMap = M.fromList\n  [ (V2 x y, emptyGridCellW) | x <- [1 .. boardWidth], y <- [1 .. boardHeight] ]\n\nemptyGridCellW :: Widget Name\nemptyGridCellW = withAttr emptyAttr cw\n\n-- emptyNextShapeCellW is dead code and can safely be removed, along with its dependency ecw.\n\n-- reason for removal: 'emptyNextShapeCellW' function is defined but not used anywhere in the program.\n-- The associated 'ecw' (cell widget) definition will also be removed as it's a dependent entity.\n\n\n\ndrawBlockCell :: VisualBlock -> Tetrimino -> Widget Name\ndrawBlockCell NormalBlock       t = withAttr (tToAttr t) cw\ndrawBlockCell (HardDropBlock s) t = withAttr (tToAttrH t) (str s)\n\ntToAttr :: Tetrimino -> AttrName\ntToAttr I = iAttr\ntToAttr O = oAttr\ntToAttr T = tAttr\ntToAttr S = sAttr\ntToAttr Z = zAttr\ntToAttr J = jAttr\ntToAttr L = lAttr\n\ntToAttrH :: Tetrimino -> AttrName\ntToAttrH I = ihAttr\ntToAttrH O = ohAttr\ntToAttrH T = thAttr\ntToAttrH S = shAttr\ntToAttrH Z = zhAttr\ntToAttrH J = jhAttr\ntToAttrH L = lhAttr\n\ncw :: Widget Name\ncw = str \" .\"\n\necw :: Widget Name\necw = str \"  \"\n\ndrawStats :: Game -> Widget Name\ndrawStats g =\n  hLimit 22\n    $ withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Stats\")\n    $ vBox\n        [ drawStat \"Score\" $ g ^. score\n        , padTop (Pad 1) $ drawStat \"Lines\" $ g ^. linesCleared\n        , padTop (Pad 1) $ drawStat \"Level\" $ g ^. level\n        , padTop (Pad 1) $ drawProgression (g ^. progression)\n        , drawLeaderBoard g\n        ]\n\ndrawProgression :: Bool -> Widget Name\ndrawProgression enabled =\n  let attr = if enabled then progressionAttr else fixedAttr\n      text = if enabled then \"On\" else \"Off\"\n  in padLeftRight 1 $ str \"Leveling \"\n      <+> withAttr attr (padLeft Max $ str text)\n\ndrawStat :: String -> Int -> Widget Name\ndrawStat s n = padLeftRight 1 $ str s <+> padLeft Max (str $ show n)\n\n-- drawLeaderBoard is effectively a placeholder and seems unnecessary in the current state of the codebase.\n-- reason for removal: Since it only returns an emptyWidget and is not utilized in the existing logic, it can safely be removed for simplicity.\n\n\n\ndrawInfo :: Game -> Widget Name\ndrawInfo g = hLimit 18 -- size of next piece box\n  $ vBox\n    [ drawNextShape (g ^. nextShape)\n    , padTop (Pad 1) drawHelp\n    , padTop (Pad 1) (drawGameOver g)\n    ]\n\ndrawNextShape :: Tetrimino -> Widget Name\ndrawNextShape t =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Next\")\n    $ padTopBottom 1\n    $ padLeftRight 4\n    $ vLimit 4\n    $ vBox\n    $ [0, -1] <&> \\y ->\n      hBox [ if V2 x y `elem` coords blk\n             then drawBlockCell NormalBlock t\n             else emptyNextShapeCellW\n           | x <- [-2 .. 1]\n           ]\n  where blk = Block t (V2 0 0) (relCells t)\n\ndrawHelp :: Widget Name\ndrawHelp =\n  withBorderStyle BS.unicodeBold\n    $ B.borderWithLabel (str \"Help\")\n    $ padTopBottom 1\n    $ vBox\n    $ map (uncurry drawKeyInfo)\n      [ (\"Left\"   , \"h, \u2190\")\n      , (\"Right\"  , \"l, \u2192\")\n      , (\"Down\"   , \"j, \u2193\")\n      , (\"Rotate\" , \"k, \u2191\")\n      , (\"Drop\"   , \"space\")\n      , (\"Mode\"   , \"m\")\n      , (\"Restart\", \"r\")\n      , (\"Pause\"  , \"p\")\n      , (\"Quit\"   , \"q\")\n      ]\n\ndrawKeyInfo :: String -> String -> Widget Name\ndrawKeyInfo action keys =\n  padRight Max (padLeft (Pad 1) $ str action)\n    <+> padLeft Max (padRight (Pad 1) $ str keys)\n\ndrawGameOver :: Game -> Widget Name\ndrawGameOver g =\n  if isGameOver g\n  then padLeftRight 4 $ withAttr gameOverAttr $ str \"GAME OVER\"\n  else emptyWidget\n\ntheMap :: AttrMap\ntheMap = attrMap\n  V.defAttr\n  [ (iAttr          , tToColor I `on` tToColor I)\n  , (oAttr          , tToColor O `on` tToColor O)\n  , (tAttr          , tToColor T `on` tToColor T)\n  , (sAttr          , tToColor S `on` tToColor S)\n  , (zAttr          , tToColor Z `on` tToColor Z)\n  , (jAttr          , tToColor J `on` tToColor J)\n  , (lAttr          , tToColor L `on` tToColor L)\n  , (ihAttr         , fg $ tToColor I)\n  , (ohAttr         , fg $ tToColor O)\n  , (thAttr         , fg $ tToColor T)\n  , (shAttr         , fg $ tToColor S)\n  , (zhAttr         , fg $ tToColor Z)\n  , (jhAttr         , fg $ tToColor J)\n  , (lhAttr         , fg $ tToColor L)\n  , (gameOverAttr   , fg V.red `V.withStyle` V.bold)\n  , (progressionAttr, fg V.green `V.withStyle` V.bold)\n  , (fixedAttr      , fg V.blue `V.withStyle` V.bold)\n  ]\n\ntToColor :: Tetrimino -> V.Color\ntToColor I = V.cyan\ntToColor O = V.yellow\ntToColor T = V.magenta\ntToColor S = V.green\ntToColor Z = V.red\ntToColor J = V.blue\ntToColor L = V.white\n\niAttr, oAttr, tAttr, sAttr, zAttr, jAttr, lAttr :: AttrName\niAttr = attrName \"I\"\noAttr = attrName \"O\"\ntAttr = attrName \"T\"\nsAttr = attrName \"S\"\nzAttr = attrName \"Z\"\njAttr = attrName \"J\"\nlAttr = attrName \"L\"\n\nihAttr, ohAttr, thAttr, shAttr, zhAttr, jhAttr, lhAttr :: AttrName\nihAttr = attrName \"Ih\"\nohAttr = attrName \"Oh\"\nthAttr = attrName \"Th\"\nshAttr = attrName \"Sh\"\nzhAttr = attrName \"Zh\"\njhAttr = attrName \"Jh\"\nlhAttr = attrName \"Lh\"\n\nemptyAttr :: AttrName\nemptyAttr = attrName \"empty\"\n\ngameOverAttr :: AttrName\ngameOverAttr = attrName \"gameOver\"\n\nprogressionAttr, fixedAttr :: AttrName\nprogressionAttr = attrName \"progression\"\nfixedAttr = attrName \"fixed\"\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}