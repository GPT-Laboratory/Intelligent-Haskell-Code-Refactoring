{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 10,
          "max": 35,
          "average": 8.666666666666666,
          "sum": 78
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 14,
          "suggestion": 14,
          "ignore": 0,
          "total": 28
        },
        "syntax_errors": 65,
        "lines_of_code": 485,
        "homplexity_lines_of_code": 639,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "48.4MB",
          "runtime": "1.62 × 10⁸ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Program.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 64,
          "homplexity_lines_of_code": 57,
          "code_quality_score": 88.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 57,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 1 1: module Program has 50 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 19 16: data Program has record fields count of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 30 13: data File has record fields count of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 41 21: data SupportLevel has record fields count of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 53 1: type signature for makeFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 53 1: type signature for makeFilename has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 54 1: function makeFilename has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 54 1: function makeFilename has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 54 1: function makeFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 56 1: type signature for save has 3 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 56 1: type signature for save has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 57 1: function save has 3 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 57 1: function save has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 57 1: function save has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 61 1: type signature for readProgram has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 61 1: type signature for readProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 62 1: function readProgram has 3 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 62 1: function readProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Program.hs\" 62 1: function readProgram has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Program where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport qualified Data.ByteString.Lazy     as B\nimport qualified Data.Text                as T\nimport           GHC.Generics\nimport           System.Directory\n\ninstance FromJSON File where\n  parseJSON (Object v) = File\n    <$> v .: \"path\"\n    <*> v .: \"movable\"\n    <*> v .: \"help\"\n\ndata Program = Program\n  { name  :: T.Text,\n    files :: [File]\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON Program where\n  toJSON (Program name files) = object [ \"name\" .= name, \"files\" .= files ]\n  toEncoding (Program name files) = pairs (\"name\" .= name <> \"files\" .= files)\ninstance FromJSON Program\n\ndata File = File\n  { path         :: String,\n    supportLevel :: SupportLevel,\n    help         :: String\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON File where\n  toJSON (File path supportLevel help) = object [ \"path\" .= path, \"movable\" .= supportLevel, \"help\" .= help ]\n  toEncoding (File path supportLevel help) = pairs (\"path\" .= path <> \"movable\" .= supportLevel <> \"help\" .= help)\n\ndata SupportLevel = Unsupported | Alias | EnvVars | Supported\n  deriving (Generic, Show)\n\ninstance ToJSON SupportLevel where\n  toJSON Unsupported = toJSON (Bool False)\n  toJSON _           = toJSON (Bool True)\n  toEncoding Unsupported = toEncoding ( Bool False )\n  toEncoding _           = toEncoding ( Bool True )\ninstance FromJSON SupportLevel where\n  parseJSON (Bool False) = return Unsupported\n  parseJSON (Bool True)  = return EnvVars\n\nmakeFilename :: T.Text -> T.Text\nmakeFilename s = T.pack ( \"./programs/\" ++ T.unpack s ++ \".json\" )\n\nsave :: T.Text -> Program -> IO ()\nsave filename program = do\n  createDirectoryIfMissing False \"./programs/\"\n  B.writeFile (T.unpack filename) (encodePretty program)\n\nreadProgram :: String -> IO ( Maybe Program )\nreadProgram filename = do\n    json_data <- B.readFile filename\n    return (decode json_data)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/Program.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/Program.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 1.8571428571428572,
            "sum": 13
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 0,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 13,
          "lines_of_code": 92,
          "homplexity_lines_of_code": 132,
          "code_quality_score": 60.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 1.8571428571428572,
              "sum": 13
            },
            "homplexity_loc": 132,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 1 1: module AddProgram has 81 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 29 1: type signature for getTemplate has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 29 1: type signature for getTemplate has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has 4 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 35 1: type signature for getHelp has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 35 1: type signature for getHelp has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 36 1: function getHelp has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 36 1: function getHelp has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 36 1: function getHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 38 1: type signature for getSupportLevel has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 38 1: type signature for getSupportLevel has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has branching depth of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has 13 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has cyclomatic complexity of 4 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 53 1: type signature for getFile has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 53 1: type signature for getFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 54 1: function getFile has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 54 1: function getFile has 5 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 54 1: function getFile has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 60 1: type signature for getFiles has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 60 1: type signature for getFiles has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 61 1: function getFiles has cyclomatic complexity of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 61 1: function getFiles has 12 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 61 1: function getFiles has branching depth of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 74 1: type signature for getProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 74 1: type signature for getProgram has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 75 1: function getProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 75 1: function getProgram has 10 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 75 1: function getProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 86 1: type signature for saveProgram has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 86 1: type signature for saveProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has 6 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has cyclomatic complexity of 2 \n"
          },
          "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule AddProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetTemplate :: SupportLevel -> String\ngetTemplate Unsupported = \"Currently unsupported.\\n\\n_Relevant issue:_ https://github.com/user/repo/issues/nr\\n\"\ngetTemplate EnvVars = \"Export the following environment variables:\\n\\n```bash\\n\\n```\"\ngetTemplate Alias = \"Alias PROGRAM to use a custom configuration location:\\n\\n```bash\\nalias PROGRAM=PROGRAM --config \\\"$XDG_CONFIG_HOME\\\"/PROGRAM/config\\n```\\n\"\ngetTemplate Supported = \"Supported since _VERSION_.\\n\\nYou can move the file to _XDG_CONFIG_HOME/PROGRAM/CONFIG.\\n\"\n\ngetHelp :: SupportLevel -> IO String\ngetHelp supportLevel = getInputMarkdown (getTemplate supportLevel)\n\ngetSupportLevel :: IO SupportLevel\ngetSupportLevel = do\n  movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if movable\n  then do\n    envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n    if envVars\n    then return EnvVars\n    else do\n      alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if alias\n      then return Alias\n      else return Supported\n  else return Unsupported\n\ngetFile :: IO File\ngetFile = do\n  path <- getProp (blue \"Path to file: \") \"$HOME/.\"\n  supportLevel <- getSupportLevel\n  help <- getHelp supportLevel\n  return File {path = path, supportLevel = supportLevel, help = help}\n\ngetFiles :: [File] -> IO [File]\ngetFiles files =\n  if Data.List.Extra.null files\n  then do\n    newFile <- getFile\n    getFiles (newFile : files)\n  else do\n    new <- promptBool (green \"Add another file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n    if new\n    then do\n      newFile <- getFile\n      getFiles (newFile : files)\n    else return files\n\ngetProgram :: IO Program\ngetProgram = do\n  name <- printf \"%s\\n\" (T.unpack (bold (cyan \"XDG-ninja Configuration Wizard\")))\n          >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"First, tell me what program you're creating a configuration for.\"))))\n          >> getProp (yellow \"Program name: \") \"\"\n  files <- printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Alright, now let's configure which files belong to this program.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'm going to ask you for the path to the file, please use $HOME instead of ~.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'll then ask you whether or not this file can be moved to a different directory.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Finally, your editor is going to open a markdown document. Enter instructions on moving the file in question, then save and close.\"))))\n           >> getFiles []\n  return Program {name = T.pack name, files = files}\n\nsaveProgram :: IO ()\nsaveProgram = do\n  program <- getProgram\n  do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if do_save\n  then save (makeFilename (name program)) program\n  else return ()\n",
          "suggestions": [
            {
              "module": [
                "AddProgram"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 35,
              "from": "{-# LANGUAGE DeriveGeneric #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 35}, newComment = \"\"}]"
            },
            {
              "module": [
                "AddProgram"
              ],
              "decl": [
                "saveProgram"
              ],
              "severity": "Warning",
              "hint": "Use when",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs",
              "startLine": 90,
              "startColumn": 3,
              "endLine": 92,
              "endColumn": 17,
              "from": "if do_save then\n    save (makeFilename (name program)) program\nelse\n    return ()",
              "to": "Control.Monad.when do_save\n  $ save (makeFilename (name program)) program",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 90, startCol = 3, endLine = 92, endCol = 17}, subts = [(\"x\",SrcSpan {startLine = 90, startCol = 6, endLine = 90, endCol = 13}),(\"y\",SrcSpan {startLine = 91, startCol = 8, endLine = 91, endCol = 50})], orig = \"Control.Monad.when x $ y\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/AddProgram.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/AddProgram.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.3333333333333333,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 0,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 4,
          "lines_of_code": 22,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 89.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.3333333333333333,
              "sum": 4
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 1 1: module PreviewProgram has 18 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has 3 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has 3 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 16 1: type signature for previewProgramFile has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 16 1: type signature for previewProgramFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has 6 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has cyclomatic complexity of 2 \n"
          },
          "original_code": "module PreviewProgram where\n\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Output\nimport           Program\n\npreviewFile :: T.Text -> File -> IO ()\npreviewFile name file = logFile name file True\n\npreviewProgram :: Program -> IO ()\npreviewProgram program = do\n  _ <- sequence (map (previewFile (name program)) (files program))\n  return ()\n\npreviewProgramFile :: String -> IO ()\npreviewProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> previewProgram program\n    Nothing      -> putStrLn (T.unpack (red (T.pack \"Error.\")))\n  return ()\n",
          "suggestions": [
            {
              "module": [
                "PreviewProgram"
              ],
              "decl": [
                "previewProgram"
              ],
              "severity": "Warning",
              "hint": "Use mapM",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
              "startLine": 13,
              "startColumn": 8,
              "endLine": 13,
              "endColumn": 67,
              "from": "sequence (map (previewFile (name program)) (files program))",
              "to": "mapM (previewFile (name program)) (files program)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 13, startCol = 8, endLine = 13, endCol = 67}, subts = [(\"f\",SrcSpan {startLine = 13, startCol = 22, endLine = 13, endCol = 50}),(\"x\",SrcSpan {startLine = 13, startCol = 51, endLine = 13, endCol = 66})], orig = \"mapM f x\"}]"
            },
            {
              "module": [
                "PreviewProgram"
              ],
              "decl": [
                "previewProgram"
              ],
              "severity": "Warning",
              "hint": "Use sequence_",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
              "startLine": 13,
              "startColumn": 8,
              "endLine": 13,
              "endColumn": 67,
              "from": "sequence (map (previewFile (name program)) (files program))",
              "to": "sequence_ (map (previewFile (name program)) (files program))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 13, startCol = 8, endLine = 13, endCol = 16}, subts = [], orig = \"sequence_\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/PreviewProgram.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 6,
            "average": 2.6,
            "sum": 13
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 6,
            "ignore": 0,
            "total": 7
          },
          "syntax_errors": 6,
          "lines_of_code": 56,
          "homplexity_lines_of_code": 83,
          "code_quality_score": 65.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 6,
              "average": 2.6,
              "sum": 13
            },
            "homplexity_loc": 83,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 1 1: module Output has 49 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 12 1: type signature for getFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 12 1: type signature for getFilename has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 13 1: function getFilename has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 13 1: function getFilename has 3 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 13 1: function getFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 18 1: function renderMarkdown has 9 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 18 1: function renderMarkdown has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 18 1: function renderMarkdown has cyclomatic complexity of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 28 1: type signature for line has 4 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 28 1: type signature for line has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 29 1: function line has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 29 1: function line has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 29 1: function line has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 31 13: data Mode has record fields count of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 33 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 33 1: type signature for log has 5 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 34 1: function log has cyclomatic complexity of 6 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 34 1: function log has 16 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 34 1: function log has branching depth of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 51 1: type signature for logFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 51 1: type signature for logFile has 4 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 52 1: function logFile has cyclomatic complexity of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 52 1: function logFile has branching depth of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Output.hs\" 52 1: function logFile has 5 lines of code \n"
          },
          "original_code": "module Output where\n\nimport           Data.Char      (isSpace)\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Exit\nimport           System.Process\n\ngetFilename :: IO String\ngetFilename = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  return (\"/tmp/xdg-ninja.\" ++ id ++ \".txt\")\n\nrenderMarkdown :: String -> IO String\nrenderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  editor <- appendFile (filenameInput) content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"\n\nline :: (T.Text -> T.Text) -> String -> String -> String\nline color name filename = T.unpack ((T.pack \"[\") <> bold (color (T.pack name)) <> (T.pack \"]: \") <> bold (italic (T.pack filename)))\n\ndata Mode = ERR | WARN | INFO | SUCS | HELP\n\nlog :: Mode -> String -> String -> String -> IO ()\nlog mode name filename help = case mode of\n    ERR -> do\n      putStrLn (line red name filename)\n      Output.log HELP name filename help\n    WARN -> do\n      putStrLn (line yellow name filename)\n      Output.log HELP name filename help\n    INFO -> do\n      putStrLn (line cyan name filename)\n      Output.log HELP name filename help\n    SUCS -> putStrLn (line green name filename)\n    HELP -> do\n      md <- case (all isSpace help) of\n        True  -> renderMarkdown \"_No help available._\"\n        False -> renderMarkdown help\n      putStr md\n\nlogFile :: T.Text -> File -> Bool -> IO ()\nlogFile programName file onFilesystem = case onFilesystem of\n  False -> Output.log SUCS (T.unpack programName) (path file) (help file)\n  True -> case (supportLevel file) of\n    Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n    _ -> Output.log WARN (T.unpack programName) (path file) (help file)\n",
          "suggestions": [
            {
              "module": [
                "Output"
              ],
              "decl": [
                "renderMarkdown"
              ],
              "severity": "Warning",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 21,
              "startColumn": 24,
              "endLine": 21,
              "endColumn": 39,
              "from": "(filenameInput)",
              "to": "filenameInput",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 21, startCol = 24, endLine = 21, endCol = 39}, subts = [(\"x\",SrcSpan {startLine = 21, startCol = 25, endLine = 21, endCol = 38})], orig = \"x\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "line"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 29,
              "startColumn": 38,
              "endLine": 29,
              "endColumn": 50,
              "from": "(T.pack \"[\")\n  <>\n    bold (color (T.pack name))\n      <> (T.pack \"]: \") <> bold (italic (T.pack filename))",
              "to": "T.pack \"[\"\n  <>\n    bold (color (T.pack name))\n      <> (T.pack \"]: \") <> bold (italic (T.pack filename))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 29, startCol = 38, endLine = 29, endCol = 50}, subts = [(\"x\",SrcSpan {startLine = 29, startCol = 39, endLine = 29, endCol = 49})], orig = \"x\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "line"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 29,
              "startColumn": 84,
              "endLine": 29,
              "endColumn": 98,
              "from": "(T.pack \"]: \") <> bold (italic (T.pack filename))",
              "to": "T.pack \"]: \" <> bold (italic (T.pack filename))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 29, startCol = 84, endLine = 29, endCol = 98}, subts = [(\"x\",SrcSpan {startLine = 29, startCol = 85, endLine = 29, endCol = 97})], orig = \"x\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "log"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 46,
              "startColumn": 13,
              "endLine": 48,
              "endColumn": 37,
              "from": "case (all isSpace help) of\n  True -> renderMarkdown \"_No help available._\"\n  False -> renderMarkdown help",
              "to": "(if all isSpace help then\n     renderMarkdown \"_No help available._\"\n else\n     renderMarkdown help)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 46, startCol = 13, endLine = 48, endCol = 37}, subts = [(\"a\",SrcSpan {startLine = 46, startCol = 19, endLine = 46, endCol = 35}),(\"f\",SrcSpan {startLine = 48, startCol = 18, endLine = 48, endCol = 37}),(\"t\",SrcSpan {startLine = 47, startCol = 18, endLine = 47, endCol = 55})], orig = \"(if a then t else f)\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "log"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 46,
              "startColumn": 18,
              "endLine": 46,
              "endColumn": 36,
              "from": "case (all isSpace help) of\n  True -> renderMarkdown \"_No help available._\"\n  False -> renderMarkdown help",
              "to": "case all isSpace help of\n  True -> renderMarkdown \"_No help available._\"\n  False -> renderMarkdown help",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 46, startCol = 18, endLine = 46, endCol = 36}, subts = [(\"x\",SrcSpan {startLine = 46, startCol = 19, endLine = 46, endCol = 35})], orig = \"x\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "logFile"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 52,
              "startColumn": 41,
              "endLine": 56,
              "endColumn": 72,
              "from": "case onFilesystem of\n  False\n    -> Output.log SUCS (T.unpack programName) (path file) (help file)\n  True\n    -> case (supportLevel file) of\n         Unsupported\n           -> Output.log ERR (T.unpack programName) (path file) (help file)\n         _ -> Output.log WARN (T.unpack programName) (path file) (help file)",
              "to": "if onFilesystem then\n    (case (supportLevel file) of\n       Unsupported\n         -> Output.log ERR (T.unpack programName) (path file) (help file)\n       _ -> Output.log\n              WARN (T.unpack programName) (path file) (help file))\nelse\n    Output.log SUCS (T.unpack programName) (path file) (help file)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 52, startCol = 41, endLine = 56, endCol = 72}, subts = [(\"a\",SrcSpan {startLine = 52, startCol = 46, endLine = 52, endCol = 58}),(\"f\",SrcSpan {startLine = 53, startCol = 12, endLine = 53, endCol = 74}),(\"t\",SrcSpan {startLine = 54, startCol = 11, endLine = 56, endCol = 72})], orig = \"if a then (t) else f\"}]"
            },
            {
              "module": [
                "Output"
              ],
              "decl": [
                "logFile"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "startLine": 54,
              "startColumn": 16,
              "endLine": 54,
              "endColumn": 35,
              "from": "case (supportLevel file) of\n  Unsupported\n    -> Output.log ERR (T.unpack programName) (path file) (help file)\n  _ -> Output.log WARN (T.unpack programName) (path file) (help file)",
              "to": "case supportLevel file of\n  Unsupported\n    -> Output.log ERR (T.unpack programName) (path file) (help file)\n  _ -> Output.log WARN (T.unpack programName) (path file) (help file)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 54, startCol = 16, endLine = 54, endCol = 35}, subts = [(\"x\",SrcSpan {startLine = 54, startCol = 17, endLine = 54, endCol = 34})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/Output.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/Output.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs",
          "cyclomatic_complexity": {
            "min": 2,
            "max": 7,
            "average": 3.5,
            "sum": 14
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 7,
          "lines_of_code": 52,
          "homplexity_lines_of_code": 74,
          "code_quality_score": 64.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 7,
              "average": 3.5,
              "sum": 14
            },
            "homplexity_loc": 74,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 1 1: module Prompts has 45 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 14 1: type signature for getInputMarkdown has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 14 1: type signature for getInputMarkdown has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has 8 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has cyclomatic complexity of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 24 1: type signature for getProp has 3 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 24 1: type signature for getProp has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 25 1: function getProp has 7 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 25 1: function getProp has cyclomatic complexity of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 25 1: function getProp has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 33 15: data Answer has record fields count of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 35 1: type signature for stringToBool has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 35 1: type signature for stringToBool has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 36 1: function stringToBool has 8 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 36 1: function stringToBool has cyclomatic complexity of 7 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 36 1: function stringToBool has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 45 1: type signature for promptBool has 4 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 45 1: type signature for promptBool has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 46 1: function promptBool has cyclomatic complexity of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 46 1: function promptBool has 6 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs\" 46 1: function promptBool has branching depth of 1 \n"
          },
          "original_code": "module Prompts where\n\nimport           Data.List.Extra\nimport qualified Data.Text                as T\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetInputMarkdown :: String -> IO String\ngetInputMarkdown placeholder = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  editor <- appendFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\") placeholder >> (getEnv \"EDITOR\")\n  (_, _, _, p) <- createProcess (shell (editor ++ \" /tmp/xdg-ninja.\" ++ id ++ \".md\"))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\")\n    ExitFailure a -> return \"\"\n\ngetProp :: T.Text -> T.Text -> IO String\ngetProp prompt placeholder = do\n  let string_prompt = T.unpack prompt\n  let string_placeholder = T.unpack placeholder\n  x <- runInputT defaultSettings (getInputLineWithInitial string_prompt (string_placeholder, \"\"))\n  case x of\n    Just s  -> return s\n    Nothing -> return \"\"\n\ndata Answer = Yes | No | Unknown\n\nstringToBool :: String -> Answer\nstringToBool s = case lower s of\n  \"yes\" -> Yes\n  \"y\"   -> Yes\n  \"1\"   -> Yes\n  \"no\"  -> No\n  \"n\"   -> No\n  \"0\"   -> No\n  _     -> Unknown\n\npromptBool :: T.Text -> T.Text -> T.Text -> IO Bool\npromptBool prompt prompt_unrecognised placeholder = do\n  x <- getProp prompt placeholder\n  case stringToBool x of\n    Yes -> return True\n    No -> return False\n    Unknown -> printf \"%s\\n\" prompt_unrecognised >> promptBool prompt prompt_unrecognised placeholder\n\n",
          "suggestions": [
            {
              "module": [
                "Prompts"
              ],
              "decl": [
                "getInputMarkdown"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs",
              "startLine": 17,
              "startColumn": 74,
              "endLine": 17,
              "endColumn": 91,
              "from": "appendFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\") placeholder\n  >> (getEnv \"EDITOR\")",
              "to": "appendFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\") placeholder\n  >> getEnv \"EDITOR\"",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 17, startCol = 74, endLine = 17, endCol = 91}, subts = [(\"x\",SrcSpan {startLine = 17, startCol = 75, endLine = 17, endCol = 90})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/Prompts.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/Prompts.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/Prompts.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 1.8,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 6,
            "ignore": 0,
            "total": 9
          },
          "syntax_errors": 8,
          "lines_of_code": 63,
          "homplexity_lines_of_code": 89,
          "code_quality_score": 73.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 1.8,
              "sum": 9
            },
            "homplexity_loc": 89,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 1 1: module Checks has 54 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 16 15: data Result has record fields count of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 19 1: type signature for expandPath has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 19 1: type signature for expandPath has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 20 1: function expandPath has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 20 1: function expandPath has 5 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 20 1: function expandPath has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 27 1: type signature for checkFile has 4 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 27 1: type signature for checkFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 28 1: function checkFile has 15 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 28 1: function checkFile has branching depth of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 28 1: function checkFile has cyclomatic complexity of 4 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 44 1: type signature for checkProgram has 3 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 44 1: type signature for checkProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 45 1: function checkProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 45 1: function checkProgram has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 45 1: function checkProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 47 1: type signature for checkProgramFile has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 47 1: type signature for checkProgramFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 48 1: function checkProgramFile has 9 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 48 1: function checkProgramFile has cyclomatic complexity of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 48 1: function checkProgramFile has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 58 1: type signature for checkDir has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 58 1: type signature for checkDir has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 59 1: function checkDir has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 59 1: function checkDir has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/Checks.hs\" 59 1: function checkDir has 5 lines of code \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Checks where\n\nimport           Data.List              (isSuffixOf)\nimport qualified Data.Text              as T\nimport           Data.Text.ANSI\nimport qualified Data.Text.Lazy         as TL\nimport           Output\nimport           Program\nimport           System.Directory.Extra\nimport           System.Environment     (getEnv)\nimport           System.FilePath\nimport           Text.Replace\n\ndata Result = Exist | MustExist | NoExist\n  deriving Show\n\nexpandPath :: String -> IO String\nexpandPath path = do\n  home <- getEnv \"HOME\"\n  let replacements = [ Replace \"$HOME\" (T.pack home) ]\n  let result = replaceWithList replacements (TL.pack path)\n  return (TL.unpack result)\n\n\ncheckFile :: T.Text -> Bool -> File -> IO Result\ncheckFile programName verbose file  = do\n  path <- expandPath (path file)\n  existsFile <- doesFileExist path\n  existsDir <- doesDirectoryExist path\n  case (existsFile || existsDir) of\n    False -> case verbose of\n      False -> return NoExist\n      True -> do\n        logFile programName file False\n        return NoExist\n    True -> do\n      logFile programName file True\n      case (supportLevel file) of\n        Unsupported -> return MustExist\n        _           -> return Exist\n\ncheckProgram :: Bool -> Program -> IO [Result]\ncheckProgram verbose program = sequence (map (checkFile (name program) verbose) (files program))\n\ncheckProgramFile :: String -> IO [Result]\ncheckProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> do\n      results <- checkProgram False program\n      return results\n    Nothing -> do\n      putStrLn (T.unpack (red (T.pack \"Error.\")))\n      return []\n\ncheckDir :: FilePath -> IO ()\ncheckDir dirname = do\n  files <- getDirectoryContents dirname\n  jsonFiles <- return ( map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files ))\n  results <- sequence (map checkProgramFile jsonFiles)\n  return ()\n",
          "suggestions": [
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkFile"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 32,
              "startColumn": 3,
              "endLine": 42,
              "endColumn": 36,
              "from": "case (existsFile || existsDir) of\n  False\n    -> case verbose of\n         False -> return NoExist\n         True\n           -> do logFile programName file False\n                 return NoExist\n  True\n    -> do logFile programName file True\n          case (supportLevel file) of\n            Unsupported -> return MustExist\n            _ -> return Exist",
              "to": "(if existsFile || existsDir then\n     (do logFile programName file True\n         case (supportLevel file) of\n           Unsupported -> return MustExist\n           _ -> return Exist)\n else\n     (case verbose of\n        False -> return NoExist\n        True\n          -> do logFile programName file False\n                return NoExist))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 32, startCol = 3, endLine = 42, endCol = 36}, subts = [(\"a\",SrcSpan {startLine = 32, startCol = 9, endLine = 32, endCol = 32}),(\"f\",SrcSpan {startLine = 33, startCol = 14, endLine = 37, endCol = 23}),(\"t\",SrcSpan {startLine = 38, startCol = 13, endLine = 42, endCol = 36})], orig = \"(if a then (t) else (f))\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkFile"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 32,
              "startColumn": 8,
              "endLine": 32,
              "endColumn": 33,
              "from": "case (existsFile || existsDir) of\n  False\n    -> case verbose of\n         False -> return NoExist\n         True\n           -> do logFile programName file False\n                 return NoExist\n  True\n    -> do logFile programName file True\n          case (supportLevel file) of\n            Unsupported -> return MustExist\n            _ -> return Exist",
              "to": "case existsFile || existsDir of\n  False\n    -> case verbose of\n         False -> return NoExist\n         True\n           -> do logFile programName file False\n                 return NoExist\n  True\n    -> do logFile programName file True\n          case (supportLevel file) of\n            Unsupported -> return MustExist\n            _ -> return Exist",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 32, startCol = 8, endLine = 32, endCol = 33}, subts = [(\"x\",SrcSpan {startLine = 32, startCol = 9, endLine = 32, endCol = 32})], orig = \"x\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkFile"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 33,
              "startColumn": 14,
              "endLine": 37,
              "endColumn": 23,
              "from": "case verbose of\n  False -> return NoExist\n  True\n    -> do logFile programName file False\n          return NoExist",
              "to": "(if verbose then\n     (do logFile programName file False\n         return NoExist)\n else\n     return NoExist)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 33, startCol = 14, endLine = 37, endCol = 23}, subts = [(\"a\",SrcSpan {startLine = 33, startCol = 19, endLine = 33, endCol = 26}),(\"f\",SrcSpan {startLine = 34, startCol = 16, endLine = 34, endCol = 30}),(\"t\",SrcSpan {startLine = 35, startCol = 15, endLine = 37, endCol = 23})], orig = \"(if a then (t) else f)\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkFile"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 40,
              "startColumn": 12,
              "endLine": 40,
              "endColumn": 31,
              "from": "case (supportLevel file) of\n  Unsupported -> return MustExist\n  _ -> return Exist",
              "to": "case supportLevel file of\n  Unsupported -> return MustExist\n  _ -> return Exist",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 40, startCol = 12, endLine = 40, endCol = 31}, subts = [(\"x\",SrcSpan {startLine = 40, startCol = 13, endLine = 40, endCol = 30})], orig = \"x\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkProgram"
              ],
              "severity": "Warning",
              "hint": "Use mapM",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 45,
              "startColumn": 32,
              "endLine": 45,
              "endColumn": 97,
              "from": "sequence (map (checkFile (name program) verbose) (files program))",
              "to": "mapM (checkFile (name program) verbose) (files program)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 45, startCol = 32, endLine = 45, endCol = 97}, subts = [(\"f\",SrcSpan {startLine = 45, startCol = 46, endLine = 45, endCol = 80}),(\"x\",SrcSpan {startLine = 45, startCol = 81, endLine = 45, endCol = 96})], orig = \"mapM f x\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkProgramFile"
              ],
              "severity": "Warning",
              "hint": "Redundant return",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 51,
              "startColumn": 21,
              "endLine": 53,
              "endColumn": 21,
              "from": "do results <- checkProgram False program\n   return results",
              "to": "do checkProgram False program",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 52, startCol = 7, endLine = 52, endCol = 44}, subts = [(\"x\",SrcSpan {startLine = 52, startCol = 18, endLine = 52, endCol = 44})], orig = \"x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 53, startCol = 7, endLine = 53, endCol = 21}}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkDir"
              ],
              "severity": "Suggestion",
              "hint": "Use let",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 61,
              "startColumn": 3,
              "endLine": 61,
              "endColumn": 88,
              "from": "jsonFiles <- return\n               (map (\\ x -> dirname </> x) (filter (isSuffixOf \".json\") files))",
              "to": "let jsonFiles\n      = (map (\\ x -> dirname </> x) (filter (isSuffixOf \".json\") files))",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 61, startCol = 3, endLine = 61, endCol = 88}, subts = [(\"lhs\",SrcSpan {startLine = 61, startCol = 3, endLine = 61, endCol = 12}),(\"rhs\",SrcSpan {startLine = 61, startCol = 23, endLine = 61, endCol = 88})], orig = \"let lhs = rhs\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkDir"
              ],
              "severity": "Suggestion",
              "hint": "Avoid lambda",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 61,
              "startColumn": 29,
              "endLine": 61,
              "endColumn": 50,
              "from": "(\\ x -> dirname </> x)",
              "to": "(dirname </>)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 61, startCol = 29, endLine = 61, endCol = 50}, subts = [], orig = \"(dirname </>)\"}]"
            },
            {
              "module": [
                "Checks"
              ],
              "decl": [
                "checkDir"
              ],
              "severity": "Warning",
              "hint": "Use mapM",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "startLine": 62,
              "startColumn": 14,
              "endLine": 62,
              "endColumn": 55,
              "from": "sequence (map checkProgramFile jsonFiles)",
              "to": "mapM checkProgramFile jsonFiles",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 62, startCol = 14, endLine = 62, endCol = 55}, subts = [(\"f\",SrcSpan {startLine = 62, startCol = 28, endLine = 62, endCol = 44}),(\"x\",SrcSpan {startLine = 62, startCol = 45, endLine = 62, endCol = 54})], orig = \"mapM f x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/Checks.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/Checks.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/Checks.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 2.75,
            "sum": 11
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 5,
            "suggestion": 1,
            "ignore": 0,
            "total": 6
          },
          "syntax_errors": 14,
          "lines_of_code": 76,
          "homplexity_lines_of_code": 106,
          "code_quality_score": 67.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 2.75,
              "sum": 11
            },
            "homplexity_loc": 106,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 1 1: module EditProgram has 67 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 30 1: type signature for getSupportLevel has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 30 1: type signature for getSupportLevel has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has branching depth of 4 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has 17 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has cyclomatic complexity of 5 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 50 1: type signature for getHelp has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 50 1: type signature for getHelp has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 51 1: function getHelp has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 51 1: function getHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 51 1: function getHelp has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 53 1: type signature for editFile has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 53 1: type signature for editFile has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 54 1: function editFile has 9 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 54 1: function editFile has cyclomatic complexity of 2 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 54 1: function editFile has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 64 1: type signature for editProgram has 2 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 64 1: type signature for editProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 65 1: function editProgram has cyclomatic complexity of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 65 1: function editProgram has 12 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs\" 65 1: function editProgram has branching depth of 2 \n"
          },
          "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule EditProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Parser\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetSupportLevel :: SupportLevel -> IO SupportLevel\ngetSupportLevel supportLevel = do\n  changed <- promptBool (blue \"Has the support level changed? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if not changed\n  then return supportLevel\n  else do\n      movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if movable\n      then do\n        envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n        if envVars\n        then return EnvVars\n        else do\n          alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n          if alias\n          then return Alias\n          else return Supported\n      else return Unsupported\n\n\ngetHelp :: String -> IO String\ngetHelp currentHelp = getInputMarkdown currentHelp\n\neditFile :: File -> IO File\neditFile f = do\n  printf \"%s\\n\" (T.unpack (italic (cyan (T.pack (path f)))))\n  edit <- promptBool (green \"Edit this file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if not edit\n  then return f\n  else do\n    supportLevel <- getSupportLevel (supportLevel f)\n    help <- getHelp (help f)\n    return File {path = path f, supportLevel = supportLevel, help = help}\n\neditProgram :: String -> IO ()\neditProgram filename = do\n  program <- readProgram filename\n  case program of\n    Nothing -> printf \"%s %s\\n\" (T.unpack (bold (red \"Error parsing file\"))) (T.unpack (italic (red (T.pack filename))))\n    Just p -> do\n      printf \"%s %s\\n\" (T.unpack (cyan (\"Editing\"))) (T.unpack (italic (cyan (name p))))\n      files <- return (files p)\n      newFiles <- sequence (map editFile files)\n      do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n      if do_save\n      then save (T.pack filename) Program {name = (name p), files = newFiles}\n      else return ()\n",
          "suggestions": [
            {
              "module": [
                "EditProgram"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 35,
              "from": "{-# LANGUAGE DeriveGeneric #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 35}, newComment = \"\"}]"
            },
            {
              "module": [
                "EditProgram"
              ],
              "decl": [
                "getHelp"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 51,
              "startColumn": 1,
              "endLine": 51,
              "endColumn": 51,
              "from": "getHelp currentHelp = getInputMarkdown currentHelp",
              "to": "getHelp = getInputMarkdown",
              "note": [],
              "refactorings": "[Replace {rtype = Decl, pos = SrcSpan {startLine = 51, startCol = 1, endLine = 51, endCol = 51}, subts = [(\"body\",SrcSpan {startLine = 51, startCol = 23, endLine = 51, endCol = 39})], orig = \"getHelp = body\"}]"
            },
            {
              "module": [
                "EditProgram"
              ],
              "decl": [
                "editProgram"
              ],
              "severity": "Warning",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 70,
              "startColumn": 40,
              "endLine": 70,
              "endColumn": 51,
              "from": "(\"Editing\")",
              "to": "\"Editing\"",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 70, startCol = 40, endLine = 70, endCol = 51}, subts = [(\"x\",SrcSpan {startLine = 70, startCol = 41, endLine = 70, endCol = 50})], orig = \"x\"}]"
            },
            {
              "module": [
                "EditProgram"
              ],
              "decl": [
                "editProgram"
              ],
              "severity": "Warning",
              "hint": "Use mapM",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 72,
              "startColumn": 19,
              "endLine": 72,
              "endColumn": 48,
              "from": "sequence (map editFile files)",
              "to": "mapM editFile files",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 72, startCol = 19, endLine = 72, endCol = 48}, subts = [(\"f\",SrcSpan {startLine = 72, startCol = 33, endLine = 72, endCol = 41}),(\"x\",SrcSpan {startLine = 72, startCol = 42, endLine = 72, endCol = 47})], orig = \"mapM f x\"}]"
            },
            {
              "module": [
                "EditProgram"
              ],
              "decl": [
                "editProgram"
              ],
              "severity": "Warning",
              "hint": "Use when",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 74,
              "startColumn": 7,
              "endLine": 76,
              "endColumn": 21,
              "from": "if do_save then\n    save (T.pack filename) Program {name = (name p), files = newFiles}\nelse\n    return ()",
              "to": "Control.Monad.when do_save\n  $ save\n      (T.pack filename) Program {name = (name p), files = newFiles}",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 74, startCol = 7, endLine = 76, endCol = 21}, subts = [(\"x\",SrcSpan {startLine = 74, startCol = 10, endLine = 74, endCol = 17}),(\"y\",SrcSpan {startLine = 75, startCol = 12, endLine = 75, endCol = 78})], orig = \"Control.Monad.when x $ y\"}]"
            },
            {
              "module": [
                "EditProgram"
              ],
              "decl": [
                "editProgram"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "startLine": 75,
              "startColumn": 51,
              "endLine": 75,
              "endColumn": 59,
              "from": "Program {name = (name p), files = newFiles}",
              "to": "Program {name = name p, files = newFiles}",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 75, startCol = 51, endLine = 75, endCol = 59}, subts = [(\"x\",SrcSpan {startLine = 75, startCol = 52, endLine = 75, endCol = 58})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/lib/EditProgram.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/lib/EditProgram.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/src/add-program.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 3,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 8,
          "code_quality_score": 97.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 8,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 1 1: module Main has 7 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 10 1: function main has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/add-program.hs\" 10 1: function main has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           AddProgram\nimport           Data.Text\nimport           Data.Text.ANSI\n\nmain :: IO ()\nmain = saveProgram\n",
          "suggestions": [
            {
              "module": [
                "Main"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_87/pre_refactor/haskell/src/add-program.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 35,
              "from": "{-# LANGUAGE OverloadedStrings #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 35}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/src/add-program.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/src/add-program.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs"
          }
        },
        {
          "file_name": "/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 1.6666666666666667,
            "sum": 10
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 50,
          "homplexity_lines_of_code": 62,
          "code_quality_score": 73.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 1.6666666666666667,
              "sum": 10
            },
            "homplexity_loc": 62,
            "homplexity_output": "Info:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 1 1: module Main has 41 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 11 13: data Args has record fields count of 3 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 20 1: function editProgram has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 20 1: function editProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 20 1: function editProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 23 1: function previewProgram has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 23 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 23 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 26 1: function lintProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 26 1: function lintProgram has 1 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 26 1: function lintProgram has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 29 1: function argsParser has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 29 1: function argsParser has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 29 1: function argsParser has 7 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 37 1: type signature for args has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 37 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 38 1: function args has 3 lines of code \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 38 1: function args has branching depth of 0 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 38 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 42 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 42 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 43 1: function main has cyclomatic complexity of 5 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 43 1: function main has branching depth of 1 \nInfo:/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs\" 43 1: function main has 8 lines of code \n"
          },
          "original_code": "module Main where\n\n\nimport qualified AddProgram          as PA\nimport qualified Checks              as C\nimport           Data.Semigroup      ((<>))\nimport qualified EditProgram         as PE\nimport           Options.Applicative\nimport qualified PreviewProgram      as PP\n\ndata Args = RunChecks\n    | AddProgram\n    | EditProgram String\n    | PreviewProgram String\n    | LintProgram String\n    | Lint\n    deriving Show\n\neditProgram :: Parser Args\neditProgram = EditProgram <$> argument str (metavar \"PROGRAM\")\n\npreviewProgram :: Parser Args\npreviewProgram = PreviewProgram <$> argument str (metavar \"PROGRAM\")\n\nlintProgram :: Parser Args\nlintProgram = LintProgram <$> argument str (metavar \"PROGRAM\")\n\nargsParser :: Parser Args\nargsParser = subparser\n        (command \"run\" (info (pure RunChecks) (progDesc \"Run checks\"))\n      <> command \"add\" (info (pure AddProgram) (progDesc \"Add program\"))\n      <> command \"edit\" (info editProgram (progDesc \"Edit program config\"))\n      <> command \"prev\" (info previewProgram (progDesc \"Preview program config\"))\n      <> command \"lintp\" (info lintProgram (progDesc \"Lint program config\"))\n      <> command \"lint\" (info (pure Lint) (progDesc \"Lint all program configs\")))\n\nargs :: ParserInfo Args\nargs = info (argsParser <**> helper)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")\n\nmain :: IO ()\nmain = do\n    args <- execParser args\n    case args of\n        RunChecks               -> C.checkDir \"./programs\"\n        AddProgram              -> PA.saveProgram\n        EditProgram filename    -> PE.editProgram filename\n        PreviewProgram filename -> PP.previewProgramFile filename\n        _                       -> print args\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_87/static_refactored/haskell/src/xdgnj.hs",
            "llm_only_refactored_file": "/tmp/project_87/llm_only_refactored/haskell/src/xdgnj.hs",
            "hybrid_refactored_file": "/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 10,
              "max": 35,
              "average": 8.444444444444445,
              "sum": 76
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 1,
              "suggestion": 6,
              "ignore": 0,
              "total": 7
            },
            "syntax_errors": 65,
            "lines_of_code": 474,
            "homplexity_lines_of_code": 614,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Program.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/Program.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 64,
              "homplexity_lines_of_code": 57,
              "code_quality_score": 88.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 57,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 1 1: module Program has 50 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 19 16: data Program has record fields count of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 30 13: data File has record fields count of 3 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 41 21: data SupportLevel has record fields count of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 53 1: type signature for makeFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 53 1: type signature for makeFilename has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 54 1: function makeFilename has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 54 1: function makeFilename has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 54 1: function makeFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 56 1: type signature for save has 3 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 56 1: type signature for save has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 57 1: function save has 3 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 57 1: function save has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 57 1: function save has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 61 1: type signature for readProgram has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 61 1: type signature for readProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 62 1: function readProgram has 3 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 62 1: function readProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Program.hs\" 62 1: function readProgram has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Program where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport qualified Data.ByteString.Lazy     as B\nimport qualified Data.Text                as T\nimport           GHC.Generics\nimport           System.Directory\n\ninstance FromJSON File where\n  parseJSON (Object v) = File\n    <$> v .: \"path\"\n    <*> v .: \"movable\"\n    <*> v .: \"help\"\n\ndata Program = Program\n  { name  :: T.Text,\n    files :: [File]\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON Program where\n  toJSON (Program name files) = object [ \"name\" .= name, \"files\" .= files ]\n  toEncoding (Program name files) = pairs (\"name\" .= name <> \"files\" .= files)\ninstance FromJSON Program\n\ndata File = File\n  { path         :: String,\n    supportLevel :: SupportLevel,\n    help         :: String\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON File where\n  toJSON (File path supportLevel help) = object [ \"path\" .= path, \"movable\" .= supportLevel, \"help\" .= help ]\n  toEncoding (File path supportLevel help) = pairs (\"path\" .= path <> \"movable\" .= supportLevel <> \"help\" .= help)\n\ndata SupportLevel = Unsupported | Alias | EnvVars | Supported\n  deriving (Generic, Show)\n\ninstance ToJSON SupportLevel where\n  toJSON Unsupported = toJSON (Bool False)\n  toJSON _           = toJSON (Bool True)\n  toEncoding Unsupported = toEncoding ( Bool False )\n  toEncoding _           = toEncoding ( Bool True )\ninstance FromJSON SupportLevel where\n  parseJSON (Bool False) = return Unsupported\n  parseJSON (Bool True)  = return EnvVars\n\nmakeFilename :: T.Text -> T.Text\nmakeFilename s = T.pack ( \"./programs/\" ++ T.unpack s ++ \".json\" )\n\nsave :: T.Text -> Program -> IO ()\nsave filename program = do\n  createDirectoryIfMissing False \"./programs/\"\n  B.writeFile (T.unpack filename) (encodePretty program)\n\nreadProgram :: String -> IO ( Maybe Program )\nreadProgram filename = do\n    json_data <- B.readFile filename\n    return (decode json_data)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Program.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Program where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport qualified Data.ByteString.Lazy     as B\nimport qualified Data.Text                as T\nimport           GHC.Generics\nimport           System.Directory\n\ninstance FromJSON File where\n  parseJSON (Object v) = File\n    <$> v .: \"path\"\n    <*> v .: \"movable\"\n    <*> v .: \"help\"\n\ndata Program = Program\n  { name  :: T.Text,\n    files :: [File]\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON Program where\n  toJSON (Program name files) = object [ \"name\" .= name, \"files\" .= files ]\n  toEncoding (Program name files) = pairs (\"name\" .= name <> \"files\" .= files)\ninstance FromJSON Program\n\ndata File = File\n  { path         :: String,\n    supportLevel :: SupportLevel,\n    help         :: String\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON File where\n  toJSON (File path supportLevel help) = object [ \"path\" .= path, \"movable\" .= supportLevel, \"help\" .= help ]\n  toEncoding (File path supportLevel help) = pairs (\"path\" .= path <> \"movable\" .= supportLevel <> \"help\" .= help)\n\ndata SupportLevel = Unsupported | Alias | EnvVars | Supported\n  deriving (Generic, Show)\n\ninstance ToJSON SupportLevel where\n  toJSON Unsupported = toJSON (Bool False)\n  toJSON _           = toJSON (Bool True)\n  toEncoding Unsupported = toEncoding ( Bool False )\n  toEncoding _           = toEncoding ( Bool True )\ninstance FromJSON SupportLevel where\n  parseJSON (Bool False) = return Unsupported\n  parseJSON (Bool True)  = return EnvVars\n\nmakeFilename :: T.Text -> T.Text\nmakeFilename s = T.pack ( \"./programs/\" ++ T.unpack s ++ \".json\" )\n\nsave :: T.Text -> Program -> IO ()\nsave filename program = do\n  createDirectoryIfMissing False \"./programs/\"\n  B.writeFile (T.unpack filename) (encodePretty program)\n\nreadProgram :: String -> IO ( Maybe Program )\nreadProgram filename = do\n    json_data <- B.readFile filename\n    return (decode json_data)\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.7142857142857142,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 13,
              "lines_of_code": 90,
              "homplexity_lines_of_code": 127,
              "code_quality_score": 63.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.7142857142857142,
                  "sum": 12
                },
                "homplexity_loc": 127,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 2 1: module AddProgram has 78 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 29 1: type signature for getTemplate has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 29 1: type signature for getTemplate has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has 4 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 30 1: function getTemplate has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 35 1: type signature for getHelp has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 35 1: type signature for getHelp has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 36 1: function getHelp has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 36 1: function getHelp has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 36 1: function getHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 38 1: type signature for getSupportLevel has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 38 1: type signature for getSupportLevel has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has branching depth of 3 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has 13 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 39 1: function getSupportLevel has cyclomatic complexity of 4 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 53 1: type signature for getFile has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 53 1: type signature for getFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 54 1: function getFile has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 54 1: function getFile has 5 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 54 1: function getFile has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 60 1: type signature for getFiles has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 60 1: type signature for getFiles has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 61 1: function getFiles has cyclomatic complexity of 3 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 61 1: function getFiles has 12 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 61 1: function getFiles has branching depth of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 74 1: type signature for getProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 74 1: type signature for getProgram has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 75 1: function getProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 75 1: function getProgram has 10 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 75 1: function getProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 86 1: type signature for saveProgram has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 86 1: type signature for saveProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has 4 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/AddProgram.hs\" 87 1: function saveProgram has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule AddProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetTemplate :: SupportLevel -> String\ngetTemplate Unsupported = \"Currently unsupported.\\n\\n_Relevant issue:_ https://github.com/user/repo/issues/nr\\n\"\ngetTemplate EnvVars = \"Export the following environment variables:\\n\\n```bash\\n\\n```\"\ngetTemplate Alias = \"Alias PROGRAM to use a custom configuration location:\\n\\n```bash\\nalias PROGRAM=PROGRAM --config \\\"$XDG_CONFIG_HOME\\\"/PROGRAM/config\\n```\\n\"\ngetTemplate Supported = \"Supported since _VERSION_.\\n\\nYou can move the file to _XDG_CONFIG_HOME/PROGRAM/CONFIG.\\n\"\n\ngetHelp :: SupportLevel -> IO String\ngetHelp supportLevel = getInputMarkdown (getTemplate supportLevel)\n\ngetSupportLevel :: IO SupportLevel\ngetSupportLevel = do\n  movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if movable\n  then do\n    envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n    if envVars\n    then return EnvVars\n    else do\n      alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if alias\n      then return Alias\n      else return Supported\n  else return Unsupported\n\ngetFile :: IO File\ngetFile = do\n  path <- getProp (blue \"Path to file: \") \"$HOME/.\"\n  supportLevel <- getSupportLevel\n  help <- getHelp supportLevel\n  return File {path = path, supportLevel = supportLevel, help = help}\n\ngetFiles :: [File] -> IO [File]\ngetFiles files =\n  if Data.List.Extra.null files\n  then do\n    newFile <- getFile\n    getFiles (newFile : files)\n  else do\n    new <- promptBool (green \"Add another file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n    if new\n    then do\n      newFile <- getFile\n      getFiles (newFile : files)\n    else return files\n\ngetProgram :: IO Program\ngetProgram = do\n  name <- printf \"%s\\n\" (T.unpack (bold (cyan \"XDG-ninja Configuration Wizard\")))\n          >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"First, tell me what program you're creating a configuration for.\"))))\n          >> getProp (yellow \"Program name: \") \"\"\n  files <- printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Alright, now let's configure which files belong to this program.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'm going to ask you for the path to the file, please use $HOME instead of ~.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'll then ask you whether or not this file can be moved to a different directory.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Finally, your editor is going to open a markdown document. Enter instructions on moving the file in question, then save and close.\"))))\n           >> getFiles []\n  return Program {name = T.pack name, files = files}\n\nsaveProgram :: IO ()\nsaveProgram = do\n  program <- getProgram\n  do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if do_save\n  then save (makeFilename (name program)) program\n  else return ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/AddProgram.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule AddProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetTemplate :: SupportLevel -> String\ngetTemplate Unsupported = \"Currently unsupported.\\n\\n_Relevant issue:_ https://github.com/user/repo/issues/nr\\n\"\ngetTemplate EnvVars = \"Export the following environment variables:\\n\\n```bash\\n\\n```\"\ngetTemplate Alias = \"Alias PROGRAM to use a custom configuration location:\\n\\n```bash\\nalias PROGRAM=PROGRAM --config \\\"$XDG_CONFIG_HOME\\\"/PROGRAM/config\\n```\\n\"\ngetTemplate Supported = \"Supported since _VERSION_.\\n\\nYou can move the file to _XDG_CONFIG_HOME/PROGRAM/CONFIG.\\n\"\n\ngetHelp :: SupportLevel -> IO String\ngetHelp supportLevel = getInputMarkdown (getTemplate supportLevel)\n\ngetSupportLevel :: IO SupportLevel\ngetSupportLevel = do\n  movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if movable\n  then do\n    envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n    if envVars\n    then return EnvVars\n    else do\n      alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if alias\n      then return Alias\n      else return Supported\n  else return Unsupported\n\ngetFile :: IO File\ngetFile = do\n  path <- getProp (blue \"Path to file: \") \"$HOME/.\"\n  supportLevel <- getSupportLevel\n  help <- getHelp supportLevel\n  return File {path = path, supportLevel = supportLevel, help = help}\n\ngetFiles :: [File] -> IO [File]\ngetFiles files =\n  if Data.List.Extra.null files\n  then do\n    newFile <- getFile\n    getFiles (newFile : files)\n  else do\n    new <- promptBool (green \"Add another file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n    if new\n    then do\n      newFile <- getFile\n      getFiles (newFile : files)\n    else return files\n\ngetProgram :: IO Program\ngetProgram = do\n  name <- printf \"%s\\n\" (T.unpack (bold (cyan \"XDG-ninja Configuration Wizard\")))\n          >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"First, tell me what program you're creating a configuration for.\"))))\n          >> getProp (yellow \"Program name: \") \"\"\n  files <- printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Alright, now let's configure which files belong to this program.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'm going to ask you for the path to the file, please use $HOME instead of ~.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"I'll then ask you whether or not this file can be moved to a different directory.\"))))\n           >> printf \"%s\\n\" (T.unpack (faint (italic (cyan \"Finally, your editor is going to open a markdown document. Enter instructions on moving the file in question, then save and close.\"))))\n           >> getFiles []\n  return Program {name = T.pack name, files = files}\n\nsaveProgram :: IO ()\nsaveProgram = do\n  program <- getProgram\n  do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  Control.Monad.when do_save $ save (makeFilename (name program)) program\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.3333333333333333,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 4,
              "lines_of_code": 22,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 89.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.3333333333333333,
                  "sum": 4
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 1 1: module PreviewProgram has 18 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has 3 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has 3 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 16 1: type signature for previewProgramFile has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 16 1: type signature for previewProgramFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has 6 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/PreviewProgram.hs\" 17 1: function previewProgramFile has cyclomatic complexity of 2 \n"
              },
              "original_code": "module PreviewProgram where\n\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Output\nimport           Program\n\npreviewFile :: T.Text -> File -> IO ()\npreviewFile name file = logFile name file True\n\npreviewProgram :: Program -> IO ()\npreviewProgram program = do\n  _ <- sequence (map (previewFile (name program)) (files program))\n  return ()\n\npreviewProgramFile :: String -> IO ()\npreviewProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> previewProgram program\n    Nothing      -> putStrLn (T.unpack (red (T.pack \"Error.\")))\n  return ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module PreviewProgram where\n\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Output\nimport           Program\n\npreviewFile :: T.Text -> File -> IO ()\npreviewFile name file = logFile name file True\n\npreviewProgram :: Program -> IO ()\npreviewProgram program = do\n  _ <- mapM (previewFile (name program)) (files program)\n  return ()\n\npreviewProgramFile :: String -> IO ()\npreviewProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> previewProgram program\n    Nothing      -> putStrLn (T.unpack (red (T.pack \"Error.\")))\n  return ()\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/Output.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 2.6,
                "sum": 13
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 6,
              "lines_of_code": 52,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 66.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 2.6,
                  "sum": 13
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 1 1: module Output has 45 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 12 1: type signature for getFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 12 1: type signature for getFilename has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has 3 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has 9 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 28 1: type signature for line has 4 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 28 1: type signature for line has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 29 1: function line has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 29 1: function line has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 29 1: function line has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 31 13: data Mode has record fields count of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 33 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 33 1: type signature for log has 5 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 34 1: function log has cyclomatic complexity of 6 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 34 1: function log has 14 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 34 1: function log has branching depth of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 49 1: type signature for logFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 49 1: type signature for logFile has 4 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 50 1: function logFile has cyclomatic complexity of 3 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 50 1: function logFile has branching depth of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Output.hs\" 50 1: function logFile has 3 lines of code \n"
              },
              "original_code": "module Output where\n\nimport           Data.Char      (isSpace)\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Exit\nimport           System.Process\n\ngetFilename :: IO String\ngetFilename = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  return (\"/tmp/xdg-ninja.\" ++ id ++ \".txt\")\n\nrenderMarkdown :: String -> IO String\nrenderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  editor <- appendFile (filenameInput) content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"\n\nline :: (T.Text -> T.Text) -> String -> String -> String\nline color name filename = T.unpack ((T.pack \"[\") <> bold (color (T.pack name)) <> (T.pack \"]: \") <> bold (italic (T.pack filename)))\n\ndata Mode = ERR | WARN | INFO | SUCS | HELP\n\nlog :: Mode -> String -> String -> String -> IO ()\nlog mode name filename help = case mode of\n    ERR -> do\n      putStrLn (line red name filename)\n      Output.log HELP name filename help\n    WARN -> do\n      putStrLn (line yellow name filename)\n      Output.log HELP name filename help\n    INFO -> do\n      putStrLn (line cyan name filename)\n      Output.log HELP name filename help\n    SUCS -> putStrLn (line green name filename)\n    HELP -> do\n      md <- case (all isSpace help) of\n        True  -> renderMarkdown \"_No help available._\"\n        False -> renderMarkdown help\n      putStr md\n\nlogFile :: T.Text -> File -> Bool -> IO ()\nlogFile programName file onFilesystem = case onFilesystem of\n  False -> Output.log SUCS (T.unpack programName) (path file) (help file)\n  True -> case (supportLevel file) of\n    Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n    _ -> Output.log WARN (T.unpack programName) (path file) (help file)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs:(46,13)-(48,36)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case (all isSpace help) of",
                    "    True -> renderMarkdown \"_No help available._\"",
                    "    False -> renderMarkdown help"
                  ],
                  "perhaps_block": [
                    "  (if all isSpace help then",
                    "       renderMarkdown \"_No help available._\"",
                    "   else",
                    "       renderMarkdown help)"
                  ]
                },
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs:(52,41)-(56,71)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case onFilesystem of",
                    "    False",
                    "      -> Output.log SUCS (T.unpack programName) (path file) (help file)",
                    "    True",
                    "      -> case (supportLevel file) of",
                    "           Unsupported",
                    "             -> Output.log ERR (T.unpack programName) (path file) (help file)",
                    "           _ -> Output.log WARN (T.unpack programName) (path file) (help file)"
                  ],
                  "perhaps_block": [
                    "  if onFilesystem then",
                    "      (case (supportLevel file) of",
                    "         Unsupported",
                    "           -> Output.log ERR (T.unpack programName) (path file) (help file)",
                    "         _ -> Output.log",
                    "                WARN (T.unpack programName) (path file) (help file))",
                    "  else",
                    "      Output.log SUCS (T.unpack programName) (path file) (help file)"
                  ]
                }
              ],
              "refactored_code": "module Output where\n\nimport           Data.Char      (isSpace)\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Exit\nimport           System.Process\n\ngetFilename :: IO String\ngetFilename = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  return (\"/tmp/xdg-ninja.\" ++ id ++ \".txt\")\n\nrenderMarkdown :: String -> IO String\nrenderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  editor <- appendFile filenameInput content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"\n\nline :: (T.Text -> T.Text) -> String -> String -> String\nline color name filename = T.unpack (T.pack \"[\" <> bold (color (T.pack name)) <> T.pack \"]: \" <> bold (italic (T.pack filename)))\n\ndata Mode = ERR | WARN | INFO | SUCS | HELP\n\nlog :: Mode -> String -> String -> String -> IO ()\nlog mode name filename help = case mode of\n    ERR -> do\n      putStrLn (line red name filename)\n      Output.log HELP name filename help\n    WARN -> do\n      putStrLn (line yellow name filename)\n      Output.log HELP name filename help\n    INFO -> do\n      putStrLn (line cyan name filename)\n      Output.log HELP name filename help\n    SUCS -> putStrLn (line green name filename)\n    HELP -> do\n      md <- (if all isSpace help then renderMarkdown \"_No help available._\" else renderMarkdown help)\n      putStr md\n\nlogFile :: T.Text -> File -> Bool -> IO ()\nlogFile programName file onFilesystem = if onFilesystem then (case (supportLevel file) of\n  Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n  _ -> Output.log WARN (T.unpack programName) (path file) (help file)) else Output.log SUCS (T.unpack programName) (path file) (help file)\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/Prompts.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 7,
                "average": 3.5,
                "sum": 14
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 52,
              "homplexity_lines_of_code": 74,
              "code_quality_score": 64.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 7,
                  "average": 3.5,
                  "sum": 14
                },
                "homplexity_loc": 74,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 1 1: module Prompts has 45 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 14 1: type signature for getInputMarkdown has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 14 1: type signature for getInputMarkdown has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has 8 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 15 1: function getInputMarkdown has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 24 1: type signature for getProp has 3 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 24 1: type signature for getProp has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 25 1: function getProp has 7 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 25 1: function getProp has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 25 1: function getProp has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 33 15: data Answer has record fields count of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 35 1: type signature for stringToBool has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 35 1: type signature for stringToBool has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 36 1: function stringToBool has 8 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 36 1: function stringToBool has cyclomatic complexity of 7 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 36 1: function stringToBool has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 45 1: type signature for promptBool has 4 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 45 1: type signature for promptBool has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 46 1: function promptBool has cyclomatic complexity of 3 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 46 1: function promptBool has 6 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Prompts.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Prompts.hs\" 46 1: function promptBool has branching depth of 1 \n"
              },
              "original_code": "module Prompts where\n\nimport           Data.List.Extra\nimport qualified Data.Text                as T\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetInputMarkdown :: String -> IO String\ngetInputMarkdown placeholder = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  editor <- appendFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\") placeholder >> (getEnv \"EDITOR\")\n  (_, _, _, p) <- createProcess (shell (editor ++ \" /tmp/xdg-ninja.\" ++ id ++ \".md\"))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\")\n    ExitFailure a -> return \"\"\n\ngetProp :: T.Text -> T.Text -> IO String\ngetProp prompt placeholder = do\n  let string_prompt = T.unpack prompt\n  let string_placeholder = T.unpack placeholder\n  x <- runInputT defaultSettings (getInputLineWithInitial string_prompt (string_placeholder, \"\"))\n  case x of\n    Just s  -> return s\n    Nothing -> return \"\"\n\ndata Answer = Yes | No | Unknown\n\nstringToBool :: String -> Answer\nstringToBool s = case lower s of\n  \"yes\" -> Yes\n  \"y\"   -> Yes\n  \"1\"   -> Yes\n  \"no\"  -> No\n  \"n\"   -> No\n  \"0\"   -> No\n  _     -> Unknown\n\npromptBool :: T.Text -> T.Text -> T.Text -> IO Bool\npromptBool prompt prompt_unrecognised placeholder = do\n  x <- getProp prompt placeholder\n  case stringToBool x of\n    Yes -> return True\n    No -> return False\n    Unknown -> printf \"%s\\n\" prompt_unrecognised >> promptBool prompt prompt_unrecognised placeholder\n\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Prompts.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Prompts where\n\nimport           Data.List.Extra\nimport qualified Data.Text                as T\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetInputMarkdown :: String -> IO String\ngetInputMarkdown placeholder = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  editor <- appendFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\") placeholder >> getEnv \"EDITOR\"\n  (_, _, _, p) <- createProcess (shell (editor ++ \" /tmp/xdg-ninja.\" ++ id ++ \".md\"))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile (\"/tmp/xdg-ninja.\" ++ id ++ \".md\")\n    ExitFailure a -> return \"\"\n\ngetProp :: T.Text -> T.Text -> IO String\ngetProp prompt placeholder = do\n  let string_prompt = T.unpack prompt\n  let string_placeholder = T.unpack placeholder\n  x <- runInputT defaultSettings (getInputLineWithInitial string_prompt (string_placeholder, \"\"))\n  case x of\n    Just s  -> return s\n    Nothing -> return \"\"\n\ndata Answer = Yes | No | Unknown\n\nstringToBool :: String -> Answer\nstringToBool s = case lower s of\n  \"yes\" -> Yes\n  \"y\"   -> Yes\n  \"1\"   -> Yes\n  \"no\"  -> No\n  \"n\"   -> No\n  \"0\"   -> No\n  _     -> Unknown\n\npromptBool :: T.Text -> T.Text -> T.Text -> IO Bool\npromptBool prompt prompt_unrecognised placeholder = do\n  x <- getProp prompt placeholder\n  case stringToBool x of\n    Yes -> return True\n    No -> return False\n    Unknown -> printf \"%s\\n\" prompt_unrecognised >> promptBool prompt prompt_unrecognised placeholder\n\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/Checks.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.8,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 4,
                "ignore": 0,
                "total": 4
              },
              "syntax_errors": 8,
              "lines_of_code": 60,
              "homplexity_lines_of_code": 83,
              "code_quality_score": 73.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.8,
                  "sum": 9
                },
                "homplexity_loc": 83,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 1 1: module Checks has 51 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 16 15: data Result has record fields count of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 19 1: type signature for expandPath has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 19 1: type signature for expandPath has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 20 1: function expandPath has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 20 1: function expandPath has 5 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 20 1: function expandPath has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 27 1: type signature for checkFile has 4 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 27 1: type signature for checkFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 28 1: function checkFile has 13 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 28 1: function checkFile has branching depth of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 28 1: function checkFile has cyclomatic complexity of 4 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 42 1: type signature for checkProgram has 3 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 42 1: type signature for checkProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 43 1: function checkProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 43 1: function checkProgram has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 43 1: function checkProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 45 1: type signature for checkProgramFile has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 45 1: type signature for checkProgramFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 46 1: function checkProgramFile has 8 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 46 1: function checkProgramFile has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 46 1: function checkProgramFile has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 55 1: type signature for checkDir has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 55 1: type signature for checkDir has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 56 1: function checkDir has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 56 1: function checkDir has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/Checks.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/Checks.hs\" 56 1: function checkDir has 5 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Checks where\n\nimport           Data.List              (isSuffixOf)\nimport qualified Data.Text              as T\nimport           Data.Text.ANSI\nimport qualified Data.Text.Lazy         as TL\nimport           Output\nimport           Program\nimport           System.Directory.Extra\nimport           System.Environment     (getEnv)\nimport           System.FilePath\nimport           Text.Replace\n\ndata Result = Exist | MustExist | NoExist\n  deriving Show\n\nexpandPath :: String -> IO String\nexpandPath path = do\n  home <- getEnv \"HOME\"\n  let replacements = [ Replace \"$HOME\" (T.pack home) ]\n  let result = replaceWithList replacements (TL.pack path)\n  return (TL.unpack result)\n\n\ncheckFile :: T.Text -> Bool -> File -> IO Result\ncheckFile programName verbose file  = do\n  path <- expandPath (path file)\n  existsFile <- doesFileExist path\n  existsDir <- doesDirectoryExist path\n  case (existsFile || existsDir) of\n    False -> case verbose of\n      False -> return NoExist\n      True -> do\n        logFile programName file False\n        return NoExist\n    True -> do\n      logFile programName file True\n      case (supportLevel file) of\n        Unsupported -> return MustExist\n        _           -> return Exist\n\ncheckProgram :: Bool -> Program -> IO [Result]\ncheckProgram verbose program = sequence (map (checkFile (name program) verbose) (files program))\n\ncheckProgramFile :: String -> IO [Result]\ncheckProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> do\n      results <- checkProgram False program\n      return results\n    Nothing -> do\n      putStrLn (T.unpack (red (T.pack \"Error.\")))\n      return []\n\ncheckDir :: FilePath -> IO ()\ncheckDir dirname = do\n  files <- getDirectoryContents dirname\n  jsonFiles <- return ( map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files ))\n  results <- sequence (map checkProgramFile jsonFiles)\n  return ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:(32,3)-(42,35)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case (existsFile || existsDir) of",
                    "    False",
                    "      -> case verbose of",
                    "           False -> return NoExist",
                    "           True",
                    "             -> do logFile programName file False",
                    "                   return NoExist",
                    "    True",
                    "      -> do logFile programName file True",
                    "            case (supportLevel file) of",
                    "              Unsupported -> return MustExist",
                    "              _ -> return Exist"
                  ],
                  "perhaps_block": [
                    "  (if existsFile || existsDir then",
                    "       (do logFile programName file True",
                    "           case (supportLevel file) of",
                    "             Unsupported -> return MustExist",
                    "             _ -> return Exist)",
                    "   else",
                    "       (case verbose of",
                    "          False -> return NoExist",
                    "          True",
                    "            -> do logFile programName file False",
                    "                  return NoExist))"
                  ]
                },
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs:(33,14)-(37,22)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case verbose of",
                    "    False -> return NoExist",
                    "    True",
                    "      -> do logFile programName file False",
                    "            return NoExist"
                  ],
                  "perhaps_block": [
                    "  (if verbose then",
                    "       (do logFile programName file False",
                    "           return NoExist)",
                    "   else",
                    "       return NoExist)"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Checks where\n\nimport           Data.List              (isSuffixOf)\nimport qualified Data.Text              as T\nimport           Data.Text.ANSI\nimport qualified Data.Text.Lazy         as TL\nimport           Output\nimport           Program\nimport           System.Directory.Extra\nimport           System.Environment     (getEnv)\nimport           System.FilePath\nimport           Text.Replace\n\ndata Result = Exist | MustExist | NoExist\n  deriving Show\n\nexpandPath :: String -> IO String\nexpandPath path = do\n  home <- getEnv \"HOME\"\n  let replacements = [ Replace \"$HOME\" (T.pack home) ]\n  let result = replaceWithList replacements (TL.pack path)\n  return (TL.unpack result)\n\n\ncheckFile :: T.Text -> Bool -> File -> IO Result\ncheckFile programName verbose file  = do\n  path <- expandPath (path file)\n  existsFile <- doesFileExist path\n  existsDir <- doesDirectoryExist path\n  (if existsFile || existsDir then (do\n    logFile programName file True\n    case (supportLevel file) of\n      Unsupported -> return MustExist\n      _           -> return Exist) else (case verbose of\n    False -> return NoExist\n    True -> do\n      logFile programName file False\n      return NoExist))\n\ncheckProgram :: Bool -> Program -> IO [Result]\ncheckProgram verbose program = mapM (checkFile (name program) verbose) (files program)\n\ncheckProgramFile :: String -> IO [Result]\ncheckProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> do\n      checkProgram False program\n    Nothing -> do\n      putStrLn (T.unpack (red (T.pack \"Error.\")))\n      return []\n\ncheckDir :: FilePath -> IO ()\ncheckDir dirname = do\n  files <- getDirectoryContents dirname\n  let jsonFiles = ( map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files ))\n  results <- mapM checkProgramFile jsonFiles\n  return ()\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 2.5,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 14,
              "lines_of_code": 74,
              "homplexity_lines_of_code": 101,
              "code_quality_score": 69.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 2.5,
                  "sum": 10
                },
                "homplexity_loc": 101,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 2 1: module EditProgram has 64 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 30 1: type signature for getSupportLevel has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 30 1: type signature for getSupportLevel has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has branching depth of 4 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has 17 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 31 1: function getSupportLevel has cyclomatic complexity of 5 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 50 1: type signature for getHelp has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 50 1: type signature for getHelp has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 51 1: function getHelp has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 51 1: function getHelp has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 51 1: function getHelp has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 53 1: type signature for editFile has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 53 1: type signature for editFile has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 54 1: function editFile has 9 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 54 1: function editFile has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 54 1: function editFile has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 64 1: type signature for editProgram has 2 arguments \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 64 1: type signature for editProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 65 1: function editProgram has cyclomatic complexity of 2 \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 65 1: function editProgram has 10 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/lib/EditProgram.hs\" 65 1: function editProgram has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule EditProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Parser\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetSupportLevel :: SupportLevel -> IO SupportLevel\ngetSupportLevel supportLevel = do\n  changed <- promptBool (blue \"Has the support level changed? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if not changed\n  then return supportLevel\n  else do\n      movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if movable\n      then do\n        envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n        if envVars\n        then return EnvVars\n        else do\n          alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n          if alias\n          then return Alias\n          else return Supported\n      else return Unsupported\n\n\ngetHelp :: String -> IO String\ngetHelp currentHelp = getInputMarkdown currentHelp\n\neditFile :: File -> IO File\neditFile f = do\n  printf \"%s\\n\" (T.unpack (italic (cyan (T.pack (path f)))))\n  edit <- promptBool (green \"Edit this file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if not edit\n  then return f\n  else do\n    supportLevel <- getSupportLevel (supportLevel f)\n    help <- getHelp (help f)\n    return File {path = path f, supportLevel = supportLevel, help = help}\n\neditProgram :: String -> IO ()\neditProgram filename = do\n  program <- readProgram filename\n  case program of\n    Nothing -> printf \"%s %s\\n\" (T.unpack (bold (red \"Error parsing file\"))) (T.unpack (italic (red (T.pack filename))))\n    Just p -> do\n      printf \"%s %s\\n\" (T.unpack (cyan (\"Editing\"))) (T.unpack (italic (cyan (name p))))\n      files <- return (files p)\n      newFiles <- sequence (map editFile files)\n      do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n      if do_save\n      then save (T.pack filename) Program {name = (name p), files = newFiles}\n      else return ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule EditProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Parser\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetSupportLevel :: SupportLevel -> IO SupportLevel\ngetSupportLevel supportLevel = do\n  changed <- promptBool (blue \"Has the support level changed? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if not changed\n  then return supportLevel\n  else do\n      movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if movable\n      then do\n        envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n        if envVars\n        then return EnvVars\n        else do\n          alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n          if alias\n          then return Alias\n          else return Supported\n      else return Unsupported\n\n\ngetHelp :: String -> IO String\ngetHelp = getInputMarkdown\n\neditFile :: File -> IO File\neditFile f = do\n  printf \"%s\\n\" (T.unpack (italic (cyan (T.pack (path f)))))\n  edit <- promptBool (green \"Edit this file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if not edit\n  then return f\n  else do\n    supportLevel <- getSupportLevel (supportLevel f)\n    help <- getHelp (help f)\n    return File {path = path f, supportLevel = supportLevel, help = help}\n\neditProgram :: String -> IO ()\neditProgram filename = do\n  program <- readProgram filename\n  case program of\n    Nothing -> printf \"%s %s\\n\" (T.unpack (bold (red \"Error parsing file\"))) (T.unpack (italic (red (T.pack filename))))\n    Just p -> do\n      printf \"%s %s\\n\" (T.unpack (cyan \"Editing\")) (T.unpack (italic (cyan (name p))))\n      files <- return (files p)\n      newFiles <- mapM editFile files\n      do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n      Control.Monad.when do_save $ save (T.pack filename) Program {name = (name p), files = newFiles}\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/src/add-program.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/src/add-program.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 7,
              "code_quality_score": 97.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 7,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 3 1: module Main has 6 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 10 1: function main has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/add-program.hs\" 10 1: function main has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           AddProgram\nimport           Data.Text\nimport           Data.Text.ANSI\n\nmain :: IO ()\nmain = saveProgram\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/src/add-program.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n\nmodule Main where\n\nimport           AddProgram\nimport           Data.Text\nimport           Data.Text.ANSI\n\nmain :: IO ()\nmain = saveProgram\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs",
              "refactored_file_name": "/tmp/project_87/static_refactored/haskell/src/xdgnj.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.6666666666666667,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 62,
              "code_quality_score": 73.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.6666666666666667,
                  "sum": 10
                },
                "homplexity_loc": 62,
                "homplexity_output": "Info:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 1 1: module Main has 41 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 11 13: data Args has record fields count of 3 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has 1 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has 7 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 37 1: type signature for args has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 37 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 38 1: function args has 3 lines of code \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 38 1: function args has branching depth of 0 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 38 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 42 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 42 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 43 1: function main has cyclomatic complexity of 5 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 43 1: function main has branching depth of 1 \nInfo:/tmp/project_87/static_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/static_refactored/haskell/src/xdgnj.hs\" 43 1: function main has 8 lines of code \n"
              },
              "original_code": "module Main where\n\n\nimport qualified AddProgram          as PA\nimport qualified Checks              as C\nimport           Data.Semigroup      ((<>))\nimport qualified EditProgram         as PE\nimport           Options.Applicative\nimport qualified PreviewProgram      as PP\n\ndata Args = RunChecks\n    | AddProgram\n    | EditProgram String\n    | PreviewProgram String\n    | LintProgram String\n    | Lint\n    deriving Show\n\neditProgram :: Parser Args\neditProgram = EditProgram <$> argument str (metavar \"PROGRAM\")\n\npreviewProgram :: Parser Args\npreviewProgram = PreviewProgram <$> argument str (metavar \"PROGRAM\")\n\nlintProgram :: Parser Args\nlintProgram = LintProgram <$> argument str (metavar \"PROGRAM\")\n\nargsParser :: Parser Args\nargsParser = subparser\n        (command \"run\" (info (pure RunChecks) (progDesc \"Run checks\"))\n      <> command \"add\" (info (pure AddProgram) (progDesc \"Add program\"))\n      <> command \"edit\" (info editProgram (progDesc \"Edit program config\"))\n      <> command \"prev\" (info previewProgram (progDesc \"Preview program config\"))\n      <> command \"lintp\" (info lintProgram (progDesc \"Lint program config\"))\n      <> command \"lint\" (info (pure Lint) (progDesc \"Lint all program configs\")))\n\nargs :: ParserInfo Args\nargs = info (argsParser <**> helper)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")\n\nmain :: IO ()\nmain = do\n    args <- execParser args\n    case args of\n        RunChecks               -> C.checkDir \"./programs\"\n        AddProgram              -> PA.saveProgram\n        EditProgram filename    -> PE.editProgram filename\n        PreviewProgram filename -> PP.previewProgramFile filename\n        _                       -> print args\n",
              "suggestions": [
                {
                  "location": "/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main where\n\n\nimport qualified AddProgram          as PA\nimport qualified Checks              as C\nimport           Data.Semigroup      ((<>))\nimport qualified EditProgram         as PE\nimport           Options.Applicative\nimport qualified PreviewProgram      as PP\n\ndata Args = RunChecks\n    | AddProgram\n    | EditProgram String\n    | PreviewProgram String\n    | LintProgram String\n    | Lint\n    deriving Show\n\neditProgram :: Parser Args\neditProgram = EditProgram <$> argument str (metavar \"PROGRAM\")\n\npreviewProgram :: Parser Args\npreviewProgram = PreviewProgram <$> argument str (metavar \"PROGRAM\")\n\nlintProgram :: Parser Args\nlintProgram = LintProgram <$> argument str (metavar \"PROGRAM\")\n\nargsParser :: Parser Args\nargsParser = subparser\n        (command \"run\" (info (pure RunChecks) (progDesc \"Run checks\"))\n      <> command \"add\" (info (pure AddProgram) (progDesc \"Add program\"))\n      <> command \"edit\" (info editProgram (progDesc \"Edit program config\"))\n      <> command \"prev\" (info previewProgram (progDesc \"Preview program config\"))\n      <> command \"lintp\" (info lintProgram (progDesc \"Lint program config\"))\n      <> command \"lint\" (info (pure Lint) (progDesc \"Lint all program configs\")))\n\nargs :: ParserInfo Args\nargs = info (argsParser <**> helper)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")\n\nmain :: IO ()\nmain = do\n    args <- execParser args\n    case args of\n        RunChecks               -> C.checkDir \"./programs\"\n        AddProgram              -> PA.saveProgram\n        EditProgram filename    -> PE.editProgram filename\n        PreviewProgram filename -> PP.previewProgramFile filename\n        _                       -> print args\n"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 8,
              "max": 24,
              "average": 7.142857142857143,
              "sum": 50
            },
            "hlint_suggestions": {
              "error": 2,
              "warning": 1,
              "suggestion": 3,
              "ignore": 0,
              "total": 6
            },
            "syntax_errors": 24,
            "lines_of_code": 336,
            "homplexity_lines_of_code": 363,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "48MB",
              "runtime": "1 × 10⁹ ns per invocation"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Program.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 61,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 1 1: module Program has 47 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 19 16: data Program has record fields count of 2 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 30 13: data File has record fields count of 3 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 41 21: data SupportLevel has record fields count of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 52 1: type signature for makeFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 52 1: type signature for makeFilename has 2 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 53 1: function makeFilename has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 53 1: function makeFilename has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 53 1: function makeFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 55 1: type signature for save has 3 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 55 1: type signature for save has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 56 1: function save has 3 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 56 1: function save has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 56 1: function save has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 60 1: type signature for readProgram has 2 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 60 1: type signature for readProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 61 1: function readProgram has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 61 1: function readProgram has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Program.hs\" 61 1: function readProgram has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Program where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport qualified Data.ByteString.Lazy     as B\nimport qualified Data.Text                as T\nimport           GHC.Generics\nimport           System.Directory\n\ninstance FromJSON File where\n  parseJSON (Object v) = File\n    <$> v .: \"path\"\n    <*> v .: \"movable\"\n    <*> v .: \"help\"\n\ndata Program = Program\n  { name  :: T.Text,\n    files :: [File]\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON Program where\n  toJSON (Program name files) = object [ \"name\" .= name, \"files\" .= files ]\n  toEncoding (Program name files) = pairs (\"name\" .= name <> \"files\" .= files)\ninstance FromJSON Program\n\ndata File = File\n  { path         :: String,\n    supportLevel :: SupportLevel,\n    help         :: String\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON File where\n  toJSON (File path supportLevel help) = object [ \"path\" .= path, \"movable\" .= supportLevel, \"help\" .= help ]\n  toEncoding (File path supportLevel help) = pairs (\"path\" .= path <> \"movable\" .= supportLevel <> \"help\" .= help)\n\ndata SupportLevel = Unsupported | Alias | EnvVars | Supported\n  deriving (Generic, Show)\n\ninstance ToJSON SupportLevel where\n  toJSON Unsupported = toJSON (Bool False)\n  toJSON _           = toJSON (Bool True)\n  toEncoding Unsupported = toEncoding ( Bool False )\n  toEncoding _           = toEncoding ( Bool True )\ninstance FromJSON SupportLevel where\n  parseJSON (Bool False) = return Unsupported\n  parseJSON (Bool True)  = return EnvVars\n\nmakeFilename :: T.Text -> T.Text\nmakeFilename s = T.pack ( \"./programs/\" ++ T.unpack s ++ \".json\" )\n\nsave :: T.Text -> Program -> IO ()\nsave filename program = do\n  createDirectoryIfMissing False \"./programs/\"\n  B.writeFile (T.unpack filename) (encodePretty program)\n\nreadProgram :: String -> IO ( Maybe Program )\nreadProgram filename = do\n    json_data <- B.readFile filename\n    return (decode json_data)\n",
              "suggestions": [
                {
                  "target_snippet": "instance ToJSON SupportLevel where\n  toJSON Unsupported = toJSON (Bool False)\n  toJSON _           = toJSON (Bool True)\n  toEncoding Unsupported = toEncoding ( Bool False )\n  toEncoding _           = toEncoding ( Bool True )",
                  "refactored_suggestion": "instance ToJSON SupportLevel where\n  toJSON Unsupported = Bool False\n  toJSON _           = Bool True\n  toEncoding = genericToEncoding defaultOptions",
                  "confidence": 0.9,
                  "justification": "This refactored code uses standard and more concise Haskell constructs for defining JSON serialization. `genericToEncoding` can be leveraged to remove manual encodings and reduce redundancy."
                },
                {
                  "target_snippet": "makeFilename s = T.pack ( \"./programs/\" ++ T.unpack s ++ \".json\" )",
                  "refactored_suggestion": "makeFilename s = \"./programs/\" <> s <> \".json\"",
                  "confidence": 0.9,
                  "justification": "Using Text concatenation directly (with `<>`) avoids the overhead of converting between Text and String, making the function more efficient and concise."
                },
                {
                  "target_snippet": "readProgram :: String -> IO ( Maybe Program )\nreadProgram filename = do\n    json_data <- B.readFile filename\n    return (decode json_data)",
                  "refactored_suggestion": "readProgram :: FilePath -> IO (Maybe Program)\nreadProgram filename = decode <$> B.readFile filename",
                  "confidence": 0.95,
                  "justification": "The refactored code simplifies the `readProgram` function by using the `<$>` operator, making it cleaner and more idiomatic."
                },
                {
                  "target_snippet": "-- No occurrence of `parseJSON (Object v)` for SupportLevel type",
                  "refactored_suggestion": "-- reason\n-- The unused `parseJSON (Object v)` code for `SupportLevel` might indicate dead code. Ensure this parsing pattern isn't required before proceeding to remove it completely.",
                  "confidence": 0.5,
                  "justification": "The `parseJSON (Object v)` definition for `SupportLevel` might be irrelevant, as only `Bool` values are parsed in all other cases. Removing it could simplify the file but must be verified against external dependencies."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Program where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport qualified Data.ByteString.Lazy     as B\nimport qualified Data.Text                as T\nimport           GHC.Generics\nimport           System.Directory\n\ninstance FromJSON File where\n  parseJSON (Object v) = File\n    <$> v .: \"path\"\n    <*> v .: \"movable\"\n    <*> v .: \"help\"\n\ndata Program = Program\n  { name  :: T.Text,\n    files :: [File]\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON Program where\n  toJSON (Program name files) = object [ \"name\" .= name, \"files\" .= files ]\n  toEncoding (Program name files) = pairs (\"name\" .= name <> \"files\" .= files)\ninstance FromJSON Program\n\ndata File = File\n  { path         :: String,\n    supportLevel :: SupportLevel,\n    help         :: String\n  }\n  deriving (Generic, Show)\n\ninstance ToJSON File where\n  toJSON (File path supportLevel help) = object [ \"path\" .= path, \"movable\" .= supportLevel, \"help\" .= help ]\n  toEncoding (File path supportLevel help) = pairs (\"path\" .= path <> \"movable\" .= supportLevel <> \"help\" .= help)\n\ndata SupportLevel = Unsupported | Alias | EnvVars | Supported\n  deriving (Generic, Show)\n\ninstance ToJSON SupportLevel where\n  toJSON Unsupported = Bool False\n  toJSON _           = Bool True\n  toEncoding = genericToEncoding defaultOptions\ninstance FromJSON SupportLevel where\n  parseJSON (Bool False) = return Unsupported\n  parseJSON (Bool True)  = return EnvVars\n\nmakeFilename :: T.Text -> T.Text\nmakeFilename s = \"./programs/\" <> s <> \".json\"\n\nsave :: T.Text -> Program -> IO ()\nsave filename program = do\n  createDirectoryIfMissing False \"./programs/\"\n  B.writeFile (T.unpack filename) (encodePretty program)\n\nreadProgram :: FilePath -> IO (Maybe Program)\nreadProgram filename = decode <$> B.readFile filename\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/PreviewProgram.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.3333333333333333,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 21,
              "homplexity_lines_of_code": 26,
              "code_quality_score": 89.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.3333333333333333,
                  "sum": 4
                },
                "homplexity_loc": 26,
                "homplexity_output": "Info:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 1 1: module PreviewProgram has 17 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 8 1: type signature for previewFile has 3 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 9 1: function previewFile has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has 2 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 11 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has 2 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 12 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 15 1: type signature for previewProgramFile has 2 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 15 1: type signature for previewProgramFile has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 16 1: function previewProgramFile has 6 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 16 1: function previewProgramFile has branching depth of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/PreviewProgram.hs\" 16 1: function previewProgramFile has cyclomatic complexity of 2 \n"
              },
              "original_code": "module PreviewProgram where\n\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Output\nimport           Program\n\npreviewFile :: T.Text -> File -> IO ()\npreviewFile name file = logFile name file True\n\npreviewProgram :: Program -> IO ()\npreviewProgram program = do\n  _ <- sequence (map (previewFile (name program)) (files program))\n  return ()\n\npreviewProgramFile :: String -> IO ()\npreviewProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> previewProgram program\n    Nothing      -> putStrLn (T.unpack (red (T.pack \"Error.\")))\n  return ()\n",
              "suggestions": [
                {
                  "target_snippet": "_ <- sequence (map (previewFile (name program)) (files program))\n  return ()",
                  "refactored_suggestion": "mapM_ (previewFile (name program)) (files program)",
                  "confidence": 1.0,
                  "justification": "The `sequence` function followed by `map` can be replaced with `mapM_` for better readability and efficiency since the goal is to perform an action for its effects without needing the results. `mapM_` is tailor-made for this pattern."
                },
                {
                  "target_snippet": "return ()",
                  "refactored_suggestion": "",
                  "confidence": 1.0,
                  "justification": "`return ()` at the end of a `do` block is redundant and can be safely removed to clean up the code."
                },
                {
                  "target_snippet": "Nothing      -> putStrLn (T.unpack (red (T.pack \"Error.\")))",
                  "refactored_suggestion": "Nothing -> putStrLn \"Error.\"",
                  "confidence": 0.9,
                  "justification": "Unnecessary calls to `T.pack`, `T.unpack`, and `red` for a static string can be simplified to directly print the string. This improves readability and slightly enhances performance by removing redundant operations."
                }
              ],
              "refactored_code": "module PreviewProgram where\n\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Output\nimport           Program\n\npreviewFile :: T.Text -> File -> IO ()\npreviewFile name file = logFile name file True\n\npreviewProgram :: Program -> IO ()\npreviewProgram program = do\n  mapM_ (previewFile (name program)) (files program)\n\npreviewProgramFile :: String -> IO ()\npreviewProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> previewProgram program\n    Nothing -> putStrLn \"Error.\"\n  return ()\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Output.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 2.6,
                "sum": 13
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 3,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 6,
              "lines_of_code": 58,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 65.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 2.6,
                  "sum": 13
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 1 1: module Output has 48 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 12 1: type signature for getFilename has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 12 1: type signature for getFilename has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has 3 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 13 1: function getFilename has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has 2 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 17 1: type signature for renderMarkdown has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has 8 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has branching depth of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 18 1: function renderMarkdown has cyclomatic complexity of 2 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 28 1: type signature for line has 4 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 28 1: type signature for line has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 29 1: function line has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 29 1: function line has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 29 1: function line has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 31 13: data Mode has record fields count of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 33 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 33 1: type signature for log has 5 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 34 1: function log has cyclomatic complexity of 6 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 34 1: function log has 16 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 34 1: function log has branching depth of 2 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 52 1: type signature for logFile has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 52 1: type signature for logFile has 4 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 53 1: function logFile has cyclomatic complexity of 3 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 53 1: function logFile has branching depth of 2 \nInfo:/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/lib/Output.hs\" 53 1: function logFile has 5 lines of code \n"
              },
              "original_code": "module Output where\n\nimport           Data.Char      (isSpace)\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Exit\nimport           System.Process\n\ngetFilename :: IO String\ngetFilename = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  return (\"/tmp/xdg-ninja.\" ++ id ++ \".txt\")\n\nrenderMarkdown :: String -> IO String\nrenderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  editor <- appendFile (filenameInput) content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"\n\nline :: (T.Text -> T.Text) -> String -> String -> String\nline color name filename = T.unpack ((T.pack \"[\") <> bold (color (T.pack name)) <> (T.pack \"]: \") <> bold (italic (T.pack filename)))\n\ndata Mode = ERR | WARN | INFO | SUCS | HELP\n\nlog :: Mode -> String -> String -> String -> IO ()\nlog mode name filename help = case mode of\n    ERR -> do\n      putStrLn (line red name filename)\n      Output.log HELP name filename help\n    WARN -> do\n      putStrLn (line yellow name filename)\n      Output.log HELP name filename help\n    INFO -> do\n      putStrLn (line cyan name filename)\n      Output.log HELP name filename help\n    SUCS -> putStrLn (line green name filename)\n    HELP -> do\n      md <- case (all isSpace help) of\n        True  -> renderMarkdown \"_No help available._\"\n        False -> renderMarkdown help\n      putStr md\n\nlogFile :: T.Text -> File -> Bool -> IO ()\nlogFile programName file onFilesystem = case onFilesystem of\n  False -> Output.log SUCS (T.unpack programName) (path file) (help file)\n  True -> case (supportLevel file) of\n    Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n    _ -> Output.log WARN (T.unpack programName) (path file) (help file)\n",
              "suggestions": [
                {
                  "target_snippet": "case (all isSpace help) of\n        True  -> renderMarkdown \"_No help available._\"\n        False -> renderMarkdown help",
                  "refactored_suggestion": "if all isSpace help then\n          renderMarkdown \"_No help available._\"\n      else\n          renderMarkdown help",
                  "confidence": 1.0,
                  "justification": "Using `if` instead of `case` is more concise and easier to read when handling boolean values in this context."
                },
                {
                  "target_snippet": "case onFilesystem of\n  False -> Output.log SUCS (T.unpack programName) (path file) (help file)\n  True -> case (supportLevel file) of\n    Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n    _ -> Output.log WARN (T.unpack programName) (path file) (help file)",
                  "refactored_suggestion": "if onFilesystem then\n      (case (supportLevel file) of\n         Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n         _ -> Output.log WARN (T.unpack programName) (path file) (help file))\n  else\n      Output.log SUCS (T.unpack programName) (path file) (help file)",
                  "confidence": 1.0,
                  "justification": "Using `if` instead of `case` for boolean checks simplifies the structure and improves readability in this situation."
                },
                {
                  "target_snippet": "editor <- appendFile (filenameInput) content",
                  "refactored_suggestion": "-- Removed unused variable 'editor' because it is never utilized in the code.",
                  "confidence": 1.0,
                  "justification": "The variable `editor` is assigned but never used in subsequent operations, so it can be safely removed to simplify the code."
                },
                {
                  "target_snippet": "renderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  editor <- appendFile (filenameInput) content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"",
                  "refactored_suggestion": "renderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  appendFile filenameInput content\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure _ -> return \"\"",
                  "confidence": 0.95,
                  "justification": "Removed the unused `editor` and replaced `a` with `_` in `ExitFailure a` because the variable is not utilized in the code."
                },
                {
                  "target_snippet": "Output.log HELP name filename help",
                  "refactored_suggestion": "log HELP name filename help",
                  "confidence": 0.9,
                  "justification": "Within the same module, it is unnecessary to prefix the function name `Output.log` repeatedly. Simplifying this to just `log` improves readability and avoids redundant code."
                }
              ],
              "refactored_code": "module Output where\n\nimport           Data.Char      (isSpace)\nimport qualified Data.Text      as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           Program\nimport           System.Exit\nimport           System.Process\n\ngetFilename :: IO String\ngetFilename = do\n  id <- toString <$> Data.UUID.V4.nextRandom\n  return (\"/tmp/xdg-ninja.\" ++ id ++ \".txt\")\n\nrenderMarkdown :: String -> IO String\nrenderMarkdown content = do\n  filenameInput <- getFilename\n  filenameOutput <- getFilename\n  -- Removed unused variable 'editor' because it is never utilized in the code.\n  (_, _, _, p) <- createProcess (shell (\"glow -s dark \" ++ filenameInput ++ \" > \" ++ filenameOutput))\n  f <- waitForProcess p\n  case f of\n    ExitSuccess   -> readFile filenameOutput\n    ExitFailure a -> return \"\"\n\nline :: (T.Text -> T.Text) -> String -> String -> String\nline color name filename = T.unpack ((T.pack \"[\") <> bold (color (T.pack name)) <> (T.pack \"]: \") <> bold (italic (T.pack filename)))\n\ndata Mode = ERR | WARN | INFO | SUCS | HELP\n\nlog :: Mode -> String -> String -> String -> IO ()\nlog mode name filename help = case mode of\n    ERR -> do\n      putStrLn (line red name filename)\n      log HELP name filename help\n    WARN -> do\n      putStrLn (line yellow name filename)\n      log HELP name filename help\n    INFO -> do\n      putStrLn (line cyan name filename)\n      log HELP name filename help\n    SUCS -> putStrLn (line green name filename)\n    HELP -> do\n      md <- if all isSpace help then\n          renderMarkdown \"_No help available._\"\n      else\n          renderMarkdown help\n      putStr md\n\nlogFile :: T.Text -> File -> Bool -> IO ()\nlogFile programName file onFilesystem = if onFilesystem then\n      (case (supportLevel file) of\n         Unsupported -> Output.log ERR (T.unpack programName) (path file) (help file)\n         _ -> Output.log WARN (T.unpack programName) (path file) (help file))\n  else\n      Output.log SUCS (T.unpack programName) (path file) (help file)\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/Checks.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/lib/Checks.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 2,
              "lines_of_code": 59,
              "homplexity_lines_of_code": 59,
              "code_quality_score": 76.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 9
                },
                "homplexity_loc": 59,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"expandPath\": 1,\n        \"checkFile\": 4,\n        \"checkProgram\": 1,\n        \"checkProgramFile\": 2,\n        \"checkDir\": 1,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 1.8,\n        \"sum\": 9\n    },\n    \"homplexity_loc\": 59,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Checks where\n\nimport           Data.List              (isSuffixOf)\nimport qualified Data.Text              as T\nimport           Data.Text.ANSI\nimport qualified Data.Text.Lazy         as TL\nimport           Output\nimport           Program\nimport           System.Directory.Extra\nimport           System.Environment     (getEnv)\nimport           System.FilePath\nimport           Text.Replace\n\ndata Result = Exist | MustExist | NoExist\n  deriving Show\n\nexpandPath :: String -> IO String\nexpandPath path = do\n  home <- getEnv \"HOME\"\n  let replacements = [ Replace \"$HOME\" (T.pack home) ]\n  let result = replaceWithList replacements (TL.pack path)\n  return (TL.unpack result)\n\n\ncheckFile :: T.Text -> Bool -> File -> IO Result\ncheckFile programName verbose file  = do\n  path <- expandPath (path file)\n  existsFile <- doesFileExist path\n  existsDir <- doesDirectoryExist path\n  case (existsFile || existsDir) of\n    False -> case verbose of\n      False -> return NoExist\n      True -> do\n        logFile programName file False\n        return NoExist\n    True -> do\n      logFile programName file True\n      case (supportLevel file) of\n        Unsupported -> return MustExist\n        _           -> return Exist\n\ncheckProgram :: Bool -> Program -> IO [Result]\ncheckProgram verbose program = sequence (map (checkFile (name program) verbose) (files program))\n\ncheckProgramFile :: String -> IO [Result]\ncheckProgramFile filename = do\n  x <- readProgram filename\n  case x of\n    Just program -> do\n      results <- checkProgram False program\n      return results\n    Nothing -> do\n      putStrLn (T.unpack (red (T.pack \"Error.\")))\n      return []\n\ncheckDir :: FilePath -> IO ()\ncheckDir dirname = do\n  files <- getDirectoryContents dirname\n  jsonFiles <- return ( map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files ))\n  results <- sequence (map checkProgramFile jsonFiles)\n  return ()\n",
              "suggestions": [
                {
                  "target_snippet": "case (existsFile || existsDir) of\n    False -> case verbose of\n      False -> return NoExist\n      True -> do\n        logFile programName file False\n        return NoExist\n    True -> do\n      logFile programName file True\n      case (supportLevel file) of\n        Unsupported -> return MustExist\n        _ -> return Exist",
                  "refactored_suggestion": "if existsFile || existsDir then\n  do logFile programName file True\n     case supportLevel file of\n       Unsupported -> return MustExist\n       _ -> return Exist\nelse\n  if verbose then\n    do logFile programName file False\n       return NoExist\n  else\n    return NoExist",
                  "confidence": 0.9,
                  "justification": "This refactor simplifies and improves readability by replacing nested `case` statements with equivalent `if` expressions. The new version retains the same logic while improving clarity and conciseness."
                },
                {
                  "target_snippet": "case verbose of\n    False -> return NoExist\n    True -> do\n            logFile programName file False\n            return NoExist",
                  "refactored_suggestion": "if verbose then\n  do logFile programName file False\n     return NoExist\nelse\n  return NoExist",
                  "confidence": 0.9,
                  "justification": "By replacing the `case` statement with an `if` expression, the code becomes more direct and easier to understand without changing its behavior."
                },
                {
                  "target_snippet": "results <- sequence (map checkProgramFile jsonFiles)\n  return ()",
                  "refactored_suggestion": "sequence_ (map checkProgramFile jsonFiles)",
                  "confidence": 0.8,
                  "justification": "Since the results of `sequence` are never used, the code can be simplified by using `sequence_` instead, which discards the results but keeps the side effects, making the intention of the code clearer and slightly more efficient."
                },
                {
                  "target_snippet": "x <- readProgram filename\n  case x of\n    Just program -> do\n      results <- checkProgram False program\n      return results\n    Nothing -> do\n      putStrLn (T.unpack (red (T.pack \"Error.\")))\n      return []",
                  "refactored_suggestion": "readProgram filename >>= \\case\n  Just program -> checkProgram False program\n  Nothing -> do\n    putStrLn (T.unpack (red (T.pack \"Error.\")))\n    return []",
                  "confidence": 0.8,
                  "justification": "Using the `>>=` operator and immediate `case` simplifies the code's structure by avoiding the intermediate binding of `x` for `readProgram`, improving conciseness."
                },
                {
                  "target_snippet": "map (checkFile (name program) verbose) (files program)",
                  "refactored_suggestion": "mapM (checkFile (name program) verbose) (files program)",
                  "confidence": 0.8,
                  "justification": "`mapM` is more idiomatic when applying a function returning a monadic value over a list. It directly conveys the intent of sequencing these operations, with side effects included."
                },
                {
                  "target_snippet": "jsonFiles <- return ( map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files ))",
                  "refactored_suggestion": "let jsonFiles = map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files)",
                  "confidence": 0.7,
                  "justification": "Using `let` is more idiomatic than `return` for defining a value that is immediately used and doesn't depend on any IO operations. This refactor improves clarity by distinguishing between pure and impure code."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Checks where\n\nimport           Data.List              (isSuffixOf)\nimport qualified Data.Text              as T\nimport           Data.Text.ANSI\nimport qualified Data.Text.Lazy         as TL\nimport           Output\nimport           Program\nimport           System.Directory.Extra\nimport           System.Environment     (getEnv)\nimport           System.FilePath\nimport           Text.Replace\n\ndata Result = Exist | MustExist | NoExist\n  deriving Show\n\nexpandPath :: String -> IO String\nexpandPath path = do\n  home <- getEnv \"HOME\"\n  let replacements = [ Replace \"$HOME\" (T.pack home) ]\n  let result = replaceWithList replacements (TL.pack path)\n  return (TL.unpack result)\n\n\ncheckFile :: T.Text -> Bool -> File -> IO Result\ncheckFile programName verbose file  = do\n  path <- expandPath (path file)\n  existsFile <- doesFileExist path\n  existsDir <- doesDirectoryExist path\n  case (existsFile || existsDir) of\n    False -> case verbose of\n      False -> return NoExist\n      True -> do\n        logFile programName file False\n        return NoExist\n    True -> do\n      logFile programName file True\n      case (supportLevel file) of\n        Unsupported -> return MustExist\n        _           -> return Exist\n\ncheckProgram :: Bool -> Program -> IO [Result]\ncheckProgram verbose program = sequence (mapM (checkFile (name program) verbose) (files program))\n\ncheckProgramFile :: String -> IO [Result]\ncheckProgramFile filename = do\n  readProgram filename >>= \\case\n  Just program -> checkProgram False program\n  Nothing -> do\n    putStrLn (T.unpack (red (T.pack \"Error.\")))\n    return []\n\ncheckDir :: FilePath -> IO ()\ncheckDir dirname = do\n  files <- getDirectoryContents dirname\n  let jsonFiles = map (\\x -> dirname </> x) (filter (isSuffixOf \".json\") files)\n  sequence_ (map checkProgramFile jsonFiles)\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/lib/EditProgram.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/lib/EditProgram.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 5,
                "average": 3,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 77,
              "homplexity_lines_of_code": 77,
              "code_quality_score": 72.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 5,
                  "average": 3,
                  "sum": 10
                },
                "homplexity_loc": 77,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"getSupportLevel\": 5,\n        \"editFile\": 2,\n        \"editProgram\": 3,\n        \"min\": 2,\n        \"max\": 5,\n        \"average\": 3.33,\n        \"sum\": 10\n    },\n    \"homplexity_loc\": 77,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- I do not know haskell, this code is probably shit\n\nmodule EditProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           Data.Aeson.Parser\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetSupportLevel :: SupportLevel -> IO SupportLevel\ngetSupportLevel supportLevel = do\n  changed <- promptBool (blue \"Has the support level changed? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if not changed\n  then return supportLevel\n  else do\n      movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if movable\n      then do\n        envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n        if envVars\n        then return EnvVars\n        else do\n          alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n          if alias\n          then return Alias\n          else return Supported\n      else return Unsupported\n\n\ngetHelp :: String -> IO String\ngetHelp currentHelp = getInputMarkdown currentHelp\n\neditFile :: File -> IO File\neditFile f = do\n  printf \"%s\\n\" (T.unpack (italic (cyan (T.pack (path f)))))\n  edit <- promptBool (green \"Edit this file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if not edit\n  then return f\n  else do\n    supportLevel <- getSupportLevel (supportLevel f)\n    help <- getHelp (help f)\n    return File {path = path f, supportLevel = supportLevel, help = help}\n\neditProgram :: String -> IO ()\neditProgram filename = do\n  program <- readProgram filename\n  case program of\n    Nothing -> printf \"%s %s\\n\" (T.unpack (bold (red \"Error parsing file\"))) (T.unpack (italic (red (T.pack filename))))\n    Just p -> do\n      printf \"%s %s\\n\" (T.unpack (cyan (\"Editing\"))) (T.unpack (italic (cyan (name p))))\n      files <- return (files p)\n      newFiles <- sequence (map editFile files)\n      do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n      if do_save\n      then save (T.pack filename) Program {name = (name p), files = newFiles}\n      else return ()\n",
              "suggestions": [
                {
                  "target_snippet": "-- I do not know haskell, this code is probably shit",
                  "refactored_suggestion": "-- The author acknowledges unfamiliarity with Haskell, so this code should be carefully reviewed for best practices.",
                  "confidence": 1.0,
                  "justification": "The comment is not descriptive and uses informal language. Rewriting the comment with professionalism and clarity improves code readability."
                },
                {
                  "target_snippet": "files <- return (files p)",
                  "refactored_suggestion": "let files = files p",
                  "confidence": 0.9,
                  "justification": "Using 'let' is more idiomatic and avoids the unnecessary monadic 'return'. Improves code clarity and minimizes redundancy."
                },
                {
                  "target_snippet": "Data.Aeson.Parser",
                  "refactored_suggestion": "-- Data.Aeson.Parser",
                  "confidence": 0.8,
                  "justification": "The `Data.Aeson.Parser` module is imported but not used in the code. Commenting out this import avoids potential confusion about unused dependencies."
                },
                {
                  "target_snippet": "Data.UUID.V4",
                  "refactored_suggestion": "-- Data.UUID.V4",
                  "confidence": 0.8,
                  "justification": "The `Data.UUID.V4` module is imported but not used in the current implementation. Commenting out this unused import is recommended to keep the code clean."
                },
                {
                  "target_snippet": "getHelp :: String -> IO String\ngetHelp currentHelp = getInputMarkdown currentHelp",
                  "refactored_suggestion": "-- getHelp :: String -> IO String\n-- getHelp currentHelp = getInputMarkdown currentHelp\n-- reason: As 'getHelp' is defined but never utilized in the code, I am suggesting to comment it out to highlight redundant or unused code safely.",
                  "confidence": 0.8,
                  "justification": "The function `getHelp` is defined but not called anywhere in this module. Commenting it out eliminates unused code while preserving it for possible future use."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- The author acknowledges unfamiliarity with Haskell, so this code should be carefully reviewed for best practices.\n\nmodule EditProgram where\n\nimport           Data.Aeson\nimport           Data.Aeson.Encode.Pretty\nimport           -- Data.Aeson.Parser\nimport           Data.Aeson.Types\nimport qualified Data.ByteString.Lazy     as B\nimport           Data.List.Extra\nimport           Data.Maybe\nimport qualified Data.Text                as T\nimport           Data.Text.ANSI\nimport           Data.UUID\nimport           -- Data.UUID.V4\nimport           GHC.Float                (double2Float)\nimport           GHC.Generics\nimport           Program\nimport           Prompts\nimport           System.Console.Haskeline\nimport           System.Environment       (getEnv)\nimport           System.Exit\nimport           System.IO\nimport           System.Process\nimport           Text.Printf              (printf)\n\ngetSupportLevel :: SupportLevel -> IO SupportLevel\ngetSupportLevel supportLevel = do\n  changed <- promptBool (blue \"Has the support level changed? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n  if not changed\n  then return supportLevel\n  else do\n      movable <- promptBool (blue \"Can the file be moved? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n      if movable\n      then do\n        envVars <- promptBool (blue \"Do you have to export environment variables? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n        if envVars\n        then return EnvVars\n        else do\n          alias <- promptBool (blue \"Do you have to set an alias? (y/n) \") (red \"Please provide a valid answer.\") \"y\"\n          if alias\n          then return Alias\n          else return Supported\n      else return Unsupported\n\n\n-- getHelp :: String -> IO String\n-- getHelp currentHelp = getInputMarkdown currentHelp\n-- reason: As 'getHelp' is defined but never utilized in the code, I am suggesting to comment it out to highlight redundant or unused code safely.\n\neditFile :: File -> IO File\neditFile f = do\n  printf \"%s\\n\" (T.unpack (italic (cyan (T.pack (path f)))))\n  edit <- promptBool (green \"Edit this file? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n  if not edit\n  then return f\n  else do\n    supportLevel <- getSupportLevel (supportLevel f)\n    help <- getHelp (help f)\n    return File {path = path f, supportLevel = supportLevel, help = help}\n\neditProgram :: String -> IO ()\neditProgram filename = do\n  program <- readProgram filename\n  case program of\n    Nothing -> printf \"%s %s\\n\" (T.unpack (bold (red \"Error parsing file\"))) (T.unpack (italic (red (T.pack filename))))\n    Just p -> do\n      printf \"%s %s\\n\" (T.unpack (cyan (\"Editing\"))) (T.unpack (italic (cyan (name p))))\n      let files = files p\n      newFiles <- sequence (map editFile files)\n      do_save <- promptBool (green \"Save? (y/n) \") (red \"Please provide a valid answer.\") \"\"\n      if do_save\n      then save (T.pack filename) Program {name = (name p), files = newFiles}\n      else return ()\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/src/add-program.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 6,
              "code_quality_score": 97.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 6,
                "homplexity_output": "Info:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 1 1: module Main has 5 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 10 1: function main has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/add-program.hs\" 10 1: function main has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           AddProgram\nimport           Data.Text\nimport           Data.Text.ANSI\n\nmain :: IO ()\nmain = saveProgram\n",
              "suggestions": [
                {
                  "target_snippet": "import           Data.Text",
                  "refactored_suggestion": "-- import           Data.Text",
                  "confidence": 1.0,
                  "justification": "The module 'Data.Text' is imported but never used in the file. Removing this unused import improves the code by reducing unnecessary dependencies."
                },
                {
                  "target_snippet": "import           Data.Text.ANSI",
                  "refactored_suggestion": "-- import           Data.Text.ANSI",
                  "confidence": 1.0,
                  "justification": "The module 'Data.Text.ANSI' is imported but never used in the file. Removing this unused import makes the code cleaner and avoids bringing in dependencies that add no value."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           AddProgram\n-- import           Data.Text\n-- -- import           Data.Text.ANSI\n\nmain :: IO ()\nmain = saveProgram\n"
            },
            {
              "file_name": "/tmp/project_87/pre_refactor/haskell/src/xdgnj.hs",
              "refactored_file_name": "/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.6666666666666667,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 62,
              "code_quality_score": 73.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.6666666666666667,
                  "sum": 10
                },
                "homplexity_loc": 62,
                "homplexity_output": "Info:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 1 1: module Main has 41 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 11 13: data Args has record fields count of 3 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 19 1: type signature for editProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 20 1: function editProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 22 1: type signature for previewProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 23 1: function previewProgram has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 25 1: type signature for lintProgram has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has 1 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 26 1: function lintProgram has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 28 1: type signature for argsParser has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 29 1: function argsParser has 7 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 37 1: type signature for args has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 37 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 38 1: function args has 3 lines of code \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 38 1: function args has branching depth of 0 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 38 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 42 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 42 1: type signature for main has 1 arguments \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 43 1: function main has cyclomatic complexity of 5 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 43 1: function main has branching depth of 1 \nInfo:/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs:SrcLoc \"/tmp/project_87/hybrid_refactored/haskell/src/xdgnj.hs\" 43 1: function main has 8 lines of code \n"
              },
              "original_code": "module Main where\n\n\nimport qualified AddProgram          as PA\nimport qualified Checks              as C\nimport           Data.Semigroup      ((<>))\nimport qualified EditProgram         as PE\nimport           Options.Applicative\nimport qualified PreviewProgram      as PP\n\ndata Args = RunChecks\n    | AddProgram\n    | EditProgram String\n    | PreviewProgram String\n    | LintProgram String\n    | Lint\n    deriving Show\n\neditProgram :: Parser Args\neditProgram = EditProgram <$> argument str (metavar \"PROGRAM\")\n\npreviewProgram :: Parser Args\npreviewProgram = PreviewProgram <$> argument str (metavar \"PROGRAM\")\n\nlintProgram :: Parser Args\nlintProgram = LintProgram <$> argument str (metavar \"PROGRAM\")\n\nargsParser :: Parser Args\nargsParser = subparser\n        (command \"run\" (info (pure RunChecks) (progDesc \"Run checks\"))\n      <> command \"add\" (info (pure AddProgram) (progDesc \"Add program\"))\n      <> command \"edit\" (info editProgram (progDesc \"Edit program config\"))\n      <> command \"prev\" (info previewProgram (progDesc \"Preview program config\"))\n      <> command \"lintp\" (info lintProgram (progDesc \"Lint program config\"))\n      <> command \"lint\" (info (pure Lint) (progDesc \"Lint all program configs\")))\n\nargs :: ParserInfo Args\nargs = info (argsParser <**> helper)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")\n\nmain :: IO ()\nmain = do\n    args <- execParser args\n    case args of\n        RunChecks               -> C.checkDir \"./programs\"\n        AddProgram              -> PA.saveProgram\n        EditProgram filename    -> PE.editProgram filename\n        PreviewProgram filename -> PP.previewProgramFile filename\n        _                       -> print args\n",
              "suggestions": [
                {
                  "target_snippet": "_ -> print args",
                  "refactored_suggestion": "LintProgram filename -> C.lintProgram filename\nLint -> C.lintAllPrograms",
                  "confidence": 0.9,
                  "justification": "Handling the 'LintProgram' and 'Lint' cases explicitly ensures all cases of the Args data type are handled in a specific and meaningful way, removing the need for a catch-all pattern match. It improves code clarity and makes intent clearer."
                },
                {
                  "target_snippet": "EditProgram filename -> PE.editProgram filename",
                  "refactored_suggestion": "EditProgram filename -> PE.editProgramFile filename",
                  "confidence": 0.8,
                  "justification": "The `editProgramFile` function in the imported `PE` module likely provides clearer, more specific semantics. The original naming does not completely clarify that files are being edited, thus making the change more descriptive and accurate."
                },
                {
                  "target_snippet": "PreviewProgram filename -> PP.previewProgramFile filename",
                  "refactored_suggestion": "PreviewProgram filename -> PP.previewFilename filename",
                  "confidence": 0.8,
                  "justification": "Changing to `previewFilename` improves naming consistency and precision, assuming `PP.previewFilename` exists and is functionally equivalent or better aligned."
                },
                {
                  "target_snippet": "args :: ParserInfo Args\nargs = info (argsParser <**> helper)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")",
                  "refactored_suggestion": "args :: ParserInfo Args\nargs = info (helper <*> argsParser)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")",
                  "confidence": 0.7,
                  "justification": "Reordering `helper` to be applied first might be more idiomatic. While functionally equivalent, moving the helper to the front makes it clearer that the helper decoration applies to the parser as a whole."
                },
                {
                  "target_snippet": "import qualified AddProgram as PA\nimport qualified Checks as C\nimport Data.Semigroup ((<>))\nimport qualified EditProgram as PE\nimport Options.Applicative\nimport qualified PreviewProgram as PP",
                  "refactored_suggestion": "import qualified AddProgram as PA\nimport qualified Checks as C\nimport Options.Applicative\nimport qualified EditProgram as PE\nimport qualified PreviewProgram as PP",
                  "confidence": 0.9,
                  "justification": "The module `Data.Semigroup` is unused and can be removed, as the `(<>)` operator is already available in Prelude starting from base-4.11. This reduces unnecessary imports, helping maintain a cleaner codebase."
                }
              ],
              "refactored_code": "module Main where\n\n\nimport qualified AddProgram          as PA\nimport qualified Checks              as C\nimport           Data.Semigroup      ((<>))\nimport qualified EditProgram         as PE\nimport           Options.Applicative\nimport qualified PreviewProgram      as PP\n\ndata Args = RunChecks\n    | AddProgram\n    | EditProgram String\n    | PreviewProgram String\n    | LintProgram String\n    | Lint\n    deriving Show\n\neditProgram :: Parser Args\neditProgram = EditProgram <$> argument str (metavar \"PROGRAM\")\n\npreviewProgram :: Parser Args\npreviewProgram = PreviewProgram <$> argument str (metavar \"PROGRAM\")\n\nlintProgram :: Parser Args\nlintProgram = LintProgram <$> argument str (metavar \"PROGRAM\")\n\nargsParser :: Parser Args\nargsParser = subparser\n        (command \"run\" (info (pure RunChecks) (progDesc \"Run checks\"))\n      <> command \"add\" (info (pure AddProgram) (progDesc \"Add program\"))\n      <> command \"edit\" (info editProgram (progDesc \"Edit program config\"))\n      <> command \"prev\" (info previewProgram (progDesc \"Preview program config\"))\n      <> command \"lintp\" (info lintProgram (progDesc \"Lint program config\"))\n      <> command \"lint\" (info (pure Lint) (progDesc \"Lint all program configs\")))\n\nargs :: ParserInfo Args\nargs = info (helper <*> argsParser)\n    ( fullDesc\n    <> progDesc \"xdg-ninja utilities\")\n\nmain :: IO ()\nmain = do\n    args <- execParser args\n    case args of\n        RunChecks               -> C.checkDir \"./programs\"\n        AddProgram              -> PA.saveProgram\n        EditProgram filename    -> PE.editProgram filename\n        PreviewProgram filename -> PP.previewFilename filename\n        _                       -> print args\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}