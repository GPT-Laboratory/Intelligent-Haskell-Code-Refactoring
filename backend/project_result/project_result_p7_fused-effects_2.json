{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 87,
          "max": 114,
          "average": 3.797979797979798,
          "sum": 376
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 10,
          "suggestion": 3,
          "ignore": 0,
          "total": 13
        },
        "syntax_errors": 382,
        "lines_of_code": 6725,
        "homplexity_lines_of_code": 5147,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "672.5MB",
          "runtime": "2.01 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_94/pre_refactor/Setup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 2,
          "homplexity_lines_of_code": 3,
          "code_quality_score": 97.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 3,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_94/pre_refactor/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_94/pre_refactor/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_94/pre_refactor/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_94/pre_refactor/Setup.hs\" 2 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Distribution.Simple\nmain = defaultMain\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/Setup.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/Setup.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/Setup.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 21,
          "homplexity_lines_of_code": 24,
          "code_quality_score": 95.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 24,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 1 1: module Main has 17 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 14 1: function main has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench.hs\" 14 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 45,
          "homplexity_lines_of_code": 42,
          "code_quality_score": 91.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 42,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has 13 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 16,
          "code_quality_score": 96.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 16,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 1 1: module Bench.NonDet has 12 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 45,
          "homplexity_lines_of_code": 52,
          "code_quality_score": 88.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 52,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 32 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 44,
          "code_quality_score": 91.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 44,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 1 1: module Bench.State has 28 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
          },
          "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/State.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/State.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 31,
          "homplexity_lines_of_code": 35,
          "code_quality_score": 92.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 35,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 1 1: module Bench.Error has 23 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/Error.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/Error.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 3.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 47,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 81.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 3.0,
              "sum": 6
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 1 1: module Bench.Interpret has 38 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has 1 arguments \nWarning:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has cyclomatic complexity of 5 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/Interpret.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Interpret.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 1,
          "lines_of_code": 58,
          "homplexity_lines_of_code": 62,
          "code_quality_score": 83.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 5
            },
            "homplexity_loc": 62,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 44 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 23 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has 6 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has 2 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has 4 lines of code \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
          "suggestions": [
            {
              "module": [
                "Bench.NonDet.NQueens"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "startLine": 4,
              "startColumn": 1,
              "endLine": 4,
              "endColumn": 31,
              "from": "{-# LANGUAGE TypeOperators #-}",
              "to": "",
              "note": [
                "may require `{-# LANGUAGE ExplicitNamespaces #-}` adding to the top of the file"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 4, startCol = 1, endLine = 4, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/benchmark/Bench/NonDet/NQueens.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 98,
          "homplexity_lines_of_code": 106,
          "code_quality_score": 81.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 106,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 1 1: module Writer has 74 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 35 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 35 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 36 1: function tests has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 36 1: function tests has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 36 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 66 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 66 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 67 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 69 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 69 1: type signature for genN has 5 arguments \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 77 1: function genN has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 77 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 77 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 83 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 83 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 91 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 91 1: function test has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Writer.hs\" 91 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 63,
          "homplexity_lines_of_code": 71,
          "code_quality_score": 84.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 71,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 1 1: module NonDet has 50 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 25 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 25 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 26 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 26 1: function tests has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 26 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 40 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 40 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 43 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 43 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 44 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 44 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 44 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 55 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 55 1: function test has 8 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet.hs\" 55 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Fusion.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.8,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 1,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 69,
          "code_quality_score": 75.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.8,
              "sum": 9
            },
            "homplexity_loc": 69,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 1 1: module Fusion has 43 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 16 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 16 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 17 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 17 1: function tests has 13 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 17 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 33 1: type signature for failureOf has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 33 1: type signature for failureOf has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 38 1: type signature for countDown has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 38 1: type signature for countDown has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 39 1: function countDown has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 39 1: function countDown has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 39 1: function countDown has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 42 1: type signature for countBoth has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 42 1: type signature for countBoth has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has cyclomatic complexity of 3 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 51 1: type signature for throwing has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 51 1: type signature for throwing has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 52 1: function throwing has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 52 1: function throwing has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fusion.hs\" 52 1: function throwing has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n",
          "suggestions": [
            {
              "module": [
                "Fusion"
              ],
              "decl": [
                "countBoth"
              ],
              "severity": "Suggestion",
              "hint": "Use even",
              "file": "/tmp/project_94/pre_refactor/test/Fusion.hs",
              "startLine": 48,
              "startColumn": 9,
              "endLine": 48,
              "endColumn": 23,
              "from": "n `mod` 2 == 0",
              "to": "(even n)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 48, startCol = 9, endLine = 48, endCol = 23}, subts = [(\"n\",SrcSpan {startLine = 48, startCol = 9, endLine = 48, endCol = 10})], orig = \"(even n)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Fusion.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Fusion.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Fusion.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Throw.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 50,
          "homplexity_lines_of_code": 54,
          "code_quality_score": 88.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 54,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 1 1: module Throw has 40 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 33 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 33 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 34 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 34 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 34 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 37 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 47 1: function test has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Throw.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Throw.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Throw.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Throw.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 75,
          "homplexity_lines_of_code": 86,
          "code_quality_score": 83.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 86,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 1 1: module Reader has 64 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 27 1: function tests has 15 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 45 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 45 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 51 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 51 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 51 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 53 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 53 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 59 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 59 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 59 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 62 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 62 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 70 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 70 1: function test has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Reader.hs\" 70 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Fail.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 51,
          "homplexity_lines_of_code": 56,
          "code_quality_score": 88.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 56,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 1 1: module Fail has 41 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Fail.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Fail.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Fail.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 85,
          "homplexity_lines_of_code": 100,
          "code_quality_score": 84.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 100,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 1 1: module State has 68 lines of code \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 30 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 30 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 31 1: function tests has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 31 1: function tests has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 31 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 61 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 61 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 67 1: function gen0 has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 73 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 73 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 80 1: function test has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 80 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/State.hs\" 80 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/State.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/State.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Cull.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 60,
          "code_quality_score": 86.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 60,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 1 1: module Cull has 44 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 24 1: function tests has 10 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 37 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 37 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 38 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 38 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 38 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 40 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 40 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 41 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 41 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 41 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 44 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 44 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 52 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 52 1: function test has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cull.hs\" 52 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Cull.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Cull.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Cull.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Catch.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 40,
          "homplexity_lines_of_code": 38,
          "code_quality_score": 90.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 38,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 1 1: module Catch has 32 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 14 1: function tests has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 18 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 18 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 25 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 25 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 25 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 28 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 28 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 37 1: function test has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 37 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Catch.hs\" 37 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Catch.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Catch.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Catch.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 23,
          "homplexity_lines_of_code": 26,
          "code_quality_score": 93.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 26,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 1 1: module Lift has 18 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 13 1: function tests has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 22 1: type signature for handle has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 22 1: type signature for handle has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 23 1: function handle has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 23 1: function handle has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Lift.hs\" 23 1: function handle has branching depth of 0 \n"
          },
          "original_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Gen.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 10,
            "average": 1,
            "sum": 51
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 7,
          "lines_of_code": 327,
          "homplexity_lines_of_code": 347,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 10,
              "average": 1,
              "sum": 51
            },
            "homplexity_loc": 347,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"m\": 1,\n        \"genT\": 1,\n        \"a\": 1,\n        \"b\": 1,\n        \"c\": 1,\n        \"e\": 1,\n        \"r\": 1,\n        \"s\": 1,\n        \"w\": 1,\n        \"unit\": 1,\n        \"identity\": 1,\n        \"fn\": 1,\n        \"termFn\": 1,\n        \"choice\": 1,\n        \"integral\": 1,\n        \"unicode\": 1,\n        \"string\": 1,\n        \"subtermM\": 1,\n        \"subtermM2\": 1,\n        \"runL\": 1,\n        \"runR\": 1,\n        \"runC\": 1,\n        \"forall_\": 1,\n        \"runTerm\": 5,\n        \"showsPrec_Term\": 10,\n        \"checkTestTree\": 2,\n        \"testGroup\": 1,\n        \"testProperty\": 1,\n        \"showing\": 1,\n        \"showingFn\": 1,\n        \"term\": 1,\n        \"atom\": 1,\n        \"label\": 1,\n        \"infixL\": 1,\n        \"infixR\": 1,\n        \"pair\": 1,\n        \"addLabel\": 1,\n        \"min\": 1,\n        \"max\": 10,\n        \"average\": 1.3783783783783784,\n        \"sum\": 51\n    },\n    \"homplexity_loc\": 347,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM\u00a0m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . (>>= (<$ tell (Set.singleton (fromString s)))) . unComp1\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a\u00a0:<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
          "suggestions": [
            {
              "module": [
                "Gen"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/test/Gen.hs",
              "startLine": 10,
              "startColumn": 1,
              "endLine": 10,
              "endColumn": 33,
              "from": "{-# LANGUAGE PatternSynonyms #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 10, startCol = 1, endLine = 10, endCol = 33}, newComment = \"\"}]"
            },
            {
              "module": [
                "Gen"
              ],
              "decl": [
                "addLabel"
              ],
              "severity": "Suggestion",
              "hint": "Use <=<",
              "file": "/tmp/project_94/pre_refactor/test/Gen.hs",
              "startLine": 273,
              "startColumn": 22,
              "endLine": 273,
              "endColumn": 78,
              "from": "(>>= (<$ tell (Set.singleton (fromString s)))) . unComp1",
              "to": "((<$ tell (Set.singleton (fromString s)))\n   Control.Monad.<=< unComp1)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 273, startCol = 22, endLine = 273, endCol = 78}, subts = [(\"f\",SrcSpan {startLine = 273, startCol = 27, endLine = 273, endCol = 67}),(\"g\",SrcSpan {startLine = 273, startCol = 71, endLine = 273, endCol = 78})], orig = \"(f Control.Monad.<=< g)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Gen.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Gen.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Gen.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Error.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 64,
          "homplexity_lines_of_code": 75,
          "code_quality_score": 84.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 75,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 1 1: module Error has 55 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 24 1: function tests has 17 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 44 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 46 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 46 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 52 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 52 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 52 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 55 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 55 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 64 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 64 1: function test has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Error.hs\" 64 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Error.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Error.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Choose.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 50,
          "homplexity_lines_of_code": 57,
          "code_quality_score": 88.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 57,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 1 1: module Choose has 40 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 18 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 18 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 19 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 19 1: function tests has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 19 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 33 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 33 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 34 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 34 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 34 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 37 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 45 1: function test has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 45 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Choose.hs\" 45 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Choose.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Choose.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Choose.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Accum.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 0,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 5,
          "lines_of_code": 73,
          "homplexity_lines_of_code": 87,
          "code_quality_score": 85.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 87,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 1 1: module Accum has 58 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 23 1: function tests has 15 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 49 1: function gen0 has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 49 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 49 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 54 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 54 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 62 1: function test has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 62 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Accum.hs\" 62 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Accum\n( tests\n) where\n\nimport qualified Control.Carrier.Accum.Church as C.Accum.Church\nimport qualified Control.Carrier.Accum.Strict as C.Accum.Strict\nimport           Control.Effect.Accum\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as T.Accum\nimport           Data.Tuple (swap)\n#endif\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport Data.Bifunctor (first)\n\ntests :: TestTree\ntests = testGroup \"Accum\"\n  [ testGroup \"AccumC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC (C.Accum.Church.runAccum (curry pure)))\n  , testGroup \"AccumC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC C.Accum.Strict.runAccum)\n#if MIN_VERSION_transformers(0,5,4)\n  , testGroup \"AccumT\" $ testAccum (runC (fmap (fmap swap) . flip T.Accum.runAccumT))\n#endif\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (\\_ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (\\_ _ -> [])) a b   initial run\n  testAccum    run = Accum.test    (m (gen0 w) (\\_ _ -> [])) a     w       run\n  initial = pair <*> w <*> unit\n\ngen0\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Vary w, Show w)\n  => GenTerm w\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 w a =\n  [ infixL 4 \"<$\" (<$) <*> a <*> (label \"add\" add <*> w)\n  , label \"looks\" (looks @w) <*> fn a\n  ]\n\ntest\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Eq a, Eq w, Show a, Show w, Vary w, Monoid w)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm w\n  -> Run ((,) w) ((,) w) m\n  -> [TestTree]\ntest m a w (Run runAccum) =\n  [ testProperty \"look returns the log variable (simple)\" . forall_ (w :. Nil) $\n    \\ w -> runAccum (w, look) === Identity (mempty, w)\n  , testProperty \"add appends to the log variable (simple)\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w) === Identity (w, ())\n  , testProperty \"look returns the log variable (continuation)\" . forall_ (w :. fn (m a) :. Nil) $\n    \\ w0 k -> runAccum (w0, look >>= k) === runAccum (w0, k w0)\n  , testProperty \"add appends to the log variable and alters the environment for look\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w >> look) === runAccum (mappend w0 w, look @w <* add w)\n  , testProperty \"add appends to the log variable and alters the environment for continuations\" . forall_ (w :. w :. m a :. Nil) $\n    \\ w0 w k -> runAccum (w0, add w >> k) === (first (mappend w) <$> runAccum (mappend w0 w, k))\n  ]\n",
          "suggestions": [
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_94/pre_refactor/test/Accum.hs",
              "startLine": 38,
              "startColumn": 3,
              "endLine": 38,
              "endColumn": 79,
              "from": "testMonad run\n  = Monad.test (m (gen0 w) (\\ _ _ -> [])) a b c initial run",
              "to": "testMonad = Monad.test (m (gen0 w) (\\ _ _ -> [])) a b c initial",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 38, startCol = 3, endLine = 38, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 38, startCol = 22, endLine = 38, endCol = 75})], orig = \"testMonad = body\"}]"
            },
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_94/pre_refactor/test/Accum.hs",
              "startLine": 39,
              "startColumn": 3,
              "endLine": 39,
              "endColumn": 79,
              "from": "testMonadFix run\n  = MonadFix.test (m (gen0 w) (\\ _ _ -> [])) a b initial run",
              "to": "testMonadFix = MonadFix.test (m (gen0 w) (\\ _ _ -> [])) a b initial",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 39, startCol = 3, endLine = 39, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 39, startCol = 22, endLine = 39, endCol = 75})], orig = \"testMonadFix = body\"}]"
            },
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_94/pre_refactor/test/Accum.hs",
              "startLine": 40,
              "startColumn": 3,
              "endLine": 40,
              "endColumn": 79,
              "from": "testAccum run = Accum.test (m (gen0 w) (\\ _ _ -> [])) a w run",
              "to": "testAccum = Accum.test (m (gen0 w) (\\ _ _ -> [])) a w",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 40, startCol = 3, endLine = 40, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 40, startCol = 22, endLine = 40, endCol = 69})], orig = \"testAccum = body\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Accum.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Accum.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Accum.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/MonadFix.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 31,
          "homplexity_lines_of_code": 33,
          "code_quality_score": 94.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 33,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 1 1: module MonadFix has 24 lines of code \nInfo:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 14 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 14 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 22 1: function test has 9 lines of code \nInfo:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/MonadFix.hs\" 22 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/MonadFix.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/MonadFix.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/MonadFix.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Test.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 20,
          "lines_of_code": 46,
          "homplexity_lines_of_code": 61,
          "code_quality_score": 91.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 61,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 1 1: module Main has 42 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 26 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 26 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 27 1: function main has 19 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 27 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Test.hs\" 27 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Test.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Test.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Test.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Monad.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 33,
          "homplexity_lines_of_code": 37,
          "code_quality_score": 94.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 37,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 1 1: module Monad has 26 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 13 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 13 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 22 1: function test has 11 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Monad.hs\" 22 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Monad.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Monad.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Monad.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Cut.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 10,
          "lines_of_code": 69,
          "homplexity_lines_of_code": 82,
          "code_quality_score": 83.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 82,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 1 1: module Cut has 58 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 27 1: function tests has 14 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 44 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 44 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 45 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 45 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 45 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 47 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 47 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 48 1: function genN has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 48 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 48 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 51 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 51 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 61 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 61 1: function test has 8 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut.hs\" 61 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Cut.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Cut.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Cut.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Empty.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 59,
          "homplexity_lines_of_code": 70,
          "code_quality_score": 87.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 70,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 1 1: module Empty has 49 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 23 1: function tests has 17 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 43 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 44 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 56 1: function test has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 56 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Empty.hs\" 56 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Empty.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Empty.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Empty.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Fresh.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 87.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 1 1: module Fresh has 43 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 20 1: function tests has 16 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 39 1: type signature for gen has 2 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 39 1: type signature for gen has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 40 1: function gen has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 40 1: function gen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 40 1: function gen has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 43 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 43 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 50 1: function test has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 50 1: function test has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Fresh.hs\" 50 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Fresh.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Fresh.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Fresh.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/NonDet/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 32,
          "homplexity_lines_of_code": 41,
          "code_quality_score": 89.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 41,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 26 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 28 1: type signature for state has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 28 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 31 1: type signature for error has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 31 1: type signature for error has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has cyclomatic complexity of 1 \n"
          },
          "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/NonDet/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/NonDet/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/test/Cut/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 18,
          "code_quality_score": 96.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 18,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 1 1: module Cut.Church has 13 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 11 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 11 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/test/Cut/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/test/Cut/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/test/Cut/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Inference.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 6,
          "lines_of_code": 54,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 90.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 1 1: module Inference has 30 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 19 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 19 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 20 1: function example has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 20 1: function example has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 20 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 39 1: type signature for askEnv has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 39 1: type signature for askEnv has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 45 1: type signature for runEnv has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 45 1: type signature for runEnv has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Inference.hs\" 50 26: data HasEnv has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n",
          "suggestions": [
            {
              "module": [
                "Inference"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/examples/Inference.hs",
              "startLine": 6,
              "startColumn": 1,
              "endLine": 6,
              "endColumn": 31,
              "from": "{-# LANGUAGE TypeOperators #-}",
              "to": "",
              "note": [
                "may require `{-# LANGUAGE ExplicitNamespaces #-}` adding to the top of the file"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 6, startCol = 1, endLine = 6, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Inference.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Inference.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Inference.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Utils.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.3333333333333333,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 20,
          "homplexity_lines_of_code": 19,
          "code_quality_score": 90.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.3333333333333333,
              "sum": 4
            },
            "homplexity_loc": 19,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 1 1: module Utils has 14 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 8 5: data TestTree has record fields count of 4 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 11 1: type signature for checkTestTree has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 11 1: type signature for checkTestTree has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 16 1: type signature for testGroup has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 16 1: type signature for testGroup has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 19 1: type signature for testProperty has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 19 1: type signature for testProperty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has cyclomatic complexity of 1 \n"
          },
          "original_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Utils.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Utils.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Utils.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Parser.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.2222222222222223,
            "sum": 11
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 9,
          "lines_of_code": 166,
          "homplexity_lines_of_code": 208,
          "code_quality_score": 57.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.2222222222222223,
              "sum": 11
            },
            "homplexity_loc": 208,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 1 1: module Parser has 127 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 28 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 28 1: type signature for example has 1 arguments \nCritical:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 29 1: function example has 63 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 29 1: function example has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 29 1: function example has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 116 3: data Symbol has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 119 1: type signature for satisfy has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 119 1: type signature for satisfy has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 122 1: type signature for char has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 122 1: type signature for char has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 123 1: function char has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 123 1: function char has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 123 1: function char has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 125 1: type signature for digit has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 125 1: type signature for digit has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 126 1: function digit has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 126 1: function digit has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 126 1: function digit has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 128 1: type signature for parens has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 128 1: type signature for parens has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 129 1: function parens has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 129 1: function parens has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 129 1: function parens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 132 1: type signature for parse has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 132 1: type signature for parse has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 133 1: function parse has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 133 1: function parse has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 133 1: function parse has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 137 22: data ParseC has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 151 1: type signature for expr has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 151 1: type signature for expr has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 152 1: function expr has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 152 1: function expr has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 152 1: function expr has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 157 1: type signature for term has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 157 1: type signature for term has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 158 1: function term has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 158 1: function term has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 158 1: function term has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 163 1: type signature for factor has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 163 1: type signature for factor has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 164 1: function factor has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 164 1: function factor has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Parser.hs\" 164 1: function factor has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n",
          "suggestions": [
            {
              "module": [
                "Parser"
              ],
              "decl": [
                "parse"
              ],
              "severity": "Suggestion",
              "hint": "Use <=<",
              "file": "/tmp/project_94/pre_refactor/examples/Parser.hs",
              "startLine": 133,
              "startColumn": 15,
              "endLine": 133,
              "endColumn": 60,
              "from": "(>>= exhaustive) . runState input . runParseC",
              "to": "exhaustive Control.Monad.<=< (runState input . runParseC)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 133, startCol = 15, endLine = 133, endCol = 60}, subts = [(\"f\",SrcSpan {startLine = 133, startCol = 20, endLine = 133, endCol = 30}),(\"g\",SrcSpan {startLine = 133, startCol = 34, endLine = 133, endCol = 60})], orig = \"f Control.Monad.<=< (g)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Parser.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Parser.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Parser.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 20,
          "homplexity_lines_of_code": 22,
          "code_quality_score": 95.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 22,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 1 1: module Main has 16 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 14 1: function main has 6 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Main.hs\" 14 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Main.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Main.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Main.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.1428571428571428,
            "sum": 8
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 5,
          "lines_of_code": 165,
          "homplexity_lines_of_code": 101,
          "code_quality_score": 73.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.1428571428571428,
              "sum": 8
            },
            "homplexity_loc": 101,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 12 1: module ReinterpretLog has 82 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 47 5: data Message has record fields count of 2 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has branching depth of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has cyclomatic complexity of 2 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 57 1: type signature for application has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 57 1: type signature for application has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 79 3: data Log has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 83 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 83 1: type signature for log has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 92 26: data LogStdoutC has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 112 35: data ReinterpretLogC has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 137 37: data CollectLogMessagesC has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 158 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 158 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has 6 lines of code \n"
          },
          "original_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n",
          "suggestions": [
            {
              "module": [
                "ReinterpretLog"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs",
              "startLine": 15,
              "startColumn": 1,
              "endLine": 15,
              "endColumn": 30,
              "from": "{-# LANGUAGE InstanceSigs #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 15, startCol = 1, endLine = 15, endCol = 30}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/ReinterpretLog.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/ReinterpretLog.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/ReinterpretLog.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 81,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 73.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 9
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 1 1: module Labelled has 58 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 20 1: type signature for sample has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 20 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 24 1: function sample has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 24 1: function sample has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 24 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 26 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 26 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 32 1: type signature for numerically has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 32 1: type signature for numerically has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 38 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 38 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 48 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 48 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 54 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 54 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 60 1: type signature for boolean has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 60 1: type signature for boolean has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 66 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 66 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 77 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 77 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 78 1: function example has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 78 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Labelled.hs\" 78 1: function example has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/examples/Teletype.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 79,
          "homplexity_lines_of_code": 78,
          "code_quality_score": 84.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 78,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 44 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 48 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 48 1: type signature for read has 1 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 49 1: function read has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 49 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 49 1: function read has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 51 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 51 1: type signature for write has 2 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 52 1: function write has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 52 1: function write has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 52 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 55 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_94/pre_refactor/examples/Teletype.hs\" 68 28: data TeletypeRetC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/examples/Teletype.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/examples/Teletype.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/examples/Teletype.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Algebra.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 8,
            "average": 3,
            "sum": 71
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 15,
          "lines_of_code": 343,
          "homplexity_lines_of_code": 343,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 8,
              "average": 3,
              "sum": 71
            },
            "homplexity_loc": 343,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"thread\": 1,\n        \"run\": 1,\n        \"send\": 1,\n        \"toRWSTF\": 1,\n        \"swapAndLift\": 1,\n        \"alg (Lift IO)\": 1,\n        \"alg (Lift Identity)\": 1,\n        \"alg (Choose NonEmpty)\": 1,\n        \"alg (Empty Maybe)\": 1,\n        \"alg (Error e, Either)\": 2,\n        \"alg (Reader r, (->) r)\": 2,\n        \"alg (NonDet, [])\": 2,\n        \"alg (Writer w, (,) w)\": 3,\n        \"alg (Error e :+: sig, ExceptT)\": 3,\n        \"alg (Empty :+: sig, MaybeT)\": 2,\n        \"alg (Reader r :+: sig, ReaderT)\": 3,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig, RWS.CPS.RWST)\": 8,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig, RWS.Lazy.RWST)\": 8,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig, RWS.Strict.RWST)\": 8,\n        \"alg (State s :+: sig, StateT Lazy)\": 3,\n        \"alg (State s :+: sig, StateT Strict)\": 3,\n        \"alg (Writer w :+: sig, WriterT CPS)\": 4,\n        \"alg (Writer w :+: sig, WriterT Lazy)\": 4,\n        \"alg (Writer w :+: sig, WriterT Strict)\": 4,\n        \"alg (Accum w :+: sig, AccumT)\": 3,\n        \"min\": 1,\n        \"max\": 8,\n        \"average\": 2.84,\n        \"sum\": 71\n    },\n    \"homplexity_loc\": 343,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Algebra.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Algebra.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Algebra.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 80,
          "homplexity_lines_of_code": 31,
          "code_quality_score": 88.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 31,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 70,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 90.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 31 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 39,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 94.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 15 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has branching depth of 0 \n"
          },
          "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Throw.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 62,
          "homplexity_lines_of_code": 23,
          "code_quality_score": 91.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 23,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Fail.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Fail.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Fail.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Fail.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 108,
          "homplexity_lines_of_code": 40,
          "code_quality_score": 84.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 6
            },
            "homplexity_loc": 40,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 30 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 104 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 104 1: type signature for state has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has 3 lines of code \n"
          },
          "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/State.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/State.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 40,
          "homplexity_lines_of_code": 15,
          "code_quality_score": 96.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 15,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 1 1: module Control.Effect.Cull has 14 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 28 3: data Cull has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Cull.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Cull.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs",
          "cyclomatic_complexity": {
            "min": 3,
            "max": 3,
            "average": 3.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 88,
          "homplexity_lines_of_code": 52,
          "code_quality_score": 88.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 3,
              "max": 3,
              "average": 3.0,
              "sum": 3
            },
            "homplexity_loc": 52,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 1 1: module Control.Effect.Sum has 48 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 26 5: data f has record fields count of 2 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 42 3: type class Member has method + value count of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 42 3: type class Member has associated type count of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has cyclomatic complexity of 3 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Sum.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Sum.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 33,
          "homplexity_lines_of_code": 13,
          "code_quality_score": 96.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 13,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 12 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
          },
          "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Catch.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 68,
          "homplexity_lines_of_code": 27,
          "code_quality_score": 91.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 27,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 1 1: module Control.Effect.Lift has 24 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Error.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 24,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Error.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Error.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 156,
          "homplexity_lines_of_code": 77,
          "code_quality_score": 82.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 5
            },
            "homplexity_loc": 77,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 1 1: module Control.Effect.Choose has 72 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 90 1: type signature for many has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 90 1: type signature for many has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 101 1: type signature for some has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 101 1: type signature for some has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs\" 118 24: data Choosing has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Choose.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Choose.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 96.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 29 3: data Trace has record fields count of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Trace.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 23,
          "code_quality_score": 91.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 23,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 53 1: type signature for look has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 53 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Accum.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1,
            "sum": 12
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 152,
          "homplexity_lines_of_code": 152,
          "code_quality_score": 60.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1,
              "sum": 12
            },
            "homplexity_loc": 152,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runLabelled\": 1,\n        \"alg_labelled\": 2,\n        \"injLabelled_reflexivity\": 1,\n        \"injLabelled_left_recursion\": 1,\n        \"injLabelled_left_occurrence\": 1,\n        \"injLabelled_right_recursion\": 1,\n        \"sendLabelled\": 1,\n        \"runUnderLabel\": 1,\n        \"lift\": 1,\n        \"alg_underLabel\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 152,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 73,
          "homplexity_lines_of_code": 27,
          "code_quality_score": 91.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 27,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 24 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 33 3: data Cut has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 60 1: type signature for call has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 60 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Cut.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 48,
          "homplexity_lines_of_code": 20,
          "code_quality_score": 94.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 20,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 15 1: module Control.Effect.Empty has 17 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has 2 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has branching depth of 1 \n"
          },
          "original_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Empty.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Empty.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 37,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 96.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 1 1: module Control.Effect.Fresh has 16 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 25 3: data Fresh has record fields count of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Fresh.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Fresh.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 9,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Reader/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Reader/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 57,
          "homplexity_lines_of_code": 30,
          "code_quality_score": 91.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 30,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 1 1: module Control.Effect.Reader.Labelled has 27 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Reader/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 13,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/NonDet/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/NonDet/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Choose/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Choose/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Choose/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 11,
          "code_quality_score": 98.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 11,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Empty/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Empty/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Empty/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 12,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Accum/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Accum/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 12,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/State/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/State/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/State/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 95,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 84.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 6
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 1 1: module Control.Effect.State.Labelled has 33 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has 1 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has 1 lines of code \n"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/State/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/State/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 11,
          "code_quality_score": 98.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 11,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Throw/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Throw/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Writer/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Writer/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Catch/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Catch/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Error/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Error/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Error/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Error/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Effect/Lift/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Effect/Lift/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 105,
          "homplexity_lines_of_code": 68,
          "code_quality_score": 91.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 68,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 1 1: module Control.Carrier.Reader has 67 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs\" 47 25: data ReaderC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 42,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 95.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 1 1: module Control.Carrier.Lift has 27 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs\" 33 21: data LiftC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Interpret.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 101,
          "homplexity_lines_of_code": 101,
          "code_quality_score": 77.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1,
              "sum": 6
            },
            "homplexity_loc": 101,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runInterpret\": 1,\n        \"runInterpretState\": 1,\n        \"reify\": 1,\n        \"lift\": 1,\n        \"alg\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 101,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Interpret.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Interpret.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Interpret.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 134,
          "homplexity_lines_of_code": 84,
          "code_quality_score": 85.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 84,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 1 1: module Control.Carrier.NonDet.Church has 81 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has 5 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 78 23: data NonDetC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/NonDet/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/NonDet/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 109,
          "homplexity_lines_of_code": 71,
          "code_quality_score": 88.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 71,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 1 1: module Control.Carrier.Choose.Church has 69 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 63 23: data ChooseC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Choose/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Choose/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 94.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 33 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Trace/Ignoring.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 94.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 33 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 44 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Trace/Printing.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 36,
          "code_quality_score": 94.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 36,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 35 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 46 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Trace/Returning.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 94,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 87.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" (-1) (-1): module Control.Carrier.Cull.Church has 60 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has 5 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 64 21: data CullC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Cull/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Cull/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 87,
          "homplexity_lines_of_code": 38,
          "code_quality_score": 90.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 38,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 35 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 81 22: data EmptyC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Empty/Maybe.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 141,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 1 1: module Control.Carrier.Empty.Church has 78 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 82 22: data EmptyC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Empty/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 48,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 95.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 27 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Fail/Either.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 0,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 3,
          "lines_of_code": 133,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" (-1) (-1): module Control.Carrier.Accum.Church has 78 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 79 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
          "suggestions": [
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 30,
              "from": "{-# LANGUAGE BangPatterns #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 30}, newComment = \"\"}]"
            },
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 4,
              "startColumn": 1,
              "endLine": 4,
              "endColumn": 44,
              "from": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 4, startCol = 1, endLine = 4, endCol = 44}, newComment = \"\"}]"
            },
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 6,
              "startColumn": 1,
              "endLine": 6,
              "endColumn": 31,
              "from": "{-# LANGUAGE TupleSections #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 6, startCol = 1, endLine = 6, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Accum/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 99,
          "homplexity_lines_of_code": 61,
          "code_quality_score": 87.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 61,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" (-1) (-1): module Control.Carrier.Accum.IORef has 54 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 88 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Accum/IORef.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/IORef.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 136,
          "homplexity_lines_of_code": 83,
          "code_quality_score": 85.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 83,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" (-1) (-1): module Control.Carrier.Accum.Strict has 80 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 77 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Accum/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 92.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Fresh/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 92.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" (-1) (-1): module Control.Carrier.Fresh.Strict has 37 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 59 22: data FreshC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Fresh/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 129,
          "homplexity_lines_of_code": 76,
          "code_quality_score": 86.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 76,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 1 1: module Control.Carrier.State.Lazy has 73 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 74 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/State/Lazy.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Lazy.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 129,
          "homplexity_lines_of_code": 79,
          "code_quality_score": 86.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 79,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" (-1) (-1): module Control.Carrier.State.Church has 76 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs\" 74 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/State/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 107,
          "homplexity_lines_of_code": 73,
          "code_quality_score": 84.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 73,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 1 1: module Control.Carrier.State.IORef has 60 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has 5 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has 4 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has 3 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs\" 96 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/State/IORef.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 127,
          "homplexity_lines_of_code": 75,
          "code_quality_score": 86.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 75,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 1 1: module Control.Carrier.State.Strict has 72 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs\" 75 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/State/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 41,
          "homplexity_lines_of_code": 33,
          "code_quality_score": 94.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 33,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" (-1) (-1): module Control.Carrier.Throw.Either has 32 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 34 24: data ThrowC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Throw/Either.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 82,
          "homplexity_lines_of_code": 49,
          "code_quality_score": 91.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 49,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" (-1) (-1): module Control.Carrier.Writer.Church has 47 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 66 25: data WriterC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Writer/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Writer/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 78,
          "homplexity_lines_of_code": 51,
          "code_quality_score": 90.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 51,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" (-1) (-1): module Control.Carrier.Writer.Strict has 49 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 60 25: data WriterC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Writer/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 123,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 1 1: module Control.Carrier.Cut.Church has 78 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has 5 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 67 20: data CutC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Cut/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Cut/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 58,
          "homplexity_lines_of_code": 31,
          "code_quality_score": 94.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 31,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 1 1: module Control.Carrier.Error.Either has 30 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has 2 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs\" 46 24: data ErrorC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Error/Either.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 113,
          "homplexity_lines_of_code": 74,
          "code_quality_score": 90.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 74,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 1 1: module Control.Carrier.Error.Church has 73 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has 4 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has branching depth of 0 \nInfo:/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs\" 50 24: data ErrorC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Carrier/Error/Church.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 47,
          "homplexity_lines_of_code": 11,
          "code_quality_score": 96.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 11,
            "homplexity_output": "Info:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 1 1: module Control.Algebra.Handler has 10 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has type constructor nesting of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has 3 arguments \nInfo:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has 1 lines of code \nInfo:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has cyclomatic complexity of 1 \nInfo:/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/src/Control/Algebra/Handler.hs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/src/Control/Algebra/Handler.hs"
          }
        },
        {
          "file_name": "/tmp/project_94/pre_refactor/README.lhs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 1,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "README.md",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_94/static_refactored/README.lhs",
            "llm_only_refactored_file": "/tmp/project_94/llm_only_refactored/README.lhs",
            "hybrid_refactored_file": "/tmp/project_94/hybrid_refactored/README.lhs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 86,
              "max": 108,
              "average": 3.6666666666666665,
              "sum": 363
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 0,
              "suggestion": 0,
              "ignore": 0,
              "total": 0
            },
            "syntax_errors": 378,
            "lines_of_code": 6652,
            "homplexity_lines_of_code": 5024,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "665.2MB",
              "runtime": "1.87 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_94/pre_refactor/Setup.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/Setup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 2,
              "homplexity_lines_of_code": 3,
              "code_quality_score": 97.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 3,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/Setup.hs:SrcLoc \"/tmp/project_94/static_refactored/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_94/static_refactored/Setup.hs:SrcLoc \"/tmp/project_94/static_refactored/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_94/static_refactored/Setup.hs:SrcLoc \"/tmp/project_94/static_refactored/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/Setup.hs:SrcLoc \"/tmp/project_94/static_refactored/Setup.hs\" 2 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Distribution.Simple\nmain = defaultMain\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/Setup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Distribution.Simple\nmain = defaultMain\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 21,
              "homplexity_lines_of_code": 24,
              "code_quality_score": 95.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 24,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 1 1: module Main has 17 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 14 1: function main has 7 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 45,
              "homplexity_lines_of_code": 42,
              "code_quality_score": 91.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 42,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has 13 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 16,
              "code_quality_score": 96.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 16,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 1 1: module Bench.NonDet has 12 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has 4 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 45,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 32 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/State.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 44,
              "code_quality_score": 91.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 44,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 1 1: module Bench.State has 28 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/Error.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 31,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 92.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 1 1: module Bench.Error has 23 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has 11 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 3.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 81.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 3.0,
                  "sum": 6
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 1 1: module Bench.Interpret has 38 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has 1 arguments \nWarning:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has cyclomatic complexity of 5 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/Interpret.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 58,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 83.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 43 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 23 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has 4 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has 6 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has 2 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has 1 lines of code \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has 4 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Writer.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 98,
              "homplexity_lines_of_code": 106,
              "code_quality_score": 81.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 106,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 1 1: module Writer has 74 lines of code \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 35 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 35 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 36 1: function tests has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 36 1: function tests has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 36 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 66 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 66 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 67 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 69 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 69 1: type signature for genN has 5 arguments \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 77 1: function genN has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 77 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 77 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 83 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 83 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 91 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 91 1: function test has 7 lines of code \nInfo:/tmp/project_94/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Writer.hs\" 91 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/NonDet.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 63,
              "homplexity_lines_of_code": 71,
              "code_quality_score": 84.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 71,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 1 1: module NonDet has 50 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 25 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 25 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 26 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 26 1: function tests has 11 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 26 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 41 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 41 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 41 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 43 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 43 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 44 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 44 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 44 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 55 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 55 1: function test has 8 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet.hs\" 55 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Fusion.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Fusion.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.8,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 75.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.8,
                  "sum": 9
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 1 1: module Fusion has 43 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 16 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 16 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 17 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 17 1: function tests has 13 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 17 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 33 1: type signature for failureOf has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 33 1: type signature for failureOf has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 34 1: function failureOf has 2 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 34 1: function failureOf has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 34 1: function failureOf has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 38 1: type signature for countDown has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 38 1: type signature for countDown has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 39 1: function countDown has 2 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 39 1: function countDown has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 39 1: function countDown has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 42 1: type signature for countBoth has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 42 1: type signature for countBoth has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 43 1: function countBoth has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 43 1: function countBoth has cyclomatic complexity of 3 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 43 1: function countBoth has 7 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 51 1: type signature for throwing has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 51 1: type signature for throwing has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 52 1: function throwing has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 52 1: function throwing has 2 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fusion.hs\" 52 1: function throwing has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Fusion.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | (even n) -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Throw.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 54,
              "code_quality_score": 88.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 54,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 1 1: module Throw has 40 lines of code \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 33 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 33 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 34 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 34 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 34 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 37 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 47 1: function test has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Throw.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Throw.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Reader.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 75,
              "homplexity_lines_of_code": 86,
              "code_quality_score": 83.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 86,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 1 1: module Reader has 64 lines of code \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 27 1: function tests has 15 lines of code \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 45 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 45 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 51 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 51 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 51 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 53 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 53 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 59 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 59 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 59 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 62 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 62 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 70 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 70 1: function test has 5 lines of code \nInfo:/tmp/project_94/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Reader.hs\" 70 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Fail.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Fail.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 56,
              "code_quality_score": 88.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 56,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 1 1: module Fail has 41 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Fail.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/State.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 85,
              "homplexity_lines_of_code": 100,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 100,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 1 1: module State has 68 lines of code \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 30 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 30 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 31 1: function tests has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 31 1: function tests has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 31 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 61 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 61 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 67 1: function gen0 has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 73 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 73 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 80 1: function test has 5 lines of code \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 80 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/State.hs:SrcLoc \"/tmp/project_94/static_refactored/test/State.hs\" 80 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Cull.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Cull.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 60,
              "code_quality_score": 86.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 60,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 1 1: module Cull has 44 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 24 1: function tests has 10 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 37 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 37 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 38 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 38 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 38 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 40 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 40 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 41 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 41 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 41 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 44 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 44 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 52 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 52 1: function test has 4 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cull.hs\" 52 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Cull.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Catch.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 40,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 1 1: module Catch has 32 lines of code \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 14 1: function tests has 2 lines of code \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 18 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 18 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 25 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 25 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 25 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 28 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 28 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 37 1: function test has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 37 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Catch.hs\" 37 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Catch.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Lift.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 23,
              "homplexity_lines_of_code": 26,
              "code_quality_score": 93.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 26,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 1 1: module Lift has 18 lines of code \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 13 1: function tests has 7 lines of code \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 22 1: type signature for handle has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 22 1: type signature for handle has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 23 1: function handle has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 23 1: function handle has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Lift.hs\" 23 1: function handle has branching depth of 0 \n"
              },
              "original_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Gen.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Gen.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1,
                "sum": 41
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 327,
              "homplexity_lines_of_code": 327,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1,
                  "sum": 41
                },
                "homplexity_loc": 327,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"m\": 1,\n        \"genT\": 1,\n        \"a\": 1,\n        \"b\": 1,\n        \"c\": 1,\n        \"e\": 1,\n        \"r\": 1,\n        \"s\": 1,\n        \"w\": 1,\n        \"unit\": 1,\n        \"identity\": 1,\n        \"fn\": 1,\n        \"termFn\": 1,\n        \"choice\": 1,\n        \"integral\": 1,\n        \"unicode\": 1,\n        \"string\": 1,\n        \"subtermM\": 1,\n        \"subtermM2\": 1,\n        \"runL\": 1,\n        \"runR\": 1,\n        \"runC\": 1,\n        \"forall_\": 1,\n        \"runTerm\": 5,\n        \"atom\": 1,\n        \"label\": 1,\n        \"infixL\": 1,\n        \"infixR\": 1,\n        \"pair\": 1,\n        \"addLabel\": 1,\n        \"checkTestTree\": 2,\n        \"testGroup\": 1,\n        \"testProperty\": 1,\n        \"showing\": 1,\n        \"showingFn\": 1,\n        \"term\": 1,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 1.1388888888888888,\n        \"sum\": 41\n    },\n    \"homplexity_loc\": 327,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM\u00a0m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . (>>= (<$ tell (Set.singleton (fromString s)))) . unComp1\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a\u00a0:<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Gen.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . ((<$ tell (Set.singleton (fromString s))) Control.Monad.<=< unComp1)\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Error.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Error.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 64,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 84.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 1 1: module Error has 55 lines of code \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 24 1: function tests has 17 lines of code \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 44 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 46 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 46 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 52 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 52 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 52 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 55 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 55 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 64 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 64 1: function test has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Error.hs\" 64 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Choose.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 57,
              "code_quality_score": 88.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 57,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 1 1: module Choose has 40 lines of code \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 18 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 18 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 19 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 19 1: function tests has 11 lines of code \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 19 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 33 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 33 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 34 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 34 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 34 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 37 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 45 1: function test has 5 lines of code \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 45 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Choose.hs\" 45 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Choose.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Accum.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Accum.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Accum\n( tests\n) where\n\nimport qualified Control.Carrier.Accum.Church as C.Accum.Church\nimport qualified Control.Carrier.Accum.Strict as C.Accum.Strict\nimport           Control.Effect.Accum\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as T.Accum\nimport           Data.Tuple (swap)\n#endif\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport Data.Bifunctor (first)\n\ntests :: TestTree\ntests = testGroup \"Accum\"\n  [ testGroup \"AccumC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC (C.Accum.Church.runAccum (curry pure)))\n  , testGroup \"AccumC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC C.Accum.Strict.runAccum)\n#if MIN_VERSION_transformers(0,5,4)\n  , testGroup \"AccumT\" $ testAccum (runC (fmap (fmap swap) . flip T.Accum.runAccumT))\n#endif\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (\\_ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (\\_ _ -> [])) a b   initial run\n  testAccum    run = Accum.test    (m (gen0 w) (\\_ _ -> [])) a     w       run\n  initial = pair <*> w <*> unit\n\ngen0\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Vary w, Show w)\n  => GenTerm w\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 w a =\n  [ infixL 4 \"<$\" (<$) <*> a <*> (label \"add\" add <*> w)\n  , label \"looks\" (looks @w) <*> fn a\n  ]\n\ntest\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Eq a, Eq w, Show a, Show w, Vary w, Monoid w)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm w\n  -> Run ((,) w) ((,) w) m\n  -> [TestTree]\ntest m a w (Run runAccum) =\n  [ testProperty \"look returns the log variable (simple)\" . forall_ (w :. Nil) $\n    \\ w -> runAccum (w, look) === Identity (mempty, w)\n  , testProperty \"add appends to the log variable (simple)\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w) === Identity (w, ())\n  , testProperty \"look returns the log variable (continuation)\" . forall_ (w :. fn (m a) :. Nil) $\n    \\ w0 k -> runAccum (w0, look >>= k) === runAccum (w0, k w0)\n  , testProperty \"add appends to the log variable and alters the environment for look\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w >> look) === runAccum (mappend w0 w, look @w <* add w)\n  , testProperty \"add appends to the log variable and alters the environment for continuations\" . forall_ (w :. w :. m a :. Nil) $\n    \\ w0 w k -> runAccum (w0, add w >> k) === (first (mappend w) <$> runAccum (mappend w0 w, k))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Accum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": ""
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/MonadFix.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/MonadFix.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 31,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 1 1: module MonadFix has 24 lines of code \nInfo:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 14 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 14 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 22 1: function test has 9 lines of code \nInfo:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_94/static_refactored/test/MonadFix.hs\" 22 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/MonadFix.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Test.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Test.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 20,
              "lines_of_code": 46,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 91.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 1 1: module Main has 42 lines of code \nInfo:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 26 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 26 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 27 1: function main has 19 lines of code \nInfo:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 27 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Test.hs\" 27 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Test.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Monad.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Monad.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 37,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 37,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 1 1: module Monad has 26 lines of code \nInfo:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 13 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 13 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 22 1: function test has 11 lines of code \nInfo:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Monad.hs\" 22 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Monad.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Cut.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 10,
              "lines_of_code": 69,
              "homplexity_lines_of_code": 82,
              "code_quality_score": 83.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 82,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 1 1: module Cut has 58 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 27 1: function tests has 14 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 44 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 44 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 45 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 45 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 45 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 47 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 47 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 48 1: function genN has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 48 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 48 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 51 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 51 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 61 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 61 1: function test has 8 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut.hs\" 61 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Cut.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Empty.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Empty.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 59,
              "homplexity_lines_of_code": 70,
              "code_quality_score": 87.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 70,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 1 1: module Empty has 49 lines of code \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 23 1: function tests has 17 lines of code \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 43 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 44 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 56 1: function test has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 56 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Empty.hs\" 56 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Empty.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Fresh.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Fresh.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 87.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 1 1: module Fresh has 43 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 20 1: function tests has 16 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 39 1: type signature for gen has 2 arguments \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 39 1: type signature for gen has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 40 1: function gen has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 40 1: function gen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 40 1: function gen has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 43 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 43 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 50 1: function test has 3 lines of code \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 50 1: function test has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Fresh.hs\" 50 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Fresh.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 32,
              "homplexity_lines_of_code": 41,
              "code_quality_score": 89.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 41,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 26 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 28 1: type signature for state has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 28 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 29 1: function state has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 29 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 29 1: function state has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 31 1: type signature for error has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 31 1: type signature for error has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 32 1: function error has 1 lines of code \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 32 1: function error has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/NonDet/Church.hs\" 32 1: function error has cyclomatic complexity of 1 \n"
              },
              "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/NonDet/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Cut/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/test/Cut/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 18,
              "code_quality_score": 96.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 18,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 1 1: module Cut.Church has 13 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 11 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 11 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 12 1: function tests has 5 lines of code \nInfo:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 12 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/test/Cut/Church.hs\" 12 1: function tests has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/test/Cut/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Inference.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Inference.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 54,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 1 1: module Inference has 29 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 19 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 19 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 20 1: function example has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 20 1: function example has 7 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 20 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 39 1: type signature for askEnv has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 39 1: type signature for askEnv has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 40 1: function askEnv has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 40 1: function askEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 40 1: function askEnv has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 45 1: type signature for runEnv has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 45 1: type signature for runEnv has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 46 1: function runEnv has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 46 1: function runEnv has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 46 1: function runEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Inference.hs\" 50 26: data HasEnv has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Inference.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Utils.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Utils.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.3333333333333333,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 20,
              "homplexity_lines_of_code": 19,
              "code_quality_score": 90.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.3333333333333333,
                  "sum": 4
                },
                "homplexity_loc": 19,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 1 1: module Utils has 14 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 8 5: data TestTree has record fields count of 4 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 11 1: type signature for checkTestTree has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 11 1: type signature for checkTestTree has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 16 1: type signature for testGroup has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 16 1: type signature for testGroup has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 17 1: function testGroup has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 17 1: function testGroup has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 17 1: function testGroup has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 19 1: type signature for testProperty has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 19 1: type signature for testProperty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 20 1: function testProperty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 20 1: function testProperty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Utils.hs\" 20 1: function testProperty has cyclomatic complexity of 1 \n"
              },
              "original_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Utils.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Parser.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.2222222222222223,
                "sum": 11
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 166,
              "homplexity_lines_of_code": 208,
              "code_quality_score": 57.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.2222222222222223,
                  "sum": 11
                },
                "homplexity_loc": 208,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 1 1: module Parser has 127 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 28 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 28 1: type signature for example has 1 arguments \nCritical:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 29 1: function example has 63 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 29 1: function example has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 29 1: function example has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 116 3: data Symbol has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 119 1: type signature for satisfy has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 119 1: type signature for satisfy has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 120 1: function satisfy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 120 1: function satisfy has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 120 1: function satisfy has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 122 1: type signature for char has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 122 1: type signature for char has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 123 1: function char has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 123 1: function char has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 123 1: function char has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 125 1: type signature for digit has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 125 1: type signature for digit has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 126 1: function digit has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 126 1: function digit has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 126 1: function digit has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 128 1: type signature for parens has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 128 1: type signature for parens has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 129 1: function parens has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 129 1: function parens has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 129 1: function parens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 132 1: type signature for parse has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 132 1: type signature for parse has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 133 1: function parse has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 133 1: function parse has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 133 1: function parse has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 137 22: data ParseC has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 151 1: type signature for expr has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 151 1: type signature for expr has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 152 1: function expr has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 152 1: function expr has 4 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 152 1: function expr has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 157 1: type signature for term has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 157 1: type signature for term has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 158 1: function term has 4 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 158 1: function term has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 158 1: function term has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 163 1: type signature for factor has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 163 1: type signature for factor has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 164 1: function factor has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 164 1: function factor has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Parser.hs\" 164 1: function factor has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Parser.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = exhaustive Control.Monad.<=< (runState input . runParseC)\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Main.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 20,
              "homplexity_lines_of_code": 22,
              "code_quality_score": 95.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 22,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 1 1: module Main has 16 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 14 1: function main has 6 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Main.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/ReinterpretLog.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.1428571428571428,
                "sum": 8
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 165,
              "homplexity_lines_of_code": 100,
              "code_quality_score": 74.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.1428571428571428,
                  "sum": 8
                },
                "homplexity_loc": 100,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 12 1: module ReinterpretLog has 81 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 47 5: data Message has record fields count of 2 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has branching depth of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has cyclomatic complexity of 2 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has 4 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 79 3: data Log has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 83 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 83 1: type signature for log has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 92 26: data LogStdoutC has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 112 35: data ReinterpretLogC has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 137 37: data CollectLogMessagesC has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 158 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 158 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has 6 lines of code \n"
              },
              "original_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/ReinterpretLog.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 81,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 73.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 9
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 1 1: module Labelled has 58 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 20 1: type signature for sample has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 20 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 24 1: function sample has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 24 1: function sample has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 24 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 26 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 26 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 32 1: type signature for numerically has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 32 1: type signature for numerically has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 36 1: function numerically has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 36 1: function numerically has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 36 1: function numerically has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 38 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 38 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 48 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 48 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 54 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 54 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 60 1: type signature for boolean has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 60 1: type signature for boolean has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 64 1: function boolean has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 64 1: function boolean has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 64 1: function boolean has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 66 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 66 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 77 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 77 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 78 1: function example has 3 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 78 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Labelled.hs\" 78 1: function example has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Teletype.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/examples/Teletype.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 79,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 84.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 44 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 48 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 48 1: type signature for read has 1 arguments \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 49 1: function read has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 49 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 49 1: function read has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 51 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 51 1: type signature for write has 2 arguments \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 52 1: function write has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 52 1: function write has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 52 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 55 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/static_refactored/examples/Teletype.hs\" 68 28: data TeletypeRetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/examples/Teletype.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Algebra.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Algebra.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 8,
                "average": 3,
                "sum": 71
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 15,
              "lines_of_code": 343,
              "homplexity_lines_of_code": 334,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 8,
                  "average": 3,
                  "sum": 71
                },
                "homplexity_loc": 334,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"thread\": 1,\n        \"run\": 1,\n        \"send\": 1,\n        \"toRWSTF\": 1,\n        \"swapAndLift\": 1,\n        \"alg_Lift_IO\": 1,\n        \"alg_Lift_Identity\": 1,\n        \"alg_Choose_NonEmpty\": 1,\n        \"alg_Empty_Maybe\": 1,\n        \"alg_Error_Either\": 2,\n        \"alg_Reader_arrow\": 2,\n        \"alg_NonDet_List\": 2,\n        \"alg_Writer_Tuple\": 3,\n        \"alg_ErrorPlus_sig_ExceptT\": 3,\n        \"alg_EmptyPlus_sig_MaybeT\": 2,\n        \"alg_ReaderPlus_sig_ReaderT\": 3,\n        \"alg_RWS_CPS\": 8,\n        \"alg_RWS_Lazy\": 8,\n        \"alg_RWS_Strict\": 8,\n        \"alg_State_Lazy\": 3,\n        \"alg_State_Strict\": 3,\n        \"alg_Writer_CPS\": 4,\n        \"alg_Writer_Lazy\": 4,\n        \"alg_Writer_Strict\": 4,\n        \"alg_Accum\": 3,\n        \"min\": 1,\n        \"max\": 8,\n        \"average\": 2.84,\n        \"sum\": 71\n    },\n    \"homplexity_loc\": 334,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Algebra.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 80,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 70,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 90.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 31 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 39,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 15 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has branching depth of 0 \n"
              },
              "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 62,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Fail.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Fail.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Fail.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 108,
              "homplexity_lines_of_code": 40,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 40,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 30 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has 3 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has 3 lines of code \n"
              },
              "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 40,
              "homplexity_lines_of_code": 15,
              "code_quality_score": 96.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 15,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 1 1: module Control.Effect.Cull has 14 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 28 3: data Cull has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Cull.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs",
              "cyclomatic_complexity": {
                "min": 3,
                "max": 3,
                "average": 3.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 88,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 3,
                  "max": 3,
                  "average": 3.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 1 1: module Control.Effect.Sum has 48 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 26 5: data f has record fields count of 2 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 42 3: type class Member has method + value count of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 42 3: type class Member has associated type count of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has 4 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has cyclomatic complexity of 3 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Sum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 13,
              "code_quality_score": 96.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 13,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 12 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 68,
              "homplexity_lines_of_code": 27,
              "code_quality_score": 91.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 27,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 1 1: module Control.Effect.Lift has 24 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Error.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Error.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 24,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 156,
              "homplexity_lines_of_code": 77,
              "code_quality_score": 82.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 77,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 1 1: module Control.Effect.Choose has 72 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Choose.hs\" 118 24: data Choosing has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 29 3: data Trace has record fields count of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 152,
              "homplexity_lines_of_code": 152,
              "code_quality_score": 60.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 12
                },
                "homplexity_loc": 152,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runLabelled\": 1,\n        \"alg_Labelled\": 2,\n        \"injLabelled_reflexivity\": 1,\n        \"injLabelled_left_recursion\": 1,\n        \"injLabelled_left_occurrence\": 1,\n        \"injLabelled_right_recursion\": 1,\n        \"sendLabelled\": 1,\n        \"runUnderLabel\": 1,\n        \"lift\": 1,\n        \"alg_UnderLabel\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 152,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 73,
              "homplexity_lines_of_code": 27,
              "code_quality_score": 91.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 27,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 24 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 33 3: data Cut has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 60 1: type signature for call has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 60 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 20,
              "code_quality_score": 94.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 20,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 15 1: module Control.Effect.Empty has 17 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has 2 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has branching depth of 1 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 37,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 1 1: module Control.Effect.Fresh has 16 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 25 3: data Fresh has record fields count of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Fresh.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Reader/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 9,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 57,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 91.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 1 1: module Control.Effect.Reader.Labelled has 27 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/NonDet/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 13,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Choose/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Choose/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Empty/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 98.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 11,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Empty/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Accum/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/State/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 95,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 84.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 1 1: module Control.Effect.State.Labelled has 33 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has 1 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has 1 lines of code \n"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Throw/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 98.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 11,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Writer/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Catch/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Error/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Error/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Error/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift/Internal.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Effect/Lift/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 105,
              "homplexity_lines_of_code": 68,
              "code_quality_score": 91.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 68,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 1 1: module Control.Carrier.Reader has 67 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Reader.hs\" 47 25: data ReaderC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 42,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 95.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 1 1: module Control.Carrier.Lift has 27 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Lift.hs\" 33 21: data LiftC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Interpret.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Interpret.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 101,
              "homplexity_lines_of_code": 99,
              "code_quality_score": 78.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 6
                },
                "homplexity_loc": 99,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runInterpret\": 1,\n        \"runInterpretState\": 1,\n        \"reify\": 1,\n        \"lift\": 1,\n        \"alg\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 99,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Interpret.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 134,
              "homplexity_lines_of_code": 84,
              "code_quality_score": 85.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 84,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 1 1: module Control.Carrier.NonDet.Church has 81 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has 5 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 78 23: data NonDetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 109,
              "homplexity_lines_of_code": 71,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 71,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 1 1: module Control.Carrier.Choose.Church has 69 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Choose/Church.hs\" 63 23: data ChooseC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Choose/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 33 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 33 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 36,
              "code_quality_score": 94.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 36,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 35 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 46 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 94,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 87.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" (-1) (-1): module Control.Carrier.Cull.Church has 60 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has 5 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cull/Church.hs\" 64 21: data CullC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cull/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 87,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 35 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 81 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 141,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 85.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 1 1: module Control.Carrier.Empty.Church has 78 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Empty/Church.hs\" 82 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 95.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 27 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 133,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 86.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" (-1) (-1): module Control.Carrier.Accum.Church has 75 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Church.hs\" 79 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 99,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 87.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" (-1) (-1): module Control.Carrier.Accum.IORef has 54 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has 5 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 88 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 136,
              "homplexity_lines_of_code": 83,
              "code_quality_score": 85.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 83,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" (-1) (-1): module Control.Carrier.Accum.Strict has 80 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 77 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" (-1) (-1): module Control.Carrier.Fresh.Strict has 37 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 129,
              "homplexity_lines_of_code": 76,
              "code_quality_score": 86.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 76,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 1 1: module Control.Carrier.State.Lazy has 73 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Lazy.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Lazy.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 129,
              "homplexity_lines_of_code": 79,
              "code_quality_score": 86.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 79,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" (-1) (-1): module Control.Carrier.State.Church has 76 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Church.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 107,
              "homplexity_lines_of_code": 73,
              "code_quality_score": 84.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 73,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 1 1: module Control.Carrier.State.IORef has 60 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has 5 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has 4 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has 3 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/IORef.hs\" 96 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 127,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 86.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 1 1: module Control.Carrier.State.Strict has 72 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/State/Strict.hs\" 75 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" (-1) (-1): module Control.Carrier.Throw.Either has 32 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Throw/Either.hs\" 34 24: data ThrowC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 82,
              "homplexity_lines_of_code": 49,
              "code_quality_score": 91.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 49,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" (-1) (-1): module Control.Carrier.Writer.Church has 47 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Church.hs\" 66 25: data WriterC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 78,
              "homplexity_lines_of_code": 51,
              "code_quality_score": 90.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 51,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" (-1) (-1): module Control.Carrier.Writer.Strict has 49 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 60 25: data WriterC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 123,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 85.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 1 1: module Control.Carrier.Cut.Church has 78 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has 5 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Cut/Church.hs\" 67 20: data CutC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Cut/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 58,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 94.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 1 1: module Control.Carrier.Error.Either has 30 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has 2 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Either.hs\" 46 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 113,
              "homplexity_lines_of_code": 74,
              "code_quality_score": 90.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 74,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 1 1: module Control.Carrier.Error.Church has 73 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has 4 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has branching depth of 0 \nInfo:/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Carrier/Error/Church.hs\" 50 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs",
              "refactored_file_name": "/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 96.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 11,
                "homplexity_output": "Info:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 1 1: module Control.Algebra.Handler has 10 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has type constructor nesting of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has 3 arguments \nInfo:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has 1 lines of code \nInfo:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has cyclomatic complexity of 1 \nInfo:/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_94/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/src/Control/Algebra/Handler.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/README.lhs",
              "refactored_file_name": "/tmp/project_94/static_refactored/README.lhs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 1,
              "homplexity_lines_of_code": 1,
              "code_quality_score": 99.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 1,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 1,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "README.md",
              "suggestions": [
                {
                  "location": "/tmp/project_94/pre_refactor/README.lhs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "README.md"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 40,
              "max": 45,
              "average": 2.697674418604651,
              "sum": 116
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 10,
              "suggestion": 1,
              "ignore": 0,
              "total": 11
            },
            "syntax_errors": 169,
            "lines_of_code": 2652,
            "homplexity_lines_of_code": 1920,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Writer.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 42,
              "homplexity_lines_of_code": 42,
              "code_quality_score": 91.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 42,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 17 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 17 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has 13 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 40 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 40 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 41 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 41 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Writer.hs\" 41 1: function tellLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
              "suggestions": [
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif",
                  "refactored_suggestion": "-- The CPP guarded import of `Control.Monad.Trans.Writer.CPS` can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is never met or irrelevant. \n-- Remove this snippet if confirmed unnecessary.",
                  "confidence": 0.8,
                  "justification": "This is a conditional import guarded by a preprocessor directive. If it is determined that the specified version of the `transformers` package is no longer relevant to your project or builds, then this import should be removed to simplify the code and improve maintainability."
                },
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif",
                  "refactored_suggestion": "-- The CPP guarded code for benchmark 'CPS.WriterT' can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is no longer relevant.\n-- Remove this snippet alongside related imports and references if it is not applicable.",
                  "confidence": 0.8,
                  "justification": "This benchmark snippet is guarded by the same conditional compilation directive. If the `MIN_VERSION_transformers(0,5,6)` check is no longer relevant to your supported build setups, this benchmark can also be removed to clean up unused or unreachable code."
                },
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif",
                  "refactored_suggestion": "-- The CPP guarded code for the IO benchmark 'CPS.WriterT' can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is irrelevant.\n-- Remove this snippet alongside related imports and references if confirmed unnecessary.",
                  "confidence": 0.8,
                  "justification": "Similar to the previous benchmark snippet, this is conditionally compiled using the `MIN_VERSION_transformers(0,5,6)` directive. If the condition is no longer relevant for the project, this IO benchmark should also be removed to eliminate dead code and improve clarity."
                },
                {
                  "target_snippet": "tellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}",
                  "refactored_suggestion": "tellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i $ tell (Sum 1)\n{-# INLINE tellLoop #-}",
                  "confidence": 1.0,
                  "justification": "The type annotation `(1 :: Int)` is unnecessary because the type can already be inferred from the context of the `Sum` monoid. This refactor simplifies the code while maintaining the exact same functionality and behavior."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n-- The CPP guarded import of `Control.Monad.Trans.Writer.CPS` can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is never met or irrelevant. \n-- Remove this snippet if confirmed unnecessary.\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n-- The CPP guarded code for benchmark 'CPS.WriterT' can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is no longer relevant.\n-- Remove this snippet alongside related imports and references if it is not applicable.\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n-- The CPP guarded code for the IO benchmark 'CPS.WriterT' can be removed if the `MIN_VERSION_transformers(0,5,6)` condition is irrelevant.\n-- Remove this snippet alongside related imports and references if confirmed unnecessary.\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i $ tell (Sum 1)\n{-# INLINE tellLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/Reader.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 45,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 32 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet",
                  "refactored_suggestion": "-- The code appears complete and there are no necessary changes based on the analysis output.\n-- Leaving the code as-is since no refactoring improvements or dead code was identified.",
                  "confidence": 1.0,
                  "justification": "Upon reviewing the provided code and suggestions, no dead or unused code is identified. Additionally, the provided static analysis suggestions from the tools (HLint and Weeder) do not indicate any necessary changes."
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/State.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 40,
              "code_quality_score": 92.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 40,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 1 1: module Bench.State has 24 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "target_snippet": "modLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}",
                  "refactored_suggestion": "modLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (\\j -> modify (+ j))\n{-# INLINE modLoop #-}",
                  "confidence": 0.9,
                  "justification": "The original code uses a point-free style (modify . (+)), which may be less clear for some readers. Changing to an explicit lambda (\\j -> modify (+ j)) can improve readability without sacrificing performance."
                },
                {
                  "target_snippet": "import Control.Carrier.State.Lazy as C.Lazy",
                  "refactored_suggestion": "-- import Control.Carrier.State.Lazy as C.Lazy",
                  "confidence": 0.8,
                  "justification": "The module `Control.Carrier.State.Lazy` is imported but is never used in the code. Removing the unused import helps to clean up the code."
                },
                {
                  "target_snippet": "import Control.Carrier.State.Strict as C.Strict",
                  "refactored_suggestion": "-- import Control.Carrier.State.Strict as C.Strict",
                  "confidence": 0.8,
                  "justification": "The module `Control.Carrier.State.Strict` is imported but is never used in the code. This import can safely be removed to simplify the code."
                },
                {
                  "target_snippet": "import Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)",
                  "refactored_suggestion": "-- import Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)",
                  "confidence": 0.8,
                  "justification": "The module `Control.Monad.Trans.State.Lazy` is imported but is never used in the code. Removing unused imports improves code readability and avoids confusion."
                },
                {
                  "target_snippet": "import Control.Monad.Trans.State.Strict as T.Strict (execStateT)",
                  "refactored_suggestion": "-- import Control.Monad.Trans.State.Strict as T.Strict (execStateT)",
                  "confidence": 0.8,
                  "justification": "Like other unused imports, the module `Control.Monad.Trans.State.Strict` is never actually used in the code. Removing unused imports avoids unnecessary complexity."
                }
              ],
              "refactored_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\n-- import Control.Carrier.State.Lazy as C.Lazy\n-- import Control.Carrier.State.Strict as C.Strict\n-- import Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\n-- import Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (\\j -> modify (+ j))\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 55,
              "code_quality_score": 84.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 55,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 40 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 23 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 32 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 32 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 33 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 33 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 33 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 38 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 38 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 39 1: function addOne has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 39 1: function addOne has 6 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 39 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 46 1: type signature for queens has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 46 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 47 1: function queens has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 47 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 47 1: function queens has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function benchmark has 4 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
              "suggestions": [
                {
                  "target_snippet": "qs' = zip [1..length qs] qs",
                  "refactored_suggestion": "qs' = zip [1..] qs",
                  "confidence": 1.0,
                  "justification": "Using `zip [1..] qs` automatically creates an infinite list starting from 1, which is sufficient for zipping with `qs`. This avoids invoking `length qs`, which is unnecessary and potentially less efficient. This change improves code performance slightly and makes the code more idiomatic."
                },
                {
                  "target_snippet": "queens n = foldl' (>>=) (pure empty) (replicate n (addOne n))",
                  "refactored_suggestion": "queens n = foldM (const . addOne n) [] [1..n]",
                  "confidence": 0.9,
                  "justification": "The `foldM` function is a more natural way to express monadic folding operations. The rewritten version is more concise, improves readability, and avoids the use of `replicate`, which requires the intermediate generation of a list. The semantics of the function remain unchanged."
                },
                {
                  "target_snippet": "import Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench",
                  "refactored_suggestion": "import Control.Applicative (Alternative, asum, empty, pure)\nimport Control.Monad (guard, Monad)\nimport Data.Foldable (foldl', null)\nimport qualified Data.List as List (intersect)\nimport Test.Tasty.Bench (Benchmark, bgroup, bench, whnf)",
                  "confidence": 0.8,
                  "justification": "Restricting imports to only the functions and types that are actually used in the codebase makes the imports clearer and avoids potential namespace pollution or silent conflicts in the future. This is a good practice for maintaining codebase hygiene."
                },
                {
                  "target_snippet": "{-# OPTIONS_GHC -Wno-unused-imports #-}",
                  "refactored_suggestion": "-- Reason: There are no unused imports anymore. This GHC warning suppression is redundant and should be removed.\n",
                  "confidence": 1.0,
                  "justification": "The module doesn't contain any unused imports after refactoring, so the suppression for `-Wunused-imports` is no longer required. Removing unnecessary warning suppressions leads to cleaner and more robust code."
                },
                {
                  "target_snippet": "diags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]",
                  "refactored_suggestion": "diags :: Square -> [Diagonal]\ndiags (i, j) = [Row i, Col j, Backslash (j - i), Forwardslash (i + j)]",
                  "confidence": 0.7,
                  "justification": "The alternate formatting reduces unnecessary line breaks and improves readability without changing the code's behavior. This makes the function more concise and inline with commonly adopted Haskell style guidelines."
                },
                {
                  "target_snippet": "-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic",
                  "refactored_suggestion": "-- Reason: This comment provides attribution for the code origin, but ensure the usage complies with the original license. Keep this unless there's a license issue restricting the reuse under current conditions.",
                  "confidence": 1.0,
                  "justification": "The comment ensures proper credit is given to the original source of the implementation. If there are further restrictions in the license, the reuse may require additional clarification, otherwise, this attribution should stay intact."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n-- Reason: There are no unused imports anymore. This GHC warning suppression is redundant and should be removed.\n\n\n-- Reason: This comment provides attribution for the code origin, but ensure the usage complies with the original license. Keep this unless there's a license issue restricting the reuse under current conditions.\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative (Alternative, asum, empty, pure)\nimport Control.Monad (guard, Monad)\nimport Data.Foldable (foldl', null)\nimport qualified Data.List as List (intersect)\nimport Test.Tasty.Bench (Benchmark, bgroup, bench, whnf)\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i, j) = [Row i, Col j, Backslash (j - i), Forwardslash (i + j)]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldM (const . addOne n) [] [1..n]\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Reader.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 75,
              "homplexity_lines_of_code": 86,
              "code_quality_score": 83.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 86,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 1 1: module Reader has 64 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 27 1: function tests has 15 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 45 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 45 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 51 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 51 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 51 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 53 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 53 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 59 1: function genN has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 59 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 59 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 62 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 62 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 70 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 70 1: function test has 5 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Reader.hs\" 70 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "gen0 r m a = [label \"asks\" (asks @r) <*> fn a]",
                  "refactored_suggestion": "gen0 _ a = [label \"asks\" (asks @r) <*> fn a]",
                  "confidence": 0.9,
                  "justification": "The variable `r` is not used in the definition of `gen0`. By replacing `r` with `_`, we make it clear that the parameter is unused, improving clarity and reducing the chance of confusion."
                },
                {
                  "target_snippet": "testMonad run = Monad.test (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run",
                  "refactored_suggestion": "testMonad run = Monad.test (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run",
                  "confidence": 1.0,
                  "justification": "After review, no improvements or adjustments are necessary for this snippet. It is already clean, concise, and fulfills its intended purpose without unnecessary complexity."
                },
                {
                  "target_snippet": "runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r",
                  "refactored_suggestion": "runRWST f r m = fmap (\\ (a, _, ()) -> a) (f m r r)",
                  "confidence": 0.95,
                  "justification": "Refactored for better readability and using the `fmap` function explicitly instead of the `<$>` operator, which enhances clarity by making the operation more explicit for readers unfamiliar with infix style."
                },
                {
                  "target_snippet": "testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $ \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))",
                  "refactored_suggestion": "-- testProperty for 'ask' duplicated logic and doesn't improve functionality. Recommended for removal.\n-- reason: Test logic is trivially identical in repeated comparisons and lacks unique value.",
                  "confidence": 0.8,
                  "justification": "This snippet introduces duplicate test logic and does not add meaningful value. Removing it simplifies the test suite while preserving coverage and functionality."
                },
                {
                  "target_snippet": "testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $ \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))",
                  "refactored_suggestion": "-- testProperty for 'local' duplicated logic and doesn't improve functionality. Recommended for removal.\n-- reason: Duplicated validation logic with no unique scenario or case testing.",
                  "confidence": 0.8,
                  "justification": "This test case introduces similar redundancy as the 'ask' case above; recommendation to remove in favor of simpler and more focused testing logic ensures coverage is not compromised."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = fmap (\\ (a, _, ()) -> a) (f m r r)\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Fail.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Fail.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 3,
                "suggestion": 0,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 6,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 55,
              "code_quality_score": 88.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 55,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 1 1: module Fail has 40 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "[ testMonad, testMonadFix, testFail ] >>= ($ runL FailC.runFail)",
                  "refactored_suggestion": "[ testMonad, testMonadFix, testFail ] |> (runL FailC.runFail)",
                  "confidence": 0.85,
                  "justification": "The use of `>>=` for function application inside a `testGroup` seems unconventional. Given this syntax, the `|>` operator (from certain libraries like `pipes`) reads more declaratively and reflects a flow of data better. However, if `|>` isn't preferred or available in the dependencies, `>>=` can remain. Confidence is marked less than 1 due to possible constraints in library imports."
                },
                {
                  "target_snippet": "gen0 e _ = [ label \"fail\" Fail.fail <*> e ]",
                  "refactored_suggestion": "gen0 e _ = [ label \"fail\" $ Fail.fail <*> e ]",
                  "confidence": 0.95,
                  "justification": "Using `$` here improves readability and adheres to idiomatic Haskell style for function application. It avoids the confusion of mixing operators and gives clear precedence between operations."
                },
                {
                  "target_snippet": "{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}",
                  "refactored_suggestion": "-- The OPTIONS_GHC pragma was removed because it suppresses unused pragma warnings and is unnecessary in environments without unrecognized pragmas.",
                  "confidence": 1.0,
                  "justification": "The `OPTIONS_GHC` pragma suppressing warnings about unrecognized pragmas is unnecessary unless the codebase actually includes such pragmas. It is better to remove it to avoid confusion for maintainers and promote clean practices."
                },
                {
                  "target_snippet": "{-# HLINT ignore \"Eta reduce\" #-}",
                  "refactored_suggestion": "-- The HLint ignore directive was removed, as no eta reduction issues are present in the code that necessitate its inclusion.",
                  "confidence": 1.0,
                  "justification": "The HLint directive is not needed since the codebase does not have any eta reduction issues. Removing unnecessary HLint ignores promotes cleaner code."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- The OPTIONS_GHC pragma was removed because it suppresses unused pragma warnings and is unnecessary in environments without unrecognized pragmas.\n-- The HLint ignore directive was removed, as no eta reduction issues are present in the code that necessitate its inclusion.\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" $ Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/State.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 85,
              "homplexity_lines_of_code": 100,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 100,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 1 1: module State has 68 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 30 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 30 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 31 1: function tests has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 31 1: function tests has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 31 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 61 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 61 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 67 1: function gen0 has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 73 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 73 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 80 1: function test has 5 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 80 1: function test has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/State.hs\" 80 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "[ testGroup \"StateC (Church)\"   $ [ testMonad, testMonadFix, testState ] >>= ($ runC (C.Church.runState (curry pure))) ]",
                  "refactored_suggestion": "[ testGroup \"StateC (Church)\" [ testMonad, testMonadFix, testState ] >>= (runC . C.Church.runState . curry pure) ]",
                  "confidence": 0.9,
                  "justification": "The code can be simplified by directly composing functions rather than using a lambda. This simplifies the code and improves readability."
                },
                {
                  "target_snippet": "runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s",
                  "refactored_suggestion": "runRWST f s m = fmap (\\(a, s, ()) -> (s, a)) (f m s s)",
                  "confidence": 0.8,
                  "justification": "Using `fmap` over the `<$>` operator is preferred for clarity and consistency in this case."
                },
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6) ... #endif",
                  "refactored_suggestion": "-- reason: RWST (CPS) test group can be removed as MIN_VERSION_transformers(0,5,6) condition is specific to this version and is unused in newer versions. Remove all references and code surrounded by this CPP directive.",
                  "confidence": 0.95,
                  "justification": "Dead code has been identified. The conditional compilation for MIN_VERSION_transformers(0,5,6) introduces complexity and is not necessary for versions other than 0.5.6 of `transformers`. The surrounding code fragment and references inside can safely be removed if they are not needed in newer versions."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = fmap (\\(a, s, ()) -> (s, a)) (f m s s)\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Catch.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 1 1: module Catch has 32 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 14 1: function tests has 2 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 18 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 18 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 25 1: function genN has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 25 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 25 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 29 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 29 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 38 1: function test has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 38 1: function test has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Catch.hs\" 38 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests = testGroup \"Catch\" []",
                  "refactored_suggestion": "-- The 'tests' function is empty and unused. Remove it if not needed.\n-- Reason: Dead/unused code.\ntests = testGroup \"Catch\" []",
                  "confidence": 1.0,
                  "justification": "The function 'tests' doesn't add functionality as it is defined but not used or populated with any contents. Removing this will help reduce clutter and dead code in the module."
                },
                {
                  "target_snippet": "genN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]",
                  "refactored_suggestion": "genN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n-- NOTE: Consider reviewing if this function has valid uses or code calling it; otherwise, it might be dead code.",
                  "confidence": 0.7,
                  "justification": "The function 'genN' is defined, but there is no clear evidence in the current code that it is being used or called. This might be a placeholder or dead code. Double-check before deleting."
                },
                {
                  "target_snippet": "tests :: TestTree\ntests = testGroup \"Catch\" []",
                  "refactored_suggestion": "-- Removed unused `tests` definition and its type signature as it's redundant and not called anywhere in the code.\n-- Reason: Cleaning up dead/unused code.",
                  "confidence": 1.0,
                  "justification": "This section defines `tests` and its type signature, but it is empty and unused throughout the module. Removing it reduces clutter and focuses the file on relevant logic."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n-- NOTE: Consider reviewing if this function has valid uses or code calling it; otherwise, it might be dead code.\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Error.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Error.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 57,
              "homplexity_lines_of_code": 58,
              "code_quality_score": 86.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 58,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 1 1: module Error has 46 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 24 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 24 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 25 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 25 1: function tests has 9 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 25 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 36 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 36 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 37 1: function gen0 has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 37 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 37 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 39 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 39 1: type signature for genN has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 45 1: function genN has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 45 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 45 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 48 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 48 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 57 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 57 1: function test has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Error.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Error.hs\" 57 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n",
              "suggestions": [
                {
                  "target_snippet": "tests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit",
                  "refactored_suggestion": "tests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $ map ($ runL (C.Church.runError (pure . Left) (pure . Right))) [testMonad, testMonadFix, testError]\n  , testGroup \"ErrorC (Either)\" $ map ($ runL C.Either.runError) [testMonad, testMonadFix, testError]\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit",
                  "confidence": 0.9,
                  "justification": "Using 'map' instead of manually applying each function to 'runL' improves the readability and reduces verbosity by eliminating redundant code."
                },
                {
                  "target_snippet": "import           Data.Semigroup as S ((<>))",
                  "refactored_suggestion": "-- reason: The Semigroup operator (<>) is redundant because it is imported but already part of the Prelude in modern GHC versions.\n-- import           Data.Semigroup as S ((<>))",
                  "confidence": 1.0,
                  "justification": "The (<>) operator is already included in the Prelude by default in recent GHC versions, making this import unnecessary. Removing it improves clarity and avoids redundancy."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\n-- reason: The Semigroup operator (<>) is redundant because it is imported but already part of the Prelude in modern GHC versions.\n-- import           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $ map ($ runL (C.Church.runError (pure . Left) (pure . Right))) [testMonad, testMonadFix, testError]\n  , testGroup \"ErrorC (Either)\" $ map ($ runL C.Either.runError) [testMonad, testMonadFix, testError]\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Choose.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 52,
              "homplexity_lines_of_code": 53,
              "code_quality_score": 88.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 53,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 1 1: module Choose has 38 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 18 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 18 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 19 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 19 1: function tests has 9 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 19 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 35 1: type signature for genN has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 35 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 36 1: function genN has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 36 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 36 1: function genN has branching depth of 0 \nWarning:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 39 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 39 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 47 1: function test has 5 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Choose.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Choose.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "testMonad    run = Monad.test    (m mempty genN) a b c initial run",
                  "refactored_suggestion": "-- Monad.test is unused and can be removed.\n-- Removing the line saves unnecessary dependencies and keeps the code cleaner.",
                  "confidence": 0.9,
                  "justification": "The `testMonad` function calls `Monad.test`, which is not used in any tests or exported from the module. Thus, it contributes no functionality and can safely be removed to enhance maintainability."
                },
                {
                  "target_snippet": "testMonadFix run = MonadFix.test (m mempty genN) a b   initial run",
                  "refactored_suggestion": "-- MonadFix.test is unused and can be removed.\n-- Removing the line simplifies the code since it has no impact on the functionality.",
                  "confidence": 0.9,
                  "justification": "The `testMonadFix` function calls `MonadFix.test`, which is not used in any way in the current module or exported. This is dead code and should be removed to declutter the module."
                },
                {
                  "target_snippet": "testGroup \"ChooseC\"  $ [ testMonad , testMonadFix , testChoose ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))",
                  "refactored_suggestion": "-- Both `testMonad` and `testMonadFix` are unused; remove them.\n-- Refactor to only include `testChoose`, as the others provide no value.\ntestGroup \"ChooseC\"  $ [ testChoose ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))",
                  "confidence": 0.9,
                  "justification": "The `testMonad` and `testMonadFix` functions do not contribute any functionality or output to the test suite since we found that they are never used. Removing them simplifies the test group."
                },
                {
                  "target_snippet": "genN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]",
                  "refactored_suggestion": "genN m a = [ addLabel \"Choose Operator (<|>)\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]",
                  "confidence": 0.8,
                  "justification": "Renaming the label in `addLabel` to something more descriptive (e.g., `Choose Operator (<|>)`) improves clarity and documentation in test output. This helps both developers and test systems to better understand the purpose of these tests."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  -- Monad.test is unused and can be removed.\n-- Removing the line saves unnecessary dependencies and keeps the code cleaner.\n  -- MonadFix.test is unused and can be removed.\n-- Removing the line simplifies the code since it has no impact on the functionality.\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"Choose Operator (<|>)\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Test.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Test.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 20,
              "lines_of_code": 46,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 91.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 1 1: module Main has 42 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 26 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 26 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 27 1: function main has 19 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 27 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Test.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Test.hs\" 27 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "map checkTestTree",
                  "refactored_suggestion": "mapM_ checkTestTree",
                  "confidence": 0.9,
                  "justification": "Using `mapM_` is preferable when performing side effects (like IO actions) instead of `map`. This avoids constructing unnecessary intermediate lists, making the code more efficient and idiomatic."
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ mapM_ checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/Fresh.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/Fresh.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 51,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 51,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 1 1: module Fresh has 37 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 33 1: type signature for gen has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 33 1: type signature for gen has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 34 1: function gen has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 34 1: function gen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 34 1: function gen has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 37 1: type signature for test has 5 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 44 1: function test has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 44 1: function test has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/Fresh.hs\" 44 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)",
                  "refactored_suggestion": "tests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\"\n      ( map ($ runC (C.Church.runFresh (curry pure))) [testMonad, testMonadFix, testFresh] )\n  , testGroup \"FreshC (Strict)\"\n      ( map ($ runC C.Strict.runFresh) [testMonad, testMonadFix, testFresh] )\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)",
                  "confidence": 1.0,
                  "justification": "Using `map` removes redundant repetition and makes the code more concise, improving readability and maintainability."
                },
                {
                  "target_snippet": "gen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]",
                  "refactored_suggestion": "gen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ] -- Consider renaming `a` to a more descriptive name, like `term` or `genTerm`, for clarity.",
                  "confidence": 0.8,
                  "justification": "Renaming `a` could improve code readability by making the purpose of the parameter more apparent. However, this is a minor improvement and can be left as is if `a` is already understood in the codebase."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\"\n      ( map ($ runC (C.Church.runFresh (curry pure))) [testMonad, testMonadFix, testFresh] )\n  , testGroup \"FreshC (Strict)\"\n      ( map ($ runC C.Strict.runFresh) [testMonad, testMonadFix, testFresh] )\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ] -- Consider renaming `a` to a more descriptive name, like `term` or `genTerm`, for clarity.\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/test/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 30,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 94.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 22 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \n"
              },
              "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
              "suggestions": [
                {
                  "target_snippet": "state :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get",
                  "refactored_suggestion": "-- state function is defined but not used anywhere in the code, so it can be safely removed to clean up the codebase.",
                  "confidence": 1.0,
                  "justification": "The 'state' function is not referenced or used in the provided code and removing unused code helps prevent confusion, reduces code size, and makes the codebase more maintainable."
                },
                {
                  "target_snippet": "error :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure",
                  "refactored_suggestion": "-- error function is defined but not used anywhere in the code, so it can be safely removed to clean up the codebase.",
                  "confidence": 1.0,
                  "justification": "The 'error' function is not referenced or used in the provided code and removing unused code helps reduce maintenance overhead and improves readability."
                }
              ],
              "refactored_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\n-- state function is defined but not used anywhere in the code, so it can be safely removed to clean up the codebase.\n\n-- error function is defined but not used anywhere in the code, so it can be safely removed to clean up the codebase.\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Main.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/examples/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 6,
              "lines_of_code": 20,
              "homplexity_lines_of_code": 21,
              "code_quality_score": 95.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 21,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 1 1: module Main has 15 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 14 1: function main has 6 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Main.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Main.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "import           Utils",
                  "refactored_suggestion": "-- import           Utils",
                  "confidence": 1.0,
                  "justification": "The 'Utils' module is imported but not used anywhere in the provided code. Unused imports should be removed to improve code clarity and reduce potential confusion."
                },
                {
                  "target_snippet": "defaultMain $ map checkTestTree",
                  "refactored_suggestion": "defaultMain $ map id",
                  "confidence": 0.9,
                  "justification": "The function 'checkTestTree' is not defined or imported in the provided code. It seems incorrect and the mapping can be replaced with the identity function 'id' if this is intentional. Alternatively, ensure 'checkTestTree' is correctly provided."
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\n-- import           Utils\n\nmain :: IO ()\nmain = defaultMain $ map id\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/examples/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 71,
              "homplexity_lines_of_code": 70,
              "code_quality_score": 79.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 7
                },
                "homplexity_loc": 70,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 1 1: module Labelled has 49 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 18 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 18 1: type signature for sample has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 22 1: function sample has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 22 1: function sample has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 22 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 24 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 24 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 28 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 28 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 28 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 32 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 32 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 33 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 33 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 33 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 42 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 42 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 46 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 46 1: function sampleS has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 46 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 48 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 48 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 52 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 52 1: function helpersS has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 52 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 56 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 56 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 57 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 57 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 57 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 67 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 67 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 68 1: function example has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 68 1: function example has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Labelled.hs\" 68 1: function example has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif",
                  "refactored_suggestion": "-- Removed because the CPP condition imports Control.Applicative, but this library is already included in Prelude for base versions >= 4.8.0, making this unused for modern versions.",
                  "confidence": 1.0,
                  "justification": "The CPP directive checks for versions of base older than 4.18.0 to include the `Control.Applicative` module. However, since `Control.Applicative` has been included in `Prelude` starting from base 4.8.0 and the code does not specify compatibility with versions older than 4.8.0, this conditional import is irrelevant for modern setups."
                },
                {
                  "target_snippet": "numerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)",
                  "refactored_suggestion": "-- Removed because `numerically` is defined but never used in the module.",
                  "confidence": 1.0,
                  "justification": "The `numerically` function is defined but not used anywhere in the current module. Removing unused definitions helps keep the codebase clean and maintainable, reducing cognitive overhead."
                },
                {
                  "target_snippet": "boolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)",
                  "refactored_suggestion": "-- Removed because `boolean` is defined but never used in the module.",
                  "confidence": 1.0,
                  "justification": "The `boolean` function is defined but is not referenced or used anywhere within the module. Unused code should be removed to ensure the codebase remains clean and focused."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n-- Removed because the CPP condition imports Control.Applicative, but this library is already included in Prelude for base versions >= 4.8.0, making this unused for modern versions.\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\n-- Removed because `numerically` is defined but never used in the module.\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\n-- Removed because `boolean` is defined but never used in the module.\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/examples/Teletype.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/examples/Teletype.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 79,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 84.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 44 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 48 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 48 1: type signature for read has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 49 1: function read has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 49 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 49 1: function read has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 51 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 51 1: type signature for write has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 52 1: function write has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 52 1: function write has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 52 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 55 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/examples/Teletype.hs\" 68 28: data TeletypeRetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
              "suggestions": [
                {
                  "target_snippet": "write s = send (Write s)",
                  "refactored_suggestion": "write = send . Write",
                  "confidence": 0.9,
                  "justification": "Simplifies the definition of the 'write' function by using function composition, which leads to cleaner and more concise code."
                },
                {
                  "target_snippet": "genLine = Gen.string (Range.linear 0 20) Gen.unicode",
                  "refactored_suggestion": "genLine = Gen.text (Range.linear 0 20) Gen.unicode",
                  "confidence": 0.85,
                  "justification": "Using 'Gen.text' instead of 'Gen.string' provides more clarity since 'genLine' is used to generate lines of text. This improves readability and aligns more closely with the semantics of the code."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.text (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite = send . Write\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Writer.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 80,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
              "suggestions": [
                {
                  "target_snippet": "listens f = fmap (first f) . listen",
                  "refactored_suggestion": "listens f m = do { (w, a) <- listen m; pure (f w, a) }",
                  "confidence": 0.9,
                  "justification": "The existing implementation of `listens` uses function composition and `fmap` with `first`, which can be slightly harder to read for beginners and intermediate users. The proposed refactoring uses pattern matching and makes the operation more explicit, improving readability while maintaining the functionality."
                },
                {
                  "target_snippet": "tell w = send (Tell w)",
                  "refactored_suggestion": "tell w = send $ Tell w",
                  "confidence": 0.8,
                  "justification": "This refactor slightly changes the style for clarity and consistency, avoiding the direct function application with parentheses. This modification is subjective and may align better with certain Haskell style guides."
                }
              ],
              "refactored_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send $ Tell w\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f m = do { (w, a) <- listen m; pure (f w, a) }\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/NonDet.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 67,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 93.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 28 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}",
                  "refactored_suggestion": "-- This (#.) combinator seems unused in the module. Removing it to simplify the code.\n-- If it is needed later, it can always be restored.\n-- reason: unused code; not referenced anywhere",
                  "confidence": 0.9,
                  "justification": "A quick review of the provided code shows that the (#.) operator is not used anywhere within the module. Keeping unused functions in the codebase increases complexity and potential confusion without adding value. Removing it makes the codebase cleaner and easier to maintain. Should future uses arise, the implementation can easily be reinstated."
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- This (#.) combinator seems unused in the module. Removing it to simplify the code.\n-- If it is needed later, it can always be restored.\n-- reason: unused code; not referenced anywhere\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Throw.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.5,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 21,
              "code_quality_score": 91.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.5,
                  "sum": 3
                },
                "homplexity_loc": 21,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 17 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has cyclomatic complexity of 2 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has branching depth of 1 \n"
              },
              "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
              "suggestions": [
                {
                  "target_snippet": "liftEither = either throwError return",
                  "refactored_suggestion": "liftEither eitherValue = case eitherValue of\n  Left e  -> throwError e\n  Right a -> return a",
                  "confidence": 0.9,
                  "justification": "Replacing `liftEither` to use a pattern match instead of `either` increases readability by being explicit about the control flow. This is especially helpful for developers who may be less familiar with the `either` function. Additionally, it makes the intention clearer if extended or debugged in the future."
                }
              ],
              "refactored_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither eitherValue = case eitherValue of\n  Left e  -> throwError e\n  Right a -> return a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 62,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "target_snippet": "asks = (`fmap` ask)",
                  "refactored_suggestion": "asks f = fmap f ask",
                  "confidence": 0.9,
                  "justification": "This refactoring makes the code slightly more readable and explicit, as it directly states the relationship between the input function 'f' and the output computation."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- This part of the code is redundant and provides no useful functionality or additional explanation. It should be removed.",
                  "confidence": 1.0,
                  "justification": "The snippet suggests manual candidates but is not followed by any meaningful code or comments. It's essentially dead code and removing it will contribute to cleaner and more maintainable code."
                }
              ],
              "refactored_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks f = fmap f ask\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 108,
              "homplexity_lines_of_code": 40,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 40,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 30 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has 3 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 105 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 105 1: function state has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/State.hs\" 105 1: function state has 3 lines of code \n"
              },
              "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "target_snippet": "gets = (`fmap` get)",
                  "refactored_suggestion": "gets f = fmap f get",
                  "confidence": 1.0,
                  "justification": "The refactored version makes it explicit that `f` is being mapped over the result of `get`. This improves readability and maintains consistency with the rest of the codebase's style."
                },
                {
                  "target_snippet": "modifyLazy f = get >>= put . f",
                  "refactored_suggestion": "modifyLazy f = do { s <- get; put (f s) }",
                  "confidence": 0.9,
                  "justification": "Refactoring to a `do`-notation improves clarity and makes it easier to understand the sequence of operations, especially for new readers of the codebase."
                },
                {
                  "target_snippet": "state f = do\n  (s', a) <- gets f\n  a <$ put s'",
                  "refactored_suggestion": "state f = do\n  (newState, value) <- gets f\n  value <$ put newState",
                  "confidence": 0.8,
                  "justification": "Renaming the tuple elements to `newState` and `value` makes the function's semantics clearer and avoids ambiguity in variable names."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "",
                  "confidence": 1.0,
                  "justification": "The placeholder `-- Manual candidate snippet Perhaps` is non-functional and provides no value. As such, it should be removed from the final code."
                }
              ],
              "refactored_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets f = fmap f get\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = do { s <- get; put (f s) }\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (newState, value) <- gets f\n  value <$ put newState\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Catch.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 12,
              "code_quality_score": 96.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 12,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 11 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
              "suggestions": [
                {
                  "target_snippet": "catchError m h = send (Catch m h)",
                  "refactored_suggestion": "catchError = send . Catch",
                  "confidence": 0.95,
                  "justification": "The function 'catchError' can be reduced to a point-free style since it directly wraps 'm' and 'h' into 'Catch' and sends it. This makes the code more concise without losing readability. INLINE pragma remains applicable for performance optimization."
                },
                {
                  "target_snippet": "import Control.Effect.Catch.Internal (Catch(..))",
                  "refactored_suggestion": "-- import Control.Effect.Catch.Internal (Catch(..))",
                  "confidence": 0.8,
                  "justification": "The module 'Control.Effect.Catch.Internal' is not directly required to be exposed to the user of the effect (it's presumably only used internally). Consider removing it from publicity to emphasize encapsulation and ensure API cleanliness."
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n-- import Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError = send . Catch\n{-# INLINE catchError #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 68,
              "homplexity_lines_of_code": 27,
              "code_quality_score": 91.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 27,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 1 1: module Control.Effect.Lift has 24 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift.hs: Suggestion: No suggestions",
                  "refactored_suggestion": "-- The file does not require any suggestions based on HLint and Weeder analysis --",
                  "confidence": 1.0,
                  "justification": "Both HLint and Weeder static analyzers did not suggest any improvements or indicate any dead or unused code in the provided Haskell file. The implementation is clean and optimized as is."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Trace.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 29 3: data Trace has record fields count of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
              "suggestions": [
                {
                  "target_snippet": "trace message = send (Trace message)",
                  "refactored_suggestion": "trace = send . Trace",
                  "confidence": 0.9,
                  "justification": "This refactoring simplifies the definition of `trace` by using function composition, making it shorter and more concise while preserving the same functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace = send . Trace\n{-# INLINE trace #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Accum.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 67,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 43 1: function add has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 43 1: function add has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 43 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 54 1: type signature for look has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 54 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 55 1: function look has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 55 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 55 1: function look has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 65 1: type signature for looks has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 65 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 66 1: function looks has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 66 1: function looks has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Accum.hs\" 66 1: function looks has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
              "suggestions": [
                {
                  "target_snippet": "looks f = fmap f look",
                  "refactored_suggestion": "looks = fmap",
                  "confidence": 1.0,
                  "justification": "The function `looks` is a specialization of `fmap` when applied to `look`. Therefore, it can be simplified to just `looks = fmap`, which is more concise and leverages Haskell's powerful function composition directly."
                },
                {
                  "target_snippet": "add w = send (Add w)",
                  "refactored_suggestion": "-- `add w` directly wraps `send (Add w)`. If unused elsewhere in the code, consider removing for clarity.\nadd w = send (Add w)",
                  "confidence": 0.6,
                  "justification": "The function `add` is a minimal wrapper around `send (Add w)`. It doesn't provide additional significant abstraction and could potentially be removed, reducing indirection. However, this depends on whether `add` is used elsewhere, so careful consideration is needed before deletion."
                },
                {
                  "target_snippet": "-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look",
                  "refactored_suggestion": "-- reason: Replace redundant explicit implementation with direct fmap point-free definition.\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks = fmap",
                  "confidence": 1.0,
                  "justification": "The simplified point-free definition of `looks` reduces cognitive complexity and adheres to Haskell's idiomatic style of leveraging function composition."
                }
              ],
              "refactored_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\n-- `add w` directly wraps `send (Add w)`. If unused elsewhere in the code, consider removing for clarity.\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks = fmap\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks = fmap\n{-# INLINE looks #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Labelled.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 147,
              "homplexity_lines_of_code": 146,
              "code_quality_score": 67.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 9
                },
                "homplexity_loc": 146,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runLabelled\": 1,\n        \"alg_Labelled\": 2,\n        \"injLabelled_Reflexivity\": 1,\n        \"injLabelled_LeftOccurrence\": 1,\n        \"sendLabelled\": 1,\n        \"runUnderLabel\": 1,\n        \"alg_UnderLabel\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2857142857142858,\n        \"sum\": 9\n    },\n    \"homplexity_loc\": 146,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "instance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}",
                  "refactored_suggestion": "-- instance MonadTrans (UnderLabel sub label) is redundant as MonadTrans has already been derived for UnderLabel.\n-- Removed this instance.",
                  "confidence": 0.9,
                  "justification": "The MonadTrans instance for UnderLabel is unnecessary as the functionality to lift a monad into UnderLabel is already provided by the newtype deriving for MonadTrans. Removing this redundant code avoids duplication and makes the codebase cleaner."
                },
                {
                  "target_snippet": "sendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())",
                  "refactored_suggestion": "sendLabelled op = alg (Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())",
                  "confidence": 0.7,
                  "justification": "Using Identity directly (instead of fmap Identity and runIdentity) simplifies the implementation of sendLabelled, improving both readability and efficiency. The transformation involves no semantic change."
                },
                {
                  "target_snippet": "instance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}",
                  "refactored_suggestion": "-- Removed the OVERLAPPABLE pragma and this instance is under review for redundancy.\n-- If labels overlap it can lead to ambiguity issues and errors in resolution.\n-- Keeping the functional dependencies in check would simplify the design.\n-- Removed.",
                  "confidence": 0.6,
                  "justification": "The usage of the OVERLAPPABLE pragma in LabelledMember instances introduces a potential for ambiguity, making it prone to resolution conflicts in complex hierarchies. Functional dependencies between label and sub/sup aim to avoid such ambiguity, so it's advisable to reassess and simplify overlapping instances when unnecessary."
                },
                {
                  "target_snippet": "-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}",
                  "refactored_suggestion": "-- Removed the OVERLAPPABLE pragma and this instance due to potential redundancy.\n-- This has been simplified by removing recursion as most efficient patterns would already use reassociateSumL.\n-- Removed as part of cleanup to maintain functional dependencies clarity.",
                  "confidence": 0.6,
                  "justification": "Similar to the previous proposal, the OVERLAPPABLE pragma increases the complexity in label resolution. Considering reassociateSumL should be sufficiently handled elsewhere, simplifying and removing this instance enhances maintainability while avoiding edge-case ambiguity."
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- Removed the OVERLAPPABLE pragma and this instance due to potential redundancy.\n-- This has been simplified by removing recursion as most efficient patterns would already use reassociateSumL.\n-- Removed as part of cleanup to maintain functional dependencies clarity.\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\n-- Removed the OVERLAPPABLE pragma and this instance is under review for redundancy.\n-- If labels overlap it can lead to ambiguity issues and errors in resolution.\n-- Keeping the functional dependencies in check would simplify the design.\n-- Removed.\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = alg (Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\n-- instance MonadTrans (UnderLabel sub label) is redundant as MonadTrans has already been derived for UnderLabel.\n-- Removed this instance.\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Cut.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 72,
              "homplexity_lines_of_code": 26,
              "code_quality_score": 91.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 26,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 23 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 32 3: data Cut has record fields count of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 48 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 48 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 49 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 49 1: function cutfail has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 49 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 59 1: type signature for call has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 59 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 70 1: type signature for cut has 1 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 70 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 71 1: function cut has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 71 1: function cut has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Effect/Cut.hs\" 71 1: function cut has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}",
                  "refactored_suggestion": "-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = cutfail <|> pure ()\n{-# INLINE cut #-}",
                  "confidence": 0.9,
                  "justification": "The order of `pure ()` and `cutfail` can be swapped to align with the more idiomatic style seen in alternating constructs like `<|>`, where failures or base cases typically appear on the left-hand side for readability."
                },
                {
                  "target_snippet": "module Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where",
                  "refactored_suggestion": "module Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n) where",
                  "confidence": 0.8,
                  "justification": "The `run` function is not defined or used anywhere in this module. Removing the unused declaration helps prevent confusion and maintains code clarity."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = cutfail <|> pure ()\n{-# INLINE cut #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Reader/Internal.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Reader/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 9,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet",
                  "refactored_suggestion": "-- reason: The code in the 'Manual candidate snippet' block appears to be either a placeholder or unused. It provides no operational information or logic. Removing it improves readability and eliminates ambiguity.",
                  "confidence": 1.0,
                  "justification": "This comment block labeled 'Manual candidate snippet' includes no functional code. It seems to be an irrelevant placeholder. Removing such unused or meaningless content improves code clarity, reduces confusion, and maintains only necessary information in the file."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Internal.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/State/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_94/pre_refactor/src/Control/Effect/State/Internal.hs",
                  "refactored_suggestion": "No changes necessary as there are no actionable suggestions from HLint or detectable improvements in the provided code. All declarations are in use and meaningful.",
                  "confidence": 1.0,
                  "justification": "The code defines a GADT `State` with two constructors (`Get` and `Put`), both of which appear necessary and properly structured. There is no unused or dead code. Static analysis tools like HLint and Weeder provided no actionable suggestions, suggesting that the code is clean and adheres to good practices."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Effect/Lift/Internal.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Effect/Lift/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a",
                  "refactored_suggestion": "-- | @since 1.0.0.0\n-- The Lift data type could potentially be refactored to include clarifying comments or restructuring for readability, but no actual changes are necessary as it encapsulates its purpose adequately.\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a",
                  "confidence": 1.0,
                  "justification": "The Lift type is defined with GADTs and RankNTypes, which is appropriate for its purpose. There are no unused or incorrect components in this file. The suggestion from static analyzers provides no actual issues to resolve. Adding clarifying comments for the purpose of 'LiftWith' could be beneficial for readers but is non-essential."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\n-- The Lift data type could potentially be refactored to include clarifying comments or restructuring for readability, but no actual changes are necessary as it encapsulates its purpose adequately.\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 33 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs: Suggestion: No suggestions",
                  "refactored_suggestion": "// No refactoring suggestions as the code is already well written, modular, and adheres to clean coding practices.",
                  "confidence": 1.0,
                  "justification": "The code has no inefficiencies or unused code, follows best practices, and functional programming paradigms effectively. Therefore, no further refactoring is beneficial."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 94.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 30 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 35 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 35 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 36 1: function runTrace has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 36 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 36 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}",
                  "refactored_suggestion": "runTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n-- INLINE pragma retained to suggest optimizing runtime for this function",
                  "confidence": 1.0,
                  "justification": "The function `runTrace` is straightforward and uses a newtype wrapper. The INLINE pragma is retained to improve runtime performance of this simple wrapper function."
                },
                {
                  "target_snippet": "newtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)",
                  "refactored_suggestion": "newtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, MonadFail, MonadFix, MonadIO, MonadPlus)",
                  "confidence": 1.0,
                  "justification": "The explicit qualification for MonadFail (`Fail.MonadFail`) seems unnecessary here because the module already imports `Control.Monad.Fail`. Removing the qualification simplifies the code without changing its functionality."
                },
                {
                  "target_snippet": "-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0",
                  "refactored_suggestion": "-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- Example usage:\n-- >>> runTrace (trace \"example message\")\n--\n-- @since 1.0.0.0",
                  "confidence": 0.8,
                  "justification": "Documenting code examples in Haddock comments is a standard Haskell practice. This improves usability for users by providing a clearer understanding of the function's purpose and correct usage."
                },
                {
                  "target_snippet": "instance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}",
                  "refactored_suggestion": "instance MonadTrans TraceC where\n  lift = TraceC\n  -- INLINE pragma retained for performance optimization",
                  "confidence": 1.0,
                  "justification": "The INLINE pragma for the `lift` function is retained as it improves runtime performance. The code is clear and does not need any changes."
                },
                {
                  "target_snippet": "import Control.Applicative (Alternative)",
                  "refactored_suggestion": "-- import Control.Applicative (Alternative) -- reason: Alternative is already re-exported by Prelude in modern GHC versions.",
                  "confidence": 0.9,
                  "justification": "Unnecessary import can be trimmed since `Alternative` is already available in the Prelude by default in recent versions of GHC. Removing this keeps the code clean."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\n-- import Control.Applicative (Alternative) -- reason: Alternative is already re-exported by Prelude in modern GHC versions.\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- Example usage:\n-- >>> runTrace (trace \"example message\")\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n-- INLINE pragma retained to suggest optimizing runtime for this function\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  -- INLINE pragma retained for performance optimization\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 54,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 94.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 36 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 2 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 47 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- No improvements or refactoring opportunities identified by HLint.\n-- Keeping the code as is.",
                  "confidence": 1.0,
                  "justification": "The suggestion provided by HLint in this case ('No suggestions') indicates no recommended changes, so the code is already optimal or well-structured for its purpose."
                },
                {
                  "target_snippet": "runTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m",
                  "refactored_suggestion": "runTrace (TraceC m) = first (appEndoToList . appEndo) <$> runWriter m\n  where appEndoToList endo = endo []",
                  "confidence": 0.9,
                  "justification": "Inline definitions like '($ []) . appEndo' can sometimes make the code less readable. This refactor introduces an auxiliary function to improve clarity, making the purpose and functionality of the composition more obvious to readers."
                },
                {
                  "target_snippet": "deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)",
                  "refactored_suggestion": "deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)",
                  "confidence": 0.8,
                  "justification": "The 'MonadPlus' derivation might be unnecessary if it is not explicitly used anywhere in the module or externally. Removing unused derivations improves clarity and avoids unnecessary complexity in type classes associated with 'TraceC'. A check of the external usages should validate this removal."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (appEndoToList . appEndo) <$> runWriter m\n  where appEndoToList endo = endo []\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 4,
              "lines_of_code": 87,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 35 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 81 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "target_snippet": "evalEmpty = void . runEmpty",
                  "refactored_suggestion": "evalEmpty = fmap (const ()) . runEmpty",
                  "confidence": 0.8,
                  "justification": "The void function is typically implemented as `fmap (const ())`. Using `fmap (const ())` here is more explicit and aligns better with functional programming practices. However, this change is mostly cosmetic and does not have a significant performance impact."
                },
                {
                  "target_snippet": "execEmpty = fmap isJust . runEmpty",
                  "refactored_suggestion": "execEmpty = (isJust <$>) . runEmpty",
                  "confidence": 0.9,
                  "justification": "Replacing `fmap` with the infix `<$>` operator makes the code slightly more concise and idiomatic for Haskell. This is purely a stylistic improvement, as the two versions are functionally equivalent."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- No unused or dead code found to refactor or remove in this module.",
                  "confidence": 1.0,
                  "justification": "There are no instances of unused or dead code in the provided module. This placeholder snippet can be eliminated for clarity and maintainability."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = fmap (const ()) . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = (isJust <$>) . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fail/Either.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 46,
              "homplexity_lines_of_code": 25,
              "code_quality_score": 95.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 25,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 24 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "target_snippet": "instance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}",
                  "refactored_suggestion": "-- The 'instance Algebra sig m => Fail.MonadFail (FailC m)' definition is using 'send . Fail', but there is no evidence in the code showing that 'Fail' is being handled. If 'Fail' is dead code (unused elsewhere), this instance can be removed, along with 'Fail' handling logic if it's never applied.",
                  "confidence": 0.8,
                  "justification": "It appears that `Fail` is defined in `Control.Effect.Fail`, but based on the visible code, `Fail` is not directly handled or used. Dead code such as this can confuse maintainers or lead to unnecessary maintenance overhead. This refactoring would involve removing unused dead code entirely if verified to be truly unused, not just here but across the entire project. Note: this suggestion should only be applied after verifying the rest of the project uses no relevant parts of `Fail`."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\n-- The 'instance Algebra sig m => Fail.MonadFail (FailC m)' definition is using 'send . Fail', but there is no evidence in the code showing that 'Fail' is being handled. If 'Fail' is dead code (unused elsewhere), this instance can be removed, along with 'Fail' handling logic if it's never applied.\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 3,
                "suggestion": 0,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 3,
              "lines_of_code": 128,
              "homplexity_lines_of_code": 73,
              "code_quality_score": 86.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 73,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" (-1) (-1): module Control.Carrier.Accum.Church has 70 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Accum/Church.hs\" 79 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "'execAccum' = 'runAccum' ('const' '.' 'pure')",
                  "refactored_suggestion": "'execAccum' = 'runAccum' (const pure)",
                  "confidence": 1.0,
                  "justification": "The code uses a redundant composition operator to create a function that can be simplified. Using 'const pure' directly makes the code shorter and easier to read without changing the functionality."
                },
                {
                  "target_snippet": "'evalAccum' = 'runAccum' ('const' '.' 'pure')",
                  "refactored_suggestion": "'evalAccum' = 'runAccum' (const pure)",
                  "confidence": 1.0,
                  "justification": "Similar to the 'execAccum' case, simplifying the composition improves readability and clarity of the code without altering its behavior."
                },
                {
                  "target_snippet": "instance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}",
                  "refactored_suggestion": "-- Removed 'MonadFail' instance for 'AccumC' \n-- Reason: The 'MonadFail' instance is not commonly used and may no longer be necessary, especially since GHC recommends explicit 'MonadFail' handling using the 'Control.Monad.Fail' module's defined features. Keeping this instance might clutter the implementation without real utility.",
                  "confidence": 0.9,
                  "justification": "The 'MonadFail' instance may be unnecessary, as the use of 'fail' is generally discouraged in modern Haskell code. Removing it simplifies the code and aligns with current best practices, but care should be taken if the instance is used in the broader project."
                },
                {
                  "target_snippet": "instance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}",
                  "refactored_suggestion": "-- Removed 'MonadPlus' instance for 'AccumC'\n-- Reason: 'MonadPlus' is largely superseded by 'Alternative', which is already implemented for 'AccumC'. Redundancy can be avoided to streamline the code design.",
                  "confidence": 0.95,
                  "justification": "This instance is redundant because 'MonadPlus' is essentially an extension of 'Alternative'. Removing it trims redundant implementations without losing any required functionality, simplifying the codebase."
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' (const pure)\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' (const pure)\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\n-- Removed 'MonadPlus' instance for 'AccumC'\n-- Reason: 'MonadPlus' is largely superseded by 'Alternative', which is already implemented for 'AccumC'. Redundancy can be avoided to streamline the code design.\n\n-- Removed 'MonadFail' instance for 'AccumC' \n-- Reason: The 'MonadFail' instance is not commonly used and may no longer be necessary, especially since GHC recommends explicit 'MonadFail' handling using the 'Control.Monad.Fail' module's defined features. Keeping this instance might clutter the implementation without real utility.\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Church.hs: Suggestion: No suggestions",
                  "refactored_suggestion": "-- No dead code or unused definitions identified. No changes required.",
                  "confidence": 1.0,
                  "justification": "The static analysis tools found no suggestions, and upon reviewing the source code manually, no redundant, unused, or inefficient code was identified. The file is already optimized and adheres to best practices."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" (-1) (-1): module Control.Carrier.Fresh.Strict has 37 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runFresh n (FreshC m) = runState n m",
                  "refactored_suggestion": "runFresh n = fmap snd . runState n . runFreshC",
                  "confidence": 0.9,
                  "justification": "Directly accessing and emphasizing the `runFreshC` wrapper improves clarity. This refactor makes `runFresh` slightly more direct and eliminates the need to pattern match explicitly while achieving the same result."
                },
                {
                  "target_snippet": "evalFresh n (FreshC m) = evalState n m",
                  "refactored_suggestion": "evalFresh n = evalState n . runFreshC",
                  "confidence": 0.9,
                  "justification": "Simplifying by directly composing the `runFreshC` function eliminates redundant pattern matching, making the code more concise and clear without altering functionality."
                },
                {
                  "target_snippet": "alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx",
                  "refactored_suggestion": "alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> modify (+1) *> get <&> (<$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx",
                  "confidence": 0.85,
                  "justification": "Using `modify` and `get` in place of manually defining state updates improves code readability and leverages existing abstractions for manipulating state. This avoids explicitly defining tuples and reduces the amount of boilerplate."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n = fmap snd . runState n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> modify (+1) *> get <&> (<$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/IORef.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 1,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 5,
              "lines_of_code": 105,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 85.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 1 1: module Control.Carrier.State.IORef has 58 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has 5 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has 4 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 89 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 89 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 90 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 90 1: function execState has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 90 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/IORef.hs\" 94 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "evalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x",
                  "refactored_suggestion": "evalState s x = runReader (unsafePerformIO $ newIORef s) . runStateC $ x",
                  "confidence": 0.7,
                  "justification": "Using 'unsafePerformIO' to create an IORef inline can optimize the creation process slightly. However, this approach should only be used if guaranteed safety can be maintained without unexpected side effects. Validate safety before applying."
                },
                {
                  "target_snippet": "execState s = fmap fst . runState s",
                  "refactored_suggestion": "execState s x = runState s x >>= return . fst",
                  "confidence": 0.8,
                  "justification": "Although functionally correct, the current implementation could be made more explicit by removing fmap in favor of >>= and return for better readability and step-by-step tracing."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = runReader (unsafePerformIO $ newIORef s) . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s x = runState s x >>= return . fst\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/State/Strict.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 122,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 87.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 1 1: module Control.Carrier.State.Strict has 66 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 46 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 46 1: type signature for runState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: function runState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: function runState has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 57 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 57 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: function evalState has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: function evalState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 68 1: type signature for execState has 3 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 68 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: function execState has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: function execState has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/State/Strict.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "m *> k = m >>= const k",
                  "refactored_suggestion": "m *> k = m >> k",
                  "confidence": 1.0,
                  "justification": "The `(>>)` operator is specifically designed for sequencing monadic actions where the result of the first action is not needed. Using `>>` instead of `>>=` with `const` simplifies the code and improves readability without changing behavior."
                },
                {
                  "target_snippet": "fail s = StateC (const (Fail.fail s))",
                  "refactored_suggestion": "fail s = StateC (const (fail s))",
                  "confidence": 1.0,
                  "justification": "Since `MonadFail` is already imported qualified as `Fail`, the call `Fail.fail` can be reduced to `fail`. This improves conciseness and consistency within the module without affecting functionality."
                },
                {
                  "target_snippet": "instance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}",
                  "refactored_suggestion": "-- Removing this implementation block because it is redundant given that Applicative and Monad are sufficient to implement Alternative for StateC, and no custom behavior has been defined.\n-- Reason: clean-up of dead code.",
                  "confidence": 0.9,
                  "justification": "The `Alternative` instance for `StateC` is redundant as the default implementations of `empty` and `<|>` provided by the `Alternative` superclass would suffice for these methods, given that no custom behavior has been defined. Removing this redundant code streamlines the module and reduces potential for maintenance issues."
                },
                {
                  "target_snippet": "instance MonadPlus (StateC s m)",
                  "refactored_suggestion": "-- Removing this implementation line because MonadPlus is derivable directly from Alternative and Monad, and no custom behavior has been defined.\n-- Reason: clean-up of unused code.",
                  "confidence": 0.9,
                  "justification": "The `MonadPlus` instance is redundant because the `MonadPlus` class is equivalent to `Alternative` with `Monad`. Automatically derived behavior will suffice since no custom implementation of `mplus` has been defined."
                },
                {
                  "target_snippet": "module Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where",
                  "refactored_suggestion": "module Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n  -- * State effect\n, module Control.Effect.State\n) where",
                  "confidence": 0.8,
                  "justification": "The `StateC(..)` export allows external modules to access the internal constructor of `StateC`, which goes against the encapsulation typically intended by effect carrier libraries. By hiding it, we discourage external manipulation of internal implementation details, making it easier to modify the internal structure later without breaking compatibility."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >> k\n  {-# INLINE (*>) #-}\n\n-- Removing this implementation block because it is redundant given that Applicative and Monad are sufficient to implement Alternative for StateC, and no custom behavior has been defined.\n-- Reason: clean-up of dead code.\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Throw/Either.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" (-1) (-1): module Control.Carrier.Throw.Either has 32 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has 2 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Throw/Either.hs\" 34 24: data ThrowC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "instance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}",
                  "refactored_suggestion": "instance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = ThrowC $ case sig of\n    L (Throw e) -> throwError e\n    R other     -> alg (runThrowC . hdl) (R other) ctx\n  {-# INLINE alg #-}",
                  "confidence": 0.9,
                  "justification": "Refactored the `case` block to directly wrap the result within `ThrowC`, making it more concise and idiomatic. The functionality is preserved while reducing the redundancy."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = ThrowC $ case sig of\n    L (Throw e) -> throwError e\n    R other     -> alg (runThrowC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 81,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 80.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 6
                },
                "homplexity_loc": 78,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runWriter\": 1,\n        \"execWriter\": 1,\n        \"alg\": 4,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 2,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 78,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "execWriter = fmap fst . runWriter",
                  "refactored_suggestion": "execWriter = mapFst . runWriter\n  where\n    mapFst (w, _) = w",
                  "confidence": 0.9,
                  "justification": "By introducing a helper function `mapFst`, the refactoring makes the intent clearer and avoids the dependency on `fmap` for tuple extraction, calling attention to the structural operation on the tuple."
                },
                {
                  "target_snippet": "newtype WriterC w m a = WriterC { runWriterC :: StateC w m a }",
                  "refactored_suggestion": "newtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving stock (Show)",
                  "confidence": 0.7,
                  "justification": "Adding a `deriving stock (Show)` instance for debugging or introspection purposes may be useful. This can help in inspecting values of `WriterC` during development or debugging without affecting the runtime characteristics."
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = mapFst . runWriter\n  where\n    mapFst (w, _) = w\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving stock (Show)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_94/pre_refactor/src/Control/Carrier/Error/Church.hs",
              "refactored_file_name": "/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 104,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 1 1: module Control.Carrier.Error.Church has 62 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has 4 arguments \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has 1 lines of code \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has branching depth of 0 \nInfo:/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_94/hybrid_refactored/src/Control/Carrier/Error/Church.hs\" 50 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "instance (Alternative m, Monad m) => MonadPlus (ErrorC e m)",
                  "refactored_suggestion": "-- Removed because MonadPlus is now deprecated and considered redundant. Use existing Alternative and Monad instances directly.",
                  "confidence": 1.0,
                  "justification": "The MonadPlus type class has been deprecated in recent versions of Haskell since its functionality is adequately covered by Monad and Alternative. Removing this instance reduces redundancy and aligns the codebase with modern practices."
                },
                {
                  "target_snippet": "instance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}",
                  "refactored_suggestion": "-- Removed because MonadFail is now implicit in Monad. Explicit instances are often unnecessary in this case.",
                  "confidence": 0.9,
                  "justification": "The Fail.MonadFail instance declaration is likely redundant in modern versions of GHC since MonadFail behavior is implicitly included in Monad where necessary. Retaining it might result in unnecessary boilerplate."
                },
                {
                  "target_snippet": "instance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}",
                  "refactored_suggestion": "-- Removed due to complexity and potential risk of undefined behavior. mfix defined here uses pattern matching on `throwError`, which can be problematic in some MonadFix contexts if exceptions are thrown outside the computation. Consider refactoring to use a safer approach if MonadFix is critical.",
                  "confidence": 0.8,
                  "justification": "While this instance enables MonadFix for ErrorC, it is implemented in a way that could lead to subtle runtime errors due to overlapping of exceptions and fixpoint computations. This necessitates either a safer implementation or complete removal if not required."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\n-- Removed because MonadFail is now implicit in Monad. Explicit instances are often unnecessary in this case.\n\n-- Removed due to complexity and potential risk of undefined behavior. mfix defined here uses pattern matching on `throwError`, which can be problematic in some MonadFix contexts if exceptions are thrown outside the computation. Consider refactoring to use a safer approach if MonadFix is critical.\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\n-- Removed because MonadPlus is now deprecated and considered redundant. Use existing Alternative and Monad instances directly.\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}