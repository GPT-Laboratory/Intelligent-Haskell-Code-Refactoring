{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 87,
          "max": 109,
          "average": 3.696969696969697,
          "sum": 366
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 10,
          "suggestion": 3,
          "ignore": 0,
          "total": 13
        },
        "syntax_errors": 382,
        "lines_of_code": 6725,
        "homplexity_lines_of_code": 5125,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "150MB",
          "runtime": "2.3s"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_93/pre_refactor/Setup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 2,
          "homplexity_lines_of_code": 3,
          "code_quality_score": 97.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 3,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_93/pre_refactor/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_93/pre_refactor/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_93/pre_refactor/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_93/pre_refactor/Setup.hs\" 2 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Distribution.Simple\nmain = defaultMain\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/Setup.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/Setup.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/Setup.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 21,
          "homplexity_lines_of_code": 24,
          "code_quality_score": 95.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 24,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 1 1: module Main has 17 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 14 1: function main has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench.hs\" 14 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 45,
          "homplexity_lines_of_code": 42,
          "code_quality_score": 91.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 42,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has 13 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 19 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 16,
          "code_quality_score": 96.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 16,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 1 1: module Bench.NonDet has 12 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 45,
          "homplexity_lines_of_code": 52,
          "code_quality_score": 88.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 52,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 32 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 40 1: function asking has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs\" 44 1: function locally has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 44,
          "code_quality_score": 91.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 44,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 1 1: module Bench.State has 28 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
          },
          "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/State.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/State.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 31,
          "homplexity_lines_of_code": 35,
          "code_quality_score": 92.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 35,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 1 1: module Bench.Error has 23 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 13 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs\" 30 1: function errorLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/Error.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/Error.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 3.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 47,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 81.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 3.0,
              "sum": 6
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 1 1: module Bench.Interpret has 38 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has 1 arguments \nWarning:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has cyclomatic complexity of 5 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/Interpret.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Interpret.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 1,
          "lines_of_code": 58,
          "homplexity_lines_of_code": 62,
          "code_quality_score": 83.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 5
            },
            "homplexity_loc": 62,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 44 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 23 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has 6 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has 2 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has 4 lines of code \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
          "suggestions": [
            {
              "module": [
                "Bench.NonDet.NQueens"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "startLine": 4,
              "startColumn": 1,
              "endLine": 4,
              "endColumn": 31,
              "from": "{-# LANGUAGE TypeOperators #-}",
              "to": "",
              "note": [
                "may require `{-# LANGUAGE ExplicitNamespaces #-}` adding to the top of the file"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 4, startCol = 1, endLine = 4, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/benchmark/Bench/NonDet/NQueens.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 98,
          "homplexity_lines_of_code": 106,
          "code_quality_score": 81.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 106,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 1 1: module Writer has 74 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 35 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 35 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 36 1: function tests has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 36 1: function tests has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 36 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 66 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 66 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 67 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 69 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 69 1: type signature for genN has 5 arguments \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 77 1: function genN has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 77 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 77 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 83 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 83 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 91 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 91 1: function test has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Writer.hs\" 91 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 63,
          "homplexity_lines_of_code": 71,
          "code_quality_score": 84.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 71,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 1 1: module NonDet has 50 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 25 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 25 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 26 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 26 1: function tests has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 26 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 40 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 40 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 41 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 43 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 43 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 44 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 44 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 44 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 55 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 55 1: function test has 8 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet.hs\" 55 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Fusion.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.8,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 1,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 69,
          "code_quality_score": 75.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.8,
              "sum": 9
            },
            "homplexity_loc": 69,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 1 1: module Fusion has 43 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 16 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 16 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 17 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 17 1: function tests has 13 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 17 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 33 1: type signature for failureOf has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 33 1: type signature for failureOf has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 34 1: function failureOf has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 38 1: type signature for countDown has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 38 1: type signature for countDown has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 39 1: function countDown has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 39 1: function countDown has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 39 1: function countDown has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 42 1: type signature for countBoth has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 42 1: type signature for countBoth has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has cyclomatic complexity of 3 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 43 1: function countBoth has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 51 1: type signature for throwing has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 51 1: type signature for throwing has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 52 1: function throwing has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 52 1: function throwing has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fusion.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fusion.hs\" 52 1: function throwing has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n",
          "suggestions": [
            {
              "module": [
                "Fusion"
              ],
              "decl": [
                "countBoth"
              ],
              "severity": "Suggestion",
              "hint": "Use even",
              "file": "/tmp/project_93/pre_refactor/test/Fusion.hs",
              "startLine": 48,
              "startColumn": 9,
              "endLine": 48,
              "endColumn": 23,
              "from": "n `mod` 2 == 0",
              "to": "(even n)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 48, startCol = 9, endLine = 48, endCol = 23}, subts = [(\"n\",SrcSpan {startLine = 48, startCol = 9, endLine = 48, endCol = 10})], orig = \"(even n)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Fusion.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Fusion.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Fusion.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Throw.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 50,
          "homplexity_lines_of_code": 54,
          "code_quality_score": 88.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 54,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 1 1: module Throw has 40 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 33 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 33 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 34 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 34 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 34 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 37 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 47 1: function test has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Throw.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Throw.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Throw.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Throw.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 75,
          "homplexity_lines_of_code": 86,
          "code_quality_score": 83.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 86,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 1 1: module Reader has 64 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 27 1: function tests has 15 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 45 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 45 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 51 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 51 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 51 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 53 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 53 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 59 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 59 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 59 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 62 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 62 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 70 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 70 1: function test has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Reader.hs\" 70 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Fail.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 51,
          "homplexity_lines_of_code": 56,
          "code_quality_score": 88.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 56,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 1 1: module Fail has 41 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fail.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Fail.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Fail.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Fail.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 85,
          "homplexity_lines_of_code": 100,
          "code_quality_score": 84.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 100,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 1 1: module State has 68 lines of code \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 30 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 30 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 31 1: function tests has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 31 1: function tests has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 31 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 61 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 61 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 67 1: function gen0 has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 73 1: type signature for test has 5 arguments \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 73 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 80 1: function test has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 80 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/State.hs\" 80 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/State.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/State.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Cull.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 60,
          "code_quality_score": 86.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 60,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 1 1: module Cull has 44 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 24 1: function tests has 10 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 37 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 37 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 38 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 38 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 38 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 40 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 40 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 41 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 41 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 41 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 44 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 44 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 52 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 52 1: function test has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cull.hs\" 52 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Cull.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Cull.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Cull.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Catch.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 40,
          "homplexity_lines_of_code": 38,
          "code_quality_score": 90.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 38,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 1 1: module Catch has 32 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 14 1: function tests has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 18 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 18 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 25 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 25 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 25 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 28 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 28 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 37 1: function test has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 37 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Catch.hs\" 37 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Catch.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Catch.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Catch.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 23,
          "homplexity_lines_of_code": 26,
          "code_quality_score": 93.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 26,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 1 1: module Lift has 18 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 13 1: function tests has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 22 1: type signature for handle has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 22 1: type signature for handle has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 23 1: function handle has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 23 1: function handle has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Lift.hs\" 23 1: function handle has branching depth of 0 \n"
          },
          "original_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Gen.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 1,
            "sum": 41
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 7,
          "lines_of_code": 327,
          "homplexity_lines_of_code": 327,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 1,
              "sum": 41
            },
            "homplexity_loc": 327,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"m\": 1,\n        \"genT\": 1,\n        \"a\": 1,\n        \"b\": 1,\n        \"c\": 1,\n        \"e\": 1,\n        \"r\": 1,\n        \"s\": 1,\n        \"w\": 1,\n        \"unit\": 1,\n        \"identity\": 1,\n        \"fn\": 1,\n        \"termFn\": 1,\n        \"choice\": 1,\n        \"integral\": 1,\n        \"unicode\": 1,\n        \"string\": 1,\n        \"subtermM\": 1,\n        \"subtermM2\": 1,\n        \"runL\": 1,\n        \"runR\": 1,\n        \"runC\": 1,\n        \"forall_\": 1,\n        \"showing\": 1,\n        \"showingFn\": 1,\n        \"term\": 1,\n        \"atom\": 1,\n        \"label\": 1,\n        \"infixL\": 1,\n        \"infixR\": 1,\n        \"pair\": 1,\n        \"addLabel\": 1,\n        \"runTerm\": 5,\n        \"checkTestTree\": 2,\n        \"testGroup\": 1,\n        \"testProperty\": 1,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 1.14,\n        \"sum\": 41\n    },\n    \"homplexity_loc\": 327,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM\u00a0m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . (>>= (<$ tell (Set.singleton (fromString s)))) . unComp1\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a\u00a0:<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
          "suggestions": [
            {
              "module": [
                "Gen"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/test/Gen.hs",
              "startLine": 10,
              "startColumn": 1,
              "endLine": 10,
              "endColumn": 33,
              "from": "{-# LANGUAGE PatternSynonyms #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 10, startCol = 1, endLine = 10, endCol = 33}, newComment = \"\"}]"
            },
            {
              "module": [
                "Gen"
              ],
              "decl": [
                "addLabel"
              ],
              "severity": "Suggestion",
              "hint": "Use <=<",
              "file": "/tmp/project_93/pre_refactor/test/Gen.hs",
              "startLine": 273,
              "startColumn": 22,
              "endLine": 273,
              "endColumn": 78,
              "from": "(>>= (<$ tell (Set.singleton (fromString s)))) . unComp1",
              "to": "((<$ tell (Set.singleton (fromString s)))\n   Control.Monad.<=< unComp1)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 273, startCol = 22, endLine = 273, endCol = 78}, subts = [(\"f\",SrcSpan {startLine = 273, startCol = 27, endLine = 273, endCol = 67}),(\"g\",SrcSpan {startLine = 273, startCol = 71, endLine = 273, endCol = 78})], orig = \"(f Control.Monad.<=< g)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Gen.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Gen.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Gen.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Error.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 9,
          "lines_of_code": 64,
          "homplexity_lines_of_code": 75,
          "code_quality_score": 84.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 75,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 1 1: module Error has 55 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 24 1: function tests has 17 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 44 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 46 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 46 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 52 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 52 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 52 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 55 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 55 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 64 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 64 1: function test has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Error.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Error.hs\" 64 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Error.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Error.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Choose.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 50,
          "homplexity_lines_of_code": 57,
          "code_quality_score": 88.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 57,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 1 1: module Choose has 40 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 18 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 18 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 19 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 19 1: function tests has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 19 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 33 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 33 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 34 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 34 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 34 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 37 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 45 1: function test has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 45 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Choose.hs\" 45 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Choose.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Choose.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Choose.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Accum.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 0,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 5,
          "lines_of_code": 73,
          "homplexity_lines_of_code": 87,
          "code_quality_score": 85.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 87,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 1 1: module Accum has 58 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 23 1: function tests has 15 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 49 1: function gen0 has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 49 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 49 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 54 1: type signature for test has 5 arguments \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 54 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 62 1: function test has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 62 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Accum.hs\" 62 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Accum\n( tests\n) where\n\nimport qualified Control.Carrier.Accum.Church as C.Accum.Church\nimport qualified Control.Carrier.Accum.Strict as C.Accum.Strict\nimport           Control.Effect.Accum\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as T.Accum\nimport           Data.Tuple (swap)\n#endif\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport Data.Bifunctor (first)\n\ntests :: TestTree\ntests = testGroup \"Accum\"\n  [ testGroup \"AccumC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC (C.Accum.Church.runAccum (curry pure)))\n  , testGroup \"AccumC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC C.Accum.Strict.runAccum)\n#if MIN_VERSION_transformers(0,5,4)\n  , testGroup \"AccumT\" $ testAccum (runC (fmap (fmap swap) . flip T.Accum.runAccumT))\n#endif\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (\\_ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (\\_ _ -> [])) a b   initial run\n  testAccum    run = Accum.test    (m (gen0 w) (\\_ _ -> [])) a     w       run\n  initial = pair <*> w <*> unit\n\ngen0\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Vary w, Show w)\n  => GenTerm w\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 w a =\n  [ infixL 4 \"<$\" (<$) <*> a <*> (label \"add\" add <*> w)\n  , label \"looks\" (looks @w) <*> fn a\n  ]\n\ntest\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Eq a, Eq w, Show a, Show w, Vary w, Monoid w)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm w\n  -> Run ((,) w) ((,) w) m\n  -> [TestTree]\ntest m a w (Run runAccum) =\n  [ testProperty \"look returns the log variable (simple)\" . forall_ (w :. Nil) $\n    \\ w -> runAccum (w, look) === Identity (mempty, w)\n  , testProperty \"add appends to the log variable (simple)\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w) === Identity (w, ())\n  , testProperty \"look returns the log variable (continuation)\" . forall_ (w :. fn (m a) :. Nil) $\n    \\ w0 k -> runAccum (w0, look >>= k) === runAccum (w0, k w0)\n  , testProperty \"add appends to the log variable and alters the environment for look\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w >> look) === runAccum (mappend w0 w, look @w <* add w)\n  , testProperty \"add appends to the log variable and alters the environment for continuations\" . forall_ (w :. w :. m a :. Nil) $\n    \\ w0 w k -> runAccum (w0, add w >> k) === (first (mappend w) <$> runAccum (mappend w0 w, k))\n  ]\n",
          "suggestions": [
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_93/pre_refactor/test/Accum.hs",
              "startLine": 38,
              "startColumn": 3,
              "endLine": 38,
              "endColumn": 79,
              "from": "testMonad run\n  = Monad.test (m (gen0 w) (\\ _ _ -> [])) a b c initial run",
              "to": "testMonad = Monad.test (m (gen0 w) (\\ _ _ -> [])) a b c initial",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 38, startCol = 3, endLine = 38, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 38, startCol = 22, endLine = 38, endCol = 75})], orig = \"testMonad = body\"}]"
            },
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_93/pre_refactor/test/Accum.hs",
              "startLine": 39,
              "startColumn": 3,
              "endLine": 39,
              "endColumn": 79,
              "from": "testMonadFix run\n  = MonadFix.test (m (gen0 w) (\\ _ _ -> [])) a b initial run",
              "to": "testMonadFix = MonadFix.test (m (gen0 w) (\\ _ _ -> [])) a b initial",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 39, startCol = 3, endLine = 39, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 39, startCol = 22, endLine = 39, endCol = 75})], orig = \"testMonadFix = body\"}]"
            },
            {
              "module": [
                "Accum"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_93/pre_refactor/test/Accum.hs",
              "startLine": 40,
              "startColumn": 3,
              "endLine": 40,
              "endColumn": 79,
              "from": "testAccum run = Accum.test (m (gen0 w) (\\ _ _ -> [])) a w run",
              "to": "testAccum = Accum.test (m (gen0 w) (\\ _ _ -> [])) a w",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 40, startCol = 3, endLine = 40, endCol = 79}, subts = [(\"body\",SrcSpan {startLine = 40, startCol = 22, endLine = 40, endCol = 69})], orig = \"testAccum = body\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Accum.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Accum.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Accum.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/MonadFix.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 31,
          "homplexity_lines_of_code": 33,
          "code_quality_score": 94.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 33,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 1 1: module MonadFix has 24 lines of code \nInfo:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 14 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 14 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 22 1: function test has 9 lines of code \nInfo:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/MonadFix.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/MonadFix.hs\" 22 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/MonadFix.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/MonadFix.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/MonadFix.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Test.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 20,
          "lines_of_code": 46,
          "homplexity_lines_of_code": 61,
          "code_quality_score": 91.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 61,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 1 1: module Main has 42 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 26 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 26 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 27 1: function main has 19 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 27 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Test.hs\" 27 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Test.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Test.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Test.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Monad.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 33,
          "homplexity_lines_of_code": 37,
          "code_quality_score": 94.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 37,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 1 1: module Monad has 26 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 13 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 13 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 22 1: function test has 11 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Monad.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Monad.hs\" 22 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Monad.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Monad.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Monad.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Cut.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 10,
          "lines_of_code": 69,
          "homplexity_lines_of_code": 82,
          "code_quality_score": 83.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 82,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 1 1: module Cut has 58 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 27 1: function tests has 14 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 44 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 44 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 45 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 45 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 45 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 47 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 47 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 48 1: function genN has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 48 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 48 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 51 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 51 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 61 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 61 1: function test has 8 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut.hs\" 61 1: function test has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Cut.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Cut.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Cut.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Empty.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 59,
          "homplexity_lines_of_code": 70,
          "code_quality_score": 87.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 70,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 1 1: module Empty has 49 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 23 1: function tests has 17 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 43 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 44 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 56 1: function test has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 56 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Empty.hs\" 56 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Empty.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Empty.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Empty.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Fresh.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 87.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 1 1: module Fresh has 43 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 20 1: function tests has 16 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 39 1: type signature for gen has 2 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 39 1: type signature for gen has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 40 1: function gen has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 40 1: function gen has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 40 1: function gen has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 43 1: type signature for test has 5 arguments \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 43 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 50 1: function test has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 50 1: function test has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Fresh.hs\" 50 1: function test has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Fresh.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Fresh.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Fresh.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/NonDet/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 32,
          "homplexity_lines_of_code": 41,
          "code_quality_score": 89.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 41,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 26 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 28 1: type signature for state has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 28 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 29 1: function state has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 31 1: type signature for error has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 31 1: type signature for error has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/NonDet/Church.hs\" 32 1: function error has cyclomatic complexity of 1 \n"
          },
          "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/NonDet/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/NonDet/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/test/Cut/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 18,
          "code_quality_score": 96.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 18,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 1 1: module Cut.Church has 13 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 11 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 11 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/test/Cut/Church.hs\" 12 1: function tests has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/test/Cut/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/test/Cut/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/test/Cut/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Inference.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 6,
          "lines_of_code": 54,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 90.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 1 1: module Inference has 30 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 19 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 19 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 20 1: function example has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 20 1: function example has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 20 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 39 1: type signature for askEnv has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 39 1: type signature for askEnv has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 40 1: function askEnv has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 45 1: type signature for runEnv has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 45 1: type signature for runEnv has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 46 1: function runEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Inference.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Inference.hs\" 50 26: data HasEnv has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n",
          "suggestions": [
            {
              "module": [
                "Inference"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/examples/Inference.hs",
              "startLine": 6,
              "startColumn": 1,
              "endLine": 6,
              "endColumn": 31,
              "from": "{-# LANGUAGE TypeOperators #-}",
              "to": "",
              "note": [
                "may require `{-# LANGUAGE ExplicitNamespaces #-}` adding to the top of the file"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 6, startCol = 1, endLine = 6, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Inference.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Inference.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Inference.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Utils.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.3333333333333333,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 20,
          "homplexity_lines_of_code": 19,
          "code_quality_score": 90.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.3333333333333333,
              "sum": 4
            },
            "homplexity_loc": 19,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 1 1: module Utils has 14 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 8 5: data TestTree has record fields count of 4 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 11 1: type signature for checkTestTree has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 11 1: type signature for checkTestTree has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 12 1: function checkTestTree has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 16 1: type signature for testGroup has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 16 1: type signature for testGroup has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 17 1: function testGroup has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 19 1: type signature for testProperty has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 19 1: type signature for testProperty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Utils.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Utils.hs\" 20 1: function testProperty has cyclomatic complexity of 1 \n"
          },
          "original_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Utils.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Utils.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Utils.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Parser.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.2222222222222223,
            "sum": 11
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 9,
          "lines_of_code": 166,
          "homplexity_lines_of_code": 208,
          "code_quality_score": 57.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.2222222222222223,
              "sum": 11
            },
            "homplexity_loc": 208,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 1 1: module Parser has 127 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 28 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 28 1: type signature for example has 1 arguments \nCritical:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 29 1: function example has 63 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 29 1: function example has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 29 1: function example has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 116 3: data Symbol has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 119 1: type signature for satisfy has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 119 1: type signature for satisfy has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 120 1: function satisfy has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 122 1: type signature for char has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 122 1: type signature for char has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 123 1: function char has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 123 1: function char has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 123 1: function char has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 125 1: type signature for digit has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 125 1: type signature for digit has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 126 1: function digit has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 126 1: function digit has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 126 1: function digit has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 128 1: type signature for parens has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 128 1: type signature for parens has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 129 1: function parens has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 129 1: function parens has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 129 1: function parens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 132 1: type signature for parse has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 132 1: type signature for parse has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 133 1: function parse has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 133 1: function parse has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 133 1: function parse has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 137 22: data ParseC has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 151 1: type signature for expr has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 151 1: type signature for expr has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 152 1: function expr has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 152 1: function expr has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 152 1: function expr has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 157 1: type signature for term has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 157 1: type signature for term has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 158 1: function term has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 158 1: function term has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 158 1: function term has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 163 1: type signature for factor has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 163 1: type signature for factor has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 164 1: function factor has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 164 1: function factor has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Parser.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Parser.hs\" 164 1: function factor has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n",
          "suggestions": [
            {
              "module": [
                "Parser"
              ],
              "decl": [
                "parse"
              ],
              "severity": "Suggestion",
              "hint": "Use <=<",
              "file": "/tmp/project_93/pre_refactor/examples/Parser.hs",
              "startLine": 133,
              "startColumn": 15,
              "endLine": 133,
              "endColumn": 60,
              "from": "(>>= exhaustive) . runState input . runParseC",
              "to": "exhaustive Control.Monad.<=< (runState input . runParseC)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 133, startCol = 15, endLine = 133, endCol = 60}, subts = [(\"f\",SrcSpan {startLine = 133, startCol = 20, endLine = 133, endCol = 30}),(\"g\",SrcSpan {startLine = 133, startCol = 34, endLine = 133, endCol = 60})], orig = \"f Control.Monad.<=< (g)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Parser.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Parser.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Parser.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 20,
          "homplexity_lines_of_code": 22,
          "code_quality_score": 95.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 22,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 1 1: module Main has 16 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 14 1: function main has 6 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Main.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Main.hs\" 14 1: function main has branching depth of 0 \n"
          },
          "original_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Main.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Main.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Main.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.1428571428571428,
            "sum": 8
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 5,
          "lines_of_code": 165,
          "homplexity_lines_of_code": 101,
          "code_quality_score": 73.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.1428571428571428,
              "sum": 8
            },
            "homplexity_loc": 101,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 12 1: module ReinterpretLog has 82 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 47 5: data Message has record fields count of 2 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has branching depth of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has cyclomatic complexity of 2 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 57 1: type signature for application has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 57 1: type signature for application has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 58 1: function application has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 67 1: function runApplication has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 79 3: data Log has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 83 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 83 1: type signature for log has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 84 1: function log has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 92 26: data LogStdoutC has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 112 35: data ReinterpretLogC has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 137 37: data CollectLogMessagesC has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 158 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 158 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs\" 159 1: function example has 6 lines of code \n"
          },
          "original_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n",
          "suggestions": [
            {
              "module": [
                "ReinterpretLog"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs",
              "startLine": 15,
              "startColumn": 1,
              "endLine": 15,
              "endColumn": 30,
              "from": "{-# LANGUAGE InstanceSigs #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 15, startCol = 1, endLine = 15, endCol = 30}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/ReinterpretLog.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/ReinterpretLog.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 81,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 73.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 9
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 1 1: module Labelled has 58 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 20 1: type signature for sample has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 20 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 24 1: function sample has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 24 1: function sample has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 24 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 26 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 26 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 30 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 32 1: type signature for numerically has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 32 1: type signature for numerically has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 36 1: function numerically has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 38 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 38 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 39 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 48 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 48 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 52 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 54 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 54 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 58 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 60 1: type signature for boolean has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 60 1: type signature for boolean has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 64 1: function boolean has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 66 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 66 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 67 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 77 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 77 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 78 1: function example has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 78 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Labelled.hs\" 78 1: function example has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/examples/Teletype.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 79,
          "homplexity_lines_of_code": 78,
          "code_quality_score": 84.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 78,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 44 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 48 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 48 1: type signature for read has 1 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 49 1: function read has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 49 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 49 1: function read has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 51 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 51 1: type signature for write has 2 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 52 1: function write has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 52 1: function write has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 52 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 55 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 66 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/examples/Teletype.hs:SrcLoc \"/tmp/project_93/pre_refactor/examples/Teletype.hs\" 68 28: data TeletypeRetC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/examples/Teletype.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/examples/Teletype.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/examples/Teletype.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Algebra.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 8,
            "average": 3,
            "sum": 71
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 15,
          "lines_of_code": 343,
          "homplexity_lines_of_code": 345,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 8,
              "average": 3,
              "sum": 71
            },
            "homplexity_loc": 345,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"thread\": 1,\n        \"run\": 1,\n        \"send\": 1,\n        \"toRWSTF\": 1,\n        \"swapAndLift\": 1,\n        \"alg_Lift_IO\": 1,\n        \"alg_Lift_Identity\": 1,\n        \"alg_Choose_NonEmpty\": 1,\n        \"alg_Empty_Maybe\": 1,\n        \"alg_Error_Either\": 2,\n        \"alg_Reader\": 2,\n        \"alg_NonDet\": 2,\n        \"alg_Writer_Tuple\": 3,\n        \"alg_ErrorPlus_sig_ExceptT\": 3,\n        \"alg_EmptyPlus_sig_MaybeT\": 2,\n        \"alg_ReaderPlus_sig_ReaderT\": 3,\n        \"alg_RWS_CPS\": 8,\n        \"alg_RWS_Lazy\": 8,\n        \"alg_RWS_Strict\": 8,\n        \"alg_State_Lazy\": 3,\n        \"alg_State_Strict\": 3,\n        \"alg_Writer_CPS\": 4,\n        \"alg_Writer_Lazy\": 4,\n        \"alg_Writer_Strict\": 4,\n        \"alg_Accum\": 3,\n        \"min\": 1,\n        \"max\": 8,\n        \"average\": 2.84,\n        \"sum\": 71\n    },\n    \"homplexity_loc\": 345,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Algebra.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Algebra.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Algebra.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 80,
          "homplexity_lines_of_code": 31,
          "code_quality_score": 88.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 31,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Writer.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 70,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 90.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 31 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs\" 69 1: function #. has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/NonDet.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 39,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 94.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 15 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs\" 39 1: function liftEither has branching depth of 0 \n"
          },
          "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Throw.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 62,
          "homplexity_lines_of_code": 23,
          "code_quality_score": 91.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 23,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Fail.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Fail.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Fail.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Fail.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 108,
          "homplexity_lines_of_code": 40,
          "code_quality_score": 84.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 6
            },
            "homplexity_loc": 40,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 30 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 80 1: function modify has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 94 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 104 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 104 1: type signature for state has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State.hs\" 105 1: function state has 3 lines of code \n"
          },
          "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/State.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/State.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 40,
          "homplexity_lines_of_code": 15,
          "code_quality_score": 96.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 15,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 1 1: module Control.Effect.Cull has 14 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 28 3: data Cull has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs\" 39 1: function cull has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Cull.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Cull.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs",
          "cyclomatic_complexity": {
            "min": 3,
            "max": 3,
            "average": 3.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 88,
          "homplexity_lines_of_code": 52,
          "code_quality_score": 88.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 3,
              "max": 3,
              "average": 3.0,
              "sum": 3
            },
            "homplexity_loc": 52,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 1 1: module Control.Effect.Sum has 48 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 26 5: data f has record fields count of 2 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 42 3: type class Member has method + value count of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 42 3: type class Member has associated type count of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has cyclomatic complexity of 3 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Sum.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Sum.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 33,
          "homplexity_lines_of_code": 13,
          "code_quality_score": 96.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 13,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 12 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
          },
          "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Catch.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 68,
          "homplexity_lines_of_code": 27,
          "code_quality_score": 91.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 27,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 1 1: module Control.Effect.Lift has 24 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 37 1: function sendM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 46 1: function sendIO has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs\" 67 1: function liftWith has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 24,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Error.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Error.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Error.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 156,
          "homplexity_lines_of_code": 77,
          "code_quality_score": 82.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 5
            },
            "homplexity_loc": 77,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 1 1: module Control.Effect.Choose has 72 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 64 1: function <|> has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 80 1: function optional has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 90 1: type signature for many has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 90 1: type signature for many has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 91 1: function many has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 101 1: type signature for some has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 101 1: type signature for some has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 102 1: function some has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 113 1: function some1 has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs\" 118 24: data Choosing has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Choose.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 36,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 96.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 29 3: data Trace has record fields count of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs\" 35 1: function trace has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Trace.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 23,
          "code_quality_score": 91.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 23,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 42 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 53 1: type signature for look has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 53 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 54 1: function look has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs\" 65 1: function looks has cyclomatic complexity of 1 \n"
          },
          "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Accum.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1,
            "sum": 12
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 152,
          "homplexity_lines_of_code": 152,
          "code_quality_score": 60.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1,
              "sum": 12
            },
            "homplexity_loc": 152,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runLabelled\": 1,\n        \"alg_Labelled\": 2,\n        \"injLabelled_1\": 1,\n        \"injLabelled_2\": 1,\n        \"injLabelled_3\": 1,\n        \"injLabelled_4\": 1,\n        \"sendLabelled\": 1,\n        \"runUnderLabel\": 1,\n        \"lift\": 1,\n        \"alg_UnderLabel\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 152,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 73,
          "homplexity_lines_of_code": 27,
          "code_quality_score": 91.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 27,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 24 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 33 3: data Cut has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 50 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 60 1: type signature for call has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 60 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 61 1: function call has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs\" 72 1: function cut has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Cut.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 48,
          "homplexity_lines_of_code": 20,
          "code_quality_score": 94.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 20,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 15 1: module Control.Effect.Empty has 17 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 39 1: function empty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has 2 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs\" 46 1: function guard has branching depth of 1 \n"
          },
          "original_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Empty.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Empty.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 37,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 96.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 1 1: module Control.Effect.Fresh has 16 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 25 3: data Fresh has record fields count of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs\" 36 1: function fresh has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Fresh.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Fresh.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 9,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Reader/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Reader/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 57,
          "homplexity_lines_of_code": 30,
          "code_quality_score": 91.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 30,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 1 1: module Control.Effect.Reader.Labelled has 27 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Reader/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 13,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/NonDet/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/NonDet/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Choose/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Choose/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 11,
          "code_quality_score": 98.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 11,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Empty/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Empty/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Empty/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 12,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Accum/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Accum/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 12,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/State/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/State/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 95,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 84.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 6
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 1 1: module Control.Effect.State.Labelled has 33 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has 1 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 37 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 59 1: function put has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs\" 94 1: function state has 1 lines of code \n"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/State/Labelled.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State/Labelled.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 10,
          "code_quality_score": 99.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 10,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 10,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Throw/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Throw/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Writer/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Writer/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Catch/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Catch/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Error/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Error/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Error/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift/Internal.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "error"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Effect/Lift/Internal.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Effect/Lift/Internal.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Lift/Internal.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 105,
          "homplexity_lines_of_code": 68,
          "code_quality_score": 91.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 68,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 1 1: module Control.Carrier.Reader has 67 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 43 1: function runReader has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs\" 47 25: data ReaderC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Reader.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Reader.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 42,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 95.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 1 1: module Control.Carrier.Lift has 27 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 29 1: function runM has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs\" 33 21: data LiftC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Lift.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Lift.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Interpret.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1,
            "sum": 6
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 101,
          "homplexity_lines_of_code": 98,
          "code_quality_score": 78.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1,
              "sum": 6
            },
            "homplexity_loc": 98,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runInterpret\": 1,\n        \"runInterpretState\": 1,\n        \"reify\": 1,\n        \"lift\": 1,\n        \"alg\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 98,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Interpret.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Interpret.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Interpret.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 134,
          "homplexity_lines_of_code": 84,
          "code_quality_score": 85.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 84,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 1 1: module Control.Carrier.NonDet.Church has 81 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has 5 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs\" 78 23: data NonDetC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/NonDet/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/NonDet/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 109,
          "homplexity_lines_of_code": 71,
          "code_quality_score": 88.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 71,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 1 1: module Control.Carrier.Choose.Church has 69 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs\" 63 23: data ChooseC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Choose/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 94.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 33 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Trace/Ignoring.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 55,
          "homplexity_lines_of_code": 34,
          "code_quality_score": 94.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 34,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 33 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs\" 44 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Trace/Printing.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 53,
          "homplexity_lines_of_code": 36,
          "code_quality_score": 94.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 36,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 35 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs\" 46 22: data TraceC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Trace/Returning.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 6,
          "lines_of_code": 94,
          "homplexity_lines_of_code": 63,
          "code_quality_score": 87.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 63,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" (-1) (-1): module Control.Carrier.Cull.Church has 60 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has 5 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs\" 64 21: data CullC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Cull/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 87,
          "homplexity_lines_of_code": 38,
          "code_quality_score": 90.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 38,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 35 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs\" 81 22: data EmptyC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Empty/Maybe.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 141,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 1 1: module Control.Carrier.Empty.Church has 78 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs\" 82 22: data EmptyC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Empty/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 48,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 95.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 27 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Fail/Either.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 0,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 3,
          "lines_of_code": 133,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" (-1) (-1): module Control.Carrier.Accum.Church has 78 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs\" 79 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
          "suggestions": [
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 30,
              "from": "{-# LANGUAGE BangPatterns #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 30}, newComment = \"\"}]"
            },
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 4,
              "startColumn": 1,
              "endLine": 4,
              "endColumn": 44,
              "from": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 4, startCol = 1, endLine = 4, endCol = 44}, newComment = \"\"}]"
            },
            {
              "module": [
                "Control.Carrier.Accum.Church"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "startLine": 6,
              "startColumn": 1,
              "endLine": 6,
              "endColumn": 31,
              "from": "{-# LANGUAGE TupleSections #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 6, startCol = 1, endLine = 6, endCol = 31}, newComment = \"\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Accum/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 99,
          "homplexity_lines_of_code": 61,
          "code_quality_score": 87.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 61,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" (-1) (-1): module Control.Carrier.Accum.IORef has 54 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs\" 88 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Accum/IORef.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/IORef.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 136,
          "homplexity_lines_of_code": 83,
          "code_quality_score": 85.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 83,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" (-1) (-1): module Control.Carrier.Accum.Strict has 80 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs\" 77 24: data AccumC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Accum/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 92.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Fresh/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 66,
          "homplexity_lines_of_code": 39,
          "code_quality_score": 92.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 39,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" (-1) (-1): module Control.Carrier.Fresh.Strict has 37 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs\" 59 22: data FreshC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Fresh/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 129,
          "homplexity_lines_of_code": 76,
          "code_quality_score": 86.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 76,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 1 1: module Control.Carrier.State.Lazy has 73 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs\" 74 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/State/Lazy.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 129,
          "homplexity_lines_of_code": 79,
          "code_quality_score": 86.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 79,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" (-1) (-1): module Control.Carrier.State.Church has 76 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs\" 74 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/State/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 4
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 107,
          "homplexity_lines_of_code": 73,
          "code_quality_score": 84.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 4
            },
            "homplexity_loc": 73,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 1 1: module Control.Carrier.State.IORef has 60 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has 5 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has 4 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has 3 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs\" 96 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/State/IORef.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/IORef.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 127,
          "homplexity_lines_of_code": 75,
          "code_quality_score": 86.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 75,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 1 1: module Control.Carrier.State.Strict has 72 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs\" 75 24: data StateC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/State/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 41,
          "homplexity_lines_of_code": 33,
          "code_quality_score": 94.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 33,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" (-1) (-1): module Control.Carrier.Throw.Either has 32 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs\" 34 24: data ThrowC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Throw/Either.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Throw/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 82,
          "homplexity_lines_of_code": 49,
          "code_quality_score": 91.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 49,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" (-1) (-1): module Control.Carrier.Writer.Church has 47 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs\" 66 25: data WriterC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Writer/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 78,
          "homplexity_lines_of_code": 51,
          "code_quality_score": 90.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 51,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" (-1) (-1): module Control.Carrier.Writer.Strict has 49 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs\" 60 25: data WriterC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Writer/Strict.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 123,
          "homplexity_lines_of_code": 81,
          "code_quality_score": 85.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 81,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 1 1: module Control.Carrier.Cut.Church has 78 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has 5 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs\" 67 20: data CutC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Cut/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 58,
          "homplexity_lines_of_code": 31,
          "code_quality_score": 94.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 31,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 1 1: module Control.Carrier.Error.Either has 30 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has 2 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs\" 46 24: data ErrorC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Error/Either.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 113,
          "homplexity_lines_of_code": 74,
          "code_quality_score": 90.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 74,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 1 1: module Control.Carrier.Error.Church has 73 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has 4 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has branching depth of 0 \nInfo:/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs\" 50 24: data ErrorC has record fields count of 1 \n"
          },
          "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Carrier/Error/Church.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Church.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 47,
          "homplexity_lines_of_code": 11,
          "code_quality_score": 96.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 11,
            "homplexity_output": "Info:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 1 1: module Control.Algebra.Handler has 10 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has type constructor nesting of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has 3 arguments \nInfo:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has 1 lines of code \nInfo:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has cyclomatic complexity of 1 \nInfo:/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/src/Control/Algebra/Handler.hs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/src/Control/Algebra/Handler.hs"
          }
        },
        {
          "file_name": "/tmp/project_93/pre_refactor/README.lhs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 1,
          "homplexity_lines_of_code": 0,
          "code_quality_score": 100.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 0,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "README.md",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_93/static_refactored/README.lhs",
            "llm_only_refactored_file": "/tmp/project_93/llm_only_refactored/README.lhs",
            "hybrid_refactored_file": "/tmp/project_93/hybrid_refactored/README.lhs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 86,
              "max": 105,
              "average": 3.595959595959596,
              "sum": 356
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 0,
              "suggestion": 0,
              "ignore": 0,
              "total": 0
            },
            "syntax_errors": 378,
            "lines_of_code": 6652,
            "homplexity_lines_of_code": 5027,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_93/pre_refactor/Setup.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/Setup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 2,
              "homplexity_lines_of_code": 3,
              "code_quality_score": 97.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 3,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/Setup.hs:SrcLoc \"/tmp/project_93/static_refactored/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_93/static_refactored/Setup.hs:SrcLoc \"/tmp/project_93/static_refactored/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_93/static_refactored/Setup.hs:SrcLoc \"/tmp/project_93/static_refactored/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/Setup.hs:SrcLoc \"/tmp/project_93/static_refactored/Setup.hs\" 2 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Distribution.Simple\nmain = defaultMain\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/Setup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Distribution.Simple\nmain = defaultMain\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 21,
              "homplexity_lines_of_code": 24,
              "code_quality_score": 95.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 24,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 1 1: module Main has 17 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 14 1: function main has 7 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 45,
              "homplexity_lines_of_code": 42,
              "code_quality_score": 91.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 42,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 18 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has 13 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 19 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 43 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Writer.hs\" 44 1: function tellLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 16,
              "code_quality_score": 96.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 16,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 1 1: module Bench.NonDet has 12 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has 4 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet.hs\" 12 1: function benchmark has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.NonDet\n( benchmark\n) where\n\nimport qualified Bench.NonDet.NQueens as NQueens\nimport           Control.Algebra\nimport qualified Control.Carrier.NonDet.Church as NonDet.Church\nimport           Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 45,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 32 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 39 1: type signature for asking has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 40 1: function asking has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 43 1: type signature for locally has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Reader.hs\" 44 1: function locally has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/State.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 44,
              "code_quality_score": 91.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 44,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 1 1: module Bench.State has 28 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/Error.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 31,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 92.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 1 1: module Bench.Error has 23 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 12 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has 11 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 13 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 29 1: type signature for errorLoop has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Error.hs\" 30 1: function errorLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Error\n( benchmark\n) where\n\nimport Control.Carrier.Error.Church as Church\nimport Control.Carrier.Error.Either as Either\nimport Data.Foldable (for_)\nimport Control.Monad.Trans.Except as Except\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nerrorLoop :: Has (Error Int) sig m => Int -> m ()\nerrorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)\n{-# INLINE errorLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 3.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 81.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 3.0,
                  "sum": 6
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 1 1: module Bench.Interpret has 38 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 15 1: type signature for benchmark has 1 arguments \nWarning:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has cyclomatic complexity of 5 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 16 1: function benchmark has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 45 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/Interpret.hs\" 46 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/Interpret.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\nmodule Bench.Interpret\n( benchmark\n) where\n\nimport Control.Carrier.Interpret\nimport Control.Carrier.State.Strict\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 58,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 83.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 43 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 23 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: type signature for diags has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has 4 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 30 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 35 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 36 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 41 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has 6 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 42 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has 2 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has 1 lines of code \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 50 1: function queens has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 52 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/static_refactored/benchmark/Bench/NonDet/NQueens.hs\" 53 1: function benchmark has 4 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Writer.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 98,
              "homplexity_lines_of_code": 106,
              "code_quality_score": 81.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 106,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 1 1: module Writer has 74 lines of code \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 35 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 35 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 36 1: function tests has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 36 1: function tests has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 36 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 66 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 66 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 67 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 69 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 69 1: type signature for genN has 5 arguments \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 77 1: function genN has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 77 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 77 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 83 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 83 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 91 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 91 1: function test has 7 lines of code \nInfo:/tmp/project_93/static_refactored/test/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Writer.hs\" 91 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/NonDet.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 63,
              "homplexity_lines_of_code": 71,
              "code_quality_score": 84.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 71,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 1 1: module NonDet has 50 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 25 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 25 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 26 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 26 1: function tests has 11 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 26 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 41 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 41 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 41 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 43 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 43 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 44 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 44 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 44 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 55 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 55 1: function test has 8 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet.hs\" 55 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Fusion.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Fusion.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.8,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 75.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.8,
                  "sum": 9
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 1 1: module Fusion has 43 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 16 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 16 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 17 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 17 1: function tests has 13 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 17 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 33 1: type signature for failureOf has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 33 1: type signature for failureOf has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 34 1: function failureOf has 2 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 34 1: function failureOf has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 34 1: function failureOf has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 38 1: type signature for countDown has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 38 1: type signature for countDown has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 39 1: function countDown has 2 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 39 1: function countDown has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 39 1: function countDown has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 42 1: type signature for countBoth has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 42 1: type signature for countBoth has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 43 1: function countBoth has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 43 1: function countBoth has cyclomatic complexity of 3 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 43 1: function countBoth has 7 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 51 1: type signature for throwing has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 51 1: type signature for throwing has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 52 1: function throwing has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 52 1: function throwing has 2 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fusion.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fusion.hs\" 52 1: function throwing has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Fusion.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | (even n) -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Throw.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 54,
              "code_quality_score": 88.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 54,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 1 1: module Throw has 40 lines of code \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 33 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 33 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 34 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 34 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 34 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 37 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 47 1: function test has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Throw.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Throw.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Reader.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 75,
              "homplexity_lines_of_code": 86,
              "code_quality_score": 83.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 86,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 1 1: module Reader has 64 lines of code \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 27 1: function tests has 15 lines of code \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 45 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 45 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 51 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 51 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 51 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 53 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 53 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 59 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 59 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 59 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 62 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 62 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 70 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 70 1: function test has 5 lines of code \nInfo:/tmp/project_93/static_refactored/test/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Reader.hs\" 70 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Reader\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Reader as ReaderC\nimport           Control.Effect.Reader\nimport qualified Control.Monad.Trans.Reader as ReaderT\nimport qualified Control.Monad.Trans.RWS.Lazy as LazyRWST\nimport qualified Control.Monad.Trans.RWS.Strict as StrictRWST\nimport           Data.Function ((&))\nimport           Gen\nimport           GHC.Generics ((:.:)(..))\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Reader\"\n  [ testGroup \"ReaderC\" $\n    [ testMonad\n    , testMonadFix\n    , testReader\n    ] >>= ($ runR (uncurry ReaderC.runReader . lower))\n  , testGroup \"(->)\"          $ testReader (runR (uncurry (fmap pure . (&))            . lower))\n  , testGroup \"ReaderT\"       $ testReader (runR (uncurry (flip ReaderT.runReaderT)    . lower))\n  , testGroup \"RWST (Lazy)\"   $ testReader (runR (uncurry (runRWST LazyRWST.runRWST)   . lower))\n  , testGroup \"RWST (Strict)\" $ testReader (runR (uncurry (runRWST StrictRWST.runRWST) . lower))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 r) (genN r)) a b c (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testMonadFix run = MonadFix.test (m (gen0 r) (genN r)) a b   (Comp1 <$> (identity <*> (pair <*> r <*> unit))) run\n  testReader   run = Reader.test r (m (gen0 r) (genN r)) a                (identity <*>                 unit)   run\n  runRWST f r m = (\\ (a, _, ()) -> a) <$> f m r r\n  lower = runIdentity . unComp1\n\n\ngen0\n  :: forall r m a sig\n  .  (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 _ a\u00a0= [ label \"asks\" (asks @r) <*> fn a ]\n\ngenN\n  :: (Has (Reader r) sig m, Arg r, Show r, Vary r)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN r m\u00a0a = [ subtermM (m a) (label \"local\" local <*> fn r <*>) ]\n\n\ntest\n  :: (Has (Reader r) sig m, Arg r, Eq a, Show a, Show r, Vary r, Functor f)\n  => GenTerm r\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run (f :.: (,) r) Identity m\n  -> [TestTree]\ntest r m a\u00a0i (Run runReader) =\n  [ testProperty \"ask returns the environment variable\" . forall_ (i :. r :. fn (m a) :. Nil) $\n    \\ i r k -> runReader (Comp1 ((r, ask >>= k) <$ i)) === runReader (Comp1 ((r, k r) <$ i))\n  , testProperty \"local modifies the environment variable\" . forall_ (i :. r :. fn r :. m a :. Nil) $\n    \\ i r f m -> runReader (Comp1 ((r, local f m) <$ i)) === runReader (Comp1 ((f r, m) <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Fail.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Fail.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 56,
              "code_quality_score": 88.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 56,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 1 1: module Fail has 41 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Fail.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/State.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 85,
              "homplexity_lines_of_code": 100,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 100,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 1 1: module State has 68 lines of code \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 30 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 30 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 31 1: function tests has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 31 1: function tests has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 31 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 61 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 61 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 67 1: function gen0 has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 67 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 67 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 73 1: type signature for test has 5 arguments \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 73 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 80 1: function test has 5 lines of code \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 80 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/State.hs:SrcLoc \"/tmp/project_93/static_refactored/test/State.hs\" 80 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule State\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.State.Church as C.Church\nimport qualified Control.Carrier.State.Lazy as C.Lazy\nimport qualified Control.Carrier.State.Strict as C.Strict\nimport           Control.Effect.State\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWST.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWST.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWST.Strict\nimport qualified Control.Monad.Trans.State.Lazy as T.Lazy\nimport qualified Control.Monad.Trans.State.Strict as T.Strict\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"State\"\n  [ testGroup \"StateC (Church)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC (C.Church.runState (curry pure)))\n  , testGroup \"StateC (Lazy)\"   $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Lazy.runState)\n  , testGroup \"StateC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testState\n    ] >>= ($ runC C.Strict.runState)\n  , testGroup \"StateT (Lazy)\"   $ testState (runC (fmap (fmap swap) . flip T.Lazy.runStateT))\n  , testGroup \"StateT (Strict)\" $ testState (runC (fmap (fmap swap) . flip T.Strict.runStateT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"      $ testState (runC (runRWST RWST.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"     $ testState (runC (runRWST RWST.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"   $ testState (runC (runRWST RWST.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 s) (\\ _ _ -> [])) a b c (pair <*> s <*> unit) run\n  testMonadFix run = MonadFix.test (m (gen0 s) (\\ _ _ -> [])) a b   (pair <*> s <*> unit) run\n  testState    run = State.test    (m (gen0 s) (\\ _ _ -> [])) a               s           run\n  runRWST f s m = (\\ (a, s, ()) -> (s, a)) <$> f m s s\n\n\ngen0\n  :: forall s m a sig\n  .  (Has (State s) sig m, Arg s, Show s, Vary s)\n  => GenTerm s\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 s a =\n  [ label \"gets\" (gets @s) <*> fn a\n  , infixL 4 \"<$\" (<$) <*> a <*> (label \"put\" put <*> s)\n  ]\n\n\ntest\n  :: (Has (State s) sig m, Arg s, Eq a, Eq s, Show a, Show s, Vary s)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm s\n  -> Run ((,) s) ((,) s) m\n  -> [TestTree]\ntest m a s (Run runState) =\n  [ testProperty \"get returns the state variable\" . forall_ (s :. fn (m a) :. Nil) $\n    \\ s k -> runState (s, get >>= k) === runState (s, k s)\n  , testProperty \"put updates the state variable\" . forall_ (s :. s :. m a :. Nil) $\n    \\ s s' m -> runState (s, put s' >> m) === runState (s', m)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Cull.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Cull.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 60,
              "code_quality_score": 86.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 60,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 1 1: module Cull has 44 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 24 1: function tests has 10 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 37 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 37 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 38 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 38 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 38 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 40 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 40 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 41 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 41 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 41 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 44 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 44 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 52 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 52 1: function test has 4 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cull.hs\" 52 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Cull.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Catch.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 40,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 1 1: module Catch has 32 lines of code \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 14 1: function tests has 2 lines of code \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 18 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 18 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 25 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 25 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 25 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 28 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 28 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 37 1: function test has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 37 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Catch.hs\" 37 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Catch.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Lift.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 23,
              "homplexity_lines_of_code": 26,
              "code_quality_score": 93.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 26,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 1 1: module Lift has 18 lines of code \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 13 1: function tests has 7 lines of code \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 22 1: type signature for handle has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 22 1: type signature for handle has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 23 1: function handle has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 23 1: function handle has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Lift.hs\" 23 1: function handle has branching depth of 0 \n"
              },
              "original_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Gen.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Gen.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 34
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 327,
              "homplexity_lines_of_code": 328,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 34
                },
                "homplexity_loc": 328,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"m\": 1,\n        \"genT\": 1,\n        \"a\": 1,\n        \"b\": 1,\n        \"c\": 1,\n        \"e\": 1,\n        \"r\": 1,\n        \"s\": 1,\n        \"w\": 1,\n        \"unit\": 1,\n        \"identity\": 1,\n        \"runL\": 1,\n        \"runR\": 1,\n        \"runC\": 1,\n        \"forall_\": 1,\n        \"showing\": 1,\n        \"atom\": 1,\n        \"label\": 1,\n        \"infixL\": 1,\n        \"infixR\": 1,\n        \"pair\": 1,\n        \"addLabel\": 1,\n        \"checkTestTree\": 2,\n        \"testGroup\": 1,\n        \"testProperty\": 1,\n        \"choice\": 1,\n        \"integral\": 1,\n        \"unicode\": 1,\n        \"string\": 1,\n        \"subtermM\": 1,\n        \"subtermM2\": 1,\n        \"fn\": 1,\n        \"termFn\": 1,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.0303030303030303,\n        \"sum\": 34\n    },\n    \"homplexity_loc\": 328,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM\u00a0m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . (>>= (<$ tell (Set.singleton (fromString s)))) . unComp1\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a\u00a0:<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Gen.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-identities #-}\nmodule Gen\n( module Data.Functor.Identity\n  -- * Polymorphic generation & instantiation\n, m\n, GenM\n, genT\n, T(..)\n, a\n, A\n, b\n, B\n, c\n, C\n, e\n, E\n, r\n, R\n, s\n, S\n, w\n, W\n, unit\n, identity\n  -- * Handlers\n, Run(..)\n, runL\n, runR\n, runC\n  -- * Generation\n, Rec(..)\n, forall_\n  -- * Showing generated values\n, showing\n, GenTerm\n, atom\n, Gen.label\n, infixL\n, infixR\n, pair\n, addLabel\n  -- * Test trees\n, TestTree\n, checkTestTree\n, testGroup\n, testProperty\n  -- * Re-exports\n, Gen\n, (===)\n, (/==)\n, Gen.choice\n, Gen.integral\n, Gen.unicode\n, Gen.string\n, Gen.subtermM\n, Gen.subtermM2\n, Fn.Arg\n, Fn.Vary\n, Gen.fn\n, termFn\n, Fn.apply\n) where\n\nimport           Control.Applicative\nimport           Control.Monad.Trans.Class\nimport           Control.Monad.Trans.Writer\nimport           Data.Foldable (traverse_)\nimport           Data.Function (on)\nimport           Data.Functor.Classes (showsUnaryWith)\nimport           Data.Functor.Identity\nimport           Data.Proxy\nimport qualified Data.Semigroup as S\nimport qualified Data.Set as Set\nimport           Data.String (fromString)\nimport           GHC.Generics ((:.:)(..))\nimport           GHC.Stack\nimport           GHC.TypeLits\nimport           Hedgehog hiding (Rec (..))\nimport qualified Hedgehog.Function as Fn\nimport           Hedgehog.Gen as Hedgehog\nimport           Hedgehog.Range\n\n-- | A generator for\u00a0computations, given a higher-order generator for effectful operations, & a generator for results.\nm\n  :: forall m\n  .  Monad m\n  => (forall a . GenTerm a -> [GenTerm (m a)])\n  -> (forall a . GenM m -> GenTerm a -> [GenTerm (m a)]) -- ^ A higher-order computation generator using any effects in @m@.\n  -> GenM m                                              -- ^ A computation generator.\nm terminals nonterminals = m where\n  m :: GenM m\n  m a = Comp1 $ scale (`div` 2) $ recursive Hedgehog.choice\n    (unComp1 <$> ((Gen.label \"pure\" pure <*> a) : terminals a))\n    ( unComp1 (addLabel \">>\" (Gen.subtermM2 (m a) (m a) (\\ a b -> infixL 1 \">>\" (>>) <*> a <*> b)))\n    : (unComp1 <$> nonterminals m a))\n\n-- | Computation generators are higher-order generators of computations in some monad @m@.\ntype GenM m = (forall a . GenTerm a -> GenTerm (m a))\n\n\ngenT :: KnownSymbol s => GenTerm (T s)\ngenT = Gen.integral (linear 0 100)\n\nnewtype T (a :: Symbol) = T { unT :: Integer }\n  deriving (Enum, Eq, Fn.Generic, Integral, Num, Ord, Real, Fn.Vary)\n\ninstance Fn.Arg (T a)\n\ninstance S.Semigroup (T a) where\n  T a <> T b = T (a + b)\n\ninstance Monoid (T a) where\n  mempty = T 0\n  mappend = (S.<>)\n\ninstance KnownSymbol s => Show (T s) where\n  showsPrec d = showsUnaryWith showsPrec (symbolVal (Proxy @s)) d . unT\n\na :: GenTerm A\na = genT\n\ntype A = T \"A\"\n\nb :: GenTerm B\nb = genT\n\ntype B = T \"B\"\n\nc :: GenTerm C\nc = genT\n\ntype C = T \"C\"\n\ne :: GenTerm E\ne = genT\n\ntype E = T \"E\"\n\nr :: GenTerm R\nr = genT\n\ntype R = T \"R\"\n\ns :: GenTerm S\ns = genT\n\ntype S = T \"S\"\n\nw :: GenTerm W\nw = genT\n\ntype W = T \"W\"\n\nunit :: GenTerm ()\nunit = atom \"()\" ()\n\nidentity :: GenTerm (a -> Identity a)\nidentity = atom \"Identity\" Identity\n\nfn :: (Fn.Arg a, Fn.Vary a, Show a) => GenTerm b -> GenTerm (a -> b)\nfn b = Comp1 (lift (fmap (fmap runTerm) . showingFn <$> Fn.fn (fst <$> runWriterT (unComp1 b))))\n\ntermFn :: GenTerm b -> GenTerm (a -> b)\ntermFn b = Comp1 $ recursive Hedgehog.choice\n  [ unComp1 (atom \"const\" const <*> b) ]\n  []\n\nchoice :: [GenTerm a] -> GenTerm a\nchoice = Comp1 . Hedgehog.choice . Prelude.map unComp1\n\nintegral :: (Integral a, Show a) => Range a -> GenTerm a\nintegral range = Comp1 (showing <$> Hedgehog.integral range)\n\nunicode :: GenTerm Char\nunicode = Comp1 (showing <$> Hedgehog.unicode)\n\nstring :: Range Int -> GenTerm Char -> GenTerm String\nstring range cs = Comp1 (showing <$> Hedgehog.string range (runTerm <$> unComp1 cs))\n\nsubtermM :: GenTerm a -> (GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM t f = Comp1 (Hedgehog.subtermM (unComp1 t) (unComp1 . f . term))\n\nsubtermM2 :: GenTerm a -> GenTerm a -> (GenTerm a -> GenTerm a -> GenTerm a) -> GenTerm a\nsubtermM2 t1 t2 f = Comp1 (Hedgehog.subtermM2 (unComp1 t1) (unComp1 t2) (fmap unComp1 . f `on` term))\n\n\n-- | This captures the shape of the handler function passed to the \"Monad\" & \"MonadFix\" tests.\nnewtype Run f g m = Run (forall a . f (m a) -> Identity (g a))\n\n-- | Handlers with output state, but no input state (e.g. 'Control.Carrier.Error.Either.ErrorC').\nrunL :: (forall a . m a -> Identity (f a)) -> Run Identity f m\nrunL run = Run (run . runIdentity)\n\n-- | Handlers with input state, but no output state (e.g. 'Control.Carrier.Reader.ReaderC').\nrunR :: (forall a . f (m a) -> Identity a) -> Run f Identity m\nrunR run = Run (fmap Identity . run)\n\n-- | Handlers with curried input state (e.g. 'Control.Carrier.Reader.ReaderC', 'Control.Carrier.State.Strict.StateC').\nrunC :: (forall a . s -> m a -> Identity (f a)) -> Run ((,) s) f m\nrunC run = Run (uncurry run)\n\n\ninfixr 5 :.\n\ndata Rec as where\n  Nil :: Rec '[]\n  (:.) :: a -> Rec as -> Rec (a ': as)\n\nforall_ :: (Forall g f, HasCallStack) => g -> f -> Hedgehog.Property\nforall_ g f = withFrozenCallStack $ Hedgehog.property (forall' g f)\n\nclass Forall g f | g -> f, f -> g where\n  forall' :: HasCallStack => g -> f -> PropertyT IO ()\n\ninstance Forall (Rec '[]) (PropertyT IO ()) where\n  forall' Nil = id\n\ninstance (Forall (Rec gs) b) => Forall (Rec (GenTerm a ': gs)) (a -> b) where\n  forall' (g :. gs) f = do\n    HideLabels (a, labels) <- Hedgehog.forAll (HideLabels <$> runWriterT (unComp1 g))\n    traverse_ Hedgehog.label labels\n    forall' gs (f (runTerm a))\n\nnewtype HideLabels a = HideLabels { unHideLabels :: (a, Set.Set LabelName) }\n\ninstance Show a => Show (HideLabels a) where\n  showsPrec d = showsPrec d . fst . unHideLabels\n\n\nshowing :: Show a => a -> Term a\nshowing = Pure . flip showsPrec <*> id\n\nshowingFn :: (Show a, Show b) => Fn.Fn a b -> Term (a -> b)\nshowingFn = Pure . flip showsPrec <*> Fn.apply\n\n\ntype GenTerm = WriterT (Set.Set LabelName) Gen :.: Term\n\nterm :: Term a -> GenTerm a\nterm = Comp1 . pure\n\natom :: String -> a -> GenTerm a\natom s = term . Pure (const (showString s))\n\nlabel :: String -> a -> GenTerm a\nlabel s = addLabel s . atom s\n\ninfixL :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixL p s f = term (InfixL p s f)\n\ninfixR :: Int -> String -> (a -> b -> c) -> GenTerm (a -> b -> c)\ninfixR p s f = term (InfixR p s f)\n\npair :: GenTerm (a -> b -> (a, b))\npair = term Pair\n\naddLabel :: String -> GenTerm a -> GenTerm a\naddLabel s = Comp1 . ((<$ tell (Set.singleton (fromString s))) Control.Monad.<=< unComp1)\n\n\ndata Term a where\n  Pure :: (Int -> ShowS) -> a -> Term a\n  InfixL :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  InfixR :: Int -> String -> (a -> b -> c) -> Term (a -> b -> c)\n  Pair :: Term (a -> b -> (a, b))\n  (:<*>) :: Term (a -> b) -> Term a -> Term b\n\ninfixl 4 :<*>\n\nrunTerm :: Term a -> a\nrunTerm = \\case\n  Pure _ a -> a\n  InfixL _ _ f -> f\n  InfixR _ _ f -> f\n  Pair -> (,)\n  f :<*> a -> runTerm f $ runTerm a\n\ninstance Functor Term where\n  fmap = liftA\n\ninstance Applicative Term where\n  pure = Pure (const (showString \"_\"))\n  (<*>) = (:<*>)\n\ninstance Show (Term a) where\n  showsPrec d = \\case\n    Pure s _ -> s d\n    InfixL _ s _ -> showParen True (showString s)\n    InfixR _ s _ -> showParen True (showString s)\n    Pair -> showParen True (showString \",\")\n    InfixL p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec p a . showString \" \" . showString s . showString \" \" . showsPrec (succ p) b)\n    InfixR p s _ :<*> a :<*> b -> showParen (d > p) (showsPrec (succ p) a . showString \" \" . showString s . showString \" \" . showsPrec p b)\n    Pair :<*> a :<*> b -> showParen True (shows a . showString \", \" . shows b)\n    InfixL p s _ :<*> a -> showParen True (showsPrec p a . showString \" \" . showString s)\n    InfixR p s _ :<*> a -> showParen True (showsPrec (succ p) a . showString \" \" . showString s)\n    f :<*> a -> showParen (d > 10) (showsPrec 10 f . showString \" \" . showsPrec 11 a)\n\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree = \\case\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Error.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Error.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 64,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 84.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 1 1: module Error has 55 lines of code \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 24 1: function tests has 17 lines of code \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 43 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 44 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 46 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 46 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 52 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 52 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 52 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 55 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 55 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 64 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 64 1: function test has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Error.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Error.hs\" 64 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Error\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Catch\nimport qualified Control.Carrier.Error.Church as C.Church\nimport qualified Control.Carrier.Error.Either as C.Either\nimport           Control.Effect.Error\nimport qualified Control.Monad.Trans.Except as T.Except\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified Throw\n\ntests :: TestTree\ntests = testGroup \"Error\"\n  [ testGroup \"ErrorC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL (C.Church.runError (pure . Left) (pure . Right)))\n  , testGroup \"ErrorC (Either)\" $\n    [ testMonad\n    , testMonadFix\n    , testError\n    ] >>= ($ runL C.Either.runError)\n  , testGroup \"Either\"  $ testError (runL pure)\n  , testGroup \"ExceptT\" $ testError (runL T.Except.runExceptT)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (genN e)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (genN e)) a b   initial run\n  testError    run = Error.test e  (m (gen0 e) (genN e)) a b   initial run\n  initial = identity <*> unit\n\ngen0 :: Has (Error e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 = Throw.gen0\n\ngenN\n  :: (Has (Error e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN = Catch.genN\n\n\ntest\n  :: (Has (Error e) sig m, Arg a, Arg e, Eq a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m = Throw.test e m S.<> Catch.test e m\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Choose.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 57,
              "code_quality_score": 88.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 57,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 1 1: module Choose has 40 lines of code \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 18 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 18 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 19 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 19 1: function tests has 11 lines of code \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 19 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 33 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 33 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 34 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 34 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 34 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 37 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 45 1: function test has 5 lines of code \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 45 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Choose.hs\" 45 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Choose.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Choose\n( tests\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Choose.Church as ChooseC\nimport           Control.Effect.Choose\nimport           Data.List.NonEmpty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Choose\"\n  [ testGroup \"ChooseC\"  $\n    [ testMonad\n    , testMonadFix\n    , testChoose\n    ] >>= ($ runL (ChooseC.runChooseS (pure . pure)))\n  , testGroup \"NonEmpty\" $ testChoose (runL (pure . toList))\n  ] where\n  testMonad    run = Monad.test    (m mempty genN) a b c initial run\n  testMonadFix run = MonadFix.test (m mempty genN) a b   initial run\n  testChoose   run = Choose.test   (m mempty genN) a b   initial run\n  initial = identity <*> unit\n\n\ngenN :: Has Choose sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = [ addLabel \"<|>\" (subtermM2 (m a) (m a) (\\ a b -> infixL 3 \"<|>\" (<|>) <*> a <*> b)) ]\n\n\ntest\n  :: (Has Choose sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runChoose) =\n  [ testProperty \">>= distributes over <|>\" . forall_ (i :. m a :. m a :. fn (m b) :. Nil) $\n    \\ i m n k -> runChoose (((m <|> n) >>= k) <$ i) === runChoose (((m >>= k) <|> (n >>= k)) <$ i)\n  , testProperty \"<|> is associative\" . forall_ (i :. m a :. m a :. m a :. Nil) $\n    \\ i m n o -> runChoose (((m <|> n) <|> o) <$ i) === runChoose ((m <|> (n <|> o)) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Accum.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Accum.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Accum\n( tests\n) where\n\nimport qualified Control.Carrier.Accum.Church as C.Accum.Church\nimport qualified Control.Carrier.Accum.Strict as C.Accum.Strict\nimport           Control.Effect.Accum\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as T.Accum\nimport           Data.Tuple (swap)\n#endif\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport Data.Bifunctor (first)\n\ntests :: TestTree\ntests = testGroup \"Accum\"\n  [ testGroup \"AccumC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC (C.Accum.Church.runAccum (curry pure)))\n  , testGroup \"AccumC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testAccum\n    ] >>= ($ runC C.Accum.Strict.runAccum)\n#if MIN_VERSION_transformers(0,5,4)\n  , testGroup \"AccumT\" $ testAccum (runC (fmap (fmap swap) . flip T.Accum.runAccumT))\n#endif\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (\\_ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (\\_ _ -> [])) a b   initial run\n  testAccum    run = Accum.test    (m (gen0 w) (\\_ _ -> [])) a     w       run\n  initial = pair <*> w <*> unit\n\ngen0\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Vary w, Show w)\n  => GenTerm w\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngen0 w a =\n  [ infixL 4 \"<$\" (<$) <*> a <*> (label \"add\" add <*> w)\n  , label \"looks\" (looks @w) <*> fn a\n  ]\n\ntest\n  :: forall w sig m a\n  .  (Has (Accum w) sig m, Arg w, Eq a, Eq w, Show a, Show w, Vary w, Monoid w)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm w\n  -> Run ((,) w) ((,) w) m\n  -> [TestTree]\ntest m a w (Run runAccum) =\n  [ testProperty \"look returns the log variable (simple)\" . forall_ (w :. Nil) $\n    \\ w -> runAccum (w, look) === Identity (mempty, w)\n  , testProperty \"add appends to the log variable (simple)\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w) === Identity (w, ())\n  , testProperty \"look returns the log variable (continuation)\" . forall_ (w :. fn (m a) :. Nil) $\n    \\ w0 k -> runAccum (w0, look >>= k) === runAccum (w0, k w0)\n  , testProperty \"add appends to the log variable and alters the environment for look\" . forall_ (w :. w :. Nil) $\n    \\ w0 w -> runAccum (w0, add w >> look) === runAccum (mappend w0 w, look @w <* add w)\n  , testProperty \"add appends to the log variable and alters the environment for continuations\" . forall_ (w :. w :. m a :. Nil) $\n    \\ w0 w k -> runAccum (w0, add w >> k) === (first (mappend w) <$> runAccum (mappend w0 w, k))\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Accum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": ""
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/MonadFix.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/MonadFix.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 31,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 1 1: module MonadFix has 24 lines of code \nInfo:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 14 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 14 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 22 1: function test has 9 lines of code \nInfo:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/static_refactored/test/MonadFix.hs\" 22 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/MonadFix.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Test.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Test.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 20,
              "lines_of_code": 46,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 91.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 1 1: module Main has 42 lines of code \nInfo:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 26 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 26 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 27 1: function main has 19 lines of code \nInfo:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 27 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Test.hs\" 27 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Test.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Accum\nimport qualified Catch\nimport qualified Choose\nimport qualified Cull\nimport qualified Cut\nimport qualified Cut.Church\nimport qualified Empty\nimport qualified Error\nimport qualified Fail\nimport qualified Fresh\nimport qualified Fusion\nimport           Gen\nimport           Hedgehog.Main\nimport qualified Lift\nimport qualified NonDet\nimport qualified NonDet.Church\nimport qualified Reader\nimport qualified State\nimport qualified Throw\nimport qualified Writer\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Accum.tests\n  , Catch.tests\n  , Choose.tests\n  , Cull.tests\n  , Cut.tests\n  , Cut.Church.tests\n  , Empty.tests\n  , Error.tests\n  , Fail.tests\n  , Fresh.tests\n  , Fusion.tests\n  , Lift.tests\n  , NonDet.tests\n  , NonDet.Church.tests\n  , Reader.tests\n  , State.tests\n  , Throw.tests\n  , Writer.tests\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Monad.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Monad.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 37,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 37,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 1 1: module Monad has 26 lines of code \nInfo:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 13 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 13 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 22 1: function test has 11 lines of code \nInfo:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Monad.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Monad.hs\" 22 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Monad.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Monad law, left identity\" #-}\n{-# HLINT ignore \"Monad law, right identity\" #-}\n{-# HLINT ignore \"Use <$>\" #-}\nmodule Monad\n( test\n) where\n\nimport Control.Monad (ap, (>=>))\nimport Gen\n\ntest\n  :: (Monad m, Arg a, Arg b, Eq (g a), Eq (g b), Eq (g c), Show a, Show b, Show (g a), Show (g b), Show (g c), Vary a, Vary b, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm c\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b c s (Run run) =\n  [ testProperty \"return is the left-identity of >>=\" . forall_ (s :. a :. fn (m b) :. Nil) $\n    \\ s a k -> run ((return a >>= k) <$ s) === run (k a <$ s)\n  , testProperty \"return is the right-identity of >>=\" . forall_ (s :. m a :. Nil) $\n    \\ s m -> run ((m >>= return) <$ s) === run (m <$ s)\n  , testProperty \">>= is associative\" . forall_ (s :. m a :. fn (m b) :. fn (m c) :. Nil) $\n    \\ s m k h -> run ((m >>= (k >=> h)) <$ s) === run (((m >>= k) >>= h) <$ s)\n  , testProperty \"return = pure\" . forall_ (s :. a :. Nil) $\n    \\ s a -> run (return a <$ s) === run (pure a <$ s)\n  , testProperty \"ap = (<*>)\" . forall_ (s :. fn b :. m a :. Nil) $\n    \\ s f m -> run ((pure f `ap` m) <$ s) === run ((pure f <*> m) <$ s)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Cut.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 10,
              "lines_of_code": 69,
              "homplexity_lines_of_code": 82,
              "code_quality_score": 83.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 82,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 1 1: module Cut has 58 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 26 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 26 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 27 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 27 1: function tests has 14 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 27 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 44 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 44 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 45 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 45 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 45 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 47 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 47 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 48 1: function genN has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 48 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 48 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 51 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 51 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 61 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 61 1: function test has 8 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut.hs\" 61 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Cut.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Cut\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cut.Church as CutC\nimport           Control.Carrier.Reader\nimport           Control.Effect.Choose\nimport           Control.Effect.Cut (Cut, call, cutfail)\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\nimport qualified Reader\n\ntests :: TestTree\ntests = testGroup \"Cut\"\n  [ testGroup \"CutC\" $\n    [ testMonad\n    , testMonadFix\n    , testCut\n    ] >>= ($ runL CutC.runCutA)\n  , testGroup \"ReaderC \u00b7 CutC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (CutC.runCutA . uncurry runReader))\n  , testGroup \"CutC \u00b7 ReaderC\" $\n    Cut.test (local (id @R)) (m (gen0 S.<> Reader.gen0 r) (\\ m -> genN m S.<> Reader.genN r m)) a b (pair <*> r <*> unit) (Run (uncurry ((. CutC.runCutA) . runReader)))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCut      run = Cut.test id   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cut sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 a = label \"cutfail\" cutfail : NonDet.gen0 a\n\ngenN :: (Has Cut sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"call\" call <*>) : NonDet.genN m a\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Cut sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => (forall a . m a -> m a)\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest hom m = (\\ a _ i (Run runCut) ->\n  [ testProperty \"cutfail annihilates >>=\" (forall_ (i :. fn @a (m a) :. Nil)\n    (\\ i k -> runCut ((hom cutfail >>= k) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"cutfail annihilates <|>\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom cutfail <|> m) <$ i) === runCut (hom cutfail <$ i)))\n  , testProperty \"call delimits cutfail\" (forall_ (i :. m a :. Nil)\n    (\\ i m -> runCut ((hom (call (hom cutfail)) <|> m) <$ i) === runCut (m <$ i)))\n  ])\n  S.<> NonDet.test m\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Empty.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Empty.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 59,
              "homplexity_lines_of_code": 70,
              "code_quality_score": 87.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 70,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 1 1: module Empty has 49 lines of code \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 23 1: function tests has 17 lines of code \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 43 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 43 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 44 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 44 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 44 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 56 1: function test has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 56 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Empty.hs\" 56 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Empty.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Fresh.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Fresh.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 87.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 1 1: module Fresh has 43 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 20 1: function tests has 16 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 39 1: type signature for gen has 2 arguments \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 39 1: type signature for gen has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 40 1: function gen has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 40 1: function gen has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 40 1: function gen has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 43 1: type signature for test has 5 arguments \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 43 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 50 1: function test has 3 lines of code \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 50 1: function test has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Fresh.hs\" 50 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Fresh.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fresh\n( tests\n, gen\n, test\n) where\n\nimport qualified Control.Carrier.Fresh.Church as C.Church\nimport qualified Control.Carrier.Fresh.Strict as C.Strict\nimport           Control.Effect.Fresh\nimport           Gen\nimport qualified Hedgehog.Range as R\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fresh\"\n  [ testGroup \"FreshC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC (C.Church.runFresh (curry pure)))\n  , testGroup \"FreshC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testFresh\n    ] >>= ($ runC C.Strict.runFresh)\n  ] where\n  testMonad    run = Monad.test    (m gen (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen (\\ _ _ -> [])) a b   initial run\n  testFresh    run = Fresh.test    (m gen (\\ _ _ -> [])) a     initial run\n  initial = pair <*> n <*> unit\n  n = Gen.integral (R.linear 0 100)\n\n\ngen :: Has Fresh sig m => GenTerm a -> [GenTerm (m a)]\ngen a = [ atom \"fmap\" fmap <*> fn a <*> label \"fresh\" fresh ]\n\n\ntest\n  :: (Has Fresh sig m, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) Int) m\n  -> [TestTree]\ntest m a i (Run runFresh) =\n  [ testProperty \"fresh yields unique values\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runFresh ((m >> fresh) <$ i) /== runFresh ((m >> fresh >> fresh) <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 32,
              "homplexity_lines_of_code": 41,
              "code_quality_score": 89.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 41,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 26 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 28 1: type signature for state has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 28 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 29 1: function state has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 29 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 29 1: function state has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 31 1: type signature for error has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 31 1: type signature for error has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 32 1: function error has 1 lines of code \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 32 1: function error has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/NonDet/Church.hs\" 32 1: function error has cyclomatic complexity of 1 \n"
              },
              "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/NonDet/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Cut/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/test/Cut/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 18,
              "code_quality_score": 96.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 18,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 1 1: module Cut.Church has 13 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 11 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 11 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 12 1: function tests has 5 lines of code \nInfo:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 12 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/test/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/test/Cut/Church.hs\" 12 1: function tests has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/test/Cut/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Cut.Church\n( tests\n) where\n\nimport Control.Carrier.Cut.Church\nimport Control.Effect.Reader\nimport Hedgehog\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Cut.Church\"\n  [ testProperty \"cutfail operates through higher-order effects\" . property $\n    runCutA @[] (local (id @()) cutfail <|> pure 'a') ()\n    ===\n    runCutA @[] (cutfail <|> pure 'a') ()\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Inference.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Inference.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 54,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 1 1: module Inference has 29 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 19 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 19 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 20 1: function example has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 20 1: function example has 7 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 20 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 39 1: type signature for askEnv has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 39 1: type signature for askEnv has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 40 1: function askEnv has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 40 1: function askEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 40 1: function askEnv has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 45 1: type signature for runEnv has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 45 1: type signature for runEnv has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 46 1: function runEnv has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 46 1: function runEnv has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 46 1: function runEnv has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Inference.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Inference.hs\" 50 26: data HasEnv has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Inference.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeApplications #-}\n\n{-# LANGUAGE UndecidableInstances #-}\nmodule Inference\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Reader\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]\n\n\n-- | A constrained wrapper around 'ask'.\n--\n--   Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the /same/ type parameter as its phantom type parameter.\n--\n--   Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.\naskEnv :: Has (Reader env) sig m => HasEnv env m env\naskEnv = ask\n\n-- | A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.\n--\n--   Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.\nrunEnv :: env -> HasEnv env (ReaderC env m) a -> m a\nrunEnv r = runReader r . runHasEnv\n\n\n-- | The identity monad transformer, with an extra phantom type parameter.\nnewtype HasEnv env m a = HasEnv { runHasEnv :: m a }\n  deriving (Applicative, Functor, Monad)\n\n-- | The 'Carrier' instance for 'HasEnv' simply delegates all effects to the underlying carrier.\nderiving instance Algebra sig m => Algebra sig (HasEnv env m)\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Utils.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Utils.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.3333333333333333,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 20,
              "homplexity_lines_of_code": 19,
              "code_quality_score": 90.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.3333333333333333,
                  "sum": 4
                },
                "homplexity_loc": 19,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 1 1: module Utils has 14 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 8 5: data TestTree has record fields count of 4 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 11 1: type signature for checkTestTree has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 11 1: type signature for checkTestTree has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 12 1: function checkTestTree has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 16 1: type signature for testGroup has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 16 1: type signature for testGroup has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 17 1: function testGroup has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 17 1: function testGroup has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 17 1: function testGroup has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 19 1: type signature for testProperty has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 19 1: type signature for testProperty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 20 1: function testProperty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 20 1: function testProperty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Utils.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Utils.hs\" 20 1: function testProperty has cyclomatic complexity of 1 \n"
              },
              "original_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Utils.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Utils\n( module Utils\n) where\n\nimport Hedgehog\n\ndata TestTree\n  = Leaf String Property\n  | Branch String [TestTree]\n\ncheckTestTree :: TestTree -> IO Bool\ncheckTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"\n\ntestGroup :: String -> [TestTree] -> TestTree\ntestGroup = Branch\n\ntestProperty :: String -> Property -> TestTree\ntestProperty = Leaf\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Parser.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.2222222222222223,
                "sum": 11
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 166,
              "homplexity_lines_of_code": 208,
              "code_quality_score": 57.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.2222222222222223,
                  "sum": 11
                },
                "homplexity_loc": 208,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 1 1: module Parser has 127 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 28 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 28 1: type signature for example has 1 arguments \nCritical:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 29 1: function example has 63 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 29 1: function example has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 29 1: function example has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 116 3: data Symbol has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 119 1: type signature for satisfy has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 119 1: type signature for satisfy has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 120 1: function satisfy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 120 1: function satisfy has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 120 1: function satisfy has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 122 1: type signature for char has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 122 1: type signature for char has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 123 1: function char has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 123 1: function char has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 123 1: function char has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 125 1: type signature for digit has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 125 1: type signature for digit has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 126 1: function digit has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 126 1: function digit has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 126 1: function digit has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 128 1: type signature for parens has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 128 1: type signature for parens has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 129 1: function parens has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 129 1: function parens has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 129 1: function parens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 132 1: type signature for parse has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 132 1: type signature for parse has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 133 1: function parse has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 133 1: function parse has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 133 1: function parse has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 137 22: data ParseC has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 151 1: type signature for expr has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 151 1: type signature for expr has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 152 1: function expr has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 152 1: function expr has 4 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 152 1: function expr has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 157 1: type signature for term has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 157 1: type signature for term has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 158 1: function term has 4 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 158 1: function term has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 158 1: function term has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 163 1: type signature for factor has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 163 1: type signature for factor has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 164 1: function factor has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 164 1: function factor has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Parser.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Parser.hs\" 164 1: function factor has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Parser.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = exhaustive Control.Monad.<=< (runState input . runParseC)\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Main.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 20,
              "homplexity_lines_of_code": 22,
              "code_quality_score": 95.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 22,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 1 1: module Main has 16 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 14 1: function main has 6 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Main.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Main.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport           Hedgehog.Main\nimport qualified Inference\nimport qualified Labelled\nimport qualified Parser\nimport qualified ReinterpretLog\nimport qualified Teletype\nimport           Utils\n\nmain :: IO ()\nmain = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/ReinterpretLog.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.1428571428571428,
                "sum": 8
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 165,
              "homplexity_lines_of_code": 100,
              "code_quality_score": 74.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.1428571428571428,
                  "sum": 8
                },
                "homplexity_loc": 100,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 12 1: module ReinterpretLog has 81 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 47 5: data Message has record fields count of 2 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has branching depth of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has cyclomatic complexity of 2 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 58 1: function application has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has 4 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 79 3: data Log has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 83 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 83 1: type signature for log has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 84 1: function log has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 92 26: data LogStdoutC has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 112 35: data ReinterpretLogC has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 131 1: type signature for reinterpretLog has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 132 1: function reinterpretLog has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 137 37: data CollectLogMessagesC has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 153 1: type signature for collectLogMessages has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 154 1: function collectLogMessages has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 158 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 158 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/ReinterpretLog.hs\" 159 1: function example has 6 lines of code \n"
              },
              "original_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 81,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 73.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 9
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 1 1: module Labelled has 58 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 20 1: type signature for sample has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 20 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 24 1: function sample has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 24 1: function sample has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 24 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 26 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 26 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 30 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 32 1: type signature for numerically has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 32 1: type signature for numerically has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 36 1: function numerically has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 36 1: function numerically has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 36 1: function numerically has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 38 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 38 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 39 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 48 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 48 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 52 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 54 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 54 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 58 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 60 1: type signature for boolean has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 60 1: type signature for boolean has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 64 1: function boolean has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 64 1: function boolean has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 64 1: function boolean has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 66 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 66 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 67 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 77 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 77 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 78 1: function example has 3 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 78 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Labelled.hs\" 78 1: function example has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Teletype.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/examples/Teletype.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 79,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 84.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 44 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 48 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 48 1: type signature for read has 1 arguments \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 49 1: function read has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 49 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 49 1: function read has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 51 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 51 1: type signature for write has 2 arguments \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 52 1: function write has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 52 1: function write has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 52 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 55 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 65 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 66 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/static_refactored/examples/Teletype.hs\" 68 28: data TeletypeRetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/examples/Teletype.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Algebra.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Algebra.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 8,
                "average": 3,
                "sum": 71
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 15,
              "lines_of_code": 343,
              "homplexity_lines_of_code": 340,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 8,
                  "average": 3,
                  "sum": 71
                },
                "homplexity_loc": 340,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"thread\": 1,\n        \"run\": 1,\n        \"send\": 1,\n        \"toRWSTF\": 1,\n        \"swapAndLift\": 1,\n        \"alg (Lift IO) IO\": 1,\n        \"alg (Lift Identity) Identity\": 1,\n        \"alg Choose NonEmpty\": 1,\n        \"alg Empty Maybe\": 1,\n        \"alg (Error e) Either\": 2,\n        \"alg (Reader r) (-> r)\": 2,\n        \"alg NonDet []\": 2,\n        \"alg (Writer w) ((,) w)\": 3,\n        \"alg (Error e :+: sig) (ExceptT)\": 3,\n        \"alg (Empty :+: sig) (MaybeT)\": 2,\n        \"alg (Reader r :+: sig) (ReaderT)\": 3,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST)\": 8,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST)\": 8,\n        \"alg (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST)\": 8,\n        \"alg (State s :+: sig) (StateT Lazy)\": 3,\n        \"alg (State s :+: sig) (StateT Strict)\": 3,\n        \"alg (Writer w :+: sig) (Writer.CPS.WriterT)\": 4,\n        \"alg (Writer w :+: sig) (Writer.Lazy.WriterT)\": 4,\n        \"alg (Writer w :+: sig) (Writer.Strict.WriterT)\": 4,\n        \"alg (Accum w :+: sig) (AccumT)\": 3,\n        \"min\": 1,\n        \"max\": 8,\n        \"average\": 2.84,\n        \"sum\": 71\n    },\n    \"homplexity_loc\": 340,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Algebra.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | The 'Algebra' class is the mechanism with which effects are interpreted.\n\nAn instance of the 'Algebra' class defines an interpretation of an effect signature atop a given monad.\n\n@since 1.0.0.0\n-}\nmodule Control.Algebra\n( Algebra(..)\n, thread\n, run\n, Has\n, send\n  -- * Re-exports\n, Handler\n, (~<~)\n, (:+:) (..)\n) where\n\nimport           Control.Algebra.Handler\n#if MIN_VERSION_transformers(0,5,4)\nimport           Control.Effect.Accum.Internal\n#endif\nimport           Control.Effect.Catch.Internal\nimport           Control.Effect.Choose.Internal\nimport           Control.Effect.Empty.Internal\nimport           Control.Effect.Error.Internal\nimport           Control.Effect.Lift.Internal\nimport           Control.Effect.NonDet.Internal\nimport           Control.Effect.Reader.Internal\nimport           Control.Effect.State.Internal\nimport           Control.Effect.Sum ((:+:)(..), Member(..), Members)\nimport           Control.Effect.Throw.Internal\nimport           Control.Effect.Writer.Internal\n#if MIN_VERSION_transformers(0,5,4)\nimport qualified Control.Monad.Trans.Accum as Accum\n#endif\nimport qualified Control.Monad.Trans.Except as Except\nimport qualified Control.Monad.Trans.Identity as Identity\nimport qualified Control.Monad.Trans.Maybe as Maybe\nimport qualified Control.Monad.Trans.Reader as Reader\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as RWS.Strict\nimport qualified Control.Monad.Trans.State.Lazy as State.Lazy\nimport qualified Control.Monad.Trans.State.Strict as State.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as Writer.Strict\nimport           Data.Functor.Compose\nimport           Data.Functor.Identity\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport           Data.Monoid\n\n-- | The class of carriers (results) for algebras (effect handlers) over signatures (effects), whose actions are given by the 'alg' method.\n--\n-- @since 1.0.0.0\nclass Monad m => Algebra sig m | m -> sig where\n  -- | Interpret an effect, running any nested actions using a 'Handler' starting from an initial state in @ctx@.\n  --\n  -- Instances receive a signature of effects containing actions in @n@ which can be lowered to @m@ using the passed 'Handler' and initial context. Continuations in @n@ can be handled after mapping into contexts returned from previous actions.\n  --\n  -- For example, considering the 'Algebra' instance for @'Either' e@:\n  --\n  -- > instance Algebra (Error e) (Either e) where\n  -- >   alg hdl sig ctx = case sig of\n  -- >     L (Throw e)   -> Left e\n  -- >     R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  --\n  -- The 'Catch' case holds actions @m :: n x@ and @h :: e -> n x@ (for some existentially-quantified type @x@), and a continuation @k :: x -> n a@. The algebra must return @m (ctx a)@, so we have to ultimately use and lower the continuation in order to produce that type. The continuation takes an @x@, which we can get from either of the actions, after lowering them to values in @'Either' e@.\n  --\n  -- To that end, the algebra lifts both the action @m@ and the result of the error handler @h@ into the initial context @ctx@ before lowering them with @hdl@. The continuation @k@ is 'fmap'ed into the resulting context and then itself lowered with @hdl@.\n  --\n  -- By contrast, the 'Throw' case can simply return a value in 'Left', since there is no continuation to call\u2014it represents an exceptional return\u2014and @'Left' e :: forall a . Either e a@ (i.e. 'Left' is polymorphic in @a@).\n  --\n  -- Instances for monad transformers will most likely handle a signature containing multiple effects, with the tail of the signature handled by whatever monad the transformer wraps. In these cases, the tail of the signature can be delegated most conveniently using 'thread'; see the 'Algebra' instances for @transformers@ types such as 'Reader.ReaderT' and 'Except.ExceptT' for details.\n  alg\n    :: Functor ctx\n    => Handler ctx n m -- ^ A 'Handler' lowering computations inside the effect into the carrier type @m@.\n    -> sig n a         -- ^ The effect signature to be interpreted.\n    -> ctx ()          -- ^ The initial state.\n    -> m (ctx a)       -- ^ The interpretation of the effect in @m@.\n\n-- | Thread a composed handler and input state through the algebra for some underlying signature.\n--\n-- @since 1.1.0.0\nthread\n  :: ( Functor ctx1\n     , Functor ctx2\n     , Algebra sig m\n     )\n  => Handler (Compose ctx1 ctx2) n m\n  -> sig n a\n  -> ctx1 (ctx2 ())\n  -> m (ctx1 (ctx2 a))\nthread hdl sig = fmap getCompose . alg hdl sig . Compose\n{-# INLINE thread #-}\n\n\n-- | Run an action exhausted of effects to produce its final result value.\n--\n-- @since 1.0.0.0\nrun :: Identity a -> a\nrun = runIdentity\n{-# INLINE run #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@.\n--\n-- Note that if @eff@ is a sum, it will be decomposed into multiple 'Member' constraints. While this technically allows one to combine multiple unrelated effects into a single 'Has' constraint, doing so has two significant drawbacks:\n--\n-- 1. Due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095), this can lead to significantly slower compiles.\n--\n-- 2. It defeats @ghc@\u2019s warnings for redundant constraints, and thus can lead to a proliferation of redundant constraints as code is changed.\n--\n-- @since 1.0.0.0\ntype Has eff sig m = (Members eff sig, Algebra sig m)\n\n-- | Construct a request for an effect to be interpreted by some handler later on.\n--\n-- @since 0.1.0.0\nsend :: (Member eff sig, Algebra sig m) => eff m a -> m a\nsend sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())\n{-# INLINE send #-}\n\n\n-- base\n\ninstance Algebra (Lift IO) IO where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra (Lift Identity) Identity where\n  alg hdl (LiftWith with) = with hdl\n  {-# INLINE alg #-}\n\ninstance Algebra Choose NonEmpty where\n  alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Algebra Empty Maybe where\n  alg _ Empty _ = Nothing\n  {-# INLINE alg #-}\n\ninstance Algebra (Error e) (Either e) where\n  alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))\n  {-# INLINE alg #-}\n\ninstance Algebra (Reader r) ((->) r) where\n  alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f\n  {-# INLINE alg #-}\n\ninstance Algebra NonDet [] where\n  alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]\n  {-# INLINE alg #-}\n\ninstance Monoid w => Algebra (Writer w) ((,) w) where\n  alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)\n  {-# INLINE alg #-}\n\n\n-- transformers\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (Except.ExceptT e m) where\n  alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)\n  {-# INLINE alg #-}\n\n\nderiving instance Algebra sig m => Algebra sig (Identity.IdentityT m)\n\n#if MIN_VERSION_base(4,12,0)\n-- | This instance permits effectful actions to be lifted into the 'Ap' monad\n-- given a monoidal return type, which can provide clarity when chaining calls\n-- to 'mappend'.\n--\n-- > mappend <$> act1 <*> (mappend <$> act2 <*> act3)\n--\n-- is equivalent to\n--\n-- > getAp (act1 <> act2 <> act3)\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Ap m)\n#endif\n\n-- | This instance permits effectful actions to be lifted into the 'Alt' monad,\n-- which eases the invocation of repeated alternation with 'Control.Applicative.<|>':\n--\n-- > a <|> b <|> c <|> d\n--\n-- is equivalent to\n--\n-- > getAlt (mconcat [a, b, c, d])\n--\n-- @since 1.0.1.0\nderiving instance Algebra sig m => Algebra sig (Alt m)\n\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (Maybe.MaybeT m) where\n  alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (Reader.ReaderT r m) where\n  alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx\n  {-# INLINE alg #-}\n\n\nnewtype RWSTF w s a = RWSTF { unRWSTF :: (a, s, w) }\n  deriving (Functor)\n\ntoRWSTF :: Monoid w => w -> (a, s, w) -> RWSTF w s a\ntoRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')\n{-# INLINE toRWSTF #-}\n\nnewtype Swap s a = Swap { getSwap :: (a, s) }\n  deriving (Functor)\n\nswapAndLift :: Functor ctx => (ctx a, w) -> ctx (w, a)\nswapAndLift p = (,) (snd p) <$> fst p\n{-# INLINE swapAndLift #-}\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.CPS.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Lazy.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Reader r :+: Writer w :+: State s :+: sig) (RWS.Strict.RWST r w s m) where\n  alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))\n  {-# INLINE alg #-}\n\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Lazy.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (State.Strict.StateT s m) where\n  alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))\n  {-# INLINE alg #-}\n\n\n#if MIN_VERSION_transformers(0,5,6)\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.CPS.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n#endif\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Lazy.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (Writer.Strict.WriterT w m) where\n  alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))\n  {-# INLINE alg #-}\n\n#if MIN_VERSION_transformers(0,5,4)\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (Accum.AccumT w m) where\n  alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))\n  {-# INLINE alg #-}\n#endif\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 80,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 70,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 90.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 31 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 68 1: type signature for #. has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/NonDet.hs\" 69 1: function #. has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 39,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 15 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 38 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Throw.hs\" 39 1: function liftEither has branching depth of 0 \n"
              },
              "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 62,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Fail.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Fail.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Fail.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 108,
              "homplexity_lines_of_code": 40,
              "code_quality_score": 84.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 40,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 30 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 80 1: function modify has 3 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 93 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 94 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 104 1: type signature for state has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State.hs\" 105 1: function state has 3 lines of code \n"
              },
              "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/State.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 40,
              "homplexity_lines_of_code": 15,
              "code_quality_score": 96.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 15,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 1 1: module Control.Effect.Cull has 14 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 28 3: data Cull has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 38 1: type signature for cull has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cull.hs\" 39 1: function cull has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Cull.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{- | Provides an effect to cull choices in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations run inside a call to 'cull' will return at most one result.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cull.Church\"\n\n@since 0.1.2.0\n-}\nmodule Control.Effect.Cull\n( -- * Cull effect\n  Cull(..)\n, cull\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\n\n-- | 'Cull' effects are used with 'Control.Effect.Choose' to provide control over branching.\n--\n-- @since 0.1.2.0\ndata Cull m k where\n  Cull :: m a -> Cull m a\n\n\n-- | Cull nondeterminism in the argument, returning at most one result.\n--\n-- @\n-- 'cull' ('pure' a 'Control.Effect.Choose.<|>' m) 'Control.Effect.Choose.<|>' n = 'pure' a 'Control.Effect.Choose.<|>' n\n-- @\n--\n-- @since 0.1.2.0\ncull :: Has Cull sig m => m a -> m a\ncull m = send (Cull m)\n{-# INLINE cull #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs",
              "cyclomatic_complexity": {
                "min": 3,
                "max": 3,
                "average": 3.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 88,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 88.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 3,
                  "max": 3,
                  "average": 3.0,
                  "sum": 3
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 1 1: module Control.Effect.Sum has 48 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 26 5: data f has record fields count of 2 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 42 3: type class Member has method + value count of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 42 3: type class Member has associated type count of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 73 1: type signature for reassociateSumL has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has 4 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has cyclomatic complexity of 3 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Sum.hs\" 74 1: function reassociateSumL has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 13,
              "code_quality_score": 96.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 13,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 12 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 68,
              "homplexity_lines_of_code": 27,
              "code_quality_score": 91.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 27,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 1 1: module Control.Effect.Lift has 24 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 36 1: type signature for sendM has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 37 1: function sendM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 45 1: type signature for sendIO has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 46 1: function sendIO has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 63 1: type signature for liftWith has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Lift.hs\" 67 1: function liftWith has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n\n{- | Provides a mechanism to kick off the evaluation of an effect stack that takes place in a monadic context.\n\n'Lift' effects are always the last effect in a given effect stack. These stacks are invoked with 'Control.Carrier.Lift.runM' or 'Control.Algebra.run'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Lift\"\n* 'IO'\n* 'Data.Functor.Identity.Identity'\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Lift\n( -- * Lift effect\n  Lift(..)\n, sendM\n, sendIO\n, liftWith\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Lift.Internal (Lift(..))\n\n-- | Given a @Lift n@ constraint in a signature carried by @m@, 'sendM'\n-- promotes arbitrary actions of type @n a@ to @m a@. It is spiritually\n-- similar to @lift@ from the @MonadTrans@ typeclass.\n--\n-- @since 1.0.0.0\nsendM :: (Has (Lift n) sig m, Functor n) => n a -> m a\nsendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)\n{-# INLINE sendM #-}\n\n-- | A type-restricted variant of 'sendM' for 'IO' actions.\n--\n-- This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.\n--\n-- @since 1.0.2.0\nsendIO :: Has (Lift IO) sig m => IO a -> m a\nsendIO = sendM\n{-# INLINE sendIO #-}\n\n\n-- | Run actions in an outer context.\n--\n-- This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:\n--\n-- @\n-- 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n-- @\n--\n-- The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.\n--\n-- As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.\n--\n-- @since 1.0.0.0\nliftWith\n  :: Has (Lift n) sig m\n  => (forall ctx . Functor ctx => Handler ctx m n -> ctx () -> n (ctx a))\n  -> m a\nliftWith with = send (LiftWith with)\n{-# INLINE liftWith #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Error.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 24,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Error.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 156,
              "homplexity_lines_of_code": 77,
              "code_quality_score": 82.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 77,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 1 1: module Control.Effect.Choose has 72 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Choose.hs\" 118 24: data Choosing has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 29 3: data Trace has record fields count of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 34 1: type signature for trace has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Trace.hs\" 35 1: function trace has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 152,
              "homplexity_lines_of_code": 149,
              "code_quality_score": 61.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 12
                },
                "homplexity_loc": 149,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runLabelled\": 1,\n        \"alg_Labelled\": 2,\n        \"injLabelled_reflexivity\": 1,\n        \"injLabelled_left_recursion\": 1,\n        \"injLabelled_left_occurrence\": 1,\n        \"injLabelled_right_recursion\": 1,\n        \"sendLabelled\": 1,\n        \"runUnderLabel\": 1,\n        \"lift\": 1,\n        \"alg_UnderLabel\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 149,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Labelled effects, allowing flexible disambiguation and dependency of parametric effects.\n--\n-- Among other things, this can be used to:\n--\n-- * Improve inference by relating parametric effect types to some arbitrary label. This can be used to lift existing effect operations, or to define new ones; cf \"Control.Effect.Reader.Labelled\", \"Control.Effect.State.Labelled\" for examples of lifting effect operations into labelled effect operations.\n--\n-- * Express stronger relationships between an effect and the context it\u2019s run in, e.g. to give an effect shadowing semantics, allowing only one instance of it to be active at a time in a given context.\n--\n-- * Resolve ambiguous types by relating parameters to a concrete label type.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Labelled\n( runLabelled\n, Labelled(Labelled)\n, LabelledMember(..)\n, HasLabelled\n, sendLabelled\n, runUnderLabel\n, UnderLabel(UnderLabel)\n, module Control.Algebra\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Sum (reassociateSumL)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\nimport Data.Kind\n\n-- | An effect transformer turning effects into labelled effects, and a carrier transformer turning carriers into labelled carriers for the same (labelled) effects.\n--\n-- @since 1.0.2.0\nnewtype Labelled (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) m a = Labelled (sub m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    , MonadTrans\n    )\n\n-- | @since 1.0.2.0\nrunLabelled :: forall label sub m a . Labelled label sub m a -> sub m a\nrunLabelled (Labelled l) = l\n{-# INLINE runLabelled #-}\n\ninstance Algebra (eff :+: sig) (sub m) => Algebra (Labelled label eff :+: sig) (Labelled label sub m) where\n  alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)\n  {-# INLINE alg #-}\n\n\n-- | The class of labelled types present in a signature.\n--\n-- @since 1.0.2.0\nclass LabelledMember label (sub :: (Type -> Type) -> (Type -> Type)) sup | label sup -> sub where\n  -- | Inject a member of a signature into the signature.\n  --\n  -- @since 1.0.2.0\n  injLabelled :: Labelled label sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance LabelledMember label t (Labelled label t) where\n  injLabelled = id\n  {-# INLINE injLabelled #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label t (l1 :+: l2 :+: r)\n      => LabelledMember label t ((l1 :+: l2) :+: r) where\n  injLabelled = reassociateSumL . injLabelled\n  {-# INLINE injLabelled #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l (Labelled label l :+: r) where\n  injLabelled = L\n  {-# INLINE injLabelled #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         LabelledMember label l r\n      => LabelledMember label l (l' :+: r) where\n  injLabelled = R . injLabelled\n  {-# INLINE injLabelled #-}\n\n\n-- | @m@ is a carrier for @sig@ containing @eff@ associated with @label@.\n--\n-- Note that if @eff@ is a sum, it will /not/ be decomposed into multiple 'LabelledMember' constraints. While this technically is possible, it results in unsolvable constraints, as the functional dependencies in 'Labelled' prevent assocating the same label with multiple distinct effects within a signature.\n--\n-- @since 1.0.2.0\ntype HasLabelled label eff sig m = (LabelledMember label eff sig, Algebra sig m)\n\n-- | Construct a request for a labelled effect to be interpreted by some handler later on.\n--\n-- @since 1.0.2.0\nsendLabelled :: forall label eff sig m a . HasLabelled label eff sig m => eff m a -> m a\nsendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())\n{-# INLINABLE sendLabelled #-}\n\n\n-- | A transformer to lift effectful actions to labelled effectful actions.\n--\n-- @since 1.0.2.0\nnewtype UnderLabel (label :: k) (sub :: (Type -> Type) -> (Type -> Type)) (m :: Type -> Type) a = UnderLabel (m a)\n  deriving\n    ( Alternative\n    , Applicative\n    , Functor\n    , Monad\n    , Fail.MonadFail\n    , MonadFix -- ^ @since 1.1.1\n    , MonadIO\n    , MonadPlus\n    )\n\n-- | @since 1.0.2.0\nrunUnderLabel :: forall label sub m a . UnderLabel label sub m a -> m a\nrunUnderLabel (UnderLabel l) = l\n{-# INLINE runUnderLabel #-}\n\ninstance MonadTrans (UnderLabel sub label) where\n  lift = UnderLabel\n  {-# INLINE lift #-}\n\ninstance (LabelledMember label sub sig, Algebra sig m) => Algebra (sub :+: sig) (UnderLabel label sub m) where\n  alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 73,
              "homplexity_lines_of_code": 27,
              "code_quality_score": 91.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 27,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 24 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 33 3: data Cut has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 60 1: type signature for call has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 60 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 61 1: function call has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 71 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Cut.hs\" 72 1: function cut has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 20,
              "code_quality_score": 94.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 20,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 15 1: module Control.Effect.Empty has 17 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 38 1: type signature for empty has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 39 1: function empty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 45 1: type signature for guard has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has 2 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Empty.hs\" 46 1: function guard has branching depth of 1 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism without choice (success or failure).\n\nThis can be seen as similar to 'Control.Effect.Fail.Fail', but without an error message. The 'Control.Effect.NonDet.NonDet' effect is the composition of 'Empty' and 'Control.Effect.Choose.Choose'.\n\nPredefined carriers:\n\n* @\"Control.Carrier.Empty.Church\".'Control.Carrier.Empty.Church.EmptyC'@\n* @\"Control.Carrier.Empty.Maybe\".'Control.Carrier.Empty.Maybe.EmptyC'@\n* @\"Control.Monad.Trans.Maybe\".'Control.Monad.Trans.Maybe.MaybeT'@\n* If 'Empty' is the last effect in a stack, it can be interpreted directly to a 'Maybe'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Empty\n( -- * Empty effect\n  Empty(..)\n, empty\n, guard\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty.Internal (Empty(..))\n\n-- | Abort the computation.\n--\n-- 'empty' annihilates '>>=':\n--\n-- @\n-- 'empty' '>>=' k = 'empty'\n-- @\n--\n-- @since 1.0.0.0\nempty :: Has Empty sig m => m a\nempty = send Empty\n{-# INLINE empty #-}\n\n-- | Conditional failure, returning only if the condition is 'True'.\n--\n-- @since 1.0.0.0\nguard :: Has Empty sig m => Bool -> m ()\nguard True  = pure ()\nguard False = empty\n{-# INLINE guard #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 37,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 1 1: module Control.Effect.Fresh has 16 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 25 3: data Fresh has record fields count of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 35 1: type signature for fresh has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Fresh.hs\" 36 1: function fresh has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Fresh.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | This effect provides source to an infinite source of 'Int' values, suitable for generating \"fresh\" values to uniquely identify data without needing to invoke random numbers or impure IO.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fresh.Church\"\n* \"Control.Carrier.Fresh.Strict\"\n-}\nmodule Control.Effect.Fresh\n( -- * Fresh effect\n  Fresh(..)\n, fresh\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Fresh (m :: Type -> Type) k where\n  Fresh :: Fresh m Int\n\n\n-- | Produce a fresh (i.e. unique) 'Int'.\n--\n-- @\n-- m '>>' 'fresh' \u2260 m '>>' 'fresh' '>>' 'fresh'\n-- @\n--\n-- @since 0.1.0.0\nfresh :: Has Fresh sig m => m Int\nfresh = send Fresh\n{-# INLINE fresh #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Reader/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 9,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 57,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 91.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 1 1: module Control.Effect.Reader.Labelled has 27 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 33 1: type signature for ask has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 34 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 44 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 45 1: function asks has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 55 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/Reader/Labelled.hs\" 56 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'Reader' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.Reader.Labelled\n( -- * Reader effect\n  Reader\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader as R\nimport           Control.Effect.Reader.Internal\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('runLabelled' @label ('ask' @label) '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 1.0.2.0\nask :: forall label r m sig . HasLabelled label (Reader r) sig m => m r\nask = runUnderLabel @label R.ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' @label f = 'fmap' f ('ask' @label)\n-- @\n--\n-- @since 1.0.2.0\nasks :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> a) -> m a\nasks f = runUnderLabel @label (R.asks f)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('runLabelled' @label ('local' @label f m)) = runReader (f a) m\n-- @\n--\n-- @since 1.0.2.0\nlocal :: forall label r m a sig . HasLabelled label (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = runUnderLabel @label (R.local f (UnderLabel m))\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/NonDet/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 13,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Choose/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Choose.Internal\n( Choose(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Choose (m :: Type -> Type) k where\n  Choose :: Choose m Bool\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Empty/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 98.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 11,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Accum/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/State/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 95,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 84.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 1 1: module Control.Effect.State.Labelled has 33 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has 1 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 36 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 37 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 47 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 48 1: function gets has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 58 1: type signature for put has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 59 1: function put has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 70 1: type signature for modify has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 71 1: function modify has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 82 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 83 1: function modifyLazy has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 93 1: type signature for state has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Effect/State/Labelled.hs\" 94 1: function state has 1 lines of code \n"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Throw/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 98.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 11,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 11,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Writer/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Catch/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Catch.Internal\n( Catch(..)\n) where\n\n-- | 'Catch' effects can be used alongside 'Control.Effect.Throw.Throw' to provide recoverable exceptions.\n--\n-- @since 1.0.0.0\ndata Catch e m k where\n  Catch :: m a -> (e -> m a) -> Catch e m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Error/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Error/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift/Internal.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Effect/Lift/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Effect/Lift/Internal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Control.Effect.Lift.Internal\n( Lift(..)\n) where\n\nimport Control.Algebra.Handler (Handler)\n\n-- | @since 1.0.0.0\ndata Lift sig m k where\n  LiftWith :: (forall ctx . Functor ctx => Handler ctx m sig -> ctx () -> sig (ctx a)) -> Lift sig m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 105,
              "homplexity_lines_of_code": 68,
              "code_quality_score": 91.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 68,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 1 1: module Control.Carrier.Reader has 67 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 42 1: type signature for runReader has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 43 1: function runReader has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Reader.hs\" 47 25: data ReaderC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Reader.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Reader' effects.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Reader\n( -- * Reader carrier\n  runReader\n, ReaderC(..)\n  -- * Reader effect\n, module Control.Effect.Reader\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Reader\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift\n\n-- | Run a 'Reader' effect with the passed environment value.\n--\n-- @\n-- 'runReader' a 'ask' = 'pure' a\n-- @\n-- @\n-- 'runReader' a ('pure' b) = 'pure' b\n-- @\n-- @\n-- 'runReader' a ('local' f m) = 'runReader' (f a) m\n-- @\n--\n-- @since 1.0.0.0\nrunReader :: r -> ReaderC r m a -> m a\nrunReader r (ReaderC runReaderC) = runReaderC r\n{-# INLINE runReader #-}\n\n-- | @since 1.0.0.0\nnewtype ReaderC r m a = ReaderC (r -> m a)\n  deriving (Functor)\n\ninstance Applicative m => Applicative (ReaderC r m) where\n  pure = ReaderC . const . pure\n  {-# INLINE pure #-}\n\n  ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)\n  {-# INLINE liftA2 #-}\n\n  ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r\n  {-# INLINE (*>) #-}\n\n  ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ReaderC r m) where\n  empty = ReaderC (const empty)\n  {-# INLINE empty #-}\n\n  ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (ReaderC r m) where\n  ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ReaderC r m) where\n  fail = ReaderC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ReaderC s m) where\n  mfix f = ReaderC (\\ r -> mfix (runReader r . f))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ReaderC r m) where\n  liftIO = ReaderC . const . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ReaderC r m)\n\ninstance MonadTrans (ReaderC r) where\n  lift = ReaderC . const\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Reader r :+: sig) (ReaderC r m) where\n  alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx\n  {-# INLINE alg #-}\n\ninstance MonadUnliftIO m => MonadUnliftIO (ReaderC r m) where\n  withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)\n  {-# INLINE withRunInIO #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 42,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 95.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 1 1: module Control.Carrier.Lift has 27 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 28 1: type signature for runM has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 29 1: function runM has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Lift.hs\" 33 21: data LiftC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Lift.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n-- | A carrier for 'Lift' allowing monadic actions to be lifted from an outer context into an inner one with 'sendM', and for an inner context to run actions in an outer one with 'liftWith'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Lift\n( -- * Lift carrier\n  runM\n, LiftC(..)\n  -- * Lift effect\n, module Control.Effect.Lift\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Lift\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\n\n-- | Extract a 'Lift'ed 'Monad'ic action from an effectful computation.\n--\n-- @since 1.0.0.0\nrunM :: LiftC m a -> m a\nrunM (LiftC m) = m\n{-# INLINE runM #-}\n\n-- | @since 1.0.0.0\nnewtype LiftC m a = LiftC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans LiftC where\n  lift = LiftC\n  {-# INLINE lift #-}\n\ninstance Monad m => Algebra (Lift m) (LiftC m) where\n  alg hdl (LiftWith with) = LiftC . with (runM . hdl)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Interpret.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Interpret.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 101,
              "homplexity_lines_of_code": 99,
              "code_quality_score": 78.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1,
                  "sum": 6
                },
                "homplexity_loc": 99,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runInterpret\": 1,\n        \"runInterpretState\": 1,\n        \"reify\": 1,\n        \"lift\": 1,\n        \"alg\": 2,\n        \"min\": 1,\n        \"max\": 2,\n        \"average\": 1.2,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 99,\n    \"homplexity_output\": \"runInterpret: 1\\nrunInterpretState: 1\\nreify: 1\\nlift: 1\\nalg: 2\"\n}"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Interpret.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides an 'InterpretC' carrier capable of interpreting an arbitrary effect using a passed-in higher order function to interpret that effect. This is suitable for prototyping new effects quickly.\n\nmodule Control.Carrier.Interpret\n( -- * Interpret carrier\n  runInterpret\n, runInterpretState\n, InterpretC(InterpretC)\n, Reifies\n, Interpreter\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Data.Functor.Const (Const(..))\nimport Data.Kind (Type)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An @Interpreter@ is a function that interprets effects described by @sig@ into the carrier monad @m@.\nnewtype Interpreter sig m = Interpreter\n  { runInterpreter :: forall ctx n s x . Functor ctx => Handler ctx n (InterpretC s sig m) -> sig n x -> ctx () -> InterpretC s sig m (ctx x) }\n\n\nclass Reifies s a | s -> a where\n  reflect :: Const a s\n\n\ndata Skolem\n\n-- | @Magic@ captures the GHC implementation detail of how single method type classes are implemented.\nnewtype Magic a r = Magic (Reifies Skolem a => Const r Skolem)\n\n-- For more information on this technique, see the @reflection@ library. We use the formulation described in https://github.com/ekmett/reflection/issues/31 for better inlining.\n--\n-- Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, which we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.\nreify :: a -> (forall s . Reifies s a => Const r s) -> r\nreify a k = unsafeCoerce (Magic k) a\n\n\n-- | Interpret an effect using a higher-order function.\n--\n-- Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!\n--\n-- @since 1.0.0.0\nrunInterpret\n  :: (forall ctx n x . Functor ctx => Handler ctx n m -> eff n x -> ctx () -> m (ctx x))\n  -> (forall s . Reifies s (Interpreter eff m) => InterpretC s eff m a)\n  -> m a\nrunInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m\n{-# INLINE runInterpret #-}\n\n-- | Interpret an effect using a higher-order function with some state variable.\n--\n-- @since 1.0.0.0\nrunInterpretState\n  :: (forall ctx n x . Functor ctx => Handler ctx n (StateC s m) -> eff n x -> s -> ctx () -> m (s, ctx x))\n  -> s\n  -> (forall t . Reifies t (Interpreter eff (StateC s m)) => InterpretC t eff (StateC s m) a)\n  -> m (s, a)\nrunInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m\n{-# INLINE runInterpretState #-}\n\n-- | @since 1.0.0.0\nnewtype InterpretC s (sig :: (Type -> Type) -> (Type -> Type)) m a = InterpretC { runInterpretC :: m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadUnliftIO)\n\ninstance MonadTrans (InterpretC s sig) where\n  lift = InterpretC\n  {-# INLINE lift #-}\n\ninstance (Reifies s (Interpreter eff m), Algebra sig m) => Algebra (eff :+: sig) (InterpretC s eff m) where\n  alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 134,
              "homplexity_lines_of_code": 84,
              "code_quality_score": 85.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 84,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 1 1: module Control.Carrier.NonDet.Church has 81 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 43 1: type signature for runNonDet has 5 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 49 1: function runNonDet has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 64 1: type signature for runNonDetA has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 65 1: function runNonDetA has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 71 1: type signature for runNonDetM has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 72 1: function runNonDetM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/NonDet/Church.hs\" 78 23: data NonDetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/NonDet/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | Provides 'NonDetC', a carrier for 'NonDet' effects providing choice and failure.\n\nUnder the hood, it uses a Church-encoded structure and a binary tree to prevent the problems associated with a na\u00efve list-based implementation.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.NonDet.Church\n( -- * NonDet carrier\n  runNonDet\n, runNonDetA\n, runNonDetM\n, NonDetC(..)\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.\n--\n-- @\n-- runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n--\n-- @since 1.0.0.0\nrunNonDet\n  :: (m b -> m b -> m b) -- ^ Handles choice ('<|>')\n  -> (a -> m b)          -- ^ Handles embedding results ('pure')\n  -> m b                 -- ^ Handles failure ('empty')\n  -> NonDetC m a         -- ^ A nondeterministic computation to execute\n  -> m b\nrunNonDet fork leaf nil (NonDetC m) = m fork leaf nil\n{-# INLINE runNonDet #-}\n\n-- | Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.\n--\n-- Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.\n--\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' [a]\n-- @\n-- @\n-- 'runNonDetA' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunNonDetA :: (Alternative f, Applicative m) => NonDetC m a -> m (f a)\nrunNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runNonDetA #-}\n\n-- | Run a 'NonDet' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunNonDetM :: (Applicative m, Monoid b) => (a -> b) -> NonDetC m a -> m b\nrunNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runNonDetM #-}\n\n-- | A carrier for 'NonDet' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype NonDetC m a = NonDetC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (NonDetC m) where\n  pure a = NonDetC (\\ _ leaf _ -> leaf a)\n  {-# INLINE pure #-}\n\n  NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (NonDetC m) where\n  empty = NonDetC (\\ _ _ nil -> nil)\n  {-# INLINE empty #-}\n\n  NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil\n  {-# INLINE (<|>) #-}\n\ninstance Monad (NonDetC m) where\n  NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (NonDetC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (NonDetC m) where\n  mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (NonDetC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (NonDetC m)\n\ninstance MonadTrans NonDetC where\n  lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (NonDet :+: sig) (NonDetC m) where\n  alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 109,
              "homplexity_lines_of_code": 71,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 71,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 1 1: module Control.Carrier.Choose.Church has 69 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Choose/Church.hs\" 63 23: data ChooseC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 33 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 33 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Printing.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 36,
              "code_quality_score": 94.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 36,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 35 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Trace/Returning.hs\" 46 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 94,
              "homplexity_lines_of_code": 63,
              "code_quality_score": 87.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 63,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" (-1) (-1): module Control.Carrier.Cull.Church has 60 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has 5 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cull/Church.hs\" 64 21: data CullC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 87,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 90.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 35 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 44 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 45 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 57 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 58 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 76 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 77 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Maybe.hs\" 81 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 141,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 85.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 1 1: module Control.Carrier.Empty.Church has 78 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 45 1: type signature for runEmpty has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 46 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 58 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 59 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 77 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 78 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Empty/Church.hs\" 82 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Empty'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Empty.Church\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Empty\nimport Control.Monad.Fix\nimport Control.Monad.Fail as Fail\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run an 'Empty' effect, returning the first continuation for 'empty' programs and applying the second to successful results.\n--\n-- @\n-- 'runEmpty' j k 'empty' = j\n-- @\n-- @\n-- 'runEmpty' j k ('pure' a) = k a\n-- @\n--\n-- @since 1.1.0.0\nrunEmpty :: m b -> (a -> m b) -> EmptyC m a -> m b\nrunEmpty nil leaf (EmptyC m) = m nil leaf\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'runEmpty' ('pure' ()) ('const' ('pure' ()))\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Applicative m => EmptyC m a -> m ()\nevalEmpty = runEmpty (pure ()) (const (pure ()))\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'runEmpty' ('pure' 'False') ('const' ('pure' 'True'))\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Applicative m => EmptyC m a -> m Bool\nexecEmpty = runEmpty (pure False) (const (pure True))\n{-# INLINE execEmpty #-}\n\n-- | @since 1.1.0.0\nnewtype EmptyC m a = EmptyC (forall b . m b -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (EmptyC m) where\n  pure a = EmptyC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  EmptyC f <*> EmptyC a = EmptyC $ \\ nil leaf ->\n    f nil (\\ f' -> a nil (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (EmptyC a) (EmptyC b) = EmptyC $ \\ nil leaf ->\n    a nil (\\ a' -> b nil (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  EmptyC a *> EmptyC b = EmptyC $ \\ nil ->\n    a nil . const . b nil\n  {-# INLINE (*>) #-}\n\n  EmptyC a <* EmptyC b = EmptyC $ \\ nil leaf ->\n    a nil (b nil . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Monad (EmptyC m) where\n  EmptyC a >>= f = EmptyC $ \\ nil leaf ->\n    a nil (runEmpty nil leaf . f)\n  {-# INLINE (>>=) #-}\n\n  (>>) = (*>)\n  {-# INLINE (>>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (EmptyC m) where\n  mfix f = EmptyC $ \\ nil leaf ->\n    mfix (toEmpty . f . run . fromEmpty)\n    >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    toEmpty   = runEmpty (pure empty) (pure . pure)\n    fromEmpty = runEmpty (error \"mfix (EmptyC): empty\") pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (EmptyC m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans EmptyC where\n  lift m = EmptyC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Empty :+: sig) (EmptyC m) where\n  alg hdl sig ctx = EmptyC $ \\ nil leaf -> case sig of\n    L Empty -> nil\n    R other -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runEmpty (coerce nil) (coerce leaf)\n    where\n    dst :: Applicative m => EmptyC Identity (EmptyC m a) -> m (EmptyC Identity a)\n    dst = run . runEmpty (pure (pure empty)) (pure . runEmpty (pure empty) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 95.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 27 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 133,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 86.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" (-1) (-1): module Control.Carrier.Accum.Church has 75 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 50 1: type signature for runAccum has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 51 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 62 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 63 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 74 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 75 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Church.hs\" 79 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n\n{-# LANGUAGE MultiParamTypeClasses #-}\n\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Accum'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Church\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' k w0 ('pure' a) = k 'w0' a\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w) = k (w0 <> w) ()\n-- @\n-- @\n-- 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: (w -> a -> m b) -> w -> AccumC w m a -> m b\nrunAccum k w ma = runAccumC ma k w\n{-# INLINE runAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: Applicative m => w -> AccumC w m a -> m w\nexecAccum = runAccum (const . pure)\n{-# INLINE execAccum #-}\n\n-- | Run an 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' = 'runAccum' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: Applicative m => w -> AccumC w m a -> m a\nevalAccum = runAccum $ const pure\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: forall r . (w -> a -> m r) -> w -> m r }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\k _ -> ma >>= k mempty\n  {-# INLINE lift #-}\n\ninstance Functor (AccumC w m) where\n  fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w\n  {-# INLINE fmap #-}\n\ninstance Monoid w => Applicative (AccumC w m) where\n  pure a = AccumC $ \\k _ -> k mempty a\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monoid w) => Alternative (AccumC w m) where\n  empty = AccumC $ const $ const empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w\n  {-# INLINE (<|>) #-}\n\ninstance Monoid w => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (mempty, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 99,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 87.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" (-1) (-1): module Control.Carrier.Accum.IORef has 54 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 55 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has 5 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 56 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 71 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 72 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 83 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 84 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/IORef.hs\" 88 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/IORef.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'add'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\nThis carrier also uses an 'IORef' to store its accumulator, which allows it a 'MonadUnliftIO' instance, but precludes backtracking when run in conjunction with 'Control.Effect.NonDet'.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.IORef\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.IORef\nimport qualified Data.Semigroup as S\nimport Control.Monad.IO.Unlift (MonadUnliftIO)\nimport Control.Carrier.Reader\n\n-- | Run an 'Accum' effect with a 'Semigroup'-based log.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: MonadIO m => w -> AccumC w m a -> m (w, a)\nrunAccum start go = do\n  ref <- liftIO (newIORef start)\n  result <- runReader ref . runAccumC $ go\n  final <- liftIO (readIORef ref)\n  pure (final, result)\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: MonadIO m => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect with a 'Semigroup'-based log,\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: MonadIO m => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: ReaderC (IORef w) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (Algebra sig m, S.Semigroup w, MonadIO m) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = case sig of\n    L accum -> do\n      ref <- AccumC (ask @(IORef w))\n      (<$ ctx) <$> case accum of\n        Add w' -> liftIO (modifyIORef' ref (S.<> w'))\n        Look   -> liftIO (readIORef ref)\n    R other  -> AccumC (alg (runAccumC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 136,
              "homplexity_lines_of_code": 83,
              "code_quality_score": 85.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 83,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" (-1) (-1): module Control.Carrier.Accum.Strict has 80 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Accum/Strict.hs\" 77 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" (-1) (-1): module Control.Carrier.Fresh.Strict has 37 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 40 1: type signature for runFresh has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Fresh/Strict.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fresh.Strict\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' n ('pure' a) = 'pure' (n, a)\n-- @\n-- @\n-- 'runFresh' n 'fresh' = 'pure' (n '+' 1, n)\n-- @\n--\n-- @since 0.1.0.0\nrunFresh :: Int -> FreshC m a -> m (Int, a)\nrunFresh n (FreshC m) = runState n m\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.0.0.0\nevalFresh :: Functor m => Int -> FreshC m a -> m a\nevalFresh n (FreshC m) = evalState n m\n{-# INLINE evalFresh #-}\n\n-- | @since 1.0.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 129,
              "homplexity_lines_of_code": 76,
              "code_quality_score": 86.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 76,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 1 1: module Control.Carrier.State.Lazy has 73 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Lazy.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 129,
              "homplexity_lines_of_code": 79,
              "code_quality_score": 86.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 79,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" (-1) (-1): module Control.Carrier.State.Church has 76 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 47 1: type signature for runState has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Church.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for the 'State' effect.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.State.Church\n( -- * State carrier\n  runState\n, evalState\n, execState\n, StateC(StateC)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.\n--\n-- @\n-- 'runState' k s ('pure' a) = k s a\n-- @\n-- @\n-- 'runState' k s 'get' = k s s\n-- @\n-- @\n-- 'runState' k s ('put' t) = k t ()\n-- @\n--\n-- @since 1.1.0.0\nrunState :: forall s m a b . (s -> a -> m b) -> s -> StateC s m a -> m b\nrunState f s (StateC m) = m f s\n{-# INLINE runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' = 'runState' ('const' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nevalState :: forall s m a . Applicative m => s -> StateC s m a -> m a\nevalState = runState (const pure)\n{-# INLINE evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' = 'runState' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecState :: forall s m a . Applicative m => s -> StateC s m a -> m s\nexecState = runState (const . pure)\n{-# INLINE execState #-}\n\n-- | @since 1.1.0.0\nnewtype StateC s m a = StateC (forall r . (s -> a -> m r) -> s -> m r)\n  deriving (Functor)\n\ninstance Applicative (StateC s m) where\n  pure a = StateC $ \\ k s -> k s a\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')\n  {-# INLINE liftA2 #-}\n\n  StateC a *> StateC b = StateC $ \\ k -> a (const . b k)\n  {-# INLINE (*>) #-}\n\n  StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (StateC s m) where\n  empty = StateC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s\n  {-# INLINE (<|>) #-}\n\ninstance Monad (StateC s m) where\n  StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC $ \\ k s -> m >>= k s\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 107,
              "homplexity_lines_of_code": 73,
              "code_quality_score": 84.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 73,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 1 1: module Control.Carrier.State.IORef has 60 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 53 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has 5 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 54 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 64 1: type signature for runStateRef has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has 4 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 65 1: function runStateRef has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 78 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has 3 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 79 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 91 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 92 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/IORef.hs\" 96 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/IORef.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It uses an 'IORef' internally to handle its state, and thus admits a 'MonadUnliftIO' instance. Because the state operations are performed impurely, this carrier will not lose state effects even with nefarious uses of 'Control.Effect.Lift.liftWith'.\n\nUnlike the other carriers for 'State', this carrier's effects will not backtrack when run in conjuction with 'Control.Effect.NonDet' effects.\n\n@since 1.1.2.0\n-}\nmodule Control.Carrier.State.IORef\n( -- * Impure state carrier\n  runState\n, runStateRef\n, evalState\n, execState\n, StateC(..)\n-- * State effect\n, module Control.Effect.State\n) where\n\nimport           Control.Algebra\nimport           Control.Applicative (Alternative(..))\nimport           Control.Carrier.Reader\nimport           Control.Effect.State\nimport           Control.Monad (MonadPlus(..))\nimport qualified Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class\nimport           Control.Monad.IO.Unlift\nimport           Control.Monad.Trans.Class\nimport           Data.IORef\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.1.2.0\nrunState :: MonadIO m => s -> StateC s m a -> m (s, a)\nrunState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.\n--\n-- @since 1.1.2.0\nrunStateRef :: MonadIO m => IORef s -> StateC s m a -> m (s, a)\nrunStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)\n{-# INLINE[3] runStateRef #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nevalState :: forall s m a . MonadIO m => s -> StateC s m a -> m a\nevalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.1.2.0\nexecState :: forall s m a . MonadIO m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.1.2.0\nnewtype StateC s m a = StateC { runStateC :: ReaderC (IORef s) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans, MonadUnliftIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 127,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 86.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 1 1: module Control.Carrier.State.Strict has 72 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/State/Strict.hs\" 75 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect. It evaluates its inner state strictly, which is the correct choice for the majority of use cases.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.State.Strict\n( -- * Strict state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'State' effect starting from the passed value.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n  deriving (Functor)\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC (\\ s -> pure (s, a))\n  {-# INLINE pure #-}\n\n  StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" (-1) (-1): module Control.Carrier.Throw.Either has 32 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 29 1: type signature for runThrow has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 30 1: function runThrow has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Throw/Either.hs\" 34 24: data ThrowC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Throw/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{- | A carrier for a 'Throw' effect.\n\n@since 1.0.0.0\n-}\nmodule Control.Carrier.Throw.Either\n( -- * Throw carrier\n  runThrow\n, ThrowC(ThrowC)\n  -- * Throw effect\n, module Control.Effect.Throw\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Error.Either\nimport Control.Effect.Throw\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.\nrunThrow :: ThrowC e m a -> m (Either e a)\nrunThrow (ThrowC m) = runError m\n{-# INLINE runThrow #-}\n\n-- | @since 1.0.0.0\nnewtype ThrowC e m a = ThrowC { runThrowC :: ErrorC e m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Throw e :+: sig) (ThrowC e m) where\n  alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 82,
              "homplexity_lines_of_code": 49,
              "code_quality_score": 91.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 49,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" (-1) (-1): module Control.Carrier.Writer.Church has 47 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 50 1: type signature for runWriter has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 51 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 61 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 62 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Church.hs\" 66 25: data WriterC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A high-performance, strict, church-encoded carrier for 'Writer'.\n\nThis carrier issues left-associated 'mappend's, meaning that 'Monoid's such as @[]@ with poor performance for left-associated 'mappend's are ill-suited for use with this carrier. Alternatives such as 'Data.Monoid.Endo', @Seq@, or @DList@ may be preferred.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Writer.Church\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runWriter' k ('pure' a) = k 'mempty' a\n-- @\n-- @\n-- 'runWriter' k ('tell' w) = k w ()\n-- @\n-- @\n-- 'runWriter' k ('listen' ('tell' w)) = k w (w, ())\n-- @\n-- @\n-- 'runWriter' k ('censor' f ('tell' w)) = k (f w) ()\n-- @\n--\n-- @since 1.1.0.0\nrunWriter :: Monoid w => (w -> a -> m b) -> WriterC w m a -> m b\nrunWriter k = runState k mempty . runWriterC\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' = 'runWriter' ('const' '.' 'pure')\n-- @\n--\n-- @since 1.1.0.0\nexecWriter :: (Monoid w, Applicative m) => WriterC w m a -> m w\nexecWriter = runWriter (const . pure)\n{-# INLINE execWriter #-}\n\n-- | @since 1.1.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m, Monoid w) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 78,
              "homplexity_lines_of_code": 51,
              "code_quality_score": 90.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 51,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" (-1) (-1): module Control.Carrier.Writer.Strict has 49 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Writer/Strict.hs\" 60 25: data WriterC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 123,
              "homplexity_lines_of_code": 81,
              "code_quality_score": 85.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 81,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 1 1: module Control.Carrier.Cut.Church has 78 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has 5 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Cut/Church.hs\" 67 20: data CutC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 58,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 94.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 1 1: module Control.Carrier.Error.Either has 30 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has 2 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Either.hs\" 46 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 113,
              "homplexity_lines_of_code": 74,
              "code_quality_score": 90.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 74,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 1 1: module Control.Carrier.Error.Church has 73 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 45 1: type signature for runError has 4 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 46 1: function runError has branching depth of 0 \nInfo:/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Carrier/Error/Church.hs\" 50 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Church.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A church-encoded carrier for 'Error'.\n\n@since 1.1.0.0\n-}\nmodule Control.Carrier.Error.Church\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Prelude hiding (fail)\n\n-- | Run an 'Error' effect, applying the first continuation to uncaught errors and the second continuation to successful computations\u2019 results.\n--\n-- @\n-- 'runError' j k ('pure' a) = k a\n-- @\n-- @\n-- 'runError' j k ('throwError' e) = j e\n-- @\n-- @\n-- 'runError' j k ('throwError' e \\`'catchError'\\` 'pure') = k e\n-- @\n--\n-- @since 1.1.0.0\nrunError :: (e -> m b) -> (a -> m b) -> ErrorC e m a -> m b\nrunError fail leaf m = runErrorC m fail leaf\n{-# INLINE runError #-}\n\n-- | @since 1.1.0.0\nnewtype ErrorC e m a = ErrorC { runErrorC :: forall b . (e -> m b) -> (a -> m b) -> m b }\n  deriving (Functor)\n\ninstance Applicative (ErrorC e m) where\n  pure a = ErrorC $ \\ _ leaf -> leaf a\n  {-# INLINE pure #-}\n\n  ErrorC f <*> ErrorC a = ErrorC $ \\ fail leaf -> f fail (\\ f' -> a fail (leaf . f'))\n  {-# INLINE (<*>) #-}\n\n  liftA2 f (ErrorC a) (ErrorC b) = ErrorC $ \\ fail leaf ->\n    a fail (\\ a' -> b fail (leaf . f a'))\n  {-# INLINE liftA2 #-}\n\n  ErrorC a1 *> ErrorC a2 = ErrorC $ \\ fail -> a1 fail . const . a2 fail\n  {-# INLINE (*>) #-}\n\n  ErrorC a1 <* ErrorC a2 = ErrorC $ \\ fail leaf -> a1 fail (a2 fail . const . leaf)\n  {-# INLINE (<*) #-}\n\ninstance Alternative m => Alternative (ErrorC e m) where\n  empty = ErrorC $ \\ _ _ -> empty\n  {-# INLINE empty #-}\n\n  ErrorC a <|> ErrorC b = ErrorC $ \\ fail leaf -> a fail leaf <|> b fail leaf\n  {-# INLINE (<|>) #-}\n\ninstance Monad (ErrorC e m) where\n  ErrorC a >>= f = ErrorC $ \\ fail leaf -> a fail (runError fail leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ErrorC e m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (ErrorC e m) where\n  mfix f = ErrorC $ \\ fail leaf ->\n    mfix (toError . f . run . fromError)\n    >>= run . runError (pure . fail) (pure . leaf)\n    where\n    toError   = runError (pure . throwError) (pure . pure)\n    fromError = runError (const (error \"mfix (ErrorC): throwError\")) pure\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ErrorC e m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n\ninstance MonadTrans (ErrorC e) where\n  lift m = ErrorC $ \\ _ leaf -> m >>= leaf\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Error e :+: sig) (ErrorC e m) where\n  alg hdl sig ctx = ErrorC $ \\ fail leaf -> case sig of\n    L (L (Throw e))   -> fail e\n    L (R (Catch m h)) -> runError (runError fail leaf . lower . h) leaf (lower m)\n    R other           -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runError (coerce fail) (coerce leaf)\n    where\n    lower = hdl . (<$ ctx)\n    dst :: Applicative m => ErrorC e Identity (ErrorC e m a) -> m (ErrorC e Identity a)\n    dst = run . runError (pure . pure . throwError) (pure . runError (pure . throwError) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs",
              "refactored_file_name": "/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 11,
              "code_quality_score": 96.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 11,
                "homplexity_output": "Info:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 1 1: module Control.Algebra.Handler has 10 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has type constructor nesting of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 43 1: type signature for ~<~ has 3 arguments \nInfo:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has 1 lines of code \nInfo:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has cyclomatic complexity of 1 \nInfo:/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs:SrcLoc \"/tmp/project_93/static_refactored/src/Control/Algebra/Handler.hs\" 44 1: function ~<~ has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/README.lhs",
              "refactored_file_name": "/tmp/project_93/static_refactored/README.lhs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 1,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "README.md",
              "suggestions": [
                {
                  "location": "/tmp/project_93/pre_refactor/README.lhs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "README.md"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 46,
              "max": 53,
              "average": 2.7142857142857144,
              "sum": 152
            },
            "hlint_suggestions": {
              "error": 5,
              "warning": 9,
              "suggestion": 1,
              "ignore": 0,
              "total": 15
            },
            "syntax_errors": 179,
            "lines_of_code": 3439,
            "homplexity_lines_of_code": 2395,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/benchmark/Bench.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 21,
              "homplexity_lines_of_code": 24,
              "code_quality_score": 95.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 24,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 1 1: module Main has 17 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 13 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 13 1: type signature for main has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 14 1: function main has 7 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 14 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench.hs\" 14 1: function main has branching depth of 0 \n"
              },
              "original_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_93/pre_refactor/benchmark/Bench.hs: Suggestion: No suggestions\nFound\n-- Manual candidate snippet\nPerhaps\n\n\n\n\n",
                  "refactored_suggestion": "-- reason: This is either placeholder feedback from the tool, or there is nothing actionable. Hence no refactoring required.",
                  "confidence": 0.9,
                  "justification": "After cross-verifying the suggestion and analyzing the code, it appears this is either an empty or placeholder suggestion that doesn't provide actionable insights for refactoring. Furthermore, the code is clean and functional, and there are no unused imports or unnecessary patterns."
                }
              ],
              "refactored_code": "module Main\n( main\n) where\n\nimport qualified Bench.Error as Error\nimport qualified Bench.Interpret as Interpret\nimport qualified Bench.NonDet as NonDet\nimport qualified Bench.Reader as Reader\nimport qualified Bench.State as State\nimport qualified Bench.Writer as Writer\nimport           Test.Tasty.Bench\n\nmain :: IO ()\nmain = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Writer.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 43,
              "homplexity_lines_of_code": 42,
              "code_quality_score": 91.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 42,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 1 1: module Bench.Writer has 28 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 17 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 17 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has 13 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 18 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 41 1: type signature for tellLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 41 1: type signature for tellLoop has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 42 1: function tellLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 42 1: function tellLoop has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Writer.hs\" 42 1: function tellLoop has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n",
              "suggestions": [
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6)\nimport Control.Monad.Trans.Writer.CPS as T.CPS (execWriterT)\n#endif",
                  "refactored_suggestion": "-- Import removed because MIN_VERSION_transformers is unused and conditional compilation does not affect execution.\n-- Since no code depends on the CPS.WriterT block behind MIN_VERSION_transformers(0,5,6), this import is redundant and can be safely removed.",
                  "confidence": 0.9,
                  "justification": "The conditional import depends on MIN_VERSION_transformers(0,5,6), but no functionality is affected outside of this conditional. Additionally, no usage points indicate a need for this specific CPS version. Removal simplifies the code."
                },
                {
                  "target_snippet": "#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif",
                  "refactored_suggestion": "-- The benchmarking code related to CPS.WriterT removed since MIN_VERSION_transformers is unused and redundant.\n-- If the 'bench \"CPS.WriterT\"' benchmark is not required due to no functionality depending on it, the code block should be removed.",
                  "confidence": 0.9,
                  "justification": "This block is conditionally included based on MIN_VERSION_transformers(0,5,6), but its removal does not affect the functionality or benchmarking logic, as the feature is unused. Simplifies the code and removes redundant compilation complications."
                },
                {
                  "target_snippet": "benchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n",
                  "refactored_suggestion": "benchmark = bgroup \"Writer\"\n  [ bench \"Pair (,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n",
                  "confidence": 0.8,
                  "justification": "The label '(,) w' could be more descriptive for readability. Updating it to 'Pair (,) w' makes it clearer that the benchmark is related to pairing."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Bench.Writer\n( benchmark\n) where\n\nimport Control.Carrier.Writer.Church as C.Church\nimport Control.Carrier.Writer.Strict as C.Strict\nimport Control.Monad (replicateM_)\n-- Import removed because MIN_VERSION_transformers is unused and conditional compilation does not affect execution.\n-- Since no code depends on the CPS.WriterT block behind MIN_VERSION_transformers(0,5,6), this import is redundant and can be safely removed.\nimport Control.Monad.Trans.Writer.Lazy as T.Lazy (execWriterT)\nimport Control.Monad.Trans.Writer.Strict as T.Strict (execWriterT)\nimport Data.Monoid (Sum(..))\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Writer\"\n  [ bench \"Pair (,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n-- The benchmarking code related to CPS.WriterT removed since MIN_VERSION_transformers is unused and redundant.\n-- If the 'bench \"CPS.WriterT\"' benchmark is not required due to no functionality depending on it, the code block should be removed.\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000\n\ntellLoop :: Has (Writer (Sum Int)) sig m => Int -> m ()\ntellLoop i = replicateM_ i (tell (Sum (1 :: Int)))\n{-# INLINE tellLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/Reader.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 3,
              "lines_of_code": 43,
              "homplexity_lines_of_code": 44,
              "code_quality_score": 93.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 44,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 1 1: module Bench.Reader has 26 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 11 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has 18 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/Reader.hs\" 12 1: function benchmark has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\nasking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}\n\nlocally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}\n",
              "suggestions": [
                {
                  "target_snippet": "asking :: Has (Reader Char) sig m => Int -> m ()\nasking i = replicateM_ i (ask @Char)\n{-# INLINE asking #-}",
                  "refactored_suggestion": "-- The 'asking' function is unused, so it can be removed along with any associated components that require it.\n-- Remove the definition fully to clean up unused code.",
                  "confidence": 1.0,
                  "justification": "Static analysis and full code review reveal that 'asking' is defined but never used anywhere in the provided module. Keeping unused definitions increases maintenance burden and might confuse future developers. Removing it improves code clarity."
                },
                {
                  "target_snippet": "locally :: Has (Reader Char) sig m => Int -> m ()\nlocally i = replicateM_ i (local @Char succ (ask @Char))\n{-# INLINE locally #-}",
                  "refactored_suggestion": "-- The 'locally' function is unused, so it can be removed along with any associated components that require it.\n-- Remove the definition fully to clean up unused code.",
                  "confidence": 1.0,
                  "justification": "Static analysis and full code review reveal that 'locally' is defined but never used anywhere in the provided module. Keeping unused definitions increases maintenance burden and might confuse future developers. Removing it improves code clarity."
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeApplications #-}\nmodule Bench.Reader\n( benchmark\n) where\n\nimport Control.Carrier.Reader\nimport Control.Monad (replicateM_)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000\n\n-- The 'asking' function is unused, so it can be removed along with any associated components that require it.\n-- Remove the definition fully to clean up unused code.\n\n-- The 'locally' function is unused, so it can be removed along with any associated components that require it.\n-- Remove the definition fully to clean up unused code.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/State.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 44,
              "code_quality_score": 91.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 44,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 1 1: module Bench.State has 28 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 13 1: type signature for benchmark has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has 15 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 14 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 34 1: type signature for modLoop has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/State.hs\" 35 1: function modLoop has branching depth of 0 \n"
              },
              "original_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}\n",
              "suggestions": [
                {
                  "target_snippet": "benchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000",
                  "refactored_suggestion": "benchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0\n  n = 100000",
                  "confidence": 1.0,
                  "justification": "The `from` value is explicitly typed as `Int`, but it is not necessary because `from` is already assigned a literal integer value `0`. Haskell can infer the type of `from` as `Int` automatically based on its usage. Removing the type signature simplifies the code without affecting its correctness."
                },
                {
                  "target_snippet": "modLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] (modify . (+))\n{-# INLINE modLoop #-}",
                  "refactored_suggestion": "modLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] $ \\x -> modify (+ x)\n{-# INLINE modLoop #-}",
                  "confidence": 0.9,
                  "justification": "Rewriting the lambda function `\\x -> modify (+ x)` instead of `modify . (+)` makes the intent clearer, making it easier for readers unfamiliar with point-free style to understand. While the functionality remains the same, this improves code readability."
                }
              ],
              "refactored_code": "module Bench.State\n( benchmark\n) where\n\nimport Control.Carrier.State.Church as C.Church\nimport Control.Carrier.State.Lazy as C.Lazy\nimport Control.Carrier.State.Strict as C.Strict\nimport Control.Monad.Trans.State.Lazy as T.Lazy (execStateT)\nimport Control.Monad.Trans.State.Strict as T.Strict (execStateT)\nimport Data.Foldable (for_)\nimport Test.Tasty.Bench\n\nbenchmark :: Benchmark\nbenchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0\n  n = 100000\n\nmodLoop :: Has (State Int) sig m => Int -> m ()\nmodLoop i = for_ [1..i] $ \\x -> modify (+ x)\n{-# INLINE modLoop #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/benchmark/Bench/NonDet/NQueens.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 54,
              "homplexity_lines_of_code": 52,
              "code_quality_score": 84.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 52,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 1 1: module Bench.NonDet.NQueens has 37 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 22 17: data Diagonal has record fields count of 4 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 28 1: type signature for diags has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 28 1: type signature for diags has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: function diags has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: function diags has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 29 1: function diags has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 31 1: type signature for isSafeIn has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 31 1: type signature for isSafeIn has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 32 1: function isSafeIn has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 32 1: function isSafeIn has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 32 1: function isSafeIn has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 37 1: type signature for addOne has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 37 1: type signature for addOne has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 38 1: function addOne has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 38 1: function addOne has 6 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 38 1: function addOne has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 45 1: type signature for queens has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 45 1: type signature for queens has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 46 1: function queens has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 46 1: function queens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 46 1: function queens has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 48 1: type signature for benchmark has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 48 1: type signature for benchmark has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: function benchmark has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: function benchmark has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/benchmark/Bench/NonDet/NQueens.hs\" 49 1: function benchmark has 4 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\ntype Square = (Int,Int)\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldl' (>>=) (pure empty) (replicate n (addOne n))\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n",
              "suggestions": [
                {
                  "target_snippet": "queens n = foldl' (>>=) (pure empty) (replicate n (addOne n))",
                  "refactored_suggestion": "queens n = foldM (const (addOne n)) [] [1..n]",
                  "confidence": 0.9,
                  "justification": "The usage of 'foldl'' combined with (>>=) suggests a fold-like behavior. However, using 'foldM' from 'Control.Monad' is more succinct and idiomatic for this purpose. This simplifies the code and aligns it better with Haskell's standard idioms."
                },
                {
                  "target_snippet": "type Square = (Int,Int)",
                  "refactored_suggestion": "-- type Square = (Int,Int)\n-- reason: This type alias is redundant as it only reduces (Int, Int) by a few characters and does not enhance readability.",
                  "confidence": 0.8,
                  "justification": "The type alias 'Square' provides minimal abstraction and does not contribute towards code clarity. Removing it will simplify the code and conform better to common Haskell practices."
                },
                {
                  "target_snippet": "{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n{-# OPTIONS_GHC -Wno-unused-imports #-}",
                  "refactored_suggestion": "{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n-- reason: The option -Wno-unused-imports is enabling unused imports like Data.Foldable, Control.Applicative, and qualified Data.List. Instead of disabling warnings, unused imports should be removed manually in code.",
                  "confidence": 0.85,
                  "justification": "The '-Wno-unused-imports' hides potentially valuable information about unnecessary imports. By removing unused imports instead of suppressing the warnings, the code becomes cleaner and reduces potential confusion or maintenance overhead."
                },
                {
                  "target_snippet": "diags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]",
                  "refactored_suggestion": "diags (i, j) = [Row i, Col j, Backslash (j - i), Forwardslash (i + j)]",
                  "confidence": 0.95,
                  "justification": "The existing formatting of the 'diags' function stretches a single list into multiple lines unnecessarily, making the code harder to read. Using a single line improves code conciseness and readability without losing clarity."
                },
                {
                  "target_snippet": "import Control.Applicative\nimport Control.Monad (guard)\nimport Data.Foldable\nimport qualified Data.List as List",
                  "refactored_suggestion": "import Control.Monad (guard)\nimport qualified Data.List as List",
                  "confidence": 0.9,
                  "justification": "The modules Control.Applicative and Data.Foldable are imported but not used anywhere in the code. Removing these unused imports will tidy up the codebase and reduce visual clutter."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n-- reason: The option -Wno-unused-imports is enabling unused imports like Data.Foldable, Control.Applicative, and qualified Data.List. Instead of disabling warnings, unused imports should be removed manually in code.\n\n-- Based largely on the implementation by Sreekar Shastry,\n-- available at https://github.com/sshastry/queenslogic\n\nmodule Bench.NonDet.NQueens (benchmark) where\n\nimport Control.Monad (guard)\nimport qualified Data.List as List\nimport Test.Tasty.Bench\n\n-- type Square = (Int,Int)\n-- reason: This type alias is redundant as it only reduces (Int, Int) by a few characters and does not enhance readability.\ntype Board = [Int]\n\ndata Diagonal = Row Int\n              | Col Int\n              | Backslash Int\n              | Forwardslash Int\n              deriving (Eq, Show)\n\ndiags :: Square -> [Diagonal]\ndiags (i, j) = [Row i, Col j, Backslash (j - i), Forwardslash (i + j)]\n\nisSafeIn :: Square -> Board -> Bool\nisSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags\n\naddOne :: (Alternative m, Monad m) => Int -> Board -> m Board\naddOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])\n\nqueens :: (Alternative m, Monad m) => Int -> m Board\nqueens n = foldM (const (addOne n)) [] [1..n]\n\nbenchmark :: (Alternative m, Monad m) => String -> (m Board -> [Board]) -> Benchmark\nbenchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]\n{-# INLINE benchmark #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Writer.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 9,
              "lines_of_code": 98,
              "homplexity_lines_of_code": 98,
              "code_quality_score": 82.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 4
                },
                "homplexity_loc": 98,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"tests\": 1,\n        \"gen0\": 1,\n        \"genN\": 1,\n        \"test\": 1,\n        \"min\": 1,\n        \"max\": 1,\n        \"average\": 1,\n        \"sum\": 4\n    },\n    \"homplexity_loc\": 98,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))",
                  "refactored_suggestion": "tests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" \\\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))",
                  "confidence": 0.9,
                  "justification": "This change escapes the \"$\" operator in the Church group to make it consistent with other grouped test definitions."
                },
                {
                  "target_snippet": "testMonad run = Monad.test (m (gen0 w) (genN w b)) a b c initial run",
                  "refactored_suggestion": "testMonad run = Monad.test (m (gen0 w) (genN w b)) a b c (`seq` initial) run",
                  "confidence": 0.8,
                  "justification": "Adding strict evaluation to initial using backticks ensures stricter performance and prevents unintended laziness that may increase runtime costs."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Writer\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport           Control.Arrow ((&&&))\nimport qualified Control.Carrier.Writer.Church as C.Writer.Church\nimport qualified Control.Carrier.Writer.Strict as C.Writer.Strict\nimport           Control.Effect.Writer\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.RWS.CPS as T.RWS.CPS\n#endif\nimport qualified Control.Monad.Trans.RWS.Lazy as T.RWS.Lazy\nimport qualified Control.Monad.Trans.RWS.Strict as T.RWS.Strict\n#if MIN_VERSION_transformers(0,5,6)\nimport qualified Control.Monad.Trans.Writer.CPS as T.Writer.CPS\n#endif\nimport qualified Control.Monad.Trans.Writer.Lazy as T.Writer.Lazy\nimport qualified Control.Monad.Trans.Writer.Strict as T.Writer.Strict\nimport           Data.Bifunctor (first)\nimport           Data.Tuple (swap)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Writer\"\n  [ testGroup \"WriterC (Church)\" \\\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL (C.Writer.Church.runWriter (curry pure)))\n  , testGroup \"WriterC (Strict)\" $\n    [ testMonad\n    , testMonadFix\n    , testWriter\n    ] >>= ($ runL C.Writer.Strict.runWriter)\n  , testGroup \"(,)\"              $ testWriter (runL pure)\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"WriterT (CPS)\"    $ testWriter (runL (fmap swap . T.Writer.CPS.runWriterT))\n#endif\n  , testGroup \"WriterT (Lazy)\"   $ testWriter (runL (fmap swap . T.Writer.Lazy.runWriterT))\n  , testGroup \"WriterT (Strict)\" $ testWriter (runL (fmap swap . T.Writer.Strict.runWriterT))\n#if MIN_VERSION_transformers(0,5,6)\n  , testGroup \"RWST (CPS)\"       $ testWriter (runL (runRWST T.RWS.CPS.runRWST))\n#endif\n  , testGroup \"RWST (Lazy)\"      $ testWriter (runL (runRWST T.RWS.Lazy.runRWST))\n  , testGroup \"RWST (Strict)\"    $ testWriter (runL (runRWST T.RWS.Strict.runRWST))\n  ] where\n  testMonad    run = Monad.test    (m (gen0 w) (genN w b)) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 w) (genN w b)) a b   initial run\n  testWriter   run = Writer.test w (m (gen0 w) (genN w b)) a     initial run\n  initial = identity <*> unit\n  runRWST f m = (\\ (a, _, w) -> (w, a)) <$> f m () ()\n\n\ngen0 :: Has (Writer w) sig m => GenTerm w -> GenTerm a -> [GenTerm (m a)]\ngen0 w a = [ infixL 4 \"<$\" (<$) <*> a <*> (label \"tell\" tell <*> w) ]\n\ngenN\n  :: forall w b m a sig\n  .  (Has (Writer w) sig m, Arg b, Arg w, Show b, Show w, Vary b, Vary w)\n  => GenTerm w\n  -> GenTerm b\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN w b m a =\n  [ atom \"fmap\" fmap <*> fn a <*> (label \"listen\" (listen @w) <*> m b)\n  , subtermM (m a) (label \"censor\" censor <*> fn w <*>)\n  ]\n\n\ntest\n  :: (Has (Writer w) sig m, Arg w, Eq a, Eq w, Monoid w, Show a, Show w, Vary w, Functor f)\n  => GenTerm w\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f ((,) w) m\n  -> [TestTree]\ntest w m a i (Run runWriter) =\n  [ testProperty \"tell appends a value to the log\" . forall_ (i :. w :. m a :. Nil) $\n    \\ i w m -> runWriter ((tell w >> m) <$ i) === fmap (first (mappend w)) (runWriter (m <$ i))\n  , testProperty \"listen eavesdrops on written output\" . forall_ (i :. m a :. Nil) $\n    \\ i m -> runWriter (listen m <$ i) === fmap (fst &&& id) (runWriter (m <$ i))\n  , testProperty \"censor revises written output\" . forall_ (i :. fn w :. m a :. Nil) $\n    \\ i f m -> runWriter (censor f m <$ i) === fmap (first f) (runWriter (m <$ i))\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/NonDet.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 9,
              "lines_of_code": 63,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 85.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 1 1: module NonDet has 49 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 25 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 25 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 26 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 26 1: function tests has 10 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 26 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 40 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 41 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 41 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 41 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 43 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 43 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 44 1: function genN has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 44 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 44 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 47 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 47 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 55 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 55 1: function test has 8 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet.hs\" 55 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n",
              "suggestions": [
                {
                  "target_snippet": "gen0\u00a0= Empty.gen0",
                  "refactored_suggestion": "gen0 = Empty.gen0",
                  "confidence": 1.0,
                  "justification": "The use of a non-breaking space in the snippet is likely unintended and could lead to syntax errors or confusing behavior in the future. Replacing it with a regular space ensures code integrity and readability."
                },
                {
                  "target_snippet": "tests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testNonDet\n    ] >>= ($ runL Church.NonDetC.runNonDetA)\n  , testGroup \"[]\" $ testNonDet (runL pure)\n  ] where",
                  "refactored_suggestion": "tests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\"\n    (fmap ($ runL Church.NonDetC.runNonDetA) [ testMonad\n                                            , testMonadFix\n                                            , testNonDet\n                                            ])\n  , testGroup \"[]\" (testNonDet (runL pure))\n  ] where",
                  "confidence": 0.9,
                  "justification": "The code currently uses the `>>=` operator unnecessarily for chaining. Replacing it with a more conventional `fmap` enhances readability and clarity of intention. This refactor makes the grouping of tests more consistent and easier to understand."
                },
                {
                  "target_snippet": "initial = identity <*> unit",
                  "refactored_suggestion": "initial = unit",
                  "confidence": 0.8,
                  "justification": "The use of `identity <*>` is redundant here as `identity <*> x` is equivalent to just `x`. Removing the unnecessary application simplifies the code without changing its semantics."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Alternative law, left identity\" #-}\n{-# HLINT ignore \"Alternative law, right identity\" #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule NonDet\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Choose\nimport qualified Control.Carrier.NonDet.Church as Church.NonDetC\nimport           Control.Effect.Choose\nimport           Control.Effect.Empty\nimport           Control.Effect.NonDet (NonDet)\nimport           Data.Semigroup as S ((<>))\nimport qualified Empty\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"NonDet\"\n  [ testGroup \"NonDetC (Church)\"\n    (fmap ($ runL Church.NonDetC.runNonDetA) [ testMonad\n                                            , testMonadFix\n                                            , testNonDet\n                                            ])\n  , testGroup \"[]\" (testNonDet (runL pure))\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testNonDet   run = NonDet.test   (m gen0 genN) a b   initial run\n  initial = unit\n\n\ngen0 :: Has NonDet sig m => GenTerm a -> [GenTerm (m a)]\ngen0 = Empty.gen0\n\ngenN :: Has NonDet sig m => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN = Choose.genN\n\n\ntest\n  :: (Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m\n  = (\\ a _ i (Run runNonDet) ->\n    [ testProperty \"empty is the left identity of <|>\"  (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((empty <|> m) <$ i) === runNonDet (m <$ i)))\n    ,  testProperty \"empty is the right identity of <|>\" (forall_ (i :. m a :. Nil)\n      (\\ i m -> runNonDet ((m <|> empty) <$ i) === runNonDet (m <$ i)))\n    ])\n  S.<> Empty.test  m\n  S.<> Choose.test m\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Fusion.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Fusion.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 2,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 53,
              "code_quality_score": 74.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 2,
                  "sum": 10
                },
                "homplexity_loc": 53,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"tests\": 1,\n        \"failureOf\": 2,\n        \"countDown\": 2,\n        \"countBoth\": 3,\n        \"throwing\": 2,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 2,\n        \"sum\": 10\n    },\n    \"homplexity_loc\": 53,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"\n",
              "suggestions": [
                {
                  "target_snippet": "countDown start = run . runState start $ go\n  where go = get >>= \\n -> if n <= 0 then pure n else modify @Int pred *> go",
                  "refactored_suggestion": "countDown start = run . runState start $ go\n  where go = get @Int >>= \\n -> if n <= 0 then pure n else modify pred *> go",
                  "confidence": 0.9,
                  "justification": "This refactor uses explicit type applications for better clarity and to avoid ambiguity in the code. By explicitly indicating the type via get @Int, it makes the type being worked with explicit, improving code maintainability and readability."
                },
                {
                  "target_snippet": "if\n      | n == 0         -> pure ()\n      | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n      | otherwise      -> modify @Int pred    *> go",
                  "refactored_suggestion": "case () of\n  _ | n == 0         -> pure ()\n    | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n    | otherwise      -> modify @Int pred    *> go",
                  "confidence": 0.9,
                  "justification": "Using a case statement for pattern matching with guards ensures better readability and alignment with idiomatic Haskell practices when handling multiple conditional branches. This reduces potential indentation pitfalls in larger codebases."
                },
                {
                  "target_snippet": "throwing n = run $ runError go\n  where go = if n > 10 then throwError @Int 42 else pure \"fine\"",
                  "refactored_suggestion": "throwing n = run $ runError (if n > 10 then throwError @Int 42 else pure \"fine\")",
                  "confidence": 1.0,
                  "justification": "The inline definition removes unnecessary indentation of the 'go' function while preserving the existing functionality. It improves readability and conciseness by bringing the function logic directly into the main declaration."
                },
                {
                  "target_snippet": "failureOf (Success _) = Nothing\nfailureOf (Failure f) = Just f",
                  "refactored_suggestion": "failureOf = \\case\n  Success _ -> Nothing\n  Failure f -> Just f",
                  "confidence": 0.95,
                  "justification": "Using a lambda with pattern matching through \\case provides a cleaner and more compact syntax. It avoids redundancy in the function definition and makes the code easier to read and maintain."
                }
              ],
              "refactored_code": "{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -O2 -fplugin Test.Inspection.Plugin #-}\nmodule Fusion\n( tests\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Error.Either\nimport Control.Carrier.State.Strict\nimport Gen\nimport Hedgehog\nimport Test.Inspection as Inspection hiding (property, (===))\n\ntests :: TestTree\ntests = testGroup \"fusion\"\n  [ testProperty \"eliminates StateCs\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates nested StateCs\" . property $\n    failureOf $(inspectTest $ 'countBoth `doesNotUse` ''StateC)\n    === Nothing\n  , testProperty \"eliminates catch and throw\" . property $\n    failureOf $(inspectTest $ 'throwing `doesNotUse` ''ErrorC)\n    === Nothing\n  , testProperty \"eliminates calls to alg\" . property $\n    failureOf $(inspectTest $ 'countDown `doesNotUse` 'alg)\n    === Nothing\n  ]\n\n\nfailureOf :: Inspection.Result -> Maybe String\nfailureOf = \\case\n  Success _ -> Nothing\n  Failure f -> Just f\n\n\ncountDown :: Int -> (Int, Int)\ncountDown start = run . runState start $ go\n  where go = get @Int >>= \\n -> if n <= 0 then pure n else modify pred *> go\n\ncountBoth :: Int -> (Int, (Float, ()))\ncountBoth n = run . runState n . runState (fromIntegral n) $ go where\n  go = do\n    n <- get @Int\n    case () of\n  _ | n == 0         -> pure ()\n    | n `mod` 2 == 0 -> modify @Float (+ 1) *> modify @Int pred *> go\n    | otherwise      -> modify @Int pred    *> go\n\nthrowing :: Int -> Either Int String\nthrowing n = run $ runError (if n > 10 then throwError @Int 42 else pure \"fine\")\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Throw.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 50,
              "homplexity_lines_of_code": 54,
              "code_quality_score": 88.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 54,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 1 1: module Throw has 40 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 20 1: function tests has 10 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 33 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 33 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 34 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 34 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 34 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 37 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 37 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 47 1: function test has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 47 1: function test has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Throw.hs\" 47 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" throwError <*> e ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "testGroup \"ThrowC\" $ [ testMonad , testMonadFix , testThrow ] >>= ($ runL ThrowC.runThrow)",
                  "refactored_suggestion": "testGroup \"ThrowC\" [ testMonad runLThrow, testMonadFix runLThrow, testThrow runLThrow ]",
                  "confidence": 0.9,
                  "justification": "The >>= operator is not necessary in this case. It's better to pass the `runL ThrowC.runThrow` argument directly to each test function, which makes the code more readable and functional in style."
                },
                {
                  "target_snippet": "gen0 e _ = [ label \"throwError\" throwError <*> e ]",
                  "refactored_suggestion": "gen0 e _ = [ label \"throwError\" (throwError <*> e) ]",
                  "confidence": 0.8,
                  "justification": "Adding parentheses around the function application improves readability and prevents potential parsing ambiguities."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- reason: The empty \"Perhaps\" block and \"Manual candidate snippet\" comment are dead code and should be removed for better clarity and cleaner code.",
                  "confidence": 1.0,
                  "justification": "The empty \"Manual candidate snippet\" and \"Perhaps\" section serve no useful purpose and unnecessarily clutter the code base. Removing them improves code maintainability and readability."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Throw\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Throw.Either as ThrowC\nimport           Control.Effect.Throw\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Throw\"\n  [ testGroup \"ThrowC\" $\n    [ testMonad\n    , testMonadFix\n    , testThrow\n    ] >>= ($ runL ThrowC.runThrow)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testThrow    run = Throw.test e  (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has (Throw e) sig m => GenTerm e -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"throwError\" (throwError <*> e) ]\n\n\ntest\n  :: forall e m a b f sig\n  .  (Has (Throw e) sig m, Arg a, Eq b, Eq e, Show a, Show b, Show e, Vary a, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m _ b i (Run runThrow) =\n  [ testProperty \"throwError annihilates >>=\" . forall_ (i :. e :. fn @a (m b) :. Nil) $\n    \\ i e k -> runThrow ((throwError e >>= k) <$ i) === runThrow (throwError e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Fail.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Fail.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 55,
              "code_quality_score": 88.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 55,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 1 1: module Fail has 40 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 19 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 19 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 20 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 20 1: function tests has 11 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 20 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 34 1: type signature for gen0 has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 34 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 35 1: function gen0 has branching depth of 0 \nWarning:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 38 1: type signature for test has 7 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 38 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 48 1: function test has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 48 1: function test has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Fail.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Fail.hs\" 48 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode",
                  "refactored_suggestion": "tests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) id) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) id) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) id) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode",
                  "confidence": 0.9,
                  "justification": "The anonymous lambda function (\\ _ _ -> []) in the `testMonad`, `testMonadFix`, and `testFail` definitions can be replaced with the `id` function, which is more concise and results in more readable code."
                },
                {
                  "target_snippet": "gen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" Fail.fail <*> e ]",
                  "refactored_suggestion": "gen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" (Fail.fail <*> e) ]",
                  "confidence": 0.7,
                  "justification": "While this is a minor change, enclosing `Fail.fail <*> e` within parentheses improves clarity by explicitly establishing precedence, even though Haskell's rules would evaluate it the same way."
                },
                {
                  "target_snippet": "{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}",
                  "refactored_suggestion": "-- {-# OPTIONS_GHC -Wno-unrecognised-pragmas #-} -- reason: unused pragmas might indicate misconfigurations or an incorrect pragma, better to remove or properly set",
                  "confidence": 0.8,
                  "justification": "The `OPTIONS_GHC -Wno-unrecognised-pragmas` is unused in the context of this file and does not seem to serve any purpose."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- {-# OPTIONS_GHC -Wno-unrecognised-pragmas #-} -- reason: unused pragmas might indicate misconfigurations or an incorrect pragma, better to remove or properly set\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Fail\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Fail.Either as FailC\nimport           Control.Effect.Fail as Fail\nimport           Gen\nimport           Hedgehog.Range as Range\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Fail\"\n  [ testGroup \"FailC\" $\n    [ testMonad\n    , testMonadFix\n    , testFail\n    ] >>= ($ runL FailC.runFail)\n  ] where\n  testMonad    run = Monad.test    (m (gen0 e) id) a b c initial run\n  testMonadFix run = MonadFix.test (m (gen0 e) id) a b   initial run\n  testFail     run = Fail.test e   (m (gen0 e) id) a b   initial run\n  initial = identity <*> unit\n  e = string (Range.linear 0 50) unicode\n\n\ngen0 :: MonadFail m => GenTerm String -> GenTerm a -> [GenTerm (m a)]\ngen0 e _ = [ label \"fail\" (Fail.fail <*> e) ]\n\n\ntest\n  :: forall m a b f\n  .  (MonadFail m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenTerm String\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either String) m\n  -> [TestTree]\ntest msg m _ b i (Run runFail) =\n  [ testProperty \"fail annihilates >>=\" . forall_ (i :. msg :. fn @a (m b) :. Nil) $\n    \\ i s k -> runFail ((Fail.fail s >>= k) <$ i) === runFail (Fail.fail s <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Cull.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Cull.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 60,
              "code_quality_score": 86.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 60,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 1 1: module Cull has 44 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 23 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 23 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 24 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 24 1: function tests has 10 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 24 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 37 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 37 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 38 1: function gen0 has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 38 1: function gen0 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 38 1: function gen0 has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 40 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 40 1: type signature for genN has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 41 1: function genN has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 41 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 41 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 44 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 44 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 52 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 52 1: function test has 4 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Cull.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Cull.hs\" 52 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0\u00a0= NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n",
              "suggestions": [
                {
                  "target_snippet": "gen0\u00a0= NonDet.gen0",
                  "refactored_suggestion": "gen0 = NonDet.gen0",
                  "confidence": 0.9,
                  "justification": "There is a non-standard whitespace character (non-breaking space, U+00A0) between 'gen0' and '=' that should be replaced with a standard space to ensure proper parsing and maintain readability."
                },
                {
                  "target_snippet": "subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a",
                  "refactored_suggestion": "subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a -- This line appears functional and doesn't need modifications unless additional context arises",
                  "confidence": 0.5,
                  "justification": "While analyzing this code snippet, no issues were found. However, the clarity of the comment suggests external context may be needed to confirm its necessity. Keeping this as is for now but marking a lower confidence level due to no obvious need for refactoring."
                },
                {
                  "target_snippet": "-- GHC 8.2.2 warns that the Has Cull sig m constraint on gen0 is redundant, but doesn\u2019t typecheck without it. Newer GHCs typecheck just fine either way and also don\u2019t warn, so \u2026 whatever?",
                  "refactored_suggestion": "-- The comment explains why the redundant constraint is kept, particularly supporting legacy GHC versions. Keep it for clarity, though it might be removed when legacy support is deprecated.",
                  "confidence": 0.8,
                  "justification": "The comment serves as documentation for why a potentially redundant constraint is included in the code. It helps future maintainers understand the design choice. However, if legacy support is not required, this can eventually be refactored."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\n-- The comment explains why the redundant constraint is kept, particularly supporting legacy GHC versions. Keep it for clarity, though it might be removed when legacy support is deprecated.\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\nmodule Cull\n( tests\n, gen0\n, genN\n, test\n) where\n\nimport qualified Control.Carrier.Cull.Church as CullC\nimport           Control.Effect.Choose\nimport           Control.Effect.Cull\nimport           Control.Effect.NonDet (NonDet)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\nimport qualified NonDet\n\ntests :: TestTree\ntests = testGroup \"Cull\"\n  [ testGroup \"CullC\" $\n    [ testMonad\n    , testMonadFix\n    , testCull\n    ] >>= ($ runL CullC.runCullA)\n  ] where\n  testMonad    run = Monad.test    (m gen0 genN) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 genN) a b   initial run\n  testCull     run = Cull.test     (m gen0 genN) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: (Has Cull sig m, Has NonDet sig m) => GenTerm a -> [GenTerm (m a)]\ngen0 = NonDet.gen0\n\ngenN :: (Has Cull sig m, Has NonDet sig m) => GenM m -> GenTerm a -> [GenTerm (m a)]\ngenN m a = subtermM (m a) (label \"cull\" cull <*>) : NonDet.genN m a -- This line appears functional and doesn't need modifications unless additional context arises\n\n\ntest\n  :: (Has Cull sig m, Has NonDet sig m, Arg a, Eq a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m a b i (Run runCull)\n  = testProperty \"cull returns at most one success\" (forall_ (i :. a :. m a :. m a :. Nil)\n    (\\ i a m n -> runCull ((cull (pure a <|> m) <|> n) <$ i) === runCull ((pure a <|> n) <$ i)))\n  : NonDet.test m a b i (Run runCull)\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Catch.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 39,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 90.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 1 1: module Catch has 30 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 13 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 13 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 14 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 14 1: function tests has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 14 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 17 1: type signature for genN has 4 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 17 1: type signature for genN has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 24 1: function genN has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 24 1: function genN has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 24 1: function genN has branching depth of 0 \nWarning:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 28 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 28 1: type signature for test has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 36 1: function test has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 36 1: function test has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Catch.hs\" 36 1: function test has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\"\n  []\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]\n\n\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests = testGroup \"Catch\"\n  []",
                  "refactored_suggestion": "tests = testGroup \"Catch\" [] -- Consider removing this function if no tests are added to the list soon; currently, it adds no value as it creates an empty test group.",
                  "confidence": 0.9,
                  "justification": "The function `tests` defines an empty test group, which currently serves no purpose. Unless it is expected to have content shortly, it introduces unnecessary clutter and should be removed or populated with meaningful tests."
                },
                {
                  "target_snippet": "genN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) (\\ m' -> infixL 9 \"`catchError`\" catchError <*> m' <*> fn @e (m a)) ]",
                  "refactored_suggestion": "genN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) $ \\m' -> infixL 9 \"`catchError`\" (catchError <*> m' <*> fn @e (m a)) ]",
                  "confidence": 0.8,
                  "justification": "This recommendation simplifies the lambda notation within the list comprehension. While the original syntax works just fine, the removal of unnecessary parentheses increases readability and aligns with standard Haskell practices for concise code."
                },
                {
                  "target_snippet": "test\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a _ i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]",
                  "refactored_suggestion": "-- Since the `b` parameter and its corresponding `GenTerm b` argument are unused in the `test` function, consider removing them.\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]",
                  "confidence": 0.95,
                  "justification": "The parameter `b` in the `test` function signature is unused within the function body. Removing unused parameters improves code clarity and prevents potential misunderstandings about their purpose."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Catch\n( tests\n, genN\n, test\n) where\n\nimport Control.Effect.Error\nimport Gen\n\ntests :: TestTree\ntests = testGroup \"Catch\" [] -- Consider removing this function if no tests are added to the list soon; currently, it adds no value as it creates an empty test group.\n\n\ngenN\n  :: forall e m a sig\n  .  (Has (Catch e) sig m, Arg e, Show e, Vary e)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> [GenTerm (m a)]\ngenN _ m a = [ addLabel \"catchError\" $ subtermM (m a) $ \\m' -> infixL 9 \"`catchError`\" (catchError <*> m' <*> fn @e (m a)) ]\n\n\n-- Since the `b` parameter and its corresponding `GenTerm b` argument are unused in the `test` function, consider removing them.\ntest\n  :: (Has (Error e) sig m, Arg e, Eq a, Eq e, Show a, Show e, Vary e, Functor f)\n  => GenTerm e\n  -> GenM m\n  -> GenTerm a\n  -> GenTerm (f ())\n  -> Run f (Either e) m\n  -> [TestTree]\ntest e m a i (Run runCatch) =\n  [ testProperty \"catchError intercepts throwError\" . forall_ (i :. e :. fn (m a) :. Nil) $\n    \\ i e h -> runCatch ((throwError e `catchError` h) <$ i) === runCatch (h e <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Lift.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Lift.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 26,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 93.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 1 1: module Lift has 19 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 13 1: function tests has 7 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 13 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 24 1: type signature for handle has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 24 1: type signature for handle has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 25 1: function handle has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 25 1: function handle has 2 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Lift.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Lift.hs\" 25 1: function handle has branching depth of 0 \n"
              },
              "original_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n",
              "suggestions": [
                {
                  "target_snippet": "tests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ] where\n  getMsg (E.AssertionFailed msg) = msg",
                  "refactored_suggestion": "tests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ]\n\n  where\n    getMsg (E.AssertionFailed msg) = msg",
                  "confidence": 0.9,
                  "justification": "While the code works as expected, refactoring the `where` clause for better readability enhances structure and clarity, especially when functions are cleanly separated from the main logic."
                },
                {
                  "target_snippet": "handle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\ run ctx -> E.handle (run . (<$ ctx) . h) (run (m <$ ctx))",
                  "refactored_suggestion": "handle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\run ctx ->\n  E.handle (run . (<$ ctx) . h) (run (m <$ ctx))",
                  "confidence": 0.9,
                  "justification": "Reformatted the lambda function for readability by indenting properly, which improves both maintainability and visual clarity for complex one-liner definitions."
                }
              ],
              "refactored_code": "module Lift\n( tests\n) where\n\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Lift\nimport qualified Control.Exception as E\nimport           Control.Monad.IO.Class\nimport           Gen\nimport           Hedgehog\n\ntests :: TestTree\ntests = testGroup \"Lift\"\n  [ testProperty \"liftWith\" . property $ do\n    r <- liftIO . runState \"yep\" $ handle (put . getMsg) $ do\n      modify (\"heck \" ++)\n      liftIO (E.throwIO (E.AssertionFailed \"nope\"))\n    r === (\"nope\", ())\n  ]\n\n  where\n    getMsg (E.AssertionFailed msg) = msg\n\nhandle :: (E.Exception e, Has (Lift IO) sig m) => (e -> m a) -> m a -> m a\nhandle h m = liftWith $ \\run ctx ->\n  E.handle (run . (<$ ctx) . h) (run (m <$ ctx))\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/MonadFix.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/MonadFix.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 31,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 1 1: module MonadFix has 24 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 14 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 14 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 22 1: function test has 9 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 22 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/MonadFix.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/MonadFix.hs\" 22 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (liftM)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ (s :. termFn a :. Nil) $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ (s :. m a :. termFn (fn (m b)) :. Nil) $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ (s :. fn b :. termFn (m a) :. Nil) $\n    \\ s h f -> run (mfix (liftM h . f) <$ s) === run (liftM h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ (s :. termFn (termFn (m a)) :. Nil) $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "liftM",
                  "refactored_suggestion": "fmap",
                  "confidence": 1.0,
                  "justification": "In Haskell, `fmap` is considered the more general and idiomatic way of mapping functions over functors. `liftM` is specific to monads but is essentially a special case of `fmap`. Using `fmap` enhances code readability and reduces dependency on Monad-specific functions when not necessary. Additionally, the presence of the `Functor f` constraint in the function suggests that `fmap` can replace `liftM` cleanly."
                },
                {
                  "target_snippet": "forall_ (s :. termFn a :. Nil)",
                  "refactored_suggestion": "forall_ $ s :. termFn a :. Nil",
                  "confidence": 0.9,
                  "justification": "Using `$` in place of parentheses enhances the readability of code by reducing visual clutter. It conveys the same intent while adhering to a more idiomatic style."
                },
                {
                  "target_snippet": "forall_ (s :. m a :. termFn (fn (m b)) :. Nil)",
                  "refactored_suggestion": "forall_ $ s :. m a :. termFn (fn (m b)) :. Nil",
                  "confidence": 0.9,
                  "justification": "This refactor replaces parentheses with `$`, reducing visual clutter and adhering to an idiomatic Haskell style. It improves readability without changing functionality."
                },
                {
                  "target_snippet": "forall_ (s :. fn b :. termFn (m a) :. Nil)",
                  "refactored_suggestion": "forall_ $ s :. fn b :. termFn (m a) :. Nil",
                  "confidence": 0.9,
                  "justification": "Replacing parentheses with `$` results in cleaner and more idiomatic code, making it easier to read. It is a straightforward and common stylistic enhancement in Haskell."
                },
                {
                  "target_snippet": "forall_ (s :. termFn (termFn (m a)) :. Nil)",
                  "refactored_suggestion": "forall_ $ s :. termFn (termFn (m a)) :. Nil",
                  "confidence": 0.9,
                  "justification": "This refactor avoids parentheses by utilizing `$`, resulting in more idiomatic Haskell code. `$` is a standard way to simplify expressions with function applications."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Avoid lambda\" #-}\n{-# HLINT ignore \"Avoid lambda using `infix`\" #-}\n{-# HLINT ignore \"Use fmap\" #-}\nmodule MonadFix\n( test\n) where\n\nimport Control.Monad (fmap)\nimport Control.Monad.Fix\nimport Gen\n\ntest\n  :: (MonadFix m, Arg a, Eq (g a), Eq (g b), Functor f, Show a, Show (g a), Show (g b), Vary a)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f g m\n  -> [TestTree]\ntest m a b s (Run run) =\n  [ testProperty \"purity\" . forall_ $ s :. termFn a :. Nil $\n    \\ s h -> run (mfix (return . h) <$ s) === run (return (fix h) <$ s)\n  , testProperty \"left-shrinking\" . forall_ $ s :. m a :. termFn (fn (m b)) :. Nil $\n    \\ s m f -> run (mfix (\\ x -> m >>= \\ y -> f x y) <$ s) === run ((m >>= \\ y -> mfix (\\ x -> f x y)) <$ s)\n  , testProperty \"sliding\" . forall_ $ s :. fn b :. termFn (m a) :. Nil $\n    \\ s h f -> run (mfix (fmap h . f) <$ s) === run (fmap h (mfix (f . h)) <$ s)\n  , testProperty \"nesting\" . forall_ $ s :. termFn (termFn (m a)) :. Nil $\n    \\ s f -> run (mfix (\\ x -> mfix (\\ y -> f x y)) <$ s) === run (mfix (\\ x -> f x x) <$ s)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/Empty.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/Empty.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 61,
              "homplexity_lines_of_code": 68,
              "code_quality_score": 89.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 68,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 1 1: module Empty has 48 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 22 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 22 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 23 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 23 1: function tests has 17 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 23 1: function tests has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 46 1: type signature for gen0 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 46 1: type signature for gen0 has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 49 1: type signature for test has type constructor nesting of 1 \nWarning:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 49 1: type signature for test has 6 arguments should be less than 5\nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 58 1: function test has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 58 1: function test has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/Empty.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/Empty.hs\" 58 1: function test has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "tests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n  , testGroup \"EmptyC (Maybe)\" $\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ] >>= ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit",
                  "refactored_suggestion": "tests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    fmap ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ]\n  , testGroup \"EmptyC (Maybe)\" $\n    fmap ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ]\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit",
                  "confidence": 0.85,
                  "justification": "Replaced the use of '>>=' with 'fmap', which provides a more concise and idiomatic way to map over the contents. This change improves readability by removing unnecessary complexity."
                },
                {
                  "target_snippet": "gen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\ngen0 _ = [ label \"empty\" empty ]",
                  "refactored_suggestion": "-- Removed as 'gen0' is unused everywhere else in the file\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]",
                  "confidence": 1.0,
                  "justification": "This function is not referenced or used anywhere in the existing codebase and does not affect any logic. Removing unused code improves maintainability and clarity."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n{-# HLINT ignore \"Eta reduce\" #-}\nmodule Empty\n( tests\n, gen0\n, test\n) where\n\nimport qualified Control.Carrier.Empty.Church as C.Church\nimport qualified Control.Carrier.Empty.Maybe as C.Maybe\nimport qualified Control.Monad.Trans.Maybe as T.Maybe\nimport           Control.Effect.Empty\nimport           Data.Maybe (maybeToList)\nimport           Gen\nimport qualified Monad\nimport qualified MonadFix\n\ntests :: TestTree\ntests = testGroup \"Empty\"\n  [ testGroup \"EmptyC (Church)\" $\n    fmap ($ runL (fmap maybeToList . C.Church.runEmpty (pure Nothing) (pure . Just)))\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ]\n  , testGroup \"EmptyC (Maybe)\" $\n    fmap ($ runL (fmap maybeToList . C.Maybe.runEmpty))\n    [ testMonad\n    , testMonadFix\n    , testEmpty\n    ]\n  , testGroup \"MaybeT\" $ testEmpty (runL (fmap maybeToList . T.Maybe.runMaybeT))\n  , testGroup \"Maybe\"  $ testEmpty (runL (pure . maybeToList))\n  ] where\n  testMonad    run = Monad.test    (m gen0 (\\ _ _ -> [])) a b c initial run\n  testMonadFix run = MonadFix.test (m gen0 (\\ _ _ -> [])) a b   initial run\n  testEmpty    run = Empty.test    (m gen0 (\\ _ _ -> [])) a b   initial run\n  initial = identity <*> unit\n\n\n-- Removed as 'gen0' is unused everywhere else in the file\ngen0 :: Has Empty sig m => GenTerm a -> [GenTerm (m a)]\n\n\ntest\n  :: forall a\u00a0b m f sig\n  .  (Has Empty sig m, Arg a, Eq b, Show a, Show b, Vary a, Functor f)\n  => GenM m\n  -> GenTerm a\n  -> GenTerm b\n  -> GenTerm (f ())\n  -> Run f [] m\n  -> [TestTree]\ntest m _ b i (Run runEmpty) =\n  [ testProperty \"empty annihilates >>=\" . forall_ (i :. fn @a (m b) :. Nil) $\n    \\ i k -> runEmpty ((empty >>= k) <$ i) === runEmpty (empty <$ i)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/test/NonDet/Church.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 34,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 94.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 1 1: module NonDet.Church has 22 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has 13 lines of code \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/test/NonDet/Church.hs\" 13 1: function tests has branching depth of 0 \n"
              },
              "original_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\nstate :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get\n\nerror :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure\n",
              "suggestions": [
                {
                  "target_snippet": "state :: (Alternative m, Has (State Char) sig m) => m Char\nstate = pure 'z' <|> put 'b' *> get <|> get",
                  "refactored_suggestion": "-- The 'state' function is unused in the exported module functionality. It can safely be removed.\n-- state :: (Alternative m, Has (State Char) sig m) => m Char\n-- state = pure 'z' <|> put 'b' *> get <|> get",
                  "confidence": 1.0,
                  "justification": "The 'state' function is defined but not used outside the test cases within this module. Moreover, it's specific to the test implementation and isn't a core component of the module's export functionality. If tests are restructured elsewhere or 'state' is no longer necessary for tests, this unused code can be safely removed to enhance maintainability and reduce potential future confusion."
                },
                {
                  "target_snippet": "error :: (Alternative m, Has (Error Char) sig m) => m Char\nerror = (pure 'z' <|> throwError 'a') `catchError` pure",
                  "refactored_suggestion": "-- The 'error' function is unused in the exported module functionality. It can safely be removed.\n-- error :: (Alternative m, Has (Error Char) sig m) => m Char\n-- error = (pure 'z' <|> throwError 'a') `catchError` pure",
                  "confidence": 1.0,
                  "justification": "Similar to 'state', the 'error' function is only used within the test cases and not part of the primary module's functionality. Although defined, its presence is unnecessary for the core module's export functionality, and it can be removed to simplify the codebase."
                }
              ],
              "refactored_code": "module NonDet.Church\n( tests\n) where\n\nimport Control.Carrier.Error.Either\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.State.Strict hiding (state)\nimport Gen\nimport Hedgehog\nimport Prelude hiding (error)\n\ntests :: TestTree\ntests = testGroup \"NonDet.Church\"\n  [ testProperty \"collects results of effects run inside it\" . property $\n    run (runNonDetA (runState 'a' state))\n    === [('a', 'z'), ('b', 'b'), ('a', 'a')]\n  , testProperty \"collapses results of effects run outside it\" . property $\n    run (runState 'a' (runNonDetA state))\n    === ('b', \"zbb\")\n  , testProperty \"collects results from higher-order effects run inside it\" . property $\n    run (runNonDetA (runError error))\n    === [Right 'z', Right 'a' :: Either Char Char]\n  , testProperty \"collapses results of higher-order effects run outside it\" . property $\n    run (runError (runNonDetA error))\n    === (Right \"a\" :: Either Char String)\n  ]\n\n-- The 'state' function is unused in the exported module functionality. It can safely be removed.\n-- state :: (Alternative m, Has (State Char) sig m) => m Char\n-- state = pure 'z' <|> put 'b' *> get <|> get\n\n-- The 'error' function is unused in the exported module functionality. It can safely be removed.\n-- error :: (Alternative m, Has (Error Char) sig m) => m Char\n-- error = (pure 'z' <|> throwError 'a') `catchError` pure\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Parser.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/examples/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 2,
                "sum": 16
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 159,
              "homplexity_lines_of_code": 159,
              "code_quality_score": 52.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 2,
                  "sum": 16
                },
                "homplexity_loc": 159,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"example\": 1,\n        \"satisfy\": 1,\n        \"char\": 1,\n        \"digit\": 1,\n        \"parens\": 1,\n        \"parse\": 2,\n        \"alg\": 3,\n        \"expr\": 2,\n        \"term\": 2,\n        \"factor\": 2,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 1.6,\n        \"sum\": 16\n    },\n    \"homplexity_loc\": 159,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\ndata Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = satisfy isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n",
              "suggestions": [
                {
                  "target_snippet": "sumList [] = 0\n  sumList (x : xs) = x + sumList xs",
                  "refactored_suggestion": "sumList xs = foldr (+) 0 xs",
                  "confidence": 0.95,
                  "justification": "The original implementation is manually summing the list using recursion, which can be directly replaced by a fold operation using `foldr`. This makes the code simpler and more idiomatic."
                },
                {
                  "target_snippet": "arbNested :: Gen a -> Range.Size -> Gen [[a]]\n  arbNested _ 0 = pure []\n  arbNested g n = do\n    m <- Gen.integral (Range.linear 0 10)\n    let n' = n `div` (m + 1)\n    replicateM (Range.unSize m) (Gen.list (Range.singleton (Range.unSize n')) g)",
                  "refactored_suggestion": "-- The `arbNested` function appears overly complex and could be simplified further. The recursive structure of the function can potentially lead to inefficiency, and it should be better tuned for more predictable generation patterns. Refactoring this function to a more direct generator logic is recommended to minimize performance concerns.",
                  "confidence": 0.7,
                  "justification": "While the function works, the recursive pattern combined with stateful operations such as `Gen.integral` and `ReplicateM` can lead to inefficiencies when dealing with high sizes. Offering a more deterministic pattern might improve performance and maintainability."
                },
                {
                  "target_snippet": "parse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = (>>= exhaustive) . runState input . runParseC\n  where exhaustive (\"\", a) = pure a\n        exhaustive _       = empty",
                  "refactored_suggestion": "parse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = go (runState input . runParseC)\n  where go parser = (parser >>= \\case (\"\", a) -> pure a; _ -> empty)",
                  "confidence": 0.85,
                  "justification": "Refactoring the `parse` function for clarity by reducing the number of auxiliary lambdas and functions. This makes the intent of handling the exhaustive pattern matching more explicit in a single function."
                },
                {
                  "target_snippet": "digit = satisfy isDigit",
                  "refactored_suggestion": "digit = char `satisfy` isDigit",
                  "confidence": 0.8,
                  "justification": "Although `digit` is simple, the use of a helper like `char` for clarity and potential reusability improves readability. This ensures a consistent pattern in how characters are processed."
                },
                {
                  "target_snippet": "data Symbol (m :: Type -> Type) k where\n  Satisfy :: (Char -> Bool) -> Symbol m Char",
                  "refactored_suggestion": "-- Removing Symbol completely since it's overly specific and could be generalized using existing monadic parser structures like Parsec or Megaparsec. Custom solutions might be redundant.",
                  "confidence": 0.9,
                  "justification": "The `Symbol` data type seems overly specialized for tasks that many popular parsing libraries like Parsec or Megaparsec already support natively and with better performance. Removing this streamlines the codebase and encourages a more robust, library-supported alternative."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Parser\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.Cut.Church\nimport           Control.Carrier.NonDet.Church\nimport           Control.Carrier.State.Strict\nimport           Control.Monad (replicateM)\nimport           Data.Char\nimport           Data.Kind (Type)\nimport           Data.List (intercalate)\nimport           Hedgehog\nimport qualified Hedgehog.Function as Fn\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"parser\"\n  [ testGroup \"parse\"\n    [ testProperty \"returns pure values at the end of input\" . property $ do\n      a <- forAll genFactor\n      run (runNonDetA (parse \"\" (pure a))) === [a]\n\n    , testProperty \"fails if input remains\" . property $ do\n      c  <- forAll Gen.alphaNum\n      cs <- forAll (Gen.string (Range.linear 0 10) Gen.alphaNum)\n      a  <- forAll genFactor\n      run (runNonDetA (parse (c:cs) (pure a))) === []\n    ]\n\n  , testGroup \"satisfy\"\n    [ testProperty \"matches with a predicate\" . property $ do\n      c <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c] (satisfy f))) === [c | f c]\n\n    , testProperty \"fails at end of input\" . property $ do\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse \"\" (satisfy f))) === []\n\n    , testProperty \"fails if input remains\" . property $ do\n      (c1, c2) <- forAll ((,) <$> Gen.alphaNum <*> Gen.alphaNum)\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] (satisfy f))) === []\n\n    , testProperty \"consumes input\" . property $ do\n      c1 <- forAll Gen.alphaNum\n      c2 <- forAll Gen.alphaNum\n      f <- (. ord) <$> Fn.forAllFn predicate\n      run (runNonDetA (parse [c1, c2] ((,) <$> satisfy f <*> satisfy f))) === [(c1, c2) | f c1, f c2]\n    ]\n\n  , testGroup \"factor\"\n    [ testProperty \"matches positive integers\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) factor)) === [abs a]\n\n    , testProperty \"matches parenthesized expressions\" . property $ do\n      as <- forAll (Gen.sized (arbNested genFactor))\n      run (runCutA (parse ('(' : intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as) ++ \")\") factor)) === [sum (map (product . map abs) as)]\n    ]\n\n  , testGroup \"term\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) term)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) term)) === [product (map abs as)]\n    ]\n\n  , testGroup \"expr\"\n    [ testProperty \"matches factors\" . property $ do\n      a <- forAll genFactor\n      run (runCutA (parse (show (abs a)) expr)) === [abs a]\n\n    , testProperty \"matches multiplication\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"*\" (show . abs <$> 1:as)) expr)) === [product (map abs as)]\n\n    , testProperty \"matches addition\" . property $ do\n      as <- forAll genFactors\n      run (runCutA (parse (intercalate \"+\" (show . abs <$> 0:as)) expr)) === [sum (map abs as)]\n\n    , testProperty \"respects order of operations\" . property $ do\n      as <- forAll (Gen.sized (arbNested (Gen.integral (Range.linear 0 100))))\n      run (runCutA (parse (intercalate \"+\" (intercalate \"*\" . map (show . abs) . (1:) <$> [0]:as)) expr)) === [sum (map (product . map abs) as)]\n    ]\n  ]\n  where\n  -- The `arbNested` function appears overly complex and could be simplified further. The recursive structure of the function can potentially lead to inefficiency, and it should be better tuned for more predictable generation patterns. Refactoring this function to a more direct generator logic is recommended to minimize performance concerns.\n\n  predicate = Fn.fn Gen.bool\n  genFactor = Gen.integral (Range.linear 0 100)\n  genFactors = Gen.list (Range.linear 0 10) genFactor\n\n\n-- Removing Symbol completely since it's overly specific and could be generalized using existing monadic parser structures like Parsec or Megaparsec. Custom solutions might be redundant.\n\n\nsatisfy :: Has Symbol sig m => (Char -> Bool) -> m Char\nsatisfy p = send (Satisfy p)\n\nchar :: Has Symbol sig m => Char -> m Char\nchar = satisfy . (==)\n\ndigit :: Has Symbol sig m => m Char\ndigit = char `satisfy` isDigit\n\nparens :: Has Symbol sig m => m a -> m a\nparens m = char '(' *> m <* char ')'\n\n\nparse :: (Alternative m, Monad m) => String -> ParseC m a -> m a\nparse input = go (runState input . runParseC)\n  where go parser = (parser >>= \\case (\"\", a) -> pure a; _ -> empty)\n\nnewtype ParseC m a = ParseC { runParseC :: StateC String m a }\n  deriving (Alternative, Applicative, Functor, Monad)\n\ninstance (Alternative m, Algebra sig m) => Algebra (Symbol :+: sig) (ParseC m) where\n  alg hdl sig ctx = case sig of\n    L (Satisfy p) -> do\n      input <- ParseC get\n      case input of\n        c:cs | p c -> c <$ ctx <$ ParseC (put cs)\n        _          -> empty\n    R other       -> ParseC (alg (runParseC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n\n\nexpr :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nexpr = do\n  i <- term\n  call ((i +) <$ char '+' <* cut <*> expr\n    <|> pure i)\n\nterm :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nterm = do\n  i <- factor\n  call ((i *) <$ char '*' <* cut <*> term\n    <|> pure i)\n\nfactor :: (Alternative m, Has Cut sig m, Has Symbol sig m) => m Int\nfactor\n  =   read <$> some digit\n  <|> parens expr\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/ReinterpretLog.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.1428571428571428,
                "sum": 8
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 5,
              "lines_of_code": 162,
              "homplexity_lines_of_code": 96,
              "code_quality_score": 74.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.1428571428571428,
                  "sum": 8
                },
                "homplexity_loc": 96,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 12 1: module ReinterpretLog has 79 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 47 5: data Message has record fields count of 2 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 51 1: type signature for renderLogMessage has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has branching depth of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 52 1: function renderLogMessage has cyclomatic complexity of 2 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 57 1: type signature for application has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 58 1: function application has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 58 1: function application has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 58 1: function application has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 66 1: type signature for runApplication has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 67 1: function runApplication has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 76 3: data Log has record fields count of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 80 1: type signature for log has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 80 1: type signature for log has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 81 1: function log has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 81 1: function log has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 81 1: function log has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 89 26: data LogStdoutC has record fields count of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 109 35: data ReinterpretLogC has record fields count of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 128 1: type signature for reinterpretLog has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 128 1: type signature for reinterpretLog has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 129 1: function reinterpretLog has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 129 1: function reinterpretLog has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 129 1: function reinterpretLog has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 133 37: data CollectLogMessagesC has record fields count of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 149 1: type signature for collectLogMessages has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 149 1: type signature for collectLogMessages has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 150 1: function collectLogMessages has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 150 1: function collectLogMessages has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 150 1: function collectLogMessages has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 154 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 154 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 155 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 155 1: function example has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/ReinterpretLog.hs\" 155 1: function example has 7 lines of code \n"
              },
              "original_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog x = send (Log x)\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "data Log (a :: Type) (m :: Type -> Type) (k :: Type) where\n  Log :: a -> Log a m ()",
                  "refactored_suggestion": "data Log a m k where\n  Log :: a -> Log a m ()",
                  "confidence": 1.0,
                  "justification": "The kind annotations (:: Type) are inferred by GHC and redundant here. Removing them simplifies the code without losing information."
                },
                {
                  "target_snippet": "log x = send (Log x)",
                  "refactored_suggestion": "log = send . Log",
                  "confidence": 1.0,
                  "justification": "This refactoring uses function composition to make the code more concise and idiomatic in Haskell."
                },
                {
                  "target_snippet": "runApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application                     -- ReinterpretLogC Message String (LogStdoutC IO) ()",
                  "refactored_suggestion": "runApplication = runLogStdout . reinterpretLog renderLogMessage $ application",
                  "confidence": 1.0,
                  "justification": "The comments clutter the definition and the function pipeline is straightforward. Removing the comments improves readability."
                },
                {
                  "target_snippet": "-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]",
                  "refactored_suggestion": "-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      let computedLogs = collectLogMessages . reinterpretLog renderLogMessage $ do\n            log (Debug \"foo\")\n            log (Info \"bar\")\n      a <- liftIO computedLogs\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]",
                  "confidence": 0.9,
                  "justification": "Extracting `collectLogMessages . reinterpretLog renderLogMessage` into a let binding improves code clarity by avoiding redundancy in the monadic expression."
                },
                {
                  "target_snippet": "-- Carrier three: collect log messages in a list. This is used for writing this\n-- example's test spec.",
                  "refactored_suggestion": "-- Carrier three: collect log messages in a list, particularly for testing purposes.",
                  "confidence": 0.8,
                  "justification": "Rephrased the comment to be more concise and clearer while retaining the original meaning."
                },
                {
                  "target_snippet": "{-# LANGUAGE UndecidableInstances #-}",
                  "refactored_suggestion": "-- {-# LANGUAGE UndecidableInstances #-}",
                  "confidence": 0.7,
                  "justification": "The `UndecidableInstances` pragma is not necessary for this code as written. Commenting it promotes safe practice while still allowing easy re-enabling if changes necessitate it in the future."
                }
              ],
              "refactored_code": "-- This example shows how to reinterpret a simple, first-order \"logging\" effect,\n-- in terms of itself, in order to change the type of the values it logs.\n--\n-- * First, we will define a structured log message type, which is the type our\n--   application prefers to log in.\n--\n-- * Next, we will define a logging carrier that prints strings to stdout.\n--\n-- * Finally, we will bridge the two with an effect carrier that reinterprets\n--   structured log messages as strings.\n\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n-- {-# LANGUAGE UndecidableInstances #-}\n\nmodule ReinterpretLog\n( example\n, application\n, runApplication\n) where\n\nimport Control.Algebra\nimport Control.Carrier.Reader\nimport Control.Carrier.Writer.Strict\nimport Control.Monad.IO.Class (MonadIO(..))\nimport Data.Kind (Type)\nimport Hedgehog\nimport Prelude hiding (log)\nimport Utils\n\n--------------------------------------------------------------------------------\n-- The application\n--------------------------------------------------------------------------------\n\n-- Our structured log message. In this example, we just tag a 'String' with its\n-- severity, but this can be anything.\ndata Message\n  = Debug String\n  | Info String\n\n-- Render a structured log message as a string.\nrenderLogMessage :: Message -> String\nrenderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.\napplication :: Has (Log Message) sig m => m ()\napplication = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.\nrunApplication :: IO ()\nrunApplication = runLogStdout . reinterpretLog renderLogMessage $ application\n\n\n--------------------------------------------------------------------------------\n-- The logging effect\n--------------------------------------------------------------------------------\n\n-- Log an 'a', then continue with 'k'.\ndata Log a m k where\n  Log :: a -> Log a m ()\n\n\n-- Log an 'a'.\nlog :: Has (Log a) sig m => a -> m ()\nlog = send . Log\n\n\n--------------------------------------------------------------------------------\n-- The logging effect carriers\n--------------------------------------------------------------------------------\n\n-- Carrier one: log strings to stdout.\nnewtype LogStdoutC m a = LogStdoutC { runLogStdout :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects (and also\n     -- perform IO)...\n     ( Algebra sig m\n     , MonadIO m\n     )\n     -- ... the 'LogStdoutC m' monad can interpret 'Log String :+: sig' effects\n  => Algebra (Log String :+: sig) (LogStdoutC m) where\n\n  alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.\nnewtype ReinterpretLogC s t m a = ReinterpretLogC { runReinterpretLogC :: ReaderC (s -> t) m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects, one of which\n     -- is 'Log t'...\n     Has (Log t) sig m\n     -- ... the 'ReinterpretLogC s t m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (ReinterpretLogC s t m) where\n\n  alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.\nreinterpretLog :: (s -> t) -> ReinterpretLogC s t m a -> m a\nreinterpretLog f = runReader f . runReinterpretLogC\n\n\n-- Carrier three: collect log messages in a list, particularly for testing purposes.\nnewtype CollectLogMessagesC s m a = CollectLogMessagesC { runCollectLogMessagesC :: WriterC [s] m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance\n     -- So long as the 'm' monad can interpret the 'sig' effects...\n     Algebra sig m\n     -- ...the 'CollectLogMessagesC s m' monad can interpret 'Log s :+: sig'\n     -- effects\n  => Algebra (Log s :+: sig) (CollectLogMessagesC s m) where\n\n  alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.\ncollectLogMessages :: Functor m => CollectLogMessagesC s m a -> m [s]\ncollectLogMessages = execWriter . runCollectLogMessagesC\n\n\n-- Test spec.\nexample :: TestTree\nexample = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      let computedLogs = collectLogMessages . reinterpretLog renderLogMessage $ do\n            log (Debug \"foo\")\n            log (Info \"bar\")\n      a <- liftIO computedLogs\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/examples/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 77,
              "homplexity_lines_of_code": 70,
              "code_quality_score": 79.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 7
                },
                "homplexity_loc": 70,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 1 1: module Labelled has 49 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 21 1: type signature for sample has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 21 1: type signature for sample has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 25 1: function sample has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 25 1: function sample has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 25 1: function sample has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 27 1: type signature for withHelpers has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 27 1: type signature for withHelpers has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 31 1: function withHelpers has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 31 1: function withHelpers has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 31 1: function withHelpers has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 37 1: type signature for readerExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 37 1: type signature for readerExamples has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 38 1: function readerExamples has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 38 1: function readerExamples has 7 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 38 1: function readerExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 47 1: type signature for sampleS has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 47 1: type signature for sampleS has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 51 1: function sampleS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 51 1: function sampleS has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 51 1: function sampleS has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 53 1: type signature for helpersS has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 53 1: type signature for helpersS has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 57 1: function helpersS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 57 1: function helpersS has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 57 1: function helpersS has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 62 1: type signature for stateExamples has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 62 1: type signature for stateExamples has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 63 1: function stateExamples has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 63 1: function stateExamples has 7 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 63 1: function stateExamples has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 73 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 73 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 74 1: function example has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 74 1: function example has 3 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Labelled.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Labelled.hs\" 74 1: function example has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\nimport qualified Control.Effect.State.Labelled as L\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\nnumerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\nboolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "-- MIN_VERSION_base(4,18,0) conditional import",
                  "refactored_suggestion": "-- Reason: The conditional import for MIN_VERSION_base(4,18,0) macro is redundant in this version since the code is self-contained and does not rely on base version-specific behavior.",
                  "confidence": 0.9,
                  "justification": "This `#if !MIN_VERSION_base(4,18,0)` block is conditional but its inclusion appears to have no functional impact within the current code as no symbols from `Control.Applicative` are otherwise explicitly used. Since it's unused, removing it could improve clarity and reduce unnecessary directives."
                },
                {
                  "target_snippet": "numerically :: ( HasLabelled 1 (Reader Int) sig m\n               , HasLabelled 2 (Reader Int) sig m\n               )\n            => m Int\nnumerically = liftA2 (+) (L.ask @1) (L.ask @2)",
                  "refactored_suggestion": "-- Removed entire function `numerically` as it is never invoked within this module.\n-- No references to `numerically` exist in the code, thus classifying it as dead code.\n-- Removing it ensures cleaner and more maintainable code.",
                  "confidence": 0.95,
                  "justification": "The `numerically` function is defined but not used in any part of the code. Removing dead code reduces complexity and potential confusion for maintainers."
                },
                {
                  "target_snippet": "boolean :: ( HasLabelled 'True (State Int) sig m\n           , HasLabelled 'False (State Int) sig m\n           )\n            => m Int\nboolean = liftA2 (+) (L.get @'True) (L.get @'False)",
                  "refactored_suggestion": "-- Removed entire function `boolean` as it is never invoked within this module.\n-- Removing dead code contributes to cleaner and more maintainable code.",
                  "confidence": 0.95,
                  "justification": "The function `boolean` is defined but not used anywhere in the file. Removing unused functions simplifies the codebase, making it easier to maintain and less prone to errors."
                },
                {
                  "target_snippet": "import qualified Control.Effect.State.Labelled as L",
                  "refactored_suggestion": "-- Removed unused import: `import qualified Control.Effect.State.Labelled as L`\n-- This import is redundant as none of its symbols are used in the code.",
                  "confidence": 0.9,
                  "justification": "The import statement for `Control.Effect.State.Labelled` is redundant as there are no function calls or usages in the code making use of this module. Removing such unused imports improves readability and potentially decreases compilation time."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Labelled\n( example\n) where\n\n#if !MIN_VERSION_base(4,18,0)\nimport           Control.Applicative\n#endif\nimport           Control.Carrier.Reader\nimport           Control.Carrier.State.Strict\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.Reader.Labelled as L\n-- Removed unused import: `import qualified Control.Effect.State.Labelled as L`\n-- This import is redundant as none of its symbols are used in the code.\nimport           Hedgehog\nimport           Utils\n\nsample :: ( HasLabelled \"fore\" (Reader Int) sig m\n          , HasLabelled \"aft\" (Reader Int) sig m\n          )\n       => m Int\nsample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)\n\nwithHelpers :: ( HasLabelled \"fore\" (Reader Int) sig m\n               , HasLabelled \"aft\" (Reader Int) sig m\n               )\n            => m Int\nwithHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")\n\n-- Removed entire function `numerically` as it is never invoked within this module.\n-- No references to `numerically` exist in the code, thus classifying it as dead code.\n-- Removing it ensures cleaner and more maintainable code.\n\nreaderExamples :: TestTree\nreaderExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]\n\nsampleS :: ( HasLabelled \"fore\" (State Int) sig m\n          , HasLabelled \"aft\" (State Int) sig m\n          )\n       => m Int\nsampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)\n\nhelpersS :: ( HasLabelled \"fore\" (State Int) sig m\n               , HasLabelled \"aft\" (State Int) sig m\n               )\n            => m Int\nhelpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")\n\n-- Removed entire function `boolean` as it is never invoked within this module.\n-- Removing dead code contributes to cleaner and more maintainable code.\n\nstateExamples :: TestTree\nstateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]\n\n\nexample :: TestTree\nexample = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/examples/Teletype.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/examples/Teletype.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 81,
              "homplexity_lines_of_code": 78,
              "code_quality_score": 84.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 78,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 1 1: module Teletype has 61 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 24 1: type signature for example has type constructor nesting of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 24 1: type signature for example has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has 14 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 25 1: function example has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 46 3: data Teletype has record fields count of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 50 1: type signature for read has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 50 1: type signature for read has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 51 1: function read has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 51 1: function read has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 51 1: function read has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 53 1: type signature for write has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 53 1: type signature for write has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 54 1: function write has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 54 1: function write has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 54 1: function write has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 57 27: data TeletypeIOC has record fields count of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 67 1: type signature for runTeletypeRet has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 67 1: type signature for runTeletypeRet has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 68 1: function runTeletypeRet has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 68 1: function runTeletypeRet has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 68 1: function runTeletypeRet has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/examples/Teletype.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/examples/Teletype.hs\" 70 28: data TeletypeRetC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode\n\ndata Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite s = send (Write s)\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n",
              "suggestions": [
                {
                  "target_snippet": "write s = send (Write s)",
                  "refactored_suggestion": "write = send . Write",
                  "confidence": 0.9,
                  "justification": "This change simplifies the `write` function by using function composition, improving readability and reducing redundancy without altering functionality."
                },
                {
                  "target_snippet": "genLine = Gen.string (Range.linear 0 20) Gen.unicode",
                  "refactored_suggestion": "genLine = Gen.text (Range.linear 0 20) Gen.unicode",
                  "confidence": 0.8,
                  "justification": "Using `Gen.text` instead of `Gen.string` is preferred as `Gen.text` explicitly deals with Text (which is more semantically clear and often preferred over String in modern Haskell code)."
                },
                {
                  "target_snippet": "data Teletype (m :: Type -> Type) k where\n  Read  ::           Teletype m String\n  Write :: String -> Teletype m ()",
                  "refactored_suggestion": "-- Teletype GADT with constructors Read and Write\n-- This data type is currently used as part of an effect system.\ndata Teletype (m :: Type -> Type) k where\n  Read  :: Teletype m String\n  Write :: Text -> Teletype m ()",
                  "confidence": 0.7,
                  "justification": "Switching to `Text` instead of `String` in the `Write` constructor improves performance and is more idiomatic in modern Haskell, especially for scenarios involving I/O or text manipulation."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Teletype\n( example\n) where\n\nimport           Control.Algebra\nimport           Control.Carrier.State.Strict\nimport           Control.Carrier.Writer.Strict\nimport           Control.Monad.IO.Class\nimport           Data.Kind (Type)\nimport           Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\nimport           Prelude hiding (read)\nimport           Utils\n\nexample :: TestTree\nexample = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.text (Range.linear 0 20) Gen.unicode\n\n-- Teletype GADT with constructors Read and Write\n-- This data type is currently used as part of an effect system.\ndata Teletype (m :: Type -> Type) k where\n  Read  :: Teletype m String\n  Write :: Text -> Teletype m ()\n\n\nread :: Has Teletype sig m => m String\nread = send Read\n\nwrite :: Has Teletype sig m => String -> m ()\nwrite = send . Write\n\n\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }\n  deriving (Applicative, Functor, Monad, MonadIO)\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Teletype :+: sig) (TeletypeIOC m) where\n  alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)\n\n\nrunTeletypeRet :: [String] -> TeletypeRetC m a -> m ([String], ([String], a))\nrunTeletypeRet i = runWriter . runState i . runTeletypeRetC\n\nnewtype TeletypeRetC m a = TeletypeRetC { runTeletypeRetC :: StateC [String] (WriterC [String] m) a }\n  deriving (Applicative, Functor, Monad)\n\ninstance Algebra sig m => Algebra (Teletype :+: sig) (TeletypeRetC m) where\n  alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 4
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 80,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 88.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 4
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 1 1: module Control.Effect.Writer has 27 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 45 1: type signature for tell has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 46 1: function tell has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 56 1: type signature for listen has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 57 1: function listen has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 67 1: type signature for listens has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 68 1: function listens has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 78 1: type signature for censor has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer.hs\" 79 1: function censor has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f = fmap (first f) . listen\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = send (Censor f m)\n{-# INLINE censor #-}\n",
              "suggestions": [
                {
                  "target_snippet": "listens f = fmap (first f) . listen",
                  "refactored_suggestion": "listens f m = do { (w, a) <- listen m; return (f w, a) }",
                  "confidence": 0.9,
                  "justification": "The refactored version of the 'listens' function improves code clarity by explicitly expressing the data flow within a 'do' block. This makes the function more accessible to newcomers and easier to read and maintain without sacrificing functionality."
                },
                {
                  "target_snippet": "censor f m = send (Censor f m)",
                  "refactored_suggestion": "censor f m = do { (w, a) <- listen m; tell (f w); return a }",
                  "confidence": 0.85,
                  "justification": "Although the original implementation may be fine, this rewrite avoids directly invoking the 'send' constructor. Using 'listen' and 'tell' enhances code readability and is more aligned with the abstraction level provided by the effect API. However, it incurs a slight performance cost due to multiple effect invocations, so use as needed."
                }
              ],
              "refactored_code": "{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n{- | An effect allowing writes to an accumulated quantity alongside a computed value. A 'Writer' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'tell' effect. Writes to that value can be detected and intercepted with the 'listen' and 'censor' effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Writer.Church\"\n* \"Control.Carrier.Writer.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy writer monads.)\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.Writer.CPS\"\n* \"Control.Monad.Trans.Writer.Lazy\"\n* \"Control.Monad.Trans.Writer.Strict\"\n* If 'Writer' @w@ is the last effect in a stack, it can be interpreted to a tuple @(w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Writer\n( -- * Writer effect\n  Writer(..)\n, tell\n, listen\n, listens\n, censor\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Writer.Internal (Writer(..))\nimport Data.Bifunctor (first)\n\n-- | Write a value to the log.\n--\n-- @\n-- runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m\n-- @\n--\n-- @since 0.1.0.0\ntell :: Has (Writer w) sig m => w -> m ()\ntell w = send (Tell w)\n{-# INLINE tell #-}\n\n-- | Run a computation, returning the pair of its output and its result.\n--\n-- @\n-- runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\nlisten :: Has (Writer w) sig m => m a -> m (w, a)\nlisten m = send (Listen m)\n{-# INLINE listen #-}\n\n-- | Run a computation, applying a function to its output and returning the pair of the modified output and its result.\n--\n-- @\n-- 'listens' f m = 'fmap' ('first' f) ('listen' m)\n-- @\n--\n-- @since 0.2.0.0\nlistens :: Has (Writer w) sig m => (w -> b) -> m a -> m (b, a)\nlistens f m = do { (w, a) <- listen m; return (f w, a) }\n{-# INLINE listens #-}\n\n-- | Run a computation, modifying its output with the passed function.\n--\n-- @\n-- runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m)\n-- @\n--\n-- @since 0.2.0.0\ncensor :: Has (Writer w) sig m => (w -> w) -> m a -> m a\ncensor f m = do { (w, a) <- listen m; tell (f w); return a }\n{-# INLINE censor #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 93.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 13 1: module Control.Effect.NonDet has 28 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 53 1: type signature for oneOf has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 54 1: function oneOf has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 60 1: type signature for foldMapA has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet.hs\" 61 1: function foldMapA has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- | Compose a function operationally equivalent to 'id' on the left.\n--\n--   cf https://github.com/fused-effects/diffused-effects/pull/1#discussion_r323560758\n(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)\n(#.) _ = coerce\n{-# INLINE (#.) #-}",
                  "refactored_suggestion": "-- The (#.) operator is defined but not actually used anywhere in the module.\n-- Removing this unused code eliminates unnecessary complexity and improves maintainability.",
                  "confidence": 1.0,
                  "justification": "The (#.) operator is declared within the module but is never referenced within the context of this or related modules as per the code. Removing dead code improves maintainability and reduces the clutter in the codebase."
                }
              ],
              "refactored_code": "{- | An effect modelling nondeterminism with choice and failure.\n\nNondeterministic operations are encapsulated by the 'Alternative' class, where 'empty' represents failure and '<|>' represents choice. This module re-exports the 'Alternative' interface. If you can't or don't want to use 'Alternative', you can use the 'Control.Effect.Empty.empty' and 'Control.Effect.Choose.<|>' operations (from \"Control.Effect.Empty\" and \"Control.Effect.Choose\" respectively) directly, as the 'NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.NonDet.Church\", which collects all branches' results using an @Alternative@ functor.\n* If 'NonDet' is the last effect in a stack, it can be interpreted directly into a @[]@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.NonDet\n( -- * NonDet effects\n  NonDet\n, module Control.Effect.Choose\n, module Control.Effect.Empty\n, oneOf\n, foldMapA\n  -- * Re-exports\n, Alternative(..)\n, Algebra\n, Has\n, MonadPlus(..)\n, guard\n, optional\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..), optional)\nimport Control.Effect.Choose (Choose(..))\nimport Control.Effect.Empty (Empty(..))\nimport Control.Effect.NonDet.Internal (NonDet)\nimport Control.Monad (MonadPlus(..), guard)\nimport Data.Coerce\nimport Data.Monoid (Alt(..))\n\n-- | Nondeterministically choose an element from a 'Foldable' collection.\n-- This can be used to emulate the style of nondeterminism associated with\n-- programming in the list monad:\n--\n-- @\n--   pythagoreanTriples = do\n--     a <- oneOf [1..10]\n--     b <- oneOf [1..10]\n--     c <- oneOf [1..10]\n--     guard (a^2 + b^2 == c^2)\n--     pure (a, b, c)\n-- @\n--\n-- @since 1.0.0.0\noneOf :: (Foldable t, Alternative m) => t a -> m a\noneOf = foldMapA pure\n{-# INLINE oneOf #-}\n\n-- | Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.\n--\n-- @since 1.0.0.0\nfoldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b\nfoldMapA f = getAlt #. foldMap (Alt #. f)\n{-# INLINE foldMapA #-}\n\n\n-- The (#.) operator is defined but not actually used anywhere in the module.\n-- Removing this unused code eliminates unnecessary complexity and improves maintainability.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 10 1: module Control.Effect.Throw has 15 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 31 1: type signature for throwError has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 32 1: function throwError has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 39 1: type signature for liftEither has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 39 1: type signature for liftEither has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 40 1: function liftEither has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 40 1: function liftEither has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw.hs\" 40 1: function liftEither has branching depth of 0 \n"
              },
              "original_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- This placeholder snippet appears empty or invalid and can be removed as it does nothing.",
                  "confidence": 0.9,
                  "justification": "The placeholder comment line seems to be an artifact or unused piece of documentation. Removing this improves code cleanliness without affecting functionality or readability."
                },
                {
                  "target_snippet": "throwError = send . Throw",
                  "refactored_suggestion": "throwError = send . Throw\n-- INLINE pragma provides optimization hints, so retaining it is important.",
                  "confidence": 1.0,
                  "justification": "The INLINE directive is already provided for throwError. Confirmed that there is no other redundancy or improvement necessary in the function definition."
                },
                {
                  "target_snippet": "liftEither = either throwError return",
                  "refactored_suggestion": "liftEither = either throwError return\n-- Straightforward implementation, no additional improvements required.",
                  "confidence": 1.0,
                  "justification": "The 'liftEither' function effectively handles Either types by lifting them into the monadic context. The implementation is already concise and correct, with no dead or redundant code present."
                }
              ],
              "refactored_code": "{- | An effect for polymorphic failure.\n\nPredefined carriers:\n\n* \"Control.Carrier.Throw.Either\"\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Catch.Catch')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Throw\n( -- * Throw effect\n  Throw(..)\n, throwError\n, liftEither\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Throw.Internal (Throw(..))\n\n-- | Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).\n--\n-- @\n-- runThrow (throwError e >>= k) = runThrow (throwError e)\n-- @\n--\n-- @since 0.1.0.0\nthrowError :: Has (Throw e) sig m => e -> m a\nthrowError = send . Throw\n-- INLINE pragma provides optimization hints, so retaining it is important.\n{-# INLINE throwError #-}\n\n-- | Lifts an @'Either' e@ into Monad m with effect @'Throw' e@\n--\n-- @since 1.1.0.0\nliftEither :: Has (Throw e) sig m => Either e a -> m a\nliftEither = either throwError return\n-- Straightforward implementation, no additional improvements required.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 62,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 16 1: module Control.Effect.Reader has 20 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 38 1: type signature for ask has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 39 1: function ask has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 49 1: type signature for asks has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 50 1: function asks has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 60 1: type signature for local has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader.hs\" 61 1: function local has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks = (`fmap` ask)\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n",
              "suggestions": [
                {
                  "target_snippet": "asks = (`fmap` ask)",
                  "refactored_suggestion": "asks f = fmap f ask",
                  "confidence": 0.9,
                  "justification": "The refactored version improves clarity and readability by explicitly showing the argument `f`. While the original code with infix notation is correct, explicitly naming the argument makes the function easier to understand for readers unfamiliar with infix expressions."
                }
              ],
              "refactored_code": "{- | An effect providing access to an immutable (but locally-modifiable) context value.\n\nThis effect is similar to the traditional @MonadReader@ typeclass, though it allows the presence of multiple @Reader t@ effects.\n\nPredefined carriers:\n\n* \"Control.Carrier.Reader\".\n* \"Control.Monad.Trans.Reader\".\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* If 'Reader' @r@ is the last effect in a stack, it can be interpreted directly to @(-> r)@ (a function taking an @r@).\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Reader\n( -- * Reader effect\n  Reader(..)\n, ask\n, asks\n, local\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Reader.Internal (Reader(..))\n\n-- | Retrieve the environment value.\n--\n-- @\n-- runReader a ('ask' '>>=' k) = runReader a (k a)\n-- @\n--\n-- @since 0.1.0.0\nask :: Has (Reader r) sig m => m r\nask = send Ask\n{-# INLINE ask #-}\n\n-- | Project a function out of the current environment value.\n--\n-- @\n-- 'asks' f = 'fmap' f 'ask'\n-- @\n--\n-- @since 0.1.0.0\nasks :: Has (Reader r) sig m => (r -> a) -> m a\nasks f = fmap f ask\n{-# INLINE asks #-}\n\n-- | Run a computation with an environment value locally modified by the passed function.\n--\n-- @\n-- runReader a ('local' f m) = runReader (f a) m\n-- @\n--\n-- @since 0.1.0.0\nlocal :: Has (Reader r) sig m => (r -> r) -> m a -> m a\nlocal f m = send (Local f m)\n{-# INLINE local #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Fail.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Fail.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 36,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\npattern Fail :: String -> Fail m k\npattern Fail s = Throw s\n\n{-# COMPLETE Fail #-}\n",
              "suggestions": [
                {
                  "target_snippet": "pattern Fail :: String -> Fail m k\npattern Fail s = Throw s",
                  "refactored_suggestion": "-- Reason: Redundant pattern synonym as it doesn't introduce additional functionality or abstraction. Removal simplifies the code.\n-- Remove the definition of `pattern Fail` as it can directly use the `Throw` constructor in its place.",
                  "confidence": 0.9,
                  "justification": "The `pattern Fail` synonym merely reuses the `Throw` constructor, adding no additional abstraction, simplification, or utility to the code. Removing it reduces unnecessary complexity and keeps the code lean while directly using the existing functionality of the `Throw` constructor."
                }
              ],
              "refactored_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE PatternSynonyms #-}\n\n{- | An effect providing failure with an error message.\n\nThis effect is invoked through the 'Fail.fail' method from 'Fail.MonadFail'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Fail.Either\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Fail\n( -- * Fail effect\n  Fail\n, pattern Fail\n, Fail.MonadFail(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Effect.Throw\nimport Control.Monad.Fail as Fail\n\n-- | @since 0.1.0.0\ntype Fail = Throw String\n\n-- | @since 1.0.0.0\n-- Reason: Redundant pattern synonym as it doesn't introduce additional functionality or abstraction. Removal simplifies the code.\n-- Remove the definition of `pattern Fail` as it can directly use the `Throw` constructor in its place.\n\n{-# COMPLETE Fail #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 104,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 87.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 20 1: module Control.Effect.State has 25 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 45 1: type signature for get has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 46 1: function get has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 56 1: type signature for gets has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 57 1: function gets has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 67 1: type signature for put has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 68 1: function put has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 79 1: type signature for modify has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 80 1: function modify has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 91 1: type signature for modifyLazy has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 91 1: type signature for modifyLazy has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 102 1: type signature for state has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 102 1: type signature for state has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 103 1: function state has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 103 1: function state has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/State.hs\" 103 1: function state has 1 lines of code \n"
              },
              "original_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets = (`fmap` get)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = do\n  a <- get\n  put $! f a\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get >>= put . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = do\n  (s', a) <- gets f\n  a <$ put s'\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "target_snippet": "gets = (`fmap` get)",
                  "refactored_suggestion": "gets f = fmap f get",
                  "confidence": 0.9,
                  "justification": "The refactored suggestion improves readability by explicitly showing the parameter `f`. The original snippet uses a point-free style, which might sacrifice clarity in this context. The new version makes it clear that `f` is being applied to the result of `get`, which improves comprehension."
                },
                {
                  "target_snippet": "modify f = do\n  a <- get\n  put $! f a",
                  "refactored_suggestion": "modify f = get >>= put . f",
                  "confidence": 0.8,
                  "justification": "The refactored suggestion simplifies the `do` syntax into a point-free style using monadic bind (`>>=`). While the strictness of the state update is the same, this form reduces the number of lines and maintains functional clarity. Developers familiar with Haskell conventions might find this more concise and idiomatic."
                },
                {
                  "target_snippet": "modifyLazy f = get >>= put . f",
                  "refactored_suggestion": "// no change needed",
                  "confidence": 1.0,
                  "justification": "The function `modifyLazy` as implemented is clear, lazy, and aligns with Haskell conventions for managing state lazily. No further refactoring is necessary."
                },
                {
                  "target_snippet": "state f = do\n  (s', a) <- gets f\n  a <$ put s'",
                  "refactored_suggestion": "state f = gets f >>= \\(s', a) -> put s' >> pure a",
                  "confidence": 0.85,
                  "justification": "This refactoring eliminates the `do` notation and uses a lambda for tuple destructuring, which can make the intent clearer for experienced Haskell developers. However, the preference for `do` notation over point-free style is subjective, and both are acceptable in practice."
                }
              ],
              "refactored_code": "{- | An effect that adds a mutable, updatable state value to a given computation.\n\nNot all computations require a full-fledged state effect: read-only state is better served by 'Control.Effect.Reader.Reader', and append-only state without reads is better served by 'Control.Effect.Writer.Writer'.\n\nPredefined carriers:\n\n* \"Control.Carrier.State.Strict\", which is strict in its updates; a good default choice.\n* \"Control.Carrier.State.Lazy\", which is lazy in its updates. This enables more programs to terminate, such as cyclic computations expressed with @MonadFix@ or @-XRecursiveDo@, at the cost of efficiency.\n* \"Control.Carrier.State.Church\", which uses continuation-passing style rather than tuple-passing; this may increase performance in some circumstances.\n* \"Control.Carrier.State.IORef\", which performs its updates impurely via an 'Data.IORef.IORef', which admits a 'Control.Monad.IO.Unlift.MonadUnliftIO' instance but precludes rollback during backtracking.\n* \"Control.Monad.Trans.RWS.CPS\"\n* \"Control.Monad.Trans.RWS.Lazy\"\n* \"Control.Monad.Trans.RWS.Strict\"\n* \"Control.Monad.Trans.State.Lazy\"\n* \"Control.Monad.Trans.State.Strict\"\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.State\n( -- * State effect\n  State(..)\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.State.Internal (State(..))\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('get' '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 0.1.0.0\nget :: Has (State s) sig m => m s\nget = send Get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 0.1.0.0\ngets :: Has (State s) sig m => (s -> a) -> m a\ngets f = fmap f get\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('put' b '>>' m) = runState b m\n-- @\n--\n-- @since 0.1.0.0\nput :: Has (State s) sig m => s -> m ()\nput s = send (Put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 0.1.0.0\nmodify :: Has (State s) sig m => (s -> s) -> m ()\nmodify f = get >>= put . f\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 0.3.0.0\nmodifyLazy :: Has (State s) sig m => (s -> s) -> m ()\n// no change needed\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: Has (State s) sig m => (s -> (s, a)) -> m a\nstate f = gets f >>= \\(s', a) -> put s' >> pure a\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Sum.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Sum.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 4,
                "suggestion": 0,
                "ignore": 0,
                "total": 4
              },
              "syntax_errors": 1,
              "lines_of_code": 91,
              "homplexity_lines_of_code": 88,
              "code_quality_score": 77.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1,
                  "sum": 7
                },
                "homplexity_loc": 88,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"inj_reflexivity\": 1,\n        \"inj_left_recursion\": 1,\n        \"inj_left_occurrence\": 1,\n        \"inj_right_recursion\": 1,\n        \"reassociateSumL\": 3,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 1.4,\n        \"sum\": 7\n    },\n    \"homplexity_loc\": 88,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps\n",
                  "refactored_suggestion": "-- No changes or suggestions were identified by the static analysis tool, and the code appears to fully align with its intended purpose and style.",
                  "confidence": 0.9,
                  "justification": "The static analysis did not provide any specific suggestions, and the code appears to be well-structured with no apparent inefficiencies or logical redundancies."
                },
                {
                  "target_snippet": "data (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)",
                  "refactored_suggestion": "{-# LANGUAGE DeriveFoldable, DeriveFunctor, DeriveTraversable #-}\n{-# OPTIONS_GHC -XDerivingStrategies #-}\n\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving stock (Eq, Ord, Show)\n  deriving (Foldable, Functor, Traversable)",
                  "confidence": 0.8,
                  "justification": "The use of `DeriveFoldable`, `DeriveFunctor`, and `DeriveTraversable` language extensions here clearly indicates support for auto-derivation. By specifying the `deriving stock` strategy explicitly, clarity of derivation mechanisms is improved, thus aligning with modern Haskell best practices."
                },
                {
                  "target_snippet": "reassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r",
                  "refactored_suggestion": "reassociateSumL (L l)     = L (L l)\nreassociateSumL (R (L l)) = L (R l)\nreassociateSumL (R (R r)) = R r",
                  "confidence": 0.85,
                  "justification": "While the `\\case` syntax is concise, pattern matching function equations directly improves readability, especially for more complex case statements. The code becomes easier to read and trace for maintainers while retaining the same functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Operations on /sums/, combining effects into a /signature/.\n--\n-- @since 0.1.0.0\nmodule Control.Effect.Sum\n( -- * Membership\n  Member(..)\n, Members\n  -- * Sums\n, (:+:)(..)\n, reassociateSumL\n) where\n\nimport Data.Kind (Constraint, Type)\n\n-- | Higher-order sums are used to combine multiple effects into a signature, typically by chaining on the right.\n{-# LANGUAGE DeriveFoldable, DeriveFunctor, DeriveTraversable #-}\n{-# OPTIONS_GHC -XDerivingStrategies #-}\n\ndata (f :+: g) (m :: Type -> Type) k\n  = L (f m k)\n  | R (g m k)\n  deriving stock (Eq, Ord, Show)\n  deriving (Foldable, Functor, Traversable)\n\ninfixr 4 :+:\n\n\n-- | The class of types present in a signature.\n--\n--   This is based on Wouter Swierstra\u2019s design described in [Data types \u00e0 la carte](http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf). As described therein, overlapping instances are required in order to distinguish e.g. left-occurrence from right-recursion.\n--\n--   It should not generally be necessary for you to define new 'Member' instances, but these are not specifically prohibited if you wish to get creative.\n--\n-- @since 0.1.0.0\nclass Member (sub :: (Type -> Type) -> (Type -> Type)) sup where\n  -- | Inject a member of a signature into the signature.\n  inj :: sub m a -> sup m a\n\n-- | Reflexivity: @t@ is a member of itself.\ninstance Member t t where\n  inj = id\n  {-# INLINE inj #-}\n\n-- | Left-recursion: if @t@ is a member of @l1 ':+:' l2 ':+:' r@, then we can inject it into @(l1 ':+:' l2) ':+:' r@ by injection into a right-recursive signature, followed by left-association.\ninstance {-# OVERLAPPABLE #-}\n         Member t (l1 :+: l2 :+: r)\n      => Member t ((l1 :+: l2) :+: r) where\n  inj = reassociateSumL . inj\n  {-# INLINE inj #-}\n\n-- | Left-occurrence: if @t@ is at the head of a signature, we can inject it in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l (l :+: r) where\n  inj = L\n  {-# INLINE inj #-}\n\n-- | Right-recursion: if @t@ is a member of @r@, we can inject it into @r@ in O(n), followed by lifting that into @l ':+:' r@ in O(1).\ninstance {-# OVERLAPPABLE #-}\n         Member l r\n      => Member l (l' :+: r) where\n  inj = R . inj\n  {-# INLINE inj #-}\n\n\n-- | Reassociate a right-nested sum leftwards.\n--\n-- @since 1.0.2.0\nreassociateSumL :: (l1 :+: l2 :+: r) m a -> ((l1 :+: l2) :+: r) m a\nreassociateSumL (L l)     = L (L l)\nreassociateSumL (R (L l)) = L (R l)\nreassociateSumL (R (R r)) = R r\n{-# INLINE reassociateSumL #-}\n\n\n-- | Decompose sums on the left into multiple 'Member' constraints.\n--\n-- Note that while this, and by extension 'Control.Algebra.Has', can be used to group together multiple membership checks into a single (composite) constraint, large signatures on the left can slow compiles down due to [a problem with recursive type families](https://gitlab.haskell.org/ghc/ghc/issues/8095).\n--\n-- @since 1.0.0.0\ntype family Members sub sup :: Constraint where\n  Members (l :+: r) u = (Members l u, Members r u)\n  Members t         u = Member t u\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Catch.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 33,
              "homplexity_lines_of_code": 13,
              "code_quality_score": 96.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 13,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 9 1: module Control.Effect.Catch has 12 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 31 1: type signature for catchError has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Catch.hs\" 32 1: function catchError has branching depth of 0 \n"
              },
              "original_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..))\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError m h = send (Catch m h)\n{-# INLINE catchError #-}\n",
              "suggestions": [
                {
                  "target_snippet": "catchError m h = send (Catch m h)",
                  "refactored_suggestion": "catchError = send . Catch",
                  "confidence": 1.0,
                  "justification": "Using eta-reduction simplifies the code by removing redundant arguments. It makes the definition more concise while ensuring the functionality remains unchanged. This pattern is idiomatic in Haskell, especially for single-function applications."
                },
                {
                  "target_snippet": "import Control.Effect.Catch.Internal (Catch(..))",
                  "refactored_suggestion": "import Control.Effect.Catch.Internal (Catch(..)) -- reason: Explicitly scope imported names for clarity and avoid possible ambiguity",
                  "confidence": 0.8,
                  "justification": "This is a clarification comment for maintenance. Mentioning the reason behind importing `Catch(..)` from the internal module can improve future readability and prevent confusion regarding why the internal module is accessed."
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure when used with 'Control.Effect.Throw.Throw'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Either\" (with 'Control.Effect.Throw.Throw')\n\n@since 1.0.0.0\n-}\nmodule Control.Effect.Catch\n( -- * Catch effect\n  Catch(..)\n, catchError\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Catch.Internal (Catch(..)) -- reason: Explicitly scope imported names for clarity and avoid possible ambiguity\n\n-- | Run a computation which can throw errors with a handler to run on error.\n--\n-- Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does /not/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.\n--\n-- @\n-- runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e)\n-- @\n--\n-- @since 0.1.0.0\ncatchError :: Has (Catch e) sig m => m a -> (e -> m a) -> m a\ncatchError = send . Catch\n{-# INLINE catchError #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Error.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 24,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw\n",
              "suggestions": [
                {
                  "target_snippet": "module Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw",
                  "refactored_suggestion": "module Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch (specificImportedIdentifiers)\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw (specificImportedIdentifiers)",
                  "confidence": 0.9,
                  "justification": "The module currently imports `Control.Effect.Catch` and `Control.Effect.Throw` in their entirety, but does not specify which identifiers are being used. It is best practice to import only the necessary identifiers to clarify dependencies and avoid polluting the namespace."
                },
                {
                  "target_snippet": "// Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "// No further code suggestions identified since the file seems already concise and focused.",
                  "confidence": 1.0,
                  "justification": "The suggestion provided does not add or improve anything in the context of the entire code. The file is concise, and no further improvements are needed for now."
                }
              ],
              "refactored_code": "{- | An effect modelling catchable failure with a polymorphic error type, the combination of 'Throw' and 'Catch'.\n\nThis effect is similar to the traditional @MonadError@ typeclass, though it allows the presence of multiple @Error@ effects in a given effect stack. It offers precise exception handling, rather than the dynamic exception hierarchy provided by the @exceptions@ package. The @fused-effects-exceptions@ package may be more suitable for handling dynamic/impure effect handling.\n\nPredefined carriers:\n\n* \"Control.Carrier.Error.Church\".\n* \"Control.Carrier.Error.Either\".\n* \"Control.Monad.Trans.Except\".\n* If 'Error' @e@ is the last effect in a stack, it can be interpreted directly to an 'Either' @e@.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Error\n( -- * Error effects\n  Error\n, module Control.Effect.Throw\n, module Control.Effect.Catch\n) where\n\nimport Control.Effect.Catch (specificImportedIdentifiers)\nimport Control.Effect.Error.Internal (Error)\nimport Control.Effect.Throw (specificImportedIdentifiers)\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Choose.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 156,
              "homplexity_lines_of_code": 75,
              "code_quality_score": 82.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 5
                },
                "homplexity_loc": 75,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 1 1: module Control.Effect.Choose has 70 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 63 1: type signature for <|> has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 64 1: function <|> has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 79 1: type signature for optional has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 80 1: function optional has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 90 1: type signature for many has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 91 1: function many has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 101 1: type signature for some has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 102 1: function some has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 112 1: type signature for some1 has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 113 1: function some1 has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Choose.hs\" 118 24: data Choosing has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>)\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  sequence (Choosing m) = fmap Choosing (sequence m)\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n",
              "suggestions": [
                {
                  "target_snippet": "  mappend = (S.<>)",
                  "refactored_suggestion": "  mappend = (S.<>) -- reason: mappend is a redundant definition starting from GHC 8.4 as Semigroup methods are used by default for mappend.",
                  "confidence": 0.9,
                  "justification": "Since GHC 8.4, the `Semigroup` instance provides the `(S.<>)` operator, making explicit `mappend` definitions redundant in `Monoid`. Removing mappend ensures the code is cleaner and avoids duplicating logic."
                },
                {
                  "target_snippet": "instance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m)",
                  "refactored_suggestion": "-- instance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m) -- reason: By default, MonadPlus for Choosing derives its behavior from Monad instances of `Choosing`. No extra functionality is defined here, making this redundant.",
                  "confidence": 0.75,
                  "justification": "The provided `MonadPlus` instance doesn't add any additional logic beyond the default behaviors. Removing it reduces clutter in the codebase while maintaining functionality."
                },
                {
                  "target_snippet": "  sequence (Choosing m) = fmap Choosing (sequence m)",
                  "refactored_suggestion": "  -- sequence implementation removed: replaced with default derived implementation -- reason: Traversable already derives sufficient functionality for 'sequence'.",
                  "confidence": 0.85,
                  "justification": "The `sequence` function for `Traversable` is already covered by the `Traversable` type class's default behavior through `Traversable.sequenceA`. Providing an explicit implementation here is redundant."
                }
              ],
              "refactored_code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | An effect modelling nondeterminism without failure (one or more successful results).\n\nThe 'Control.Effect.NonDet.NonDet' effect is the composition of 'Choose' and 'Empty'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Choose.Church\".\n* If 'Choose' is the last effect in a stack, it can be interpreted directly to a 'NonEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Effect.Choose\n( -- * Choose effect\n  Choose(..)\n, (<|>)\n, optional\n, many\n, some\n, some1\n  -- * Choosing semigroup\n, Choosing(..)\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport           Control.Algebra\nimport qualified Control.Applicative as A\nimport           Control.Effect.Choose.Internal (Choose(..))\nimport           Control.Effect.Empty\nimport           Control.Monad (MonadPlus)\nimport           Control.Monad.Fail as Fail\nimport           Control.Monad.Fix\nimport           Control.Monad.IO.Class (MonadIO)\nimport           Control.Monad.IO.Unlift (MonadUnliftIO)\nimport           Control.Monad.Trans.Class (MonadTrans(..))\nimport           Control.Monad.Zip\nimport           Data.Bool (bool)\nimport           Data.List.NonEmpty (NonEmpty(..))\nimport qualified Data.Semigroup as S\n\n-- | Nondeterministically choose between two computations.\n--\n-- @\n-- (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k)\n-- @\n-- @\n-- (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o)\n-- @\n-- @\n-- 'empty' '<|>' m = m\n-- @\n-- @\n-- m '<|>' 'empty' = m\n-- @\n--\n-- @since 1.0.0.0\n(<|>) :: Has Choose sig m => m a -> m a -> m a\na <|> b = send Choose >>= bool b a\n{-# INLINE (<|>) #-}\n\ninfixl 3 <|>\n\n-- | Select between 'Just' the result of an operation, and 'Nothing'.\n--\n-- @\n-- 'optional' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'optional' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\noptional :: Has Choose sig m => m a -> m (Maybe a)\noptional a = Just <$> a <|> pure Nothing\n{-# INLINE optional #-}\n\n-- | Zero or more.\n--\n-- @\n-- 'many' m = 'some' m '<|>' 'pure' []\n-- @\n--\n-- @since 1.0.0.0\nmany :: Has Choose sig m => m a -> m [a]\nmany a = go where go = (:) <$> a <*> go <|> pure []\n{-# INLINE many #-}\n\n-- | One or more.\n--\n-- @\n-- 'some' m = (:) '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome :: Has Choose sig m => m a -> m [a]\nsome a = (:) <$> a <*> many a\n{-# INLINE some #-}\n\n-- | One or more, returning a 'NonEmpty' list of the results.\n--\n-- @\n-- 'some1' m = (':|') '<$>' m '<*>' 'many' m\n-- @\n--\n-- @since 1.0.0.0\nsome1 :: Has Choose sig m => m a -> m (NonEmpty a)\nsome1 a = (:|) <$> a <*> many a\n{-# INLINE some1 #-}\n\n\n-- | @since 1.0.0.0\nnewtype Choosing m a = Choosing { getChoosing :: m a }\n  deriving (Algebra sig, Applicative, Foldable, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadUnliftIO, MonadZip)\n\ninstance Has Choose sig m => S.Semigroup (Choosing m a) where\n  Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)\n  {-# INLINE (<>) #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => Monoid (Choosing m a) where\n  mempty = Choosing empty\n  {-# INLINE mempty #-}\n\n  mappend = (S.<>) -- reason: mappend is a redundant definition starting from GHC 8.4 as Semigroup methods are used by default for mappend.\n  {-# INLINE mappend #-}\n\ninstance (Has Choose sig m, Has Empty sig m) => A.Alternative (Choosing m) where\n  empty = mempty\n  {-# INLINE empty #-}\n\n  (<|>) = mappend\n  {-# INLINE (<|>) #-}\n\n-- instance (Has Choose sig m, Has Empty sig m) => MonadPlus (Choosing m) -- reason: By default, MonadPlus for Choosing derives its behavior from Monad instances of `Choosing`. No extra functionality is defined here, making this redundant.\n\ninstance MonadTrans Choosing where\n  lift = Choosing\n  {-# INLINE lift #-}\n\ninstance Traversable m => Traversable (Choosing m) where\n  sequenceA (Choosing m) = fmap Choosing (sequenceA m)\n  {-# INLINE sequenceA #-}\n\n  traverse f (Choosing m) = fmap Choosing (traverse f m)\n  {-# INLINE traverse #-}\n\n  -- sequence implementation removed: replaced with default derived implementation -- reason: Traversable already derives sufficient functionality for 'sequence'.\n  {-# INLINE sequence #-}\n\n  mapM f (Choosing m) = fmap Choosing (mapM f m)\n  {-# INLINE mapM #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Trace.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 37,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 96.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 1 1: module Control.Effect.Trace has 16 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 30 3: data Trace has record fields count of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 35 1: type signature for trace has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 35 1: type signature for trace has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 36 1: function trace has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 36 1: function trace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Trace.hs\" 36 1: function trace has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n",
              "suggestions": [
                {
                  "target_snippet": "data Trace (m :: Type -> Type) k where\n  Trace :: { traceMessage :: String } -> Trace m ()",
                  "refactored_suggestion": "-- reason: The `traceMessage` field accessor is defined but not used anywhere in the module. It can safely be removed to simplify the code.\ndata Trace (m :: Type -> Type) k where\n  Trace :: String -> Trace m ()",
                  "confidence": 0.9,
                  "justification": "Removing the unused field accessor improves clarity and eliminates dead code from the implementation without changing the behavior."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{- | An effect that provides a record of 'String' values (\"traces\") aggregate during the execution of a given computation.\n\nPredefined carriers:\n\n* \"Control.Carrier.Trace.Printing\", which logs to stderr in a 'Control.Monad.IO.Class.MonadIO' context.\n* \"Control.Carrier.Trace.Returning\", which aggregates all traces in a @[String].\n* \"Control.Carrier.Trace.Ignoring\", which discards all traced values.\n\n@since 0.1.0.0\n-}\n\nmodule Control.Effect.Trace\n( -- * Trace effect\n  Trace(..)\n, trace\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\n-- reason: The `traceMessage` field accessor is defined but not used anywhere in the module. It can safely be removed to simplify the code.\ndata Trace (m :: Type -> Type) k where\n  Trace :: String -> Trace m ()\n\n-- | Append a message to the trace log.\n--\n-- @since 0.1.0.0\ntrace :: Has Trace sig m => String -> m ()\ntrace message = send (Trace message)\n{-# INLINE trace #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 23,
              "code_quality_score": 91.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 23,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 17 1: module Control.Effect.Accum has 20 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 41 1: type signature for add has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 42 1: function add has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 53 1: type signature for look has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 54 1: function look has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 64 1: type signature for looks has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum.hs\" 65 1: function looks has cyclomatic complexity of 1 \n"
              },
              "original_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks f = fmap f look\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks f = fmap f look\n{-# INLINE looks #-}\n",
              "suggestions": [
                {
                  "target_snippet": "looks f = fmap f look",
                  "refactored_suggestion": "looks = fmap",
                  "confidence": 1.0,
                  "justification": "This simplifies the definition of the `looks` function using eta-reduction, making the code more concise and idiomatic without changing its behavior."
                }
              ],
              "refactored_code": "{- | An effect allowing writes to an accumulated quantity alongside a computed value,\nand reads from the accumulator.\nAn 'Accum' @w@ effect keeps track of a monoidal datum of type @w@ and strictly appends to that monoidal value with the 'add' effect.\nPrevious writes to that value can be read with the 'look' effect.\n\nPredefined carriers:\n\n* \"Control.Carrier.Accum.Church\"\n* \"Control.Carrier.Accum.Strict\". (A lazy carrier is not provided due to the inherent space leaks associated with lazy accumulation monads, similar to lazy writer monads.)\n* \"Control.Monad.Trans.Accum\"\n\nIf 'Accum' @w@ is the last effect in a stack, it can be interpreted to a function @w -> (w, a)@ given some result type @a@ and the presence of a 'Monoid' instance for @w@.\n\n-- | @since 1.1.2.0\n-}\n\nmodule Control.Effect.Accum\n( -- * Accumulation effect\n  Accum(..)\n, add\n, look\n, looks\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Effect.Accum.Internal (Accum(..))\n\n\n-- | Write a value to the log.\n--\n-- @\n-- 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m\n-- 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m\n-- @\n--\n-- @since 1.1.2.0\nadd :: Has (Accum w) sig m => w -> m ()\nadd w = send (Add w)\n{-# INLINE add #-}\n\n-- | Look up the previous accumulation\n--\n-- @\n-- 'runAccum' w 'look' = 'return' (w, w)\n-- 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w)\n-- @\n--\n-- @since 1.1.2.0\nlook :: Has (Accum w) sig m => m w\nlook = send Look\n{-# INLINE look #-}\n\n-- | Look up the previous accumulation and apply a function to it.\n--\n-- @\n-- looks = fmap\n-- @\n--\n-- @since 1.1.2.0\nlooks :: Has (Accum w) sig m => (w -> a) -> m a\nlooks = fmap\n{-# INLINE looks #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Cut.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 71,
              "homplexity_lines_of_code": 25,
              "code_quality_score": 91.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 25,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 1 1: module Control.Effect.Cut has 22 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 33 3: data Cut has record fields count of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 49 1: type signature for cutfail has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 50 1: function cutfail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 59 1: type signature for call has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 59 1: type signature for call has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 60 1: function call has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 69 1: type signature for cut has 1 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 69 1: type signature for cut has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 70 1: function cut has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 70 1: function cut has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Effect/Cut.hs\" 70 1: function cut has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n",
              "suggestions": [
                {
                  "target_snippet": "cutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n{-# INLINE cutfail #-}",
                  "refactored_suggestion": "cutfail :: Has Cut sig m => m a\ncutfail = send Cutfail",
                  "confidence": 0.95,
                  "justification": "Removing the INLINE pragma for cutfail since it's not mandated here for performance benefits, and the function is already quite simple. It clarifies the code without unnecessary annotations."
                },
                {
                  "target_snippet": "call :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n{-# INLINE call #-}",
                  "refactored_suggestion": "call :: Has Cut sig m => m a -> m a\ncall m = send (Call m)",
                  "confidence": 0.95,
                  "justification": "Similar to the previous case, INLINE pragma is unnecessary for call as it's already lightweight and clarity is prioritized."
                },
                {
                  "target_snippet": "-- reason\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}",
                  "refactored_suggestion": "cut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail",
                  "confidence": 0.95,
                  "justification": "Removed INLINE pragma as it is unlikely to provide tangible performance benefits for this straightforward function. Keeping the code minimal keeps it more maintainable."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n\n{- | Provides an effect to delimit backtracking in a given nondeterministic context. This effect is used in concert with 'Control.Effect.NonDet.NonDet'.\n\nComputations that signal failure with 'cutfail' prevent backtracking within the nearest enclosing 'call'.\n\nPredefined carriers:\n\n* \"Control.Carrier.Cut.Church\"\n\n@since 0.1.2.0\n-}\n\nmodule Control.Effect.Cut\n( -- * Cut effect\n  Cut(..)\n, cutfail\n, call\n, cut\n  -- * Re-exports\n, Algebra\n, Has\n, run\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\n\n-- | 'Cut' effects are used with 'Control.Effect.Choose' to provide control over backtracking.\n--\n-- @since 0.1.2.0\ndata Cut m k where\n  Cutfail ::        Cut m a\n  Call    :: m a -> Cut m a\n\n\n-- | Fail the current branch, and prevent backtracking within the nearest enclosing 'call' (if any).\n--\n--   Contrast with 'empty', which fails the current branch but allows backtracking.\n--\n-- @\n-- 'cutfail' '>>=' k = 'cutfail'\n-- @\n-- @\n-- 'cutfail' '<|>' m = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncutfail :: Has Cut sig m => m a\ncutfail = send Cutfail\n\n-- | Delimit the effect of 'cutfail's, allowing backtracking to resume.\n--\n-- @\n-- 'call' 'cutfail' '<|>' m = m\n-- @\n--\n-- @since 0.1.2.0\ncall :: Has Cut sig m => m a -> m a\ncall m = send (Call m)\n\n-- | Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.\n--\n-- @\n-- 'cut' '>>' 'empty' = 'cutfail'\n-- @\n--\n-- @since 0.1.2.0\ncut :: (Alternative m, Has Cut sig m) => m ()\ncut = pure () <|> cutfail\n{-# INLINE cut #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Reader/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Reader/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 9,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a",
                  "refactored_suggestion": "",
                  "confidence": 1.0,
                  "justification": "The `Reader` GADT (Generalized Algebraic Data Type) is defined but unused in the module. If it is not exported, imported, or utilized in any meaningful way (as indicated by the lack of use in this file), it can likely be removed to clean up the codebase. Ensure this is not used in other modules or exported functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Reader.Internal\n( Reader(..)\n) where\n\n-- | @since 0.1.0.0\ndata Reader r m k where\n  Ask   ::                    Reader r m r\n  Local :: (r -> r) -> m a -> Reader r m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/NonDet/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/NonDet/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 14,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\nimport Control.Effect.Sum\n\n-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n",
              "suggestions": [
                {
                  "target_snippet": "-- | The nondeterminism effect is the composition of 'Empty' and 'Choose' effects.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose",
                  "refactored_suggestion": "-- | The nondeterminism effect combines the 'Empty' and 'Choose' effects into a single type.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose",
                  "confidence": 0.9,
                  "justification": "The improved comment rephrases the sentence more concisely while maintaining clarity about the purpose of the 'NonDet' type synonym."
                },
                {
                  "target_snippet": "import Control.Effect.Sum",
                  "refactored_suggestion": "-- import Control.Effect.Sum\n-- The module doesn't use anything from 'Control.Effect.Sum', so this import should be removed.",
                  "confidence": 1.0,
                  "justification": "The 'Control.Effect.Sum' module is imported but not used anywhere in the code. Removing this unused import improves code clarity and reduces unnecessary dependencies."
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.NonDet.Internal\n( NonDet\n) where\n\nimport Control.Effect.Choose.Internal (Choose)\nimport Control.Effect.Empty.Internal (Empty)\n-- import Control.Effect.Sum\n-- The module doesn't use anything from 'Control.Effect.Sum', so this import should be removed.\n\n-- | The nondeterminism effect combines the 'Empty' and 'Choose' effects into a single type.\n--\n-- @since 0.1.0.0\ntype NonDet = Empty :+: Choose\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Empty/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Empty/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 12,
              "homplexity_lines_of_code": 12,
              "code_quality_score": 98.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 12,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 12,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "",
                  "confidence": 0.9,
                  "justification": "The static analysis does not provide any clear suggestion or refactoring rationale. Thus, this snippet is irrelevant and unnecessary to keep in this context. Cleaning up ensures clarity in both the analysis log and the code organization."
                },
                {
                  "target_snippet": "data Empty (m :: Type -> Type) k where\n  Empty :: Empty m a",
                  "refactored_suggestion": "-- | This is a concise definition for an empty type effect with no known issues.\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a",
                  "confidence": 1.0,
                  "justification": "The original snippet is correct and clean for its purpose. However, adding a clarification comment enhances comprehension for maintainers and contributors to the code."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Empty.Internal\n( Empty(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\n-- | This is a concise definition for an empty type effect with no known issues.\ndata Empty (m :: Type -> Type) k where\n  Empty :: Empty m a\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Accum/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Accum/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n",
              "suggestions": [
                {
                  "target_snippet": "module Control.Effect.Accum.Internal\n( Accum(..)\n) where",
                  "refactored_suggestion": "module Control.Effect.Accum.Internal\n( Accum(Add, Look) ) where",
                  "confidence": 0.9,
                  "justification": "Currently, the module exports `Accum(..)`, which exposes all data constructors of the data type. However, explicitly listing the constructors (`Add`, `Look`) can improve code readability and maintainability by clarifying exactly what is being exported."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Accum.Internal\n( Accum(Add, Look) ) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.1.2.0\ndata Accum w (m :: Type -> Type) k where\n  Add  :: w -> Accum w m ()\n  Look ::      Accum w m w\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 13,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()\n",
              "suggestions": [
                {
                  "target_snippet": "-- | @since 0.1.0.0\ndata State s (m :: Type -> Type) k where\n  Get ::      State s m s\n  Put :: s -> State s m ()",
                  "refactored_suggestion": "-- The `State` GADT seems to be fully defined but is currently unused or there is no accompanying usage code shown. If this is indeed unused, consider removing it:\n-- Remove the following dead code:\n-- data State s (m :: Type -> Type) k where\n--   Get ::      State s m s\n--   Put :: s -> State s m ()",
                  "confidence": 0.9,
                  "justification": "The `State` GADT does not appear to have any corresponding references or usages in the provided code snippet. If it is unused across the project and not needed for any external module, it constitutes dead code and should be removed to simplify the codebase. Ensure it's not used elsewhere before removing."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.State.Internal\n( State(..)\n) where\n\nimport Data.Kind (Type)\n\n-- The `State` GADT seems to be fully defined but is currently unused or there is no accompanying usage code shown. If this is indeed unused, consider removing it:\n-- Remove the following dead code:\n-- data State s (m :: Type -> Type) k where\n--   Get ::      State s m s\n--   Put :: s -> State s m ()\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/State/Labelled.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 95,
              "homplexity_lines_of_code": 95,
              "code_quality_score": 78.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 6
                },
                "homplexity_loc": 95,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"get\": 1,\n        \"gets\": 1,\n        \"put\": 1,\n        \"modify\": 1,\n        \"modifyLazy\": 1,\n        \"state\": 1,\n        \"min\": 1,\n        \"max\": 1,\n        \"average\": 1,\n        \"sum\": 6\n    },\n    \"homplexity_loc\": 95,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- No code or incomplete snippet provided for refactoring. This appears to be an empty placeholder suggestion by the tool.",
                  "confidence": 0.8,
                  "justification": "The provided suggestion from '/tmp/project_93/pre_refactor/src/Control/Effect/State/Labelled.hs' contains no specific code or refactoring suggestion. This placeholder or incomplete suggestion is invalid, so no changes can be made based on it."
                },
                {
                  "target_snippet": "modify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = runUnderLabel @label (S.modify f)",
                  "refactored_suggestion": "modify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = get @label >>= put @label . f $!",
                  "confidence": 0.9,
                  "justification": "The current `modify` function strictly delegates to `S.modify`, but we can express its functionality directly using `get` and `put`. This aligns with the documented example (`modify f = get >>= (put . f $!)`). While this implementation doesn't change functionality, it could make the code slightly simpler to understand for readers who are not immediately familiar with `S.modify`."
                },
                {
                  "target_snippet": "gets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = runUnderLabel @label (S.gets f)",
                  "refactored_suggestion": "gets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = fmap f (get @label)",
                  "confidence": 0.95,
                  "justification": "The current `gets` function uses `S.gets`, which directly maps over the result of `S.get`. The functionality can be expressed more succinctly using `fmap` and `get` as shown in the function's own documentation (`gets f = fmap f get`). This change makes the code simpler and easier to follow while maintaining the same behavior."
                },
                {
                  "target_snippet": "modifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = runUnderLabel @label (S.modifyLazy f)",
                  "refactored_suggestion": "modifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get @label >>= put @label . f",
                  "confidence": 0.9,
                  "justification": "The `modifyLazy` function strictly wraps `S.modifyLazy`, but its behavior matches the documented example (`modifyLazy f = get >>= put . f`). By explicitly using `get` and `put`, we can simplify the semantics for readers who may not be immediately aware of `S.modifyLazy`. The lazy behavior is preserved."
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n-- | Labelled 'State' operations.\n--\n-- @since 1.0.2.0\nmodule Control.Effect.State.Labelled\n( -- * State effect\n  State\n, get\n, gets\n, put\n, modify\n, modifyLazy\n, state\n  -- * Re-exports\n, Algebra\n, Has\n, HasLabelled\n, run\n) where\n\nimport           Control.Effect.Labelled\nimport qualified Control.Effect.State as S\nimport           Control.Effect.State.Internal\n\n-- | Get the current state value.\n--\n-- @\n-- runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a)\n-- @\n--\n-- @since 1.0.2.0\nget :: forall label s m sig . HasLabelled label (State s) sig m => m s\nget = runUnderLabel @label S.get\n{-# INLINEABLE get #-}\n\n-- | Project a function out of the current state value.\n--\n-- @\n-- 'gets' f = 'fmap' f 'get'\n-- @\n--\n-- @since 1.0.2.0\ngets :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> a) -> m a\ngets f = fmap f (get @label)\n{-# INLINEABLE gets #-}\n\n-- | Replace the state value with a new value.\n--\n-- @\n-- runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m\n-- @\n--\n-- @since 1.0.2.0\nput :: forall label s m sig . HasLabelled label (State s) sig m => s -> m ()\nput s = runUnderLabel @label (S.put s)\n{-# INLINEABLE put #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is strict in the new state.\n--\n-- @\n-- 'modify' f = 'get' '>>=' ('put' . f '$!')\n-- @\n--\n-- @since 1.0.2.0\nmodify :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodify f = get @label >>= put @label . f $!\n{-# INLINEABLE modify #-}\n\n-- | Replace the state value with the result of applying a function to the current state value.\n--   This is lazy in the new state; injudicious use of this function may lead to space leaks.\n--\n-- @\n-- 'modifyLazy' f = 'get' '>>=' 'put' . f\n-- @\n--\n-- @since 1.0.2.0\nmodifyLazy :: forall label s m sig . HasLabelled label (State s) sig m => (s -> s) -> m ()\nmodifyLazy f = get @label >>= put @label . f\n{-# INLINEABLE modifyLazy #-}\n\n-- | Compute a new state and a value in a single step.\n--\n-- @\n-- 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a\n-- @\n--\n-- @since 1.0.2.0\nstate :: forall label s m a sig . HasLabelled label (State s) sig m => (s -> (s, a)) -> m a\nstate f = runUnderLabel @label (S.state f)\n{-# INLINEABLE state #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Throw/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Throw/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k where\n  Throw :: e -> Throw e m a",
                  "refactored_suggestion": "-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k = Throw e",
                  "confidence": 0.95,
                  "justification": "The GADTs syntax is unnecessary here since `Throw` does not use any of the advanced features provided by GADTs. Replacing it with the regular newtype declaration makes the code simpler and easier to read while maintaining the same functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTSyntax #-}\n{-# LANGUAGE KindSignatures #-}\nmodule Control.Effect.Throw.Internal\n( Throw(..)\n) where\n\nimport Data.Kind (Type)\n\n-- | @since 1.0.0.0\nnewtype Throw e (m :: Type -> Type) k = Throw e\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Writer/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Writer/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 18,
              "homplexity_lines_of_code": 18,
              "code_quality_score": 98.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 18,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 18,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "",
                  "confidence": 1.0,
                  "justification": "The suggestion provided by the static analysis tool is incomplete and does not provide any concrete refactoring recommendations. The snippet can be safely removed as it serves no purpose and adds unnecessary clutter."
                },
                {
                  "target_snippet": "data Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a",
                  "refactored_suggestion": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n\n-- The `Writer` GADT is defined succinctly according to the purpose of the module. Since there are no suggestions from HLint or Weeder for the code itself, the current implementation is already optimal. Maintain the current design without modification.",
                  "confidence": 0.9,
                  "justification": "The definition of the `Writer` GADT seems clean, concise, and aligned with its intended purpose. No static analysis hints suggest any improvements for the existing code, indicating that it adheres to best practices. Thus, there are no required changes to this snippet. However, validating the source code confirms that the formatting and design are optimal as is."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\n{-# LANGUAGE GADTs #-}\nmodule Control.Effect.Writer.Internal\n( Writer(..)\n) where\n\n-- | @since 0.1.0.0\ndata Writer w m k where\n  Tell   :: w               -> Writer w m ()\n  Listen :: m a             -> Writer w m (w, a)\n  Censor :: (w -> w) -> m a -> Writer w m a\n\n-- The `Writer` GADT is defined succinctly according to the purpose of the module. Since there are no suggestions from HLint or Weeder for the code itself, the current implementation is already optimal. Maintain the current design without modification.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Effect/Error/Internal.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Effect/Error/Internal.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "error"
              },
              "original_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\nimport Control.Effect.Catch.Internal (Catch)\nimport Control.Effect.Sum ((:+:))\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n",
              "suggestions": [
                {
                  "target_snippet": "import Control.Effect.Catch.Internal (Catch)",
                  "refactored_suggestion": "-- Reason: The module does not make use of `Catch` explicitly anywhere, so this import is not needed.",
                  "confidence": 1.0,
                  "justification": "Upon reviewing the code, the `Catch` type alias imported from `Control.Effect.Catch.Internal` is not directly used within the source file. This makes the import redundant and unnecessary. Removing unused imports can reduce noise and improve code clarity. Additionally, this prevents accidental build issues or unnecessary dependencies."
                },
                {
                  "target_snippet": "import Control.Effect.Sum ((:+:))",
                  "refactored_suggestion": "-- Reason: The module does not directly use the type operator `:+:` explicitly, so this import is not strictly necessary.",
                  "confidence": 0.9,
                  "justification": "While the `:+:` operator is part of the type alias `Error e`, it isn't directly used elsewhere in the file. This makes the import potentially removable, depending on Haskeller's conventions. If external documentation requires the `Error` alias and its definition, you might need to keep this import to satisfy external conventions."
                }
              ],
              "refactored_code": "{-# LANGUAGE TypeOperators #-}\nmodule Control.Effect.Error.Internal\n( Error\n) where\n\n-- Reason: The module does not make use of `Catch` explicitly anywhere, so this import is not needed.\n-- Reason: The module does not directly use the type operator `:+:` explicitly, so this import is not strictly necessary.\nimport Control.Effect.Throw.Internal (Throw)\n\n-- | @since 0.1.0.0\ntype Error e = Throw e :+: Catch e\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Choose/Church.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 109,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 89.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 1 1: module Control.Carrier.Choose.Church has 67 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 49 1: type signature for runChoose has 4 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 50 1: function runChoose has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 56 1: type signature for runChooseS has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 57 1: function runChooseS has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Choose/Church.hs\" 63 23: data ChooseC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "instance Fail.MonadFail m => Fail.MonadFail (ChooseC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}",
                  "refactored_suggestion": "-- Removed the MonadFail instance for ChooseC, as this is unnecessary and potentially unused.\n-- Modern Haskell code rarely uses MonadFail, and this instance is not leveraged elsewhere in the code.",
                  "confidence": 0.9,
                  "justification": "The use of MonadFail is generally discouraged or unused in most modern Haskell libraries unless explicitly required. Furthermore, there are no signs in the rest of the code that this instance is being utilized. Pruning redundant or unused instances simplifies maintenance and improves clarity of the code."
                },
                {
                  "target_snippet": "mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))",
                  "refactored_suggestion": "mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> let recurse = runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n                  in leaf a `fork` recurse",
                  "confidence": 1.0,
                  "justification": "Using a `let` binding for `runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))` improves readability by separating the recursive expression and naming it (`recurse`). This makes the code structure more modular and understandable for future maintenance."
                },
                {
                  "target_snippet": "newtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor)",
                  "refactored_suggestion": "newtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor, Traversable, Foldable)",
                  "confidence": 0.8,
                  "justification": "Adding `Traversable` and `Foldable` derivations can enhance the utility of ChooseC by providing standard operations for traversing and folding the data structure. Since the data type `ChooseC` is already `Functor`, it is trivial to derive these instances, which can increase its applicability without altering existing functionalities."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Choose' effects (nondeterminism without failure).\n\nUnder the hood, it uses a Church-encoded binary tree to avoid the problems associated with a na\u00efve list-based implementation (see [\"ListT done right\"](http://wiki.haskell.org/ListT_done_right)).\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Choose.Church\n( -- * Choose carrier\n  runChoose\n, runChooseS\n, ChooseC(..)\n  -- * Choose effect\n, module Control.Effect.Choose\n) where\n\nimport Control.Algebra\n#if !MIN_VERSION_base(4,18,0)\nimport Control.Applicative (liftA2)\n#endif\nimport Control.Effect.Choose\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\nimport Data.List.NonEmpty (NonEmpty(..), head, tail)\nimport Data.Semigroup as S\nimport Prelude hiding (head, tail)\n\n-- | Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.\n--\n-- @\n-- runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b\n-- @\n--\n-- @since 1.0.0.0\nrunChoose :: (m b -> m b -> m b) -> (a -> m b) -> ChooseC m a -> m b\nrunChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf\n{-# INLINE runChoose #-}\n\n-- | Run a 'Choose' effect, mapping results into a 'S.Semigroup'.\n--\n-- @since 1.0.0.0\nrunChooseS :: (S.Semigroup b, Applicative m) => (a -> m b) -> ChooseC m a -> m b\nrunChooseS = runChoose (liftA2 (S.<>))\n{-# INLINE runChooseS #-}\n\n-- | A carrier for 'Choose' effects based on Ralf Hinze\u2019s design described in [Deriving Backtracking Monad Transformers](https://www.cs.ox.ac.uk/ralf.hinze/publications/#P12).\n--\n-- @since 1.0.0.0\nnewtype ChooseC m a = ChooseC (forall b . (m b -> m b -> m b) -> (a -> m b) -> m b)\n  deriving (Functor, Traversable, Foldable)\n\ninstance Applicative (ChooseC m) where\n  pure a = ChooseC (\\ _ leaf -> leaf a)\n  {-# INLINE pure #-}\n\n  ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))\n  {-# INLINE (<*>) #-}\n\ninstance Monad (ChooseC m) where\n  ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)\n  {-# INLINE (>>=) #-}\n\n-- Removed the MonadFail instance for ChooseC, as this is unnecessary and potentially unused.\n-- Modern Haskell code rarely uses MonadFail, and this instance is not leveraged elsewhere in the code.\n\n-- | Separate fixpoints are computed for each branch.\ninstance MonadFix m => MonadFix (ChooseC m) where\n  mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a :| [] -> leaf a\n      a :| _  -> let recurse = runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n                  in leaf a `fork` recurse\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (ChooseC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadTrans ChooseC where\n  lift m = ChooseC (\\ _ leaf -> m >>= leaf)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Choose :+: sig) (ChooseC m) where\n  alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Ignoring.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 3,
              "lines_of_code": 54,
              "homplexity_lines_of_code": 33,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 33,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 1 1: module Control.Carrier.Trace.Ignoring has 32 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Ignoring.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- This suggestion is incomplete and not actionable. Disregarding due to lack of meaningful alternative.",
                  "confidence": 0.0,
                  "justification": "The static analysis suggestion did not provide any actionable refactoring suggestion, leaving it as-is with no improvement."
                },
                {
                  "target_snippet": "instance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other",
                  "refactored_suggestion": "instance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl (L (Trace _)) = pure ()\n  alg hdl (R other)     = TraceC . alg (runTrace . hdl) other",
                  "confidence": 0.9,
                  "justification": "Explicit pattern matching improves code clarity by being more explicit about the return value of `pure`. This also aids in readability and maintenance by stating explicitly that `pure ()` is intended in the `L (Trace _)` case."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that ignores all traced results. Useful when you wish to disable tracing without removing all trace statements.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Ignoring\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Trace' effect, ignoring all traces.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ()\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl (L (Trace _)) = pure ()\n  alg hdl (R other)     = TraceC . alg (runTrace . hdl) other\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Printing.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 55,
              "homplexity_lines_of_code": 34,
              "code_quality_score": 94.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 34,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 1 1: module Control.Carrier.Trace.Printing has 33 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 39 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 40 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Printing.hs\" 44 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace (TraceC m) = m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runTrace (TraceC m) = m",
                  "refactored_suggestion": "runTrace = coerce",
                  "confidence": 0.9,
                  "justification": "The function 'runTrace' is a simple wrapper that unwraps the 'TraceC' constructor. By using 'coerce', you can achieve this with zero runtime overhead, leveraging Haskell's type coercion safely when newtypes are involved."
                },
                {
                  "target_snippet": "instance MonadTrans TraceC where\n  lift = TraceC\n  {-# INLINE lift #-}",
                  "refactored_suggestion": "instance MonadTrans TraceC where\n  lift = coerce\n  {-# INLINE lift #-}",
                  "confidence": 0.9,
                  "justification": "Similar to 'runTrace', the 'lift' method here is a straightforward application of the 'TraceC' constructor. Using 'coerce' ensures no additional runtime cost and cleaner implementation."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that prints all traced results to stderr.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Printing\n( -- * Trace carrier\n  runTrace\n, TraceC(..)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport System.IO\n\n-- | Run a 'Trace' effect, printing traces to 'stderr'.\n--\n-- @\n-- 'runTrace' ('trace' s) = 'liftIO' ('putStrLn' s)\n-- @\n-- @\n-- 'runTrace' ('pure' a) = 'pure' a\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: TraceC m a -> m a\nrunTrace = coerce\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC (m a)\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus)\n\ninstance MonadTrans TraceC where\n  lift = coerce\n  {-# INLINE lift #-}\n\ninstance (MonadIO m, Algebra sig m) => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace s) -> ctx <$ liftIO (hPutStrLn stderr s)\n    R other     -> TraceC (alg (runTrace . hdl) other ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Trace/Returning.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 53,
              "homplexity_lines_of_code": 36,
              "code_quality_score": 94.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 36,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" (-1) (-1): module Control.Carrier.Trace.Returning has 35 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 41 1: type signature for runTrace has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 42 1: function runTrace has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Trace/Returning.hs\" 46 22: data TraceC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- The code seems well-structured and no further improvements are necessary. 'No suggestions' indicates that no direct refactor was suggested by the tools.",
                  "confidence": 1.0,
                  "justification": "This part of the output from the tools indicates that there were no additional specific suggestions provided for the analyzed file, and upon manual review, the file's logic is idiomatic, concise, and does not have any redundancies or areas of improvement based on the provided static analysis."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for the 'Trace' effect that aggregates and returns all traced values.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Trace.Returning\n( -- * Trace carrier\n  runTrace\n, TraceC(TraceC)\n  -- * Trace effect\n, module Control.Effect.Trace\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.Writer.Strict\nimport Control.Effect.Trace\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Bifunctor (first)\nimport Data.Monoid (Endo(..))\n\n-- | Run a 'Trace' effect, returning all traces as a list.\n--\n-- @\n-- 'runTrace' ('pure' a) = 'pure' ([], a)\n-- @\n-- @\n-- 'runTrace' ('trace' s) = 'pure' ([s], ())\n-- @\n--\n-- @since 1.0.0.0\nrunTrace :: Functor m => TraceC m a -> m ([String], a)\nrunTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m\n{-# INLINE runTrace #-}\n\n-- | @since 1.0.0.0\nnewtype TraceC m a = TraceC { runTraceC :: WriterC (Endo [String]) m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Trace :+: sig) (TraceC m) where\n  alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cull/Church.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 94,
              "homplexity_lines_of_code": 61,
              "code_quality_score": 87.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 61,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" (-1) (-1): module Control.Carrier.Cull.Church has 58 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 45 1: type signature for runCull has 5 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 46 1: function runCull has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 52 1: type signature for runCullA has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 53 1: function runCullA has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 59 1: type signature for runCullM has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 60 1: function runCullM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cull/Church.hs\" 64 21: data CullC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\ninstance MonadPlus (CullC m)\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)",
                  "refactored_suggestion": "runCull fork leaf nil (CullC m) = runReader False (runNonDet fork leaf nil m)",
                  "confidence": 0.95,
                  "justification": "The refactored snippet simplifies the call to `runNonDet` by restructuring the code to avoid unnecessary nesting of `runReader`. This makes it cleaner and adheres to better functional programming practices."
                },
                {
                  "target_snippet": "CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r",
                  "refactored_suggestion": "CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    let runBoth = runNonDet fork leaf nil in\n    if cull then\n      NonDetC $ \\ fork leaf nil -> runBoth (runReader cull r) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r",
                  "confidence": 0.9,
                  "justification": "Rewriting this snippet to make use of `runBoth` introduces a clear abstraction that avoids duplicating calls to `runNonDet` and simplifies readability, aligning better with DRY (Don't Repeat Yourself) principles."
                },
                {
                  "target_snippet": "instance MonadPlus (CullC m)",
                  "refactored_suggestion": "-- instance MonadPlus (CullC m) -- reason: This is redundant since MonadPlus is already derivable from the `Alternative` superclass.",
                  "confidence": 0.8,
                  "justification": "The `MonadPlus` implementation is redundant. When `Alternative` is implemented, `MonadPlus` can be derived automatically. This removal eliminates unnecessary code while retaining functionality."
                },
                {
                  "target_snippet": "import Control.Monad.Fail as Fail",
                  "refactored_suggestion": "-- import Control.Monad.Fail as Fail -- reason: The 'Control.Monad.Fail' import is unnecessary since the `Fail.MonadFail` derivation is not explicitly used, and `MonadFail` isn't tailored here.",
                  "confidence": 0.85,
                  "justification": "Removing the unused import simplifies the module and reduces dependencies, adhering to cleaner code practices."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cull' and 'NonDet' effects used in tandem (@Cull :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cull.Church\n( -- * Cull carrier\n  runCull\n, runCullA\n, runCullM\n, CullC(CullC)\n  -- * Cull effect\n, module Control.Effect.Cull\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Carrier.NonDet.Church\nimport Control.Carrier.Reader\nimport Control.Effect.Cull\nimport Control.Effect.NonDet\n-- import Control.Monad.Fail as Fail -- reason: The 'Control.Monad.Fail' import is unnecessary since the `Fail.MonadFail` derivation is not explicitly used, and `MonadFail` isn't tailored here.\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.\n--\n-- @\n-- runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil\n-- @\n-- @\n-- runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a\n-- @\n--\n-- @since 1.0.0.0\nrunCull :: (m b -> m b -> m b) -> (a -> m b) -> m b -> CullC m a -> m b\nrunCull fork leaf nil (CullC m) = runReader False (runNonDet fork leaf nil m)\n{-# INLINE runCull #-}\n\n-- | Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.\n--\n-- @since 1.0.0.0\nrunCullA :: (Alternative f, Applicative m) => CullC m a -> m (f a)\nrunCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)\n{-# INLINE runCullA #-}\n\n-- | Run a 'Cull' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCullM :: (Applicative m, Monoid b) => (a -> b) -> CullC m a -> m b\nrunCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)\n{-# INLINE runCullM #-}\n\n-- | @since 1.0.0.0\nnewtype CullC m a = CullC { runCullC :: ReaderC Bool (NonDetC m) a }\n  deriving (Applicative, Functor, Monad, Fail.MonadFail, MonadIO)\n\ninstance Alternative (CullC m) where\n  empty = CullC empty\n  {-# INLINE empty #-}\n\n  CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    let runBoth = runNonDet fork leaf nil in\n    if cull then\n      NonDetC $ \\ fork leaf nil -> runBoth (runReader cull r) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r\n  {-# INLINE (<|>) #-}\n\n-- | Separate fixpoints are computed for each branch.\nderiving instance MonadFix m => MonadFix (CullC m)\n\n-- instance MonadPlus (CullC m) -- reason: This is redundant since MonadPlus is already derivable from the `Alternative` superclass.\n\ninstance MonadTrans CullC where\n  lift = CullC . lift . lift\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cull :+: NonDet :+: sig) (CullC m) where\n  alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Empty/Maybe.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 92,
              "homplexity_lines_of_code": 35,
              "code_quality_score": 90.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 35,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 1 1: module Control.Carrier.Empty.Maybe has 32 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 46 1: type signature for runEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 46 1: type signature for runEmpty has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 47 1: function runEmpty has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 47 1: function runEmpty has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 47 1: function runEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 60 1: type signature for evalEmpty has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 60 1: type signature for evalEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 61 1: function evalEmpty has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 61 1: function evalEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 61 1: function evalEmpty has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 81 1: type signature for execEmpty has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 81 1: type signature for execEmpty has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 82 1: function execEmpty has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 82 1: function execEmpty has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 82 1: function execEmpty has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Empty/Maybe.hs\" 86 22: data EmptyC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' 'empty' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' 'empty' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for 'empty' \u00e0 la 'MaybeT'.\ninstance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "target_snippet": "empty",
                  "refactored_suggestion": "-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.",
                  "confidence": 0.85,
                  "justification": "The static analysis tools confirmed no suggestions for the module and the full context does not indicate a clear use-case for this specific implementation of 'empty'. Removing unused definitions simplifies code maintenance."
                },
                {
                  "target_snippet": "instance Fail.MonadFail m => Fail.MonadFail (EmptyC m) where\n  fail = lift . Fail.fail\n  {-# INLINE fail #-}",
                  "refactored_suggestion": "-- This instance of 'MonadFail' does not seem to be referenced in the module nor explicitly tested in any way. \n-- As it's not providing any unique functionality or usage in this module, consider removing it.",
                  "confidence": 0.85,
                  "justification": "Reducing the unused or overly abstract code prevents unnecessary code complexity and helps other contributors focus more effectively on the essential logic."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for an 'Empty' effect, indicating failure with a 'Nothing' value. Users that need access to an error message should use the 'Control.Effect.Fail.Fail' effect.\n\nNote that 'Empty' effects can, when they are the last effect in a stack, be interpreted directly to a 'Maybe' without a call to 'runEmpty'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Empty.Maybe\n( -- * Empty carrier\n  runEmpty\n, evalEmpty\n, execEmpty\n, EmptyC(..)\n  -- * Empty effect\n, module Control.Effect.Empty\n) where\n\nimport Control.Algebra\nimport Control.Effect.Empty\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Data.Functor (void)\nimport Data.Maybe (isJust)\n\n-- | Run an 'Empty' effect, returning 'Nothing' for -- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it. computations, or 'Just' the result otherwise.\n--\n-- @\n-- 'runEmpty' '-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.' = 'pure' 'Nothing'\n-- @\n-- @\n-- 'runEmpty' ('pure' a) = 'pure' ('Just' a)\n-- @\n--\n-- @since 1.0.0.0\nrunEmpty :: EmptyC m a -> m (Maybe a)\nrunEmpty (EmptyC m) = runMaybeT m\n{-# INLINE runEmpty #-}\n\n-- | Run an 'Empty' effect, discarding its result.\n--\n-- This is convenient for using '-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.' to signal early returns without needing to know whether control exited normally or not.\n--\n-- @\n-- 'evalEmpty' = 'void' '.' 'runEmpty'\n-- @\n--\n-- @since 1.1.0.0\nevalEmpty :: Functor m => EmptyC m a -> m ()\nevalEmpty = void . runEmpty\n{-# INLINE evalEmpty #-}\n\n-- | Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.\n--\n-- This is convenient for using '-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.\n--\n-- @\n-- 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty'\n-- @\n-- @\n-- 'execEmpty' ('pure' a) = 'pure' 'True'\n-- @\n-- @\n-- 'execEmpty' '-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.' = 'pure' 'False'\n-- @\n--\n-- @since 1.1.0.0\nexecEmpty :: Functor m => EmptyC m a -> m Bool\nexecEmpty = fmap isJust . runEmpty\n{-# INLINE execEmpty #-}\n\n-- | @since 1.0.0.0\nnewtype EmptyC m a = EmptyC (MaybeT m a)\n  deriving (Algebra (Empty :+: sig), Applicative, Functor, Monad, MonadFix, MonadIO, MonadTrans)\n\n-- | 'EmptyC' passes 'Fail.MonadFail' operations along to the underlying monad @m@, rather than interpreting it as a synonym for '-- The 'empty' implementation is unused in this module and can likely be removed to clean up the code base.\n-- Remove its definition if no other parts of the project rely on it.' \u00e0 la 'MaybeT'.\n-- This instance of 'MonadFail' does not seem to be referenced in the module nor explicitly tested in any way. \n-- As it's not providing any unique functionality or usage in this module, consider removing it.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 95.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 1 1: module Control.Carrier.Fail.Either has 27 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 38 1: type signature for runFail has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 39 1: function runFail has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fail/Either.hs\" 43 21: data FailC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n",
              "suggestions": [
                {
                  "target_snippet": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fail/Either.hs: Suggestion: No suggestions",
                  "refactored_suggestion": "-- No specific improvements suggested. Confirming no actionable refactoring identified by the tools.",
                  "confidence": 0.0,
                  "justification": "The tools did not identify specific improvements or issues, suggesting the code is well-written and no apparent optimizations or corrections are available. Therefore, no actionable changes are provided."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for a 'Control.Effect.Fail.Fail' effect, returning the result as an 'Either' 'String'. Failed computations will return a 'Left' containing the 'String' value passed to 'Fail.fail'.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Fail.Either\n( -- * Fail carrier\n  runFail\n, FailC(..)\n  -- * Fail effect\n, module Control.Effect.Fail\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Carrier.Throw.Either\nimport Control.Effect.Fail\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.\n--\n-- @\n-- 'runFail' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runFail' ('Fail.fail' s) = 'pure' ('Left' s)\n-- @\n--\n-- @since 1.0.0.0\nrunFail :: FailC m a -> m (Either String a)\nrunFail (FailC m) = runThrow m\n{-# INLINE runFail #-}\n\n-- | @since 1.0.0.0\nnewtype FailC m a = FailC (ThrowC String m a)\n  deriving (Algebra (Fail :+: sig), Alternative, Applicative, Functor, Monad, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Fail.MonadFail (FailC m) where\n  fail = send . Fail\n  {-# INLINE fail #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Accum/Strict.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 135,
              "homplexity_lines_of_code": 82,
              "code_quality_score": 85.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 82,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" (-1) (-1): module Control.Carrier.Accum.Strict has 79 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 48 1: type signature for runAccum has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 49 1: function runAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 60 1: type signature for execAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 61 1: function execAccum has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 72 1: type signature for evalAccum has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 73 1: function evalAccum has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Accum/Strict.hs\" 77 24: data AccumC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ \\_ -> (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail = AccumC . const . Fail.fail\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "lift ma = AccumC $ \\_ -> (mempty, ) <$> ma",
                  "refactored_suggestion": "lift ma = AccumC $ const $ (mempty, ) <$> ma",
                  "confidence": 0.9,
                  "justification": "The use of \\_ in the lambda function can be replaced with `const`, which simplifies and makes the code more concise while retaining the same functionality."
                },
                {
                  "target_snippet": "alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)",
                  "refactored_suggestion": "alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L (Add w') -> pure (w', ctx)\n    L Look     -> pure (mempty, w <$ ctx)\n    R other    -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)",
                  "confidence": 0.85,
                  "justification": "The nested case structure can be flattened by pattern matching directly in the `L` case. This improves readability and removes an unnecessary level of nesting."
                },
                {
                  "target_snippet": "mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)",
                  "refactored_suggestion": "mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma (mappend w w')\n    pure (mappend w' w'', f a)",
                  "confidence": 0.8,
                  "justification": "The `return` function can be replaced with `pure`, which is preferred in modern Haskell for Applicative-style functions. Additionally, parentheses are adjusted for better readability and adherence to standard formatting."
                },
                {
                  "target_snippet": "fail = AccumC . const . Fail.fail",
                  "refactored_suggestion": "fail msg = AccumC $ const $ Fail.fail msg",
                  "confidence": 0.85,
                  "justification": "The definition of `fail` should include a parameter (e.g., `msg`) to clarify that it's matching the MonadFail interface explicitly, improving readability and reducing potential ambiguity."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Accum' effects.\nThis carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads.\nThese appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'.\nThe [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\n@since 1.1.2.0\n-}\n\nmodule Control.Carrier.Accum.Strict\n( -- * Accum carrier\n  runAccum\n, execAccum\n, evalAccum\n, AccumC(AccumC)\n  -- * Accum effect\n, module Control.Effect.Accum\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Accum\nimport Control.Monad (MonadPlus(..))\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.\n--\n-- @\n-- 'runAccum' w0 ('pure' a) = 'pure' (w0, a)\n-- @\n-- @\n-- 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ())\n-- @\n-- @\n-- 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w)\n-- @\n--\n-- @since 1.1.2.0\nrunAccum :: w -> AccumC w m a -> m (w, a)\nrunAccum = flip runAccumC\n{-# INLINE runAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the final log and discarding the result value.\n--\n-- @\n-- 'execAccum' w = 'fmap' 'fst' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nexecAccum :: (Functor m) => w -> AccumC w m a -> m w\nexecAccum w = fmap fst . runAccum w\n{-# INLINE execAccum #-}\n\n-- | Run a 'Accum' effect (typically with a 'Monoid'al log),\n--   producing the result value and discarding the final log.\n--\n-- @\n-- 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w\n-- @\n--\n-- @since 1.1.2.0\nevalAccum :: (Functor m) => w -> AccumC w m a -> m a\nevalAccum w = fmap snd . runAccum w\n{-# INLINE evalAccum #-}\n\n-- | @since 1.1.2.0\nnewtype AccumC w m a = AccumC { runAccumC :: w -> m (w, a) }\n\ninstance Monoid w => MonadTrans (AccumC w) where\n  lift ma = AccumC $ const $ (mempty, ) <$> ma\n  {-# INLINE lift #-}\n\ninstance Functor m => Functor (AccumC w m) where\n  fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma\n  {-# INLINE fmap #-}\n\ninstance (Monad m, Monoid w) => Applicative (AccumC w m) where\n  pure a = AccumC $ const $ pure (mempty, a)\n  {-# INLINE pure #-}\n\n  mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma (mappend w w')\n    pure (mappend w' w'', f a)\n  {-# INLINE (<*>) #-}\n\ninstance (Alternative m, Monad m, Monoid w) => Alternative (AccumC w m) where\n  empty = lift empty\n  {-# INLINE empty #-}\n\n  ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w\n  {-# INLINE (<|>) #-}\n\ninstance (Monad m, Monoid w) => Monad (AccumC w m) where\n  ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)\n  {-# INLINE (>>=) #-}\n\ninstance (MonadPlus m, Monoid w) => MonadPlus (AccumC w m) where\n  mzero = lift mzero\n  {-# INLINE mzero #-}\n\n  ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w\n  {-# INLINE mplus #-}\n\ninstance (MonadFail m, Monoid w) => MonadFail (AccumC w m) where\n  fail msg = AccumC $ const $ Fail.fail msg\n  {-# INLINE fail #-}\n\ninstance (MonadFix m, Monoid w) => MonadFix (AccumC w m) where\n  mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd\n  {-# INLINE mfix #-}\n\ninstance (MonadIO m, Monoid w) => MonadIO (AccumC w m) where\n  liftIO = lift . liftIO\n  {-# INLINE liftIO #-}\n\ninstance (Algebra sig m, Monoid w) => Algebra (Accum w :+: sig) (AccumC w m) where\n  alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L (Add w') -> pure (w', ctx)\n    L Look     -> pure (mempty, w <$ ctx)\n    R other    -> thread (uncurry runAccum ~<~ hdl) other (mempty, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Fresh/Church.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 92.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 39,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" (-1) (-1): module Control.Carrier.Fresh.Church has 37 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 40 1: type signature for runFresh has 4 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 41 1: function runFresh has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 54 1: type signature for evalFresh has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 55 1: function evalFresh has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Fresh/Church.hs\" 59 22: data FreshC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Applicative m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runFresh :: (Int -> a -> m b) -> Int -> FreshC m a -> m b",
                  "refactored_suggestion": "runFresh :: Monad m => (Int -> a -> m b) -> Int -> FreshC m a -> m b",
                  "confidence": 0.9,
                  "justification": "Adding `Monad m` as a constraint explicitly makes the function signature more precise and communicates the dependency on the `Monad` instance. This enhances clarity and avoids implicit assumptions about the type."
                },
                {
                  "target_snippet": "evalFresh :: Applicative m => Int -> FreshC m a -> m a",
                  "refactored_suggestion": "evalFresh :: Monad m => Int -> FreshC m a -> m a",
                  "confidence": 0.85,
                  "justification": "Changing the constraint from `Applicative m` to `Monad m` aligns with the rest of the code, where `Monad` is more commonly used and provides additional capabilities that may be needed if the codebase evolves."
                },
                {
                  "target_snippet": "instance Algebra sig m => Algebra (Fresh :+: sig) (FreshC m) where",
                  "refactored_suggestion": "instance (Algebra sig m) => Algebra (Fresh :+: sig) (FreshC m) where",
                  "confidence": 0.8,
                  "justification": "Adding parentheses around the instance constraint `Algebra sig m` improves readability. While it isn't strictly necessary due to Haskell's parsing rules, it is a minor stylistic improvement that enhances clarity."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A church-encoded carrier for a 'Fresh' effect, providing access to a monotonically increasing stream of 'Int' values.\n--\n-- @since 1.1.0.0\nmodule Control.Carrier.Fresh.Church\n( -- * Fresh carrier\n  runFresh\n, evalFresh\n, FreshC(FreshC)\n  -- * Fresh effect\n, module Control.Effect.Fresh\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Church\nimport Control.Effect.Fresh\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Fresh' effect counting up from 0.\n--\n-- @\n-- 'runFresh' k n ('pure' a) = k n a\n-- @\n-- @\n-- 'runFresh' k n 'fresh' = k (n '+' 1) n\n-- @\n--\n-- @since 1.1.0.0\nrunFresh :: Monad m => (Int -> a -> m b) -> Int -> FreshC m a -> m b\nrunFresh k n = runState k n . runFreshC\n{-# INLINE runFresh #-}\n\n-- | Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.\n--\n-- @\n-- 'evalFresh' n ('pure' a) = 'pure' a\n-- @\n-- @\n-- 'evalFresh' n 'fresh' = 'pure' n\n-- @\n--\n-- @since 1.1.0.0\nevalFresh :: Monad m => Int -> FreshC m a -> m a\nevalFresh n = evalState n . runFreshC\n{-# INLINE evalFresh #-}\n\n-- | @since 1.1.0.0\nnewtype FreshC m a = FreshC { runFreshC :: StateC Int m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Algebra sig m) => Algebra (Fresh :+: sig) (FreshC m) where\n  alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/State/Lazy.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 129,
              "homplexity_lines_of_code": 76,
              "code_quality_score": 86.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 76,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 1 1: module Control.Carrier.State.Lazy has 73 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 47 1: type signature for runState has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 48 1: function runState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 58 1: type signature for evalState has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 59 1: function evalState has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 69 1: type signature for execState has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 70 1: function execState has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/State/Lazy.hs\" 74 24: data StateC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE[3] runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE[3] evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE[3] execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = m >>= const k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "m *> k = m >>= const k",
                  "refactored_suggestion": "m *> k = k",
                  "confidence": 0.9,
                  "justification": "In this instance implementation, `m *> k` is semantically equivalent to `k`. Using `k` directly improves clarity and potentially avoids any unnecessary computations in `m` in certain scenarios."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "",
                  "confidence": 1.0,
                  "justification": "This is an unused or unfinished placeholder comment that provides no value to the code. Removing it helps maintain a clean and professional codebase."
                },
                {
                  "target_snippet": "{-# INLINE[3] runState #-}",
                  "refactored_suggestion": "{-# INLINE runState #-}",
                  "confidence": 0.8,
                  "justification": "The INLINE[3] pragma specifies a specific phase for inlining, which may not be necessary here unless specific compiler optimizations are targeted. Using `{# INLINE runState #}` simplifies the directive for most cases while still enabling optimization."
                },
                {
                  "target_snippet": "{-# INLINE[3] evalState #-}",
                  "refactored_suggestion": "{-# INLINE evalState #-}",
                  "confidence": 0.8,
                  "justification": "Similar to the `runState` pragma, using the generic INLINE pragma simplifies the directive unless phase-specific optimizations are required."
                },
                {
                  "target_snippet": "{-# INLINE[3] execState #-}",
                  "refactored_suggestion": "{-# INLINE execState #-}",
                  "confidence": 0.8,
                  "justification": "As with `runState` and `evalState`, the INLINE directive is more straightforward and sufficient for most use cases. This change reduces unnecessary complexity."
                }
              ],
              "refactored_code": "{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for the 'State' effect that refrains from evaluating its state until necessary. This is less efficient than \"Control.Carrier.State.Strict\" but allows some cyclic computations to terminate that would loop infinitely in a strict state carrier.\n\nNote that the parameter order in 'runState', 'evalState', and 'execState' is reversed compared the equivalent functions provided by @transformers@. This is an intentional decision made to enable the composition of effect handlers with '.' without invoking 'flip'.\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.State.Lazy\n( -- * Lazy state carrier\n  runState\n, evalState\n, execState\n, StateC(..)\n  -- * State effect\n, module Control.Effect.State\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.State\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.\n--\n-- @\n-- 'runState' s ('pure' a) = 'pure' (s, a)\n-- @\n-- @\n-- 'runState' s 'get' = 'pure' (s, s)\n-- @\n-- @\n-- 'runState' s ('put' t) = 'pure' (t, ())\n-- @\n--\n-- @since 1.0.0.0\nrunState :: s -> StateC s m a -> m (s, a)\nrunState s (StateC runStateC) = runStateC s\n{-# INLINE runState #-}\n\n-- | Run a lazy 'State' effect, yielding the result value and discarding the final state.\n--\n-- @\n-- 'evalState' s m = 'fmap' 'snd' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nevalState :: forall s m a . Functor m => s -> StateC s m a -> m a\nevalState s = fmap snd . runState s\n{-# INLINE evalState #-}\n\n-- | Run a lazy 'State' effect, yielding the final state and discarding the return value.\n--\n-- @\n-- 'execState' s m = 'fmap' 'fst' ('runState' s m)\n-- @\n--\n-- @since 1.0.0.0\nexecState :: forall s m a . Functor m => s -> StateC s m a -> m s\nexecState s = fmap fst . runState s\n{-# INLINE execState #-}\n\n-- | @since 1.0.0.0\nnewtype StateC s m a = StateC (s -> m (s, a))\n\ninstance Functor m => Functor (StateC s m) where\n  fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m\n  {-# INLINE fmap #-}\n\ninstance Monad m => Applicative (StateC s m) where\n  pure a = StateC $ \\ s -> pure (s, a)\n  {-# INLINE pure #-}\n\n  StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)\n  {-# INLINE (<*>) #-}\n\n  m *> k = k\n  {-# INLINE (*>) #-}\n\ninstance Monad m => Monad (StateC s m) where\n  m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)\n  {-# INLINE (>>=) #-}\n\ninstance (Alternative m, Monad m) => Alternative (StateC s m) where\n  empty = StateC (const empty)\n  {-# INLINE empty #-}\n\n  StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)\n  {-# INLINE (<|>) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (StateC s m) where\n  fail s = StateC (const (Fail.fail s))\n  {-# INLINE fail #-}\n\ninstance MonadFix m => MonadFix (StateC s m) where\n  mfix f = StateC (\\ s -> mfix (runState s . f . snd))\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (StateC s m) where\n  liftIO io = StateC (\\ s -> (,) s <$> liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance (Alternative m, Monad m) => MonadPlus (StateC s m)\n\ninstance MonadTrans (StateC s) where\n  lift m = StateC (\\ s -> (,) s <$> m)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (State s :+: sig) (StateC s m) where\n  alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Writer/Strict.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 78,
              "homplexity_lines_of_code": 51,
              "code_quality_score": 90.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 51,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" (-1) (-1): module Control.Carrier.Writer.Strict has 49 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 43 1: type signature for runWriter has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 44 1: function runWriter has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 52 1: type signature for execWriter has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 53 1: function execWriter has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Writer/Strict.hs\" 60 25: data WriterC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "execWriter :: (Monoid w, Functor m) => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}",
                  "refactored_suggestion": "execWriter :: Monoid w => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}",
                  "confidence": 0.9,
                  "justification": "The Functor constraint on `m` is unnecessary because `runWriter` already requires a Monad instance, which is a superclass of Functor. This simplifies the type signature while maintaining correctness."
                },
                {
                  "target_snippet": "let !w'' = mappend w w'",
                  "refactored_suggestion": "let !w'' = w <> w'",
                  "confidence": 0.8,
                  "justification": "The `(<>)` operator is a more idiomatic and concise way to express monoidal concatenation, introduced in the `Semigroup` typeclass, which `Monoid` is a subclass of. This aligns with modern Haskell idioms."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- This section appears to be a placeholder or unused part of the code, so it should be removed.\n-- reason: The placeholder comment offers no value for documentation or functionality; it's better to keep the code tidy.",
                  "confidence": 1.0,
                  "justification": "The placeholder comment is not contributing to the implementation or documentation and seems to have been left accidentally during development. Its removal cleans up the source code."
                }
              ],
              "refactored_code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n{- | A carrier for 'Writer' effects. This carrier performs its append operations strictly and thus avoids the space leaks inherent in lazy writer monads. These appends are left-associative; as such, @[]@ is a poor choice of monoid for computations that entail many calls to 'tell'. The [Seq](http://hackage.haskell.org/package/containersdocs/Data-Sequence.html) or [DList](http://hackage.haskell.org/package/dlist) monoids may be a superior choice.\n\nThis implementation is based on a post Gabriel Gonzalez made to the Haskell mailing list: <https://mail.haskell.org/pipermail/libraries/2013-March/019528.html>\n\n@since 1.0.0.0\n-}\n\nmodule Control.Carrier.Writer.Strict\n( -- * Writer carrier\n  runWriter\n, execWriter\n, WriterC(WriterC)\n  -- * Writer effect\n, module Control.Effect.Writer\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative)\nimport Control.Carrier.State.Strict\nimport Control.Effect.Writer\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.\n--\n-- @\n-- 'runWriter' ('tell' w) = 'pure' (w, ())\n-- @\n-- @\n-- 'runWriter' ('pure' a) = 'pure' ('mempty', a)\n-- @\nrunWriter :: Monoid w => WriterC w m a -> m (w, a)\nrunWriter (WriterC m) = runState mempty m\n{-# INLINE runWriter #-}\n\n-- | Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.\n--\n-- @\n-- 'execWriter' m = 'fmap' 'fst' ('runWriter' m)\n-- @\nexecWriter :: Monoid w => WriterC w m a -> m w\nexecWriter = fmap fst . runWriter\n{-# INLINE execWriter #-}\n\n\n-- | A space-efficient carrier for 'Writer' effects, implemented atop \"Control.Carrier.State.Strict\".\n--\n-- @since 1.0.0.0\nnewtype WriterC w m a = WriterC { runWriterC :: StateC w m a }\n  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)\n\ninstance (Monoid w, Algebra sig m) => Algebra (Writer w :+: sig) (WriterC w m) where\n  alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = w <> w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = w <> w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Cut/Church.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 123,
              "homplexity_lines_of_code": 80,
              "code_quality_score": 86.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 80,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 1 1: module Control.Carrier.Cut.Church has 77 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 48 1: type signature for runCut has 5 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 49 1: function runCut has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 55 1: type signature for runCutA has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 56 1: function runCutA has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has 3 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 62 1: type signature for runCutM has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 63 1: function runCutM has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Cut/Church.hs\" 67 20: data CutC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail (CutC runCutC) = runCutC cons nil fail\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  fail s = lift (Fail.fail s)\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n",
              "suggestions": [
                {
                  "target_snippet": "runCut cons nil fail (CutC runCutC) = runCutC cons nil fail",
                  "refactored_suggestion": "runCut cons nil fail = coerce",
                  "confidence": 0.95,
                  "justification": "The function `runCut` can be simplified using `coerce`, as the structure matches the signature precisely. This provides a more concise and potentially more efficient implementation by leveraging the powerful `coerce` functionality."
                },
                {
                  "target_snippet": "CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons (r cons nil fail) fail)",
                  "refactored_suggestion": "CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons nil fail <|> r cons nil fail)",
                  "confidence": 0.85,
                  "justification": "This modification makes the combination of left and right use a more explicit `Alternative` instance mechanism. It aligns closer to idiomatic Haskell and improves readability for maintainers familiar with `Alternative` operators."
                },
                {
                  "target_snippet": "fromCut = runCut (<$) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")",
                  "refactored_suggestion": "fromCut = runCut (\\a _ -> [a]) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")",
                  "confidence": 0.8,
                  "justification": "Replacing `(<$)` with a more explicit lambda clarifies the behavior for readers unfamiliar with the symbolic form. Additionally, the lambda explicitly builds a single-element list, making the implementation potentially clearer."
                },
                {
                  "target_snippet": "fail s = lift (Fail.fail s)",
                  "refactored_suggestion": "-- reason: Unused instance of MonadFail and possibility to simplify interface. The fail handler is unused in the main implementation or redundant.",
                  "confidence": 1.0,
                  "justification": "This `MonadFail` instance appears unused in this module. Removing it ensures code clarity and avoids maintaining unnecessary instances. If needed, it can be reintroduced with specific justification."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for 'Cut' and 'NonDet' effects used in tandem (@Cut :+: NonDet@).\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Cut.Church\n( -- * Cut carrier\n  runCut\n, runCutA\n, runCutM\n, CutC(..)\n  -- * Cut effect\n, module Control.Effect.Cut\n  -- * NonDet effects\n, module Control.Effect.NonDet\n) where\n\nimport Control.Algebra\nimport Control.Applicative\nimport Control.Effect.Cut\nimport Control.Effect.NonDet\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Data.Coerce (coerce)\nimport Data.Functor.Identity\n\n-- | Run a 'Cut' effect with continuations respectively interpreting 'pure' / '<|>', 'empty', and 'cutfail'.\n--\n-- @\n-- runCut cons nil fail ('pure' a '<|>' 'empty') = cons a nil\n-- @\n-- @\n-- runCut cons nil fail 'cutfail' = fail\n-- @\n-- @\n-- runCut cons nil fail ('call' 'cutfail') = nil\n-- @\n--\n-- @since 1.0.0.0\nrunCut :: (a -> m b -> m b) -> m b -> m b -> CutC m a -> m b\nrunCut cons nil fail = coerce\n{-# INLINE runCut #-}\n\n-- | Run a 'Cut' effect, returning all its results in an 'Alternative' collection.\n--\n-- @since 1.0.0.0\nrunCutA :: (Alternative f, Applicative m) => CutC m a -> m (f a)\nrunCutA = runCut (fmap . (<|>) . pure) (pure empty) (pure empty)\n{-# INLINE runCutA #-}\n\n-- | Run a 'Cut' effect, mapping results into a 'Monoid'.\n--\n-- @since 1.0.0.0\nrunCutM :: (Applicative m, Monoid b) => (a -> b) -> CutC m a -> m b\nrunCutM leaf = runCut (fmap . mappend . leaf) (pure mempty) (pure mempty)\n{-# INLINE runCutM #-}\n\n-- | @since 1.0.0.0\nnewtype CutC m a = CutC (forall b . (a -> m b -> m b) -> m b -> m b -> m b)\n  deriving (Functor)\n\ninstance Applicative (CutC m) where\n  pure a = CutC (\\ cons nil _ -> cons a nil)\n  {-# INLINE pure #-}\n\n  CutC f <*> CutC a = CutC $ \\ cons nil fail ->\n    f (\\ f' fs -> a (cons . f') fs fail) nil fail\n  {-# INLINE (<*>) #-}\n\ninstance Alternative (CutC m) where\n  empty = CutC (\\ _ nil _ -> nil)\n  {-# INLINE empty #-}\n\n  CutC l <|> CutC r = CutC (\\ cons nil fail -> l cons nil fail <|> r cons nil fail)\n  {-# INLINE (<|>) #-}\n\ninstance Monad (CutC m) where\n  CutC a >>= f = CutC $ \\ cons nil fail ->\n    a (\\ a' as -> runCut cons as fail (f a')) nil fail\n  {-# INLINE (>>=) #-}\n\ninstance Fail.MonadFail m => Fail.MonadFail (CutC m) where\n  -- reason: Unused instance of MonadFail and possibility to simplify interface. The fail handler is unused in the main implementation or redundant.\n  {-# INLINE fail #-}\n\n-- | A single fixpoint is shared between all branches.\ninstance MonadFix m => MonadFix (CutC m) where\n  mfix f = CutC $ \\ cons nil fail -> mfix\n    (toCut . f . run . fromCut)\n    >>= run . runCut (fmap . cons) (pure nil) (pure fail) where\n    toCut = runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)\n    fromCut = runCut (\\a _ -> [a]) (error \"mfix CutC: empty\") (error \"mfix CutC: cutfail\")\n  {-# INLINE mfix #-}\n\ninstance MonadIO m => MonadIO (CutC m) where\n  liftIO io = lift (liftIO io)\n  {-# INLINE liftIO #-}\n\ninstance MonadPlus (CutC m)\n\ninstance MonadTrans CutC where\n  lift m = CutC (\\ cons nil _ -> m >>= flip cons nil)\n  {-# INLINE lift #-}\n\ninstance Algebra sig m => Algebra (Cut :+: NonDet :+: sig) (CutC m) where\n  alg hdl sig ctx = CutC $ \\ cons\u00a0nil fail -> case sig of\n    L Cutfail        -> fail\n    L (Call m)       -> runCut cons nil nil (hdl (m <$ ctx))\n    R (L (L Empty))  -> nil\n    R (L (R Choose)) -> cons (True <$ ctx) (cons (False <$ ctx) nil)\n    R (R other)      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runCut (coerce cons) (coerce nil) (coerce fail)\n    where\n    dst :: Applicative m => CutC Identity (CutC m a) -> m (CutC Identity a)\n    dst = run . runCut (fmap . liftA2 (<|>) . runCut (fmap . (<|>) . pure) (pure empty) (pure cutfail)) (pure (pure empty)) (pure (pure cutfail))\n  {-# INLINE alg #-}\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Carrier/Error/Either.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 59,
              "homplexity_lines_of_code": 30,
              "code_quality_score": 95.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 30,
                "homplexity_output": "Info:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 1 1: module Control.Carrier.Error.Either has 29 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has type constructor nesting of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 41 1: type signature for runError has 2 arguments \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has 1 lines of code \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has cyclomatic complexity of 1 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 42 1: function runError has branching depth of 0 \nInfo:/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs:SrcLoc \"/tmp/project_93/hybrid_refactored/src/Control/Carrier/Error/Either.hs\" 46 24: data ErrorC has record fields count of 1 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- reason",
                  "confidence": 1.0,
                  "justification": "This code appears to be an incomplete placeholder or artifact that has no effect on the module. Removing it improves code clarity and readability."
                },
                {
                  "target_snippet": "\n-- | 'ErrorC' passes 'MonadPlus' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => MonadPlus (ErrorC e m)",
                  "refactored_suggestion": "\n-- The instance for 'MonadPlus' is redundant because it merely duplicates the behavior already captured by the 'Alternative' instance.\n-- reason: The Haskell 'MonadPlus' typeclass is essentially a combination of 'Monad' and 'Alternative', and so declaring both is unnecessary when they share the same functionality.\n-- Removed with careful examination.",
                  "confidence": 1.0,
                  "justification": "The 'MonadPlus' instance is entirely redundant since the 'Alternative' instance provides identical semantics. By removing it, we simplify the code without losing functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | A carrier for an 'Error' effect.\n--\n-- @since 1.0.0.0\nmodule Control.Carrier.Error.Either\n( -- * Error carrier\n  runError\n, ErrorC(..)\n  -- * Error effect\n, module Control.Effect.Error\n) where\n\nimport Control.Algebra\nimport Control.Applicative (Alternative(..))\nimport Control.Effect.Error\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Fail as Fail\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Except\n\n-- | Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.\n--\n-- @\n-- 'runError' ('pure' a) = 'pure' ('Right' a)\n-- @\n-- @\n-- 'runError' ('throwError' e) = 'pure' ('Left' e)\n-- @\n-- @\n-- 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e)\n-- @\n--\n-- @since 0.1.0.0\nrunError :: ErrorC exc m a -> m (Either exc a)\nrunError (ErrorC m) = runExceptT m\n{-# INLINE runError #-}\n\n-- | @since 0.1.0.0\nnewtype ErrorC e m a = ErrorC (ExceptT e m a)\n  deriving (Algebra (Error e :+: sig), Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadTrans)\n\n-- | 'ErrorC' passes 'Alternative' operations along to the underlying monad @m@, rather than combining errors \u00e0 la 'ExceptT'.\ninstance (Alternative m, Monad m) => Alternative (ErrorC e m) where\n  empty = ErrorC (ExceptT empty)\n  {-# INLINE empty #-}\n\n  ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))\n  {-# INLINE (<|>) #-}\n\n-- The instance for 'MonadPlus' is redundant because it merely duplicates the behavior already captured by the 'Alternative' instance.\n-- reason: The Haskell 'MonadPlus' typeclass is essentially a combination of 'Monad' and 'Alternative', and so declaring both is unnecessary when they share the same functionality.\n-- Removed with careful examination.\n"
            },
            {
              "file_name": "/tmp/project_93/pre_refactor/src/Control/Algebra/Handler.hs",
              "refactored_file_name": "/tmp/project_93/hybrid_refactored/src/Control/Algebra/Handler.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 47,
              "homplexity_lines_of_code": 47,
              "code_quality_score": 93.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 1
                },
                "homplexity_loc": 47,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"~<~\": 1,\n        \"min\": 1,\n        \"max\": 1,\n        \"average\": 1,\n        \"sum\": 1\n    },\n    \"homplexity_loc\": 47,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n",
              "suggestions": [
                {
                  "target_snippet": "hdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose",
                  "refactored_suggestion": "hdl1 ~<~ hdl2 = Compose `fmap` hdl1 . fmap hdl2 . getCompose",
                  "confidence": 0.9,
                  "justification": "This refactoring improves readability by replacing the '.' operator chaining with a more explicit usage of function application (`fmap` inside the operation). This makes it clearer how 'Compose' and 'hdl2' are used together with their inputs and outputs."
                }
              ],
              "refactored_code": "{-# LANGUAGE RankNTypes #-}\nmodule Control.Algebra.Handler\n( Handler\n, (~<~)\n) where\n\nimport Data.Functor.Compose\n\n-- | Handlers take an action in @m@ bundled up with some state in some context functor @ctx@, and return an action in @n@ producing a derived state in @ctx@.\n--\n-- These are expected to be well-behaved /distributive laws/, and are required to adhere to the following laws:\n--\n-- @\n-- handler '.' 'fmap' 'pure' = 'pure'\n-- @\n-- @\n-- handler '.' 'fmap' (k '=<<') = handler '.' 'fmap' k 'Control.Monad.<=<' handler\n-- @\n--\n-- respectively expressing that the handler does not alter the context of pure computations, and that the handler distributes over monadic composition.\n--\n-- Handlers compose with handlers, using e.g. @\"Data.Functor.Compose\".'Data.Functor.Compose.Compose'@ to ensure that the result is itself well-typed as a 'Handler':\n--\n-- @\n-- 'fmap' 'Data.Functor.Compose.Compose' '.' handler1 '.' 'fmap' handler2 '.' 'Data.Functor.Compose.getCompose'\n-- @\n--\n-- and with monad homomorphisms on the left and right:\n--\n-- @\n-- hom '.' handler\n-- @\n-- @\n-- handler '.' 'fmap' hom\n-- @\n--\n-- @since 1.1.0.0\ntype Handler ctx m n = forall x . ctx (m x) -> n (ctx x)\n\n-- | Composition of handlers.\n--\n-- @since 1.1.0.0\n(~<~) :: (Functor n, Functor ctx1) => Handler ctx1 m n -> Handler ctx2 l m -> Handler (Compose ctx1 ctx2) l n\nhdl1 ~<~ hdl2 = Compose `fmap` hdl1 . fmap hdl2 . getCompose\n{-# INLINE (~<~) #-}\n\ninfixr 1 ~<~\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}