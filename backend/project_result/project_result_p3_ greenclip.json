{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 2,
          "max": 11,
          "average": 44.5,
          "sum": 89
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 5,
          "suggestion": 5,
          "ignore": 0,
          "total": 10
        },
        "syntax_errors": 32,
        "lines_of_code": 633,
        "homplexity_lines_of_code": 631,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "63MB",
          "runtime": "1.87 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_89/pre_refactor/src/Clipboard.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 2,
            "sum": 38
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 12,
          "lines_of_code": 297,
          "homplexity_lines_of_code": 296,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 2,
              "sum": 38
            },
            "homplexity_loc": 296,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"selectionLength\": 4,\n        \"test\": 1,\n        \"windowNameOfClipboardOwner\": 2,\n        \"isIncrementalTransfert\": 2,\n        \"getSupportedMimes\": 2,\n        \"getClipboardSelection\": 1,\n        \"getPrimarySelection\": 1,\n        \"getSelection\": 4,\n        \"getXorgContext\": 1,\n        \"destroyXorgContext\": 1,\n        \"waitNotify\": 1,\n        \"setClipboardSelection\": 1,\n        \"selectionTypeToMime\": 4,\n        \"getContent\": 4,\n        \"advertiseSelection\": 4,\n        \"handleRequest\": 3,\n        \"sendSelectionNotify\": 1,\n        \"byteStringToCUChars\": 1,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 2.11,\n        \"sum\": 38\n    },\n    \"homplexity_loc\": 296,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n\nmodule Clipboard where\n\nimport           Protolude                hiding ((<&>))\nimport           Protolude.Unsafe                   (unsafeIndex)\nimport qualified Protolude.Conv as StrConvOld\n\nimport           Graphics.X11.Xlib\nimport           Graphics.X11.Xlib.Extras\n\nimport           Data.Binary              (Binary)\nimport qualified Data.ByteString          as B\nimport qualified Data.Text as T\nimport           Lens.Micro\n\nimport           System.Directory         (setCurrentDirectory)\nimport           System.IO                (hClose)\nimport           System.Posix.Process     (forkProcess)\n\nimport           Data.ByteString          (unpack)\nimport           Foreign                  (alloca, castPtr, peek, peekArray)\nimport           Foreign.C.Types          (CUChar)\nimport           Foreign.Marshal.Array    (withArrayLen)\n\ndata SelectionType = UTF8 Text\n                   | PNG ByteString\n                   | JPEG ByteString\n                   | BITMAP ByteString\n                   deriving (Show, Eq, Generic, Binary)\n\nselectionLength :: Selection -> Int\nselectionLength (Selection _ (UTF8 a)) = T.length a\nselectionLength (Selection _ (PNG a)) = B.length a\nselectionLength (Selection _ (JPEG a)) = B.length a\nselectionLength (Selection _ (BITMAP a)) = B.length a\n\n\ndata Selection = Selection {\n    appName   :: Text\n  , selection :: SelectionType\n} deriving (Show, Eq, Generic, Binary)\n\ndata XorgContext = XorgContext {\n    display          :: Display\n  , ownWindow        :: Window\n  , defaultClipboard :: Atom\n  , primaryClipboard :: Atom\n  , selectionTarget  :: Atom\n  , mimesPriorities  :: [Atom]\n  , defaultMime      :: Atom\n} deriving (Show)\n\ntest :: IO ()\ntest =\n  bracket getXorgContext destroyXorgContext $ \\ctx -> do\n    ret <- getPrimarySelection ctx True\n    print $! ret\n    return ()\n\nwindowNameOfClipboardOwner :: XorgContext -> Atom -> IO Text\nwindowNameOfClipboardOwner XorgContext{..} clipboard = do\n\n  window <- xGetSelectionOwner display clipboard\n\n  if window > 0\n    then fetchName display window <&> toS . fromMaybe mempty\n    else return mempty\n\n\nisIncrementalTransfert :: XorgContext -> IO Bool\nisIncrementalTransfert XorgContext{..}  =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        incr <- internAtom display \"INCR\" False\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0 False anyPropertyType\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        if ret /= 0\n           then return False\n        else do\n            actual_type   <- peek actual_type_return <&> fromIntegral :: IO Atom\n            _ <- peek prop_return >>= xFree\n            return $ actual_type == incr\n\ngetSupportedMimes :: XorgContext -> Atom -> IO [Atom]\ngetSupportedMimes ctx@XorgContext{..} clipboard =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        targets <- internAtom display \"TARGETS\" False\n        xConvertSelection display clipboard targets selectionTarget ownWindow currentTime\n        _ <- waitNotify ctx\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0xFFFFFFFF False aTOM\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        ret2 <- if ret /= 0\n                then return Nothing\n                else do\n                    prop_ptr      <- peek prop_return\n                    actual_format <- peek actual_format_return <&> fromIntegral :: IO Atom\n                    nitems        <- peek nitems_return <&> fromIntegral\n                    getprop prop_ptr nitems actual_format\n        return $ fromMaybe mempty ret2\n\n  where\n    getprop prop_ptr nitems actual_format\n        | actual_format == 0    = return Nothing -- Property not found\n        | otherwise = do\n            retval <- peekArray nitems (castPtr prop_ptr)\n            _ <- xFree prop_ptr\n            return $ Just retval\n\n\ngetClipboardSelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetClipboardSelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage defaultClipboard\n\ngetPrimarySelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetPrimarySelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage primaryClipboard\n\ngetSelection :: XorgContext -> Bool -> Atom -> IO (Maybe Selection)\ngetSelection ctx@XorgContext{..} enableImage clipboard = do\n  mimes <- if enableImage \n            then getSupportedMimes ctx clipboard \n            else return [defaultMime] \n  let targetMime = chooseSelectionType mimes\n\n  xConvertSelection display clipboard targetMime selectionTarget ownWindow currentTime\n  waitNotify ctx\n  isIncremental <- isIncrementalTransfert ctx\n  clipboardContent <- if isIncremental\n                      then return mempty -- Incremental use too much CPU, do not handle it\n                      else getWindowProperty8 display selectionTarget ownWindow\n                           <&> B.pack . map fromIntegral . fromMaybe mempty\n\n  if clipboardContent == mempty\n  then return Nothing\n  else do\n    windowName <- windowNameOfClipboardOwner ctx clipboard\n    return $ Just Selection { appName = windowName\n                            , selection = mimeToSelectionType targetMime clipboardContent\n                            }\n\n where\n   chooseSelectionType mimes =\n     let selectedMime = msum $ (\\mime -> find (== mime) mimes) <$> mimesPriorities\n     in fromMaybe defaultMime selectedMime\n\n   mimeToSelectionType mimeTarget selContent =\n     if      mimeTarget == unsafeIndex mimesPriorities 0 then PNG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 1 then JPEG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 2 then BITMAP selContent\n     else UTF8 $ decodeUtf8 selContent\n\n   -- getContentIncrementally acc = do\n   --   _ <- xDeleteProperty display ownWindow selectionTarget\n   --   flush display\n   --   waitNotify ctx\n   --   content <- getWindowProperty8 display selectionTarget ownWindow\n   --              <&> B.pack . map fromIntegral . fromMaybe mempty\n   --   if content == mempty\n   --      then return acc\n   --      else getContentIncrementally (acc <> content)\n\n\ngetXorgContext :: IO XorgContext\ngetXorgContext = do\n    display <- openDisplay mempty\n    window <- createSimpleWindow display (defaultRootWindow display) 0 0 1 1 0 0 0\n    -- selectInput display window propertyChangeMask\n\n    clipboard <- internAtom display \"CLIPBOARD\" False\n    selTarget <- internAtom display \"GREENCLIP\" False\n    priorities <- traverse (\\atomName -> internAtom display atomName False) [\"image/png\", \"image/jpeg\", \"image/bmp\", \"UTF8_STRING\", \"TEXT\"] \n    defaultM <- internAtom display \"UTF8_STRING\" False\n    return XorgContext {\n        display = display\n      , ownWindow = window\n      , defaultClipboard = clipboard\n      , primaryClipboard = pRIMARY\n      , selectionTarget = selTarget\n      , mimesPriorities = priorities\n      , defaultMime = defaultM\n    }\n\ndestroyXorgContext :: XorgContext -> IO ()\ndestroyXorgContext XorgContext{..} = do\n    destroyWindow display ownWindow\n    closeDisplay display\n\nwaitNotify :: XorgContext -> IO ()\nwaitNotify XorgContext{..} = allocaXEvent (go display ownWindow)\n  where\n  go display' window evPtr = do\n    waitForEvents display'\n    nextEvent display' evPtr\n    ev <- getEvent evPtr\n    when (ev_event_type ev /= selectionNotify\n          &&  not (ev_event_type ev == propertyNotify && ev_atom ev == selectionTarget && ev_propstate ev == 1))\n      (go display' window evPtr)\n\n  waitForEvents display' = do\n    nbEvs <- pending display'\n    when (nbEvs == 0) $ threadDelay _10ms >> waitForEvents display'\n\n  _10ms = 10000\n\n\n\nsetClipboardSelection :: Selection -> IO ()\nsetClipboardSelection sel = void $ forkProcess $ do\n        mapM_ hClose [stdin, stdout, stderr]\n        setCurrentDirectory \"/\"\n        bracket getXorgContext destroyXorgContext $ \\ctx@XorgContext{..} -> do\n          let clipboards = [defaultClipboard, primaryClipboard]\n          mapM_ (\\atom -> xSetSelectionOwner display atom ownWindow currentTime) clipboards\n          advertiseSelection ctx sel\n          return ()\n\n\nselectionTypeToMime :: SelectionType -> ByteString\nselectionTypeToMime (PNG _)    = \"image/png\"\nselectionTypeToMime (JPEG _)   = \"image/jpeg\"\nselectionTypeToMime (BITMAP _) = \"image/bmp\"\nselectionTypeToMime (UTF8 _)   = \"UTF8_STRING\"\n\ngetContent :: SelectionType -> ByteString\ngetContent (PNG bytes)    = bytes\ngetContent (JPEG bytes)   = bytes\ngetContent (BITMAP bytes) = bytes\ngetContent (UTF8 txt)     = encodeUtf8 txt\n\nadvertiseSelection :: XorgContext -> Selection ->  IO ()\nadvertiseSelection ctx@XorgContext{..} sel = allocaXEvent (go [defaultClipboard, primaryClipboard])\n  where\n    go [] _ = return ()\n    go clipboards evPtr = do\n      nextEvent display evPtr\n      ev <- getEvent evPtr\n      case ev of\n          SelectionRequest {..} -> do\n              target' <- getAtomName display ev_target\n              response <- case target' of\n                Nothing -> return none\n                Just atomName -> handleRequest ctx (selection sel) ev_requestor ev_property (toS atomName)\n\n              sendSelectionNotify display ev_requestor ev_selection ev_target response ev_time\n              go clipboards evPtr\n\n          SelectionClear{..} -> go (filter (/= ev_selection) clipboards) evPtr\n\n          _ -> go clipboards evPtr\n\nhandleRequest :: XorgContext -> SelectionType -> Window -> Atom -> Text -> IO Atom\nhandleRequest XorgContext{..} sel requestorWindow selection \"TARGETS\" = do\n  targets <- internAtom display \"TARGETS\" True\n  target <- internAtom display (StrConvOld.toS $ selectionTypeToMime sel) True\n  changeProperty32 display requestorWindow selection aTOM propModeReplace [fromIntegral targets, fromIntegral target]\n  return selection\n\nhandleRequest XorgContext{..} sel req prop targetStr =\n  if targetStr == decodeUtf8 (selectionTypeToMime sel)\n    then do\n      target <- internAtom display (toS targetStr) True\n      void $ withArrayLen (byteStringToCUChars $ getContent sel) $ \\len bytes ->\n          xChangeProperty display req prop target 8 propModeReplace bytes (fromIntegral len)\n      return prop\n    else return none\n\nsendSelectionNotify :: Display -> Window -> Atom -> Atom -> Atom -> Time -> IO ()\nsendSelectionNotify display req sel target prop time = allocaXEvent $ \\ev -> do\n  setEventType ev selectionNotify\n  setSelectionNotify ev req sel target prop time\n  sendEvent display req False 0 ev\n\nbyteStringToCUChars :: ByteString -> [CUChar]\nbyteStringToCUChars = map fromIntegral . unpack\n",
          "suggestions": [
            {
              "module": [
                "Clipboard"
              ],
              "decl": [
                "getSelection"
              ],
              "severity": "Suggestion",
              "hint": "Use guards",
              "file": "/tmp/project_89/pre_refactor/src/Clipboard.hs",
              "startLine": 169,
              "startColumn": 4,
              "endLine": 173,
              "endColumn": 39,
              "from": "mimeToSelectionType mimeTarget selContent\n  = if mimeTarget == unsafeIndex mimesPriorities 0 then\n        PNG selContent\n    else\n        if mimeTarget == unsafeIndex mimesPriorities 1 then\n            JPEG selContent\n        else\n            if mimeTarget == unsafeIndex mimesPriorities 2 then\n                BITMAP selContent\n            else\n                UTF8 $ decodeUtf8 selContent",
              "to": "mimeToSelectionType mimeTarget selContent\n  | mimeTarget == unsafeIndex mimesPriorities 0 = PNG selContent\n  | mimeTarget == unsafeIndex mimesPriorities 1 = JPEG selContent\n  | mimeTarget == unsafeIndex mimesPriorities 2 = BITMAP selContent\n  | otherwise = UTF8 $ decodeUtf8 selContent",
              "note": [],
              "refactorings": "[Replace {rtype = Match, pos = SrcSpan {startLine = 169, startCol = 4, endLine = 173, endCol = 39}, subts = [(\"p1001\",SrcSpan {startLine = 169, startCol = 24, endLine = 169, endCol = 34}),(\"p1002\",SrcSpan {startLine = 169, startCol = 35, endLine = 169, endCol = 45}),(\"g1001\",SrcSpan {startLine = 170, startCol = 14, endLine = 170, endCol = 57}),(\"g1002\",SrcSpan {startLine = 171, startCol = 14, endLine = 171, endCol = 57}),(\"g1003\",SrcSpan {startLine = 172, startCol = 14, endLine = 172, endCol = 57}),(\"e1001\",SrcSpan {startLine = 170, startCol = 63, endLine = 170, endCol = 77}),(\"e1002\",SrcSpan {startLine = 171, startCol = 63, endLine = 171, endCol = 78}),(\"e1003\",SrcSpan {startLine = 172, startCol = 63, endLine = 172, endCol = 80}),(\"e1004\",SrcSpan {startLine = 173, startCol = 11, endLine = 173, endCol = 39})], orig = \"mimeToSelectionType p1001 p1002\\n  | g1001 = e1001\\n  | g1002 = e1002\\n  | g1003 = e1003\\n  | otherwise = e1004\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_89/static_refactored/src/Clipboard.hs",
            "llm_only_refactored_file": "/tmp/project_89/llm_only_refactored/src/Clipboard.hs",
            "hybrid_refactored_file": "/tmp/project_89/hybrid_refactored/src/Clipboard.hs"
          }
        },
        {
          "file_name": "/tmp/project_89/pre_refactor/src/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 7,
            "average": 3,
            "sum": 51
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 5,
            "suggestion": 4,
            "ignore": 0,
            "total": 9
          },
          "syntax_errors": 20,
          "lines_of_code": 336,
          "homplexity_lines_of_code": 335,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 7,
              "average": 3,
              "sum": 51
            },
            "homplexity_loc": 335,
            "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"configCodec\": 1,\n    \"readFile\": 1,\n    \"getHistory\": 2,\n    \"getStaticHistory\": 1,\n    \"storeHistory\": 1,\n    \"pruneHistory\": 2,\n    \"appendToHistory\": 7,\n    \"setHistoryFilePermission\": 2,\n    \"prepareDirs\": 1,\n    \"runDaemon\": 2,\n    \"toRofiStr\": 6,\n    \"fromRofiStr\": 5,\n    \"getHash\": 1,\n    \"printHistoryForRofi\": 1,\n    \"advertiseSelection\": 1,\n    \"getConfig\": 3,\n    \"parseArgs\": 6,\n    \"run\": 6,\n    \"main\": 2,\n    \"min\": 1,\n    \"max\": 7,\n    \"average\": 2.6842105263157894,\n    \"sum\": 51\n  },\n  \"homplexity_loc\": 335,\n  \"homplexity_output\": \"\"\n}"
          },
          "original_code": "\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE ViewPatterns          #-}\n\n\nmodule Main where\n\nimport           Protolude             hiding (readFile, to, (<&>), (&), toS)\nimport           Protolude.Conv        (toS)\n\nimport           Control.Monad.Catch   (MonadCatch, catchAll)\nimport qualified Crypto.Hash.MD5       as H\nimport           Data.Binary           (decodeFile, encode)\nimport qualified Data.ByteString       as B\nimport qualified Data.ByteString.Base16 as BB\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.List             (dropWhileEnd)\nimport qualified Data.Text             as T\nimport qualified Data.Text.Encoding    as TE\nimport           Data.Vector           (Vector)\nimport qualified Data.Vector           as V\nimport           Lens.Micro\nimport           Lens.Micro.Mtl    hiding ((.=))\nimport qualified System.Directory      as Dir\nimport           System.Posix.Files    (setFileMode)\nimport           System.Environment    (lookupEnv)\nimport           System.IO             (hClose, hGetContents)\nimport           System.Timeout        (timeout)\nimport           System.Wordexp.Simple (wordexp)\n--import           System.Posix.Temp     (mkdtemp)\n\nimport Toml (TomlCodec, (.=))\nimport qualified Toml\n\nimport qualified Clipboard             as Clip\n\n\ndata Command = DAEMON | PRINT | COPY Text | CLEAR | PRUNE FilePath | HELP deriving (Show, Read)\n\ndata Config = Config\n  { maxHistoryLength           :: Int\n  , maxItemSizeBytes           :: Int\n  , historyPath                :: Text\n  , imageCachePath             :: Text\n  , usePrimarySelectionAsInput :: Bool\n  , blacklistedApps            :: [Text]\n  , trimSpaceFromSelection     :: Bool\n  , enableImageSupport         :: Bool\n  , staticHistory              :: [Text]\n  } deriving (Show, Read)\n\nconfigCodec :: TomlCodec Config\nconfigCodec = Config\n    <$> Toml.int \"max_history_length\"  .= maxHistoryLength\n    <*> Toml.int \"max_selection_size_bytes\" .= maxItemSizeBytes\n    <*> Toml.text \"history_file\" .= historyPath\n    <*> Toml.text \"image_cache_directory\" .= imageCachePath\n    <*> Toml.bool \"use_primary_selection_as_input\" .= usePrimarySelectionAsInput\n    <*> Toml.arrayOf Toml._Text  \"blacklisted_applications\" .= blacklistedApps\n    <*> Toml.bool \"trim_space_from_selection\" .= trimSpaceFromSelection\n    <*> Toml.bool \"enable_image_support\" .= enableImageSupport\n    <*> Toml.arrayOf Toml._Text  \"static_history\" .= staticHistory\n\n\ntype ClipHistory = Vector Clip.Selection\n\nreadFile :: FilePath -> IO ByteString\nreadFile filepath = bracket (openFile filepath ReadMode) hClose $ \\h -> do\n  str <- hGetContents h\n  return $! toS str\n\n\ngetHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetHistory = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ (V.fromList <$> decodeFile storePath) `catchAll` const mempty\n\n\ngetStaticHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetStaticHistory = do\n  history <- view $ to (staticHistory)\n  return . V.fromList $ Clip.Selection \"greenclip\" . Clip.UTF8 <$> history\n\n\n\nstoreHistory :: (MonadIO m, MonadReader Config m) => ClipHistory -> m ()\nstoreHistory history = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ writeH storePath history\n  where\n    writeH storePath = B.writeFile storePath . toS . encode . V.toList\n\n\npruneHistory :: (MonadIO m, MonadReader Config m) => FilePath -> m ()\npruneHistory path = do\n  targets <- liftIO $ BC.lines <$> readFile path\n  history <- getHistory\n  storeHistory $ V.filter (go targets) history\n  where\n    go ts (Clip.Selection _ (Clip.UTF8 x)) = hashText x `notElem` ts\n    go _  _                                = False\n    hashText = BB.encode . H.hash . TE.encodeUtf8\n\n\nappendToHistory :: (MonadIO m, MonadReader Config m) => Clip.Selection -> ClipHistory -> m (ClipHistory, ClipHistory)\nappendToHistory sel history' = do\n  trimSelection <- view $ to trimSpaceFromSelection\n  case sel of\n    Clip.Selection appName (Clip.UTF8 txt) -> appendGeneric (if trimSelection then Clip.Selection appName (Clip.UTF8 (T.strip txt)) else sel) history'\n    Clip.Selection _ (Clip.PNG bytes) -> appendImage Clip.PNG \".png\" bytes\n    Clip.Selection _ (Clip.JPEG bytes) -> appendImage Clip.JPEG \".jpeg\" bytes\n    Clip.Selection _ (Clip.BITMAP bytes) -> appendImage Clip.BITMAP \".bmp\" bytes\n\n\n  where\n    appendImage imgCtr extension bytes = do\n      cachePth <- view (to imageCachePath)\n      let imgHash = show $ hash bytes\n      let imgPath = toS $ cachePth <> \"/\" <> imgHash <> extension\n      _ <- liftIO $ writeImage imgPath bytes\n      appendGeneric (sel {Clip.selection = imgCtr $ toS imgHash}) history'\n\n    writeImage path bytes = do\n      fileExist <- Dir.doesFileExist path\n      if fileExist\n        then return False\n        else B.writeFile path bytes >> setFileMode path 0o600 >> return True\n\n    appendGeneric selection history =\n      if maybe False (\\sel' -> Clip.selection sel' == Clip.selection selection) (history V.!? 0)\n        then return (history, mempty)\n        else do\n          maxLen <- view $ to maxHistoryLength\n          return $ V.splitAt maxLen . V.cons selection $ V.filter (\\ori -> Clip.selection ori /= Clip.selection selection) history\n\n\nsetHistoryFilePermission :: (MonadIO m, MonadReader Config m) => m ()\nsetHistoryFilePermission = do\n  storePath <- view $ to (toS . historyPath)\n  fileExist <- liftIO $ Dir.doesFileExist storePath\n  when (not fileExist) (storeHistory mempty)\n  liftIO $ setFileMode storePath 0o600\n\nprepareDirs :: (MonadIO m, MonadReader Config m) => m ()\nprepareDirs = do\n  historyFile <- view $ to (T.unpack . historyPath)\n  imgDir <- view $ to (T.unpack . imageCachePath)\n  let dirs = [imgDir, dropWhileEnd (/= '/') historyFile]\n  mapM_ (liftIO . Dir.createDirectoryIfMissing True) dirs\n\nrunDaemon:: (MonadIO m, MonadCatch m, MonadReader Config m) => m ()\nrunDaemon = prepareDirs >> setHistoryFilePermission >> (forever $ go `catchAll` handleError)\n  where\n    _0_5sec :: Int\n    _0_5sec = 5 * 100000\n\n    _5sec :: Int\n    _5sec = 5000000\n\n    go = do\n      history <- getHistory\n      usePrimary <- view $ to usePrimarySelectionAsInput\n      enableImage <- view $ to enableImageSupport\n      cfg <- ask\n\n      liftIO $ bracket Clip.getXorgContext Clip.destroyXorgContext $ \\x11Context -> do\n        let getSelections = (getSelectionFrom (Clip.getClipboardSelection x11Context enableImage), Nothing)\n                          : [(getSelectionFrom (Clip.getPrimarySelection x11Context enableImage), Nothing) | usePrimary]\n        void $ runReaderT (innerloop getSelections history) cfg\n\n    getSelection [] = return ([], Nothing)\n    getSelection ((getSel, lastSel):getSels) = do\n      selection <- liftIO getSel\n      if fmap Clip.selection selection /= fmap Clip.selection lastSel\n         then return ((getSel, selection) : getSels, selection)\n         else getSelection getSels >>= \\(e, sel) -> return ((getSel, lastSel) : e, sel)\n\n    innerloop :: (MonadIO m, MonadReader Config m) => [(IO (Maybe Clip.Selection), Maybe Clip.Selection)] -> ClipHistory -> m ClipHistory\n    innerloop getSelections history = do\n      -- Get selection from enabled clipboards\n      (getSelections', rawSelection) <- liftIO $ getSelection getSelections\n\n      -- Do not store selection items above threshold size\n      maxItemSize <- view (to maxItemSizeBytes)\n      let sel = case rawSelection of\n            Nothing -> Nothing\n            Just selection -> if maxItemSize > 0 && Clip.selectionLength selection >= maxItemSize\n                              then Nothing\n                              else Just selection\n             \n      -- Do not use selection coming from blacklisted app\n      liftIO $ when (isJust sel) (print (Clip.appName <$> sel))\n      blacklist <- view (to blacklistedApps)\n      let selection = sel >>= \\s -> if isJust $ find (== Clip.appName s) blacklist\n                                      then Nothing\n                                      else Just s\n\n      -- Append current selection to history and get back entries needed to be purged\n      (history', toBePurged) <- maybe (return (history, mempty)) (`appendToHistory` history) selection\n      traverse_ purgeSelection toBePurged\n\n      -- backup on disk history if it as changed seen last backup\n      when (isJust selection && history' /= history) (storeHistory history')\n\n      -- Getting some rest\n      liftIO $ threadDelay _0_5sec\n      innerloop getSelections' history'\n\n    getSelectionFrom :: IO (Maybe Clip.Selection) -> IO (Maybe Clip.Selection)\n    getSelectionFrom = fmap join . timeout _5sec\n\n    purgeSelection (Clip.Selection _ (Clip.PNG txt)) = purge (toS txt <> \".png\")\n    purgeSelection (Clip.Selection _ (Clip.JPEG txt)) = purge (toS txt <> \".jpeg\")\n    purgeSelection (Clip.Selection _ (Clip.BITMAP txt)) = purge (toS txt <> \".bmp\")\n    purgeSelection _ = return ()\n\n    purge path = do\n      cachePth <- view (to imageCachePath)\n      liftIO $ Dir.removeFile (toS $ cachePth <> \"/\" <> path) `catchAll` const mempty\n\n    handleError ex = do\n      let displayMissing = \"openDisplay\" `T.isInfixOf` show ex\n      if displayMissing\n      then panic \"X display not available. Please start Xorg before running greenclip\"\n      else print ex\n      liftIO $ threadDelay _0_5sec\n\n\ntoRofiStr :: Clip.Selection -> Text\ntoRofiStr (Clip.Selection _ (Clip.UTF8 txt)) = T.map (\\c -> if c == '\\n' || c == '\\r' then '\\xA0' else c) txt\ntoRofiStr (Clip.Selection appName (Clip.PNG txt)) = \"image/png \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.JPEG txt)) = \"image/jpeg \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.BITMAP txt)) = \"image/bmp \" <> appName <> \" \" <> toS txt\n\nfromRofiStr :: Text -> Text -> IO Clip.Selection\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/png \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".png\") <&> Clip.Selection \"greenclip\" . Clip.PNG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/jpeg \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".jpeg\") <&> Clip.Selection \"greenclip\" . Clip.JPEG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/bmp \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".bmp\") <&> Clip.Selection \"greenclip\" . Clip.BITMAP\nfromRofiStr _ txt = return $ Clip.Selection \"greenclip\" (Clip.UTF8 (T.map (\\c -> if c == '\\xA0' then '\\n' else c) txt))\n\ngetHash :: Text -> Text\ngetHash = fromMaybe mempty . lastMay . T.split (== ' ')\n\n\nprintHistoryForRofi :: (MonadIO m, MonadReader Config m) => m ()\nprintHistoryForRofi = do\n  history <- mappend <$> getHistory <*> getStaticHistory\n  _ <- traverse (putStrLn . toRofiStr) history\n  return ()\n\n\nadvertiseSelection :: (MonadIO m, MonadReader Config m) => Text -> m ()\nadvertiseSelection txt = do\n  cachePth <- view (to imageCachePath)\n  selection <- liftIO $ fromRofiStr cachePth txt\n  liftIO $ Clip.setClipboardSelection selection\n\n\ngetConfig :: IO Config\ngetConfig = do\n  home <- Dir.getHomeDirectory\n  let configPath = home <> \"/.config/greenclip.toml\"\n  \n  configExist <- Dir.doesFileExist configPath\n  when (not configExist) $ do \n    config <- Toml.encode (Toml.table configCodec \"greenclip\") <$> defaultConfig\n    writeFile configPath config\n    return ()\n  \n  tomlRes <- Toml.decodeFileEither (Toml.table configCodec \"greenclip\") configPath\n  when (isLeft tomlRes) $ do\n    die . toS $  \"Error parsing the config file at \" <> (show configPath) <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n  \n  let cfg = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes \n  \n  -- Replace $HOME|~|*... in config path\n  cfg <- do\n    imgCachePath <- wordexp . toS $ imageCachePath cfg\n    historyP <- wordexp . toS $ historyPath cfg \n    return $ cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP)}\n    \n  -- if it ends with / we don't create a temp directory\n  -- user is responsible for it\n  -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n  --    then do\n  --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n  --      return $ cfg { imageCachePath = toS dirPath }\n  --    else return cfg\n     \n  return cfg\n\n  where\n    defaultConfig = do \n      homeDir <- toS . fromMaybe mempty . listToMaybe <$> wordexp \"~/\"\n      return $ Config 50 0 (homeDir <> \".cache/greenclip.history\") \"/tmp/greenclip\" False [] True True \n        [\"Greenclip has been updated to v4.1, update your new config file at ~/.config/greenclip.toml\"]\n\n\nparseArgs :: [Text] -> Command\nparseArgs (\"daemon\":_)   = DAEMON\nparseArgs [\"clear\"]      = CLEAR\nparseArgs [\"prune\", p]   = PRUNE $ T.unpack p\nparseArgs [\"print\"]      = PRINT\nparseArgs [\"print\", sel] = COPY sel\nparseArgs _              = HELP\n\nrun :: Command -> IO ()\nrun cmd = do\n  cfg <- getConfig\n  case cmd of\n    DAEMON   -> runReaderT runDaemon cfg\n    PRINT    -> runReaderT printHistoryForRofi cfg\n    CLEAR    -> runReaderT (storeHistory mempty) cfg\n    PRUNE p  -> runReaderT (pruneHistory p) cfg\n    -- Should rename COPY into ADVERTISE but as greenclip is already used I don't want to break configs\n    -- of other people\n    COPY sel -> runReaderT (advertiseSelection sel) cfg\n    HELP     -> putText $ \"greenclip v4.3 -- Recyle your clipboard selections\\n\\n\" <>\n                          \"Available commands\\n\" <>\n                          \"daemon: Spawn the daemon that will listen to selections\\n\" <>\n                          \"print:  Display all selections history\\n\" <>\n                          \"prune FILE: Remove selections in list of md5 hashes in FILE\\n\" <>\n                          \"clear:  Clear history\\n\" <>\n                          \"help:   Display this message\\n\"\n\nmain :: IO ()\nmain = do\n  displayPresent <- lookupEnv \"DISPLAY\"\n  case displayPresent of\n    Nothing -> putText \"X display not available. Please start Xorg before running greenclip\"\n    _       -> getArgs >>= run . parseArgs . fmap toS\n",
          "suggestions": [
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getStaticHistory"
              ],
              "severity": "Warning",
              "hint": "Redundant bracket",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 86,
              "startColumn": 24,
              "endLine": 86,
              "endColumn": 39,
              "from": "(staticHistory)",
              "to": "staticHistory",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 86, startCol = 24, endLine = 86, endCol = 39}, subts = [(\"x\",SrcSpan {startLine = 86, startCol = 25, endLine = 86, endCol = 38})], orig = \"x\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "setHistoryFilePermission"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 146,
              "startColumn": 3,
              "endLine": 146,
              "endColumn": 23,
              "from": "when (not fileExist)",
              "to": "unless fileExist",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 146, startCol = 3, endLine = 146, endCol = 23}, subts = [(\"x\",SrcSpan {startLine = 146, startCol = 13, endLine = 146, endCol = 22})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "runDaemon"
              ],
              "severity": "Suggestion",
              "hint": "Move brackets to avoid $",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 157,
              "startColumn": 13,
              "endLine": 157,
              "endColumn": 93,
              "from": "prepareDirs >> setHistoryFilePermission\n  >> (forever $ go `catchAll` handleError)",
              "to": "prepareDirs >> setHistoryFilePermission\n  >> forever (go `catchAll` handleError)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 157, startCol = 56, endLine = 157, endCol = 93}, subts = [(\"a\",SrcSpan {startLine = 157, startCol = 57, endLine = 157, endCol = 64}),(\"b\",SrcSpan {startLine = 157, startCol = 67, endLine = 157, endCol = 92})], orig = \"a (b)\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "printHistoryForRofi"
              ],
              "severity": "Warning",
              "hint": "Use traverse_",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 253,
              "startColumn": 8,
              "endLine": 253,
              "endColumn": 47,
              "from": "traverse (putStrLn . toRofiStr) history",
              "to": "traverse_ (putStrLn . toRofiStr) history",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 253, startCol = 8, endLine = 253, endCol = 16}, subts = [], orig = \"traverse_\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getConfig"
              ],
              "severity": "Warning",
              "hint": "Redundant return",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 265,
              "startColumn": 13,
              "endLine": 295,
              "endColumn": 13,
              "from": "do home <- Dir.getHomeDirectory\n   let configPath = home <> \"/.config/greenclip.toml\"\n   configExist <- Dir.doesFileExist configPath\n   when (not configExist)\n     $ do config <- Toml.encode (Toml.table configCodec \"greenclip\")\n                      <$> defaultConfig\n          writeFile configPath config\n          return ()\n   tomlRes <- Toml.decodeFileEither\n                (Toml.table configCodec \"greenclip\") configPath\n   when (isLeft tomlRes)\n     $ do die . toS\n            $ \"Error parsing the config file at \"\n                <>\n                  (show configPath)\n                    <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n   let cfg\n         = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes\n   cfg <- do imgCachePath <- wordexp . toS $ imageCachePath cfg\n             historyP <- wordexp . toS $ historyPath cfg\n             return\n               $ cfg\n                   {imageCachePath = (toS $ headDef \"\" imgCachePath),\n                    historyPath = (toS $ headDef \"\" historyP)}\n   return cfg",
              "to": "do home <- Dir.getHomeDirectory\n   let configPath = home <> \"/.config/greenclip.toml\"\n   configExist <- Dir.doesFileExist configPath\n   when (not configExist)\n     $ do config <- Toml.encode (Toml.table configCodec \"greenclip\")\n                      <$> defaultConfig\n          writeFile configPath config\n          return ()\n   tomlRes <- Toml.decodeFileEither\n                (Toml.table configCodec \"greenclip\") configPath\n   when (isLeft tomlRes)\n     $ do die . toS\n            $ \"Error parsing the config file at \"\n                <>\n                  (show configPath)\n                    <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n   let cfg\n         = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes\n   do imgCachePath <- wordexp . toS $ imageCachePath cfg\n      historyP <- wordexp . toS $ historyPath cfg\n      return\n        $ cfg\n            {imageCachePath = (toS $ headDef \"\" imgCachePath),\n             historyPath = (toS $ headDef \"\" historyP)}",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 282, startCol = 3, endLine = 285, endCol = 112}, subts = [(\"x\",SrcSpan {startLine = 282, startCol = 10, endLine = 285, endCol = 112})], orig = \"x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 295, startCol = 3, endLine = 295, endCol = 13}}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getConfig"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 270,
              "startColumn": 3,
              "endLine": 270,
              "endColumn": 25,
              "from": "when (not configExist)",
              "to": "unless configExist",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 270, startCol = 3, endLine = 270, endCol = 25}, subts = [(\"x\",SrcSpan {startLine = 270, startCol = 13, endLine = 270, endCol = 24})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getConfig"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 277,
              "startColumn": 57,
              "endLine": 277,
              "endColumn": 74,
              "from": "(show configPath)\n  <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)",
              "to": "show configPath\n  <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 277, startCol = 57, endLine = 277, endCol = 74}, subts = [(\"x\",SrcSpan {startLine = 277, startCol = 58, endLine = 277, endCol = 73})], orig = \"x\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getConfig"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 285,
              "startColumn": 37,
              "endLine": 285,
              "endColumn": 68,
              "from": "cfg\n  {imageCachePath = (toS $ headDef \"\" imgCachePath),\n   historyPath = (toS $ headDef \"\" historyP)}",
              "to": "cfg\n  {imageCachePath = toS $ headDef \"\" imgCachePath,\n   historyPath = (toS $ headDef \"\" historyP)}",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 285, startCol = 37, endLine = 285, endCol = 68}, subts = [(\"x\",SrcSpan {startLine = 285, startCol = 38, endLine = 285, endCol = 67})], orig = \"x\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "getConfig"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_89/pre_refactor/src/Main.hs",
              "startLine": 285,
              "startColumn": 84,
              "endLine": 285,
              "endColumn": 111,
              "from": "cfg\n  {imageCachePath = (toS $ headDef \"\" imgCachePath),\n   historyPath = (toS $ headDef \"\" historyP)}",
              "to": "cfg\n  {imageCachePath = (toS $ headDef \"\" imgCachePath),\n   historyPath = toS $ headDef \"\" historyP}",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 285, startCol = 84, endLine = 285, endCol = 111}, subts = [(\"x\",SrcSpan {startLine = 285, startCol = 85, endLine = 285, endCol = 110})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_89/static_refactored/src/Main.hs",
            "llm_only_refactored_file": "/tmp/project_89/llm_only_refactored/src/Main.hs",
            "hybrid_refactored_file": "/tmp/project_89/hybrid_refactored/src/Main.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 10,
              "average": 41.5,
              "sum": 83
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 2,
              "suggestion": 0,
              "ignore": 0,
              "total": 2
            },
            "syntax_errors": 32,
            "lines_of_code": 633,
            "homplexity_lines_of_code": 633,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "63MB",
              "runtime": "1.17 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_89/pre_refactor/src/Clipboard.hs",
              "refactored_file_name": "/tmp/project_89/static_refactored/src/Clipboard.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 35
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 297,
              "homplexity_lines_of_code": 296,
              "code_quality_score": 0.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 35
                },
                "homplexity_loc": 296,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"selectionLength\": 4,\n        \"test\": 1,\n        \"windowNameOfClipboardOwner\": 2,\n        \"isIncrementalTransfert\": 2,\n        \"getSupportedMimes\": 2,\n        \"getClipboardSelection\": 1,\n        \"getPrimarySelection\": 1,\n        \"getSelection\": 4,\n        \"getXorgContext\": 1,\n        \"destroyXorgContext\": 1,\n        \"waitNotify\": 1,\n        \"setClipboardSelection\": 1,\n        \"selectionTypeToMime\": 4,\n        \"getContent\": 4,\n        \"advertiseSelection\": 1,\n        \"handleRequest\": 3,\n        \"sendSelectionNotify\": 1,\n        \"byteStringToCUChars\": 1,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 1.94,\n        \"sum\": 35\n    },\n    \"homplexity_loc\": 296,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n\nmodule Clipboard where\n\nimport           Protolude                hiding ((<&>))\nimport           Protolude.Unsafe                   (unsafeIndex)\nimport qualified Protolude.Conv as StrConvOld\n\nimport           Graphics.X11.Xlib\nimport           Graphics.X11.Xlib.Extras\n\nimport           Data.Binary              (Binary)\nimport qualified Data.ByteString          as B\nimport qualified Data.Text as T\nimport           Lens.Micro\n\nimport           System.Directory         (setCurrentDirectory)\nimport           System.IO                (hClose)\nimport           System.Posix.Process     (forkProcess)\n\nimport           Data.ByteString          (unpack)\nimport           Foreign                  (alloca, castPtr, peek, peekArray)\nimport           Foreign.C.Types          (CUChar)\nimport           Foreign.Marshal.Array    (withArrayLen)\n\ndata SelectionType = UTF8 Text\n                   | PNG ByteString\n                   | JPEG ByteString\n                   | BITMAP ByteString\n                   deriving (Show, Eq, Generic, Binary)\n\nselectionLength :: Selection -> Int\nselectionLength (Selection _ (UTF8 a)) = T.length a\nselectionLength (Selection _ (PNG a)) = B.length a\nselectionLength (Selection _ (JPEG a)) = B.length a\nselectionLength (Selection _ (BITMAP a)) = B.length a\n\n\ndata Selection = Selection {\n    appName   :: Text\n  , selection :: SelectionType\n} deriving (Show, Eq, Generic, Binary)\n\ndata XorgContext = XorgContext {\n    display          :: Display\n  , ownWindow        :: Window\n  , defaultClipboard :: Atom\n  , primaryClipboard :: Atom\n  , selectionTarget  :: Atom\n  , mimesPriorities  :: [Atom]\n  , defaultMime      :: Atom\n} deriving (Show)\n\ntest :: IO ()\ntest =\n  bracket getXorgContext destroyXorgContext $ \\ctx -> do\n    ret <- getPrimarySelection ctx True\n    print $! ret\n    return ()\n\nwindowNameOfClipboardOwner :: XorgContext -> Atom -> IO Text\nwindowNameOfClipboardOwner XorgContext{..} clipboard = do\n\n  window <- xGetSelectionOwner display clipboard\n\n  if window > 0\n    then fetchName display window <&> toS . fromMaybe mempty\n    else return mempty\n\n\nisIncrementalTransfert :: XorgContext -> IO Bool\nisIncrementalTransfert XorgContext{..}  =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        incr <- internAtom display \"INCR\" False\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0 False anyPropertyType\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        if ret /= 0\n           then return False\n        else do\n            actual_type   <- peek actual_type_return <&> fromIntegral :: IO Atom\n            _ <- peek prop_return >>= xFree\n            return $ actual_type == incr\n\ngetSupportedMimes :: XorgContext -> Atom -> IO [Atom]\ngetSupportedMimes ctx@XorgContext{..} clipboard =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        targets <- internAtom display \"TARGETS\" False\n        xConvertSelection display clipboard targets selectionTarget ownWindow currentTime\n        _ <- waitNotify ctx\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0xFFFFFFFF False aTOM\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        ret2 <- if ret /= 0\n                then return Nothing\n                else do\n                    prop_ptr      <- peek prop_return\n                    actual_format <- peek actual_format_return <&> fromIntegral :: IO Atom\n                    nitems        <- peek nitems_return <&> fromIntegral\n                    getprop prop_ptr nitems actual_format\n        return $ fromMaybe mempty ret2\n\n  where\n    getprop prop_ptr nitems actual_format\n        | actual_format == 0    = return Nothing -- Property not found\n        | otherwise = do\n            retval <- peekArray nitems (castPtr prop_ptr)\n            _ <- xFree prop_ptr\n            return $ Just retval\n\n\ngetClipboardSelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetClipboardSelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage defaultClipboard\n\ngetPrimarySelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetPrimarySelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage primaryClipboard\n\ngetSelection :: XorgContext -> Bool -> Atom -> IO (Maybe Selection)\ngetSelection ctx@XorgContext{..} enableImage clipboard = do\n  mimes <- if enableImage \n            then getSupportedMimes ctx clipboard \n            else return [defaultMime] \n  let targetMime = chooseSelectionType mimes\n\n  xConvertSelection display clipboard targetMime selectionTarget ownWindow currentTime\n  waitNotify ctx\n  isIncremental <- isIncrementalTransfert ctx\n  clipboardContent <- if isIncremental\n                      then return mempty -- Incremental use too much CPU, do not handle it\n                      else getWindowProperty8 display selectionTarget ownWindow\n                           <&> B.pack . map fromIntegral . fromMaybe mempty\n\n  if clipboardContent == mempty\n  then return Nothing\n  else do\n    windowName <- windowNameOfClipboardOwner ctx clipboard\n    return $ Just Selection { appName = windowName\n                            , selection = mimeToSelectionType targetMime clipboardContent\n                            }\n\n where\n   chooseSelectionType mimes =\n     let selectedMime = msum $ (\\mime -> find (== mime) mimes) <$> mimesPriorities\n     in fromMaybe defaultMime selectedMime\n\n   mimeToSelectionType mimeTarget selContent =\n     if      mimeTarget == unsafeIndex mimesPriorities 0 then PNG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 1 then JPEG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 2 then BITMAP selContent\n     else UTF8 $ decodeUtf8 selContent\n\n   -- getContentIncrementally acc = do\n   --   _ <- xDeleteProperty display ownWindow selectionTarget\n   --   flush display\n   --   waitNotify ctx\n   --   content <- getWindowProperty8 display selectionTarget ownWindow\n   --              <&> B.pack . map fromIntegral . fromMaybe mempty\n   --   if content == mempty\n   --      then return acc\n   --      else getContentIncrementally (acc <> content)\n\n\ngetXorgContext :: IO XorgContext\ngetXorgContext = do\n    display <- openDisplay mempty\n    window <- createSimpleWindow display (defaultRootWindow display) 0 0 1 1 0 0 0\n    -- selectInput display window propertyChangeMask\n\n    clipboard <- internAtom display \"CLIPBOARD\" False\n    selTarget <- internAtom display \"GREENCLIP\" False\n    priorities <- traverse (\\atomName -> internAtom display atomName False) [\"image/png\", \"image/jpeg\", \"image/bmp\", \"UTF8_STRING\", \"TEXT\"] \n    defaultM <- internAtom display \"UTF8_STRING\" False\n    return XorgContext {\n        display = display\n      , ownWindow = window\n      , defaultClipboard = clipboard\n      , primaryClipboard = pRIMARY\n      , selectionTarget = selTarget\n      , mimesPriorities = priorities\n      , defaultMime = defaultM\n    }\n\ndestroyXorgContext :: XorgContext -> IO ()\ndestroyXorgContext XorgContext{..} = do\n    destroyWindow display ownWindow\n    closeDisplay display\n\nwaitNotify :: XorgContext -> IO ()\nwaitNotify XorgContext{..} = allocaXEvent (go display ownWindow)\n  where\n  go display' window evPtr = do\n    waitForEvents display'\n    nextEvent display' evPtr\n    ev <- getEvent evPtr\n    when (ev_event_type ev /= selectionNotify\n          &&  not (ev_event_type ev == propertyNotify && ev_atom ev == selectionTarget && ev_propstate ev == 1))\n      (go display' window evPtr)\n\n  waitForEvents display' = do\n    nbEvs <- pending display'\n    when (nbEvs == 0) $ threadDelay _10ms >> waitForEvents display'\n\n  _10ms = 10000\n\n\n\nsetClipboardSelection :: Selection -> IO ()\nsetClipboardSelection sel = void $ forkProcess $ do\n        mapM_ hClose [stdin, stdout, stderr]\n        setCurrentDirectory \"/\"\n        bracket getXorgContext destroyXorgContext $ \\ctx@XorgContext{..} -> do\n          let clipboards = [defaultClipboard, primaryClipboard]\n          mapM_ (\\atom -> xSetSelectionOwner display atom ownWindow currentTime) clipboards\n          advertiseSelection ctx sel\n          return ()\n\n\nselectionTypeToMime :: SelectionType -> ByteString\nselectionTypeToMime (PNG _)    = \"image/png\"\nselectionTypeToMime (JPEG _)   = \"image/jpeg\"\nselectionTypeToMime (BITMAP _) = \"image/bmp\"\nselectionTypeToMime (UTF8 _)   = \"UTF8_STRING\"\n\ngetContent :: SelectionType -> ByteString\ngetContent (PNG bytes)    = bytes\ngetContent (JPEG bytes)   = bytes\ngetContent (BITMAP bytes) = bytes\ngetContent (UTF8 txt)     = encodeUtf8 txt\n\nadvertiseSelection :: XorgContext -> Selection ->  IO ()\nadvertiseSelection ctx@XorgContext{..} sel = allocaXEvent (go [defaultClipboard, primaryClipboard])\n  where\n    go [] _ = return ()\n    go clipboards evPtr = do\n      nextEvent display evPtr\n      ev <- getEvent evPtr\n      case ev of\n          SelectionRequest {..} -> do\n              target' <- getAtomName display ev_target\n              response <- case target' of\n                Nothing -> return none\n                Just atomName -> handleRequest ctx (selection sel) ev_requestor ev_property (toS atomName)\n\n              sendSelectionNotify display ev_requestor ev_selection ev_target response ev_time\n              go clipboards evPtr\n\n          SelectionClear{..} -> go (filter (/= ev_selection) clipboards) evPtr\n\n          _ -> go clipboards evPtr\n\nhandleRequest :: XorgContext -> SelectionType -> Window -> Atom -> Text -> IO Atom\nhandleRequest XorgContext{..} sel requestorWindow selection \"TARGETS\" = do\n  targets <- internAtom display \"TARGETS\" True\n  target <- internAtom display (StrConvOld.toS $ selectionTypeToMime sel) True\n  changeProperty32 display requestorWindow selection aTOM propModeReplace [fromIntegral targets, fromIntegral target]\n  return selection\n\nhandleRequest XorgContext{..} sel req prop targetStr =\n  if targetStr == decodeUtf8 (selectionTypeToMime sel)\n    then do\n      target <- internAtom display (toS targetStr) True\n      void $ withArrayLen (byteStringToCUChars $ getContent sel) $ \\len bytes ->\n          xChangeProperty display req prop target 8 propModeReplace bytes (fromIntegral len)\n      return prop\n    else return none\n\nsendSelectionNotify :: Display -> Window -> Atom -> Atom -> Atom -> Time -> IO ()\nsendSelectionNotify display req sel target prop time = allocaXEvent $ \\ev -> do\n  setEventType ev selectionNotify\n  setSelectionNotify ev req sel target prop time\n  sendEvent display req False 0 ev\n\nbyteStringToCUChars :: ByteString -> [CUChar]\nbyteStringToCUChars = map fromIntegral . unpack\n",
              "suggestions": [
                {
                  "location": "/tmp/project_89/pre_refactor/src/Clipboard.hs:(169,4)-(173,38)",
                  "suggestion_title": "Use guards",
                  "found_block": [
                    "  mimeToSelectionType mimeTarget selContent",
                    "    = if mimeTarget == unsafeIndex mimesPriorities 0 then",
                    "          PNG selContent",
                    "      else",
                    "          if mimeTarget == unsafeIndex mimesPriorities 1 then",
                    "              JPEG selContent",
                    "          else",
                    "              if mimeTarget == unsafeIndex mimesPriorities 2 then",
                    "                  BITMAP selContent",
                    "              else",
                    "                  UTF8 $ decodeUtf8 selContent"
                  ],
                  "perhaps_block": [
                    "  mimeToSelectionType mimeTarget selContent",
                    "    | mimeTarget == unsafeIndex mimesPriorities 0 = PNG selContent",
                    "    | mimeTarget == unsafeIndex mimesPriorities 1 = JPEG selContent",
                    "    | mimeTarget == unsafeIndex mimesPriorities 2 = BITMAP selContent",
                    "    | otherwise = UTF8 $ decodeUtf8 selContent"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n\nmodule Clipboard where\n\nimport           Protolude                hiding ((<&>))\nimport           Protolude.Unsafe                   (unsafeIndex)\nimport qualified Protolude.Conv as StrConvOld\n\nimport           Graphics.X11.Xlib\nimport           Graphics.X11.Xlib.Extras\n\nimport           Data.Binary              (Binary)\nimport qualified Data.ByteString          as B\nimport qualified Data.Text as T\nimport           Lens.Micro\n\nimport           System.Directory         (setCurrentDirectory)\nimport           System.IO                (hClose)\nimport           System.Posix.Process     (forkProcess)\n\nimport           Data.ByteString          (unpack)\nimport           Foreign                  (alloca, castPtr, peek, peekArray)\nimport           Foreign.C.Types          (CUChar)\nimport           Foreign.Marshal.Array    (withArrayLen)\n\ndata SelectionType = UTF8 Text\n                   | PNG ByteString\n                   | JPEG ByteString\n                   | BITMAP ByteString\n                   deriving (Show, Eq, Generic, Binary)\n\nselectionLength :: Selection -> Int\nselectionLength (Selection _ (UTF8 a)) = T.length a\nselectionLength (Selection _ (PNG a)) = B.length a\nselectionLength (Selection _ (JPEG a)) = B.length a\nselectionLength (Selection _ (BITMAP a)) = B.length a\n\n\ndata Selection = Selection {\n    appName   :: Text\n  , selection :: SelectionType\n} deriving (Show, Eq, Generic, Binary)\n\ndata XorgContext = XorgContext {\n    display          :: Display\n  , ownWindow        :: Window\n  , defaultClipboard :: Atom\n  , primaryClipboard :: Atom\n  , selectionTarget  :: Atom\n  , mimesPriorities  :: [Atom]\n  , defaultMime      :: Atom\n} deriving (Show)\n\ntest :: IO ()\ntest =\n  bracket getXorgContext destroyXorgContext $ \\ctx -> do\n    ret <- getPrimarySelection ctx True\n    print $! ret\n    return ()\n\nwindowNameOfClipboardOwner :: XorgContext -> Atom -> IO Text\nwindowNameOfClipboardOwner XorgContext{..} clipboard = do\n\n  window <- xGetSelectionOwner display clipboard\n\n  if window > 0\n    then fetchName display window <&> toS . fromMaybe mempty\n    else return mempty\n\n\nisIncrementalTransfert :: XorgContext -> IO Bool\nisIncrementalTransfert XorgContext{..}  =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        incr <- internAtom display \"INCR\" False\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0 False anyPropertyType\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        if ret /= 0\n           then return False\n        else do\n            actual_type   <- peek actual_type_return <&> fromIntegral :: IO Atom\n            _ <- peek prop_return >>= xFree\n            return $ actual_type == incr\n\ngetSupportedMimes :: XorgContext -> Atom -> IO [Atom]\ngetSupportedMimes ctx@XorgContext{..} clipboard =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        targets <- internAtom display \"TARGETS\" False\n        xConvertSelection display clipboard targets selectionTarget ownWindow currentTime\n        _ <- waitNotify ctx\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0xFFFFFFFF False aTOM\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        ret2 <- if ret /= 0\n                then return Nothing\n                else do\n                    prop_ptr      <- peek prop_return\n                    actual_format <- peek actual_format_return <&> fromIntegral :: IO Atom\n                    nitems        <- peek nitems_return <&> fromIntegral\n                    getprop prop_ptr nitems actual_format\n        return $ fromMaybe mempty ret2\n\n  where\n    getprop prop_ptr nitems actual_format\n        | actual_format == 0    = return Nothing -- Property not found\n        | otherwise = do\n            retval <- peekArray nitems (castPtr prop_ptr)\n            _ <- xFree prop_ptr\n            return $ Just retval\n\n\ngetClipboardSelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetClipboardSelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage defaultClipboard\n\ngetPrimarySelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetPrimarySelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage primaryClipboard\n\ngetSelection :: XorgContext -> Bool -> Atom -> IO (Maybe Selection)\ngetSelection ctx@XorgContext{..} enableImage clipboard = do\n  mimes <- if enableImage\n            then getSupportedMimes ctx clipboard\n            else return [defaultMime]\n  let targetMime = chooseSelectionType mimes\n\n  xConvertSelection display clipboard targetMime selectionTarget ownWindow currentTime\n  waitNotify ctx\n  isIncremental <- isIncrementalTransfert ctx\n  clipboardContent <- if isIncremental\n                      then return mempty -- Incremental use too much CPU, do not handle it\n                      else getWindowProperty8 display selectionTarget ownWindow\n                           <&> B.pack . map fromIntegral . fromMaybe mempty\n\n  if clipboardContent == mempty\n  then return Nothing\n  else do\n    windowName <- windowNameOfClipboardOwner ctx clipboard\n    return $ Just Selection { appName = windowName\n                            , selection = mimeToSelectionType targetMime clipboardContent\n                            }\n\n where\n   chooseSelectionType mimes =\n     let selectedMime = msum $ (\\mime -> find (== mime) mimes) <$> mimesPriorities\n     in fromMaybe defaultMime selectedMime\n\n   mimeToSelectionType mimeTarget selContent\n     | mimeTarget == unsafeIndex mimesPriorities 0 = PNG selContent\n     | mimeTarget == unsafeIndex mimesPriorities 1 = JPEG selContent\n     | mimeTarget == unsafeIndex mimesPriorities 2 = BITMAP selContent\n     | otherwise = UTF8 $ decodeUtf8 selContent\n\n   -- getContentIncrementally acc = do\n   --   _ <- xDeleteProperty display ownWindow selectionTarget\n   --   flush display\n   --   waitNotify ctx\n   --   content <- getWindowProperty8 display selectionTarget ownWindow\n   --              <&> B.pack . map fromIntegral . fromMaybe mempty\n   --   if content == mempty\n   --      then return acc\n   --      else getContentIncrementally (acc <> content)\n\n\ngetXorgContext :: IO XorgContext\ngetXorgContext = do\n    display <- openDisplay mempty\n    window <- createSimpleWindow display (defaultRootWindow display) 0 0 1 1 0 0 0\n    -- selectInput display window propertyChangeMask\n\n    clipboard <- internAtom display \"CLIPBOARD\" False\n    selTarget <- internAtom display \"GREENCLIP\" False\n    priorities <- traverse (\\atomName -> internAtom display atomName False) [\"image/png\", \"image/jpeg\", \"image/bmp\", \"UTF8_STRING\", \"TEXT\"]\n    defaultM <- internAtom display \"UTF8_STRING\" False\n    return XorgContext {\n        display = display\n      , ownWindow = window\n      , defaultClipboard = clipboard\n      , primaryClipboard = pRIMARY\n      , selectionTarget = selTarget\n      , mimesPriorities = priorities\n      , defaultMime = defaultM\n    }\n\ndestroyXorgContext :: XorgContext -> IO ()\ndestroyXorgContext XorgContext{..} = do\n    destroyWindow display ownWindow\n    closeDisplay display\n\nwaitNotify :: XorgContext -> IO ()\nwaitNotify XorgContext{..} = allocaXEvent (go display ownWindow)\n  where\n  go display' window evPtr = do\n    waitForEvents display'\n    nextEvent display' evPtr\n    ev <- getEvent evPtr\n    when (ev_event_type ev /= selectionNotify\n          &&  not (ev_event_type ev == propertyNotify && ev_atom ev == selectionTarget && ev_propstate ev == 1))\n      (go display' window evPtr)\n\n  waitForEvents display' = do\n    nbEvs <- pending display'\n    when (nbEvs == 0) $ threadDelay _10ms >> waitForEvents display'\n\n  _10ms = 10000\n\n\n\nsetClipboardSelection :: Selection -> IO ()\nsetClipboardSelection sel = void $ forkProcess $ do\n        mapM_ hClose [stdin, stdout, stderr]\n        setCurrentDirectory \"/\"\n        bracket getXorgContext destroyXorgContext $ \\ctx@XorgContext{..} -> do\n          let clipboards = [defaultClipboard, primaryClipboard]\n          mapM_ (\\atom -> xSetSelectionOwner display atom ownWindow currentTime) clipboards\n          advertiseSelection ctx sel\n          return ()\n\n\nselectionTypeToMime :: SelectionType -> ByteString\nselectionTypeToMime (PNG _)    = \"image/png\"\nselectionTypeToMime (JPEG _)   = \"image/jpeg\"\nselectionTypeToMime (BITMAP _) = \"image/bmp\"\nselectionTypeToMime (UTF8 _)   = \"UTF8_STRING\"\n\ngetContent :: SelectionType -> ByteString\ngetContent (PNG bytes)    = bytes\ngetContent (JPEG bytes)   = bytes\ngetContent (BITMAP bytes) = bytes\ngetContent (UTF8 txt)     = encodeUtf8 txt\n\nadvertiseSelection :: XorgContext -> Selection ->  IO ()\nadvertiseSelection ctx@XorgContext{..} sel = allocaXEvent (go [defaultClipboard, primaryClipboard])\n  where\n    go [] _ = return ()\n    go clipboards evPtr = do\n      nextEvent display evPtr\n      ev <- getEvent evPtr\n      case ev of\n          SelectionRequest {..} -> do\n              target' <- getAtomName display ev_target\n              response <- case target' of\n                Nothing -> return none\n                Just atomName -> handleRequest ctx (selection sel) ev_requestor ev_property (toS atomName)\n\n              sendSelectionNotify display ev_requestor ev_selection ev_target response ev_time\n              go clipboards evPtr\n\n          SelectionClear{..} -> go (filter (/= ev_selection) clipboards) evPtr\n\n          _ -> go clipboards evPtr\n\nhandleRequest :: XorgContext -> SelectionType -> Window -> Atom -> Text -> IO Atom\nhandleRequest XorgContext{..} sel requestorWindow selection \"TARGETS\" = do\n  targets <- internAtom display \"TARGETS\" True\n  target <- internAtom display (StrConvOld.toS $ selectionTypeToMime sel) True\n  changeProperty32 display requestorWindow selection aTOM propModeReplace [fromIntegral targets, fromIntegral target]\n  return selection\n\nhandleRequest XorgContext{..} sel req prop targetStr =\n  if targetStr == decodeUtf8 (selectionTypeToMime sel)\n    then do\n      target <- internAtom display (toS targetStr) True\n      void $ withArrayLen (byteStringToCUChars $ getContent sel) $ \\len bytes ->\n          xChangeProperty display req prop target 8 propModeReplace bytes (fromIntegral len)\n      return prop\n    else return none\n\nsendSelectionNotify :: Display -> Window -> Atom -> Atom -> Atom -> Time -> IO ()\nsendSelectionNotify display req sel target prop time = allocaXEvent $ \\ev -> do\n  setEventType ev selectionNotify\n  setSelectionNotify ev req sel target prop time\n  sendEvent display req False 0 ev\n\nbyteStringToCUChars :: ByteString -> [CUChar]\nbyteStringToCUChars = map fromIntegral . unpack\n"
            },
            {
              "file_name": "/tmp/project_89/pre_refactor/src/Main.hs",
              "refactored_file_name": "/tmp/project_89/static_refactored/src/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 3,
                "sum": 48
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 0,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 20,
              "lines_of_code": 336,
              "homplexity_lines_of_code": 337,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 3,
                  "sum": 48
                },
                "homplexity_loc": 337,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"configCodec\": 1,\n    \"readFile\": 1,\n    \"getHistory\": 2,\n    \"getStaticHistory\": 1,\n    \"storeHistory\": 1,\n    \"pruneHistory\": 1,\n    \"appendToHistory\": 6,\n    \"setHistoryFilePermission\": 2,\n    \"prepareDirs\": 1,\n    \"runDaemon\": 2,\n    \"toRofiStr\": 5,\n    \"fromRofiStr\": 5,\n    \"getHash\": 1,\n    \"printHistoryForRofi\": 1,\n    \"advertiseSelection\": 1,\n    \"getConfig\": 3,\n    \"parseArgs\": 6,\n    \"run\": 6,\n    \"main\": 2,\n    \"min\": 1,\n    \"max\": 6,\n    \"average\": 2.526315789473684,\n    \"sum\": 48\n  },\n  \"homplexity_loc\": 337,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE ViewPatterns          #-}\n\n\nmodule Main where\n\nimport           Protolude             hiding (readFile, to, (<&>), (&), toS)\nimport           Protolude.Conv        (toS)\n\nimport           Control.Monad.Catch   (MonadCatch, catchAll)\nimport qualified Crypto.Hash.MD5       as H\nimport           Data.Binary           (decodeFile, encode)\nimport qualified Data.ByteString       as B\nimport qualified Data.ByteString.Base16 as BB\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.List             (dropWhileEnd)\nimport qualified Data.Text             as T\nimport qualified Data.Text.Encoding    as TE\nimport           Data.Vector           (Vector)\nimport qualified Data.Vector           as V\nimport           Lens.Micro\nimport           Lens.Micro.Mtl    hiding ((.=))\nimport qualified System.Directory      as Dir\nimport           System.Posix.Files    (setFileMode)\nimport           System.Environment    (lookupEnv)\nimport           System.IO             (hClose, hGetContents)\nimport           System.Timeout        (timeout)\nimport           System.Wordexp.Simple (wordexp)\n--import           System.Posix.Temp     (mkdtemp)\n\nimport Toml (TomlCodec, (.=))\nimport qualified Toml\n\nimport qualified Clipboard             as Clip\n\n\ndata Command = DAEMON | PRINT | COPY Text | CLEAR | PRUNE FilePath | HELP deriving (Show, Read)\n\ndata Config = Config\n  { maxHistoryLength           :: Int\n  , maxItemSizeBytes           :: Int\n  , historyPath                :: Text\n  , imageCachePath             :: Text\n  , usePrimarySelectionAsInput :: Bool\n  , blacklistedApps            :: [Text]\n  , trimSpaceFromSelection     :: Bool\n  , enableImageSupport         :: Bool\n  , staticHistory              :: [Text]\n  } deriving (Show, Read)\n\nconfigCodec :: TomlCodec Config\nconfigCodec = Config\n    <$> Toml.int \"max_history_length\"  .= maxHistoryLength\n    <*> Toml.int \"max_selection_size_bytes\" .= maxItemSizeBytes\n    <*> Toml.text \"history_file\" .= historyPath\n    <*> Toml.text \"image_cache_directory\" .= imageCachePath\n    <*> Toml.bool \"use_primary_selection_as_input\" .= usePrimarySelectionAsInput\n    <*> Toml.arrayOf Toml._Text  \"blacklisted_applications\" .= blacklistedApps\n    <*> Toml.bool \"trim_space_from_selection\" .= trimSpaceFromSelection\n    <*> Toml.bool \"enable_image_support\" .= enableImageSupport\n    <*> Toml.arrayOf Toml._Text  \"static_history\" .= staticHistory\n\n\ntype ClipHistory = Vector Clip.Selection\n\nreadFile :: FilePath -> IO ByteString\nreadFile filepath = bracket (openFile filepath ReadMode) hClose $ \\h -> do\n  str <- hGetContents h\n  return $! toS str\n\n\ngetHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetHistory = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ (V.fromList <$> decodeFile storePath) `catchAll` const mempty\n\n\ngetStaticHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetStaticHistory = do\n  history <- view $ to (staticHistory)\n  return . V.fromList $ Clip.Selection \"greenclip\" . Clip.UTF8 <$> history\n\n\n\nstoreHistory :: (MonadIO m, MonadReader Config m) => ClipHistory -> m ()\nstoreHistory history = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ writeH storePath history\n  where\n    writeH storePath = B.writeFile storePath . toS . encode . V.toList\n\n\npruneHistory :: (MonadIO m, MonadReader Config m) => FilePath -> m ()\npruneHistory path = do\n  targets <- liftIO $ BC.lines <$> readFile path\n  history <- getHistory\n  storeHistory $ V.filter (go targets) history\n  where\n    go ts (Clip.Selection _ (Clip.UTF8 x)) = hashText x `notElem` ts\n    go _  _                                = False\n    hashText = BB.encode . H.hash . TE.encodeUtf8\n\n\nappendToHistory :: (MonadIO m, MonadReader Config m) => Clip.Selection -> ClipHistory -> m (ClipHistory, ClipHistory)\nappendToHistory sel history' = do\n  trimSelection <- view $ to trimSpaceFromSelection\n  case sel of\n    Clip.Selection appName (Clip.UTF8 txt) -> appendGeneric (if trimSelection then Clip.Selection appName (Clip.UTF8 (T.strip txt)) else sel) history'\n    Clip.Selection _ (Clip.PNG bytes) -> appendImage Clip.PNG \".png\" bytes\n    Clip.Selection _ (Clip.JPEG bytes) -> appendImage Clip.JPEG \".jpeg\" bytes\n    Clip.Selection _ (Clip.BITMAP bytes) -> appendImage Clip.BITMAP \".bmp\" bytes\n\n\n  where\n    appendImage imgCtr extension bytes = do\n      cachePth <- view (to imageCachePath)\n      let imgHash = show $ hash bytes\n      let imgPath = toS $ cachePth <> \"/\" <> imgHash <> extension\n      _ <- liftIO $ writeImage imgPath bytes\n      appendGeneric (sel {Clip.selection = imgCtr $ toS imgHash}) history'\n\n    writeImage path bytes = do\n      fileExist <- Dir.doesFileExist path\n      if fileExist\n        then return False\n        else B.writeFile path bytes >> setFileMode path 0o600 >> return True\n\n    appendGeneric selection history =\n      if maybe False (\\sel' -> Clip.selection sel' == Clip.selection selection) (history V.!? 0)\n        then return (history, mempty)\n        else do\n          maxLen <- view $ to maxHistoryLength\n          return $ V.splitAt maxLen . V.cons selection $ V.filter (\\ori -> Clip.selection ori /= Clip.selection selection) history\n\n\nsetHistoryFilePermission :: (MonadIO m, MonadReader Config m) => m ()\nsetHistoryFilePermission = do\n  storePath <- view $ to (toS . historyPath)\n  fileExist <- liftIO $ Dir.doesFileExist storePath\n  when (not fileExist) (storeHistory mempty)\n  liftIO $ setFileMode storePath 0o600\n\nprepareDirs :: (MonadIO m, MonadReader Config m) => m ()\nprepareDirs = do\n  historyFile <- view $ to (T.unpack . historyPath)\n  imgDir <- view $ to (T.unpack . imageCachePath)\n  let dirs = [imgDir, dropWhileEnd (/= '/') historyFile]\n  mapM_ (liftIO . Dir.createDirectoryIfMissing True) dirs\n\nrunDaemon:: (MonadIO m, MonadCatch m, MonadReader Config m) => m ()\nrunDaemon = prepareDirs >> setHistoryFilePermission >> (forever $ go `catchAll` handleError)\n  where\n    _0_5sec :: Int\n    _0_5sec = 5 * 100000\n\n    _5sec :: Int\n    _5sec = 5000000\n\n    go = do\n      history <- getHistory\n      usePrimary <- view $ to usePrimarySelectionAsInput\n      enableImage <- view $ to enableImageSupport\n      cfg <- ask\n\n      liftIO $ bracket Clip.getXorgContext Clip.destroyXorgContext $ \\x11Context -> do\n        let getSelections = (getSelectionFrom (Clip.getClipboardSelection x11Context enableImage), Nothing)\n                          : [(getSelectionFrom (Clip.getPrimarySelection x11Context enableImage), Nothing) | usePrimary]\n        void $ runReaderT (innerloop getSelections history) cfg\n\n    getSelection [] = return ([], Nothing)\n    getSelection ((getSel, lastSel):getSels) = do\n      selection <- liftIO getSel\n      if fmap Clip.selection selection /= fmap Clip.selection lastSel\n         then return ((getSel, selection) : getSels, selection)\n         else getSelection getSels >>= \\(e, sel) -> return ((getSel, lastSel) : e, sel)\n\n    innerloop :: (MonadIO m, MonadReader Config m) => [(IO (Maybe Clip.Selection), Maybe Clip.Selection)] -> ClipHistory -> m ClipHistory\n    innerloop getSelections history = do\n      -- Get selection from enabled clipboards\n      (getSelections', rawSelection) <- liftIO $ getSelection getSelections\n\n      -- Do not store selection items above threshold size\n      maxItemSize <- view (to maxItemSizeBytes)\n      let sel = case rawSelection of\n            Nothing -> Nothing\n            Just selection -> if maxItemSize > 0 && Clip.selectionLength selection >= maxItemSize\n                              then Nothing\n                              else Just selection\n             \n      -- Do not use selection coming from blacklisted app\n      liftIO $ when (isJust sel) (print (Clip.appName <$> sel))\n      blacklist <- view (to blacklistedApps)\n      let selection = sel >>= \\s -> if isJust $ find (== Clip.appName s) blacklist\n                                      then Nothing\n                                      else Just s\n\n      -- Append current selection to history and get back entries needed to be purged\n      (history', toBePurged) <- maybe (return (history, mempty)) (`appendToHistory` history) selection\n      traverse_ purgeSelection toBePurged\n\n      -- backup on disk history if it as changed seen last backup\n      when (isJust selection && history' /= history) (storeHistory history')\n\n      -- Getting some rest\n      liftIO $ threadDelay _0_5sec\n      innerloop getSelections' history'\n\n    getSelectionFrom :: IO (Maybe Clip.Selection) -> IO (Maybe Clip.Selection)\n    getSelectionFrom = fmap join . timeout _5sec\n\n    purgeSelection (Clip.Selection _ (Clip.PNG txt)) = purge (toS txt <> \".png\")\n    purgeSelection (Clip.Selection _ (Clip.JPEG txt)) = purge (toS txt <> \".jpeg\")\n    purgeSelection (Clip.Selection _ (Clip.BITMAP txt)) = purge (toS txt <> \".bmp\")\n    purgeSelection _ = return ()\n\n    purge path = do\n      cachePth <- view (to imageCachePath)\n      liftIO $ Dir.removeFile (toS $ cachePth <> \"/\" <> path) `catchAll` const mempty\n\n    handleError ex = do\n      let displayMissing = \"openDisplay\" `T.isInfixOf` show ex\n      if displayMissing\n      then panic \"X display not available. Please start Xorg before running greenclip\"\n      else print ex\n      liftIO $ threadDelay _0_5sec\n\n\ntoRofiStr :: Clip.Selection -> Text\ntoRofiStr (Clip.Selection _ (Clip.UTF8 txt)) = T.map (\\c -> if c == '\\n' || c == '\\r' then '\\xA0' else c) txt\ntoRofiStr (Clip.Selection appName (Clip.PNG txt)) = \"image/png \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.JPEG txt)) = \"image/jpeg \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.BITMAP txt)) = \"image/bmp \" <> appName <> \" \" <> toS txt\n\nfromRofiStr :: Text -> Text -> IO Clip.Selection\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/png \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".png\") <&> Clip.Selection \"greenclip\" . Clip.PNG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/jpeg \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".jpeg\") <&> Clip.Selection \"greenclip\" . Clip.JPEG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/bmp \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".bmp\") <&> Clip.Selection \"greenclip\" . Clip.BITMAP\nfromRofiStr _ txt = return $ Clip.Selection \"greenclip\" (Clip.UTF8 (T.map (\\c -> if c == '\\xA0' then '\\n' else c) txt))\n\ngetHash :: Text -> Text\ngetHash = fromMaybe mempty . lastMay . T.split (== ' ')\n\n\nprintHistoryForRofi :: (MonadIO m, MonadReader Config m) => m ()\nprintHistoryForRofi = do\n  history <- mappend <$> getHistory <*> getStaticHistory\n  _ <- traverse (putStrLn . toRofiStr) history\n  return ()\n\n\nadvertiseSelection :: (MonadIO m, MonadReader Config m) => Text -> m ()\nadvertiseSelection txt = do\n  cachePth <- view (to imageCachePath)\n  selection <- liftIO $ fromRofiStr cachePth txt\n  liftIO $ Clip.setClipboardSelection selection\n\n\ngetConfig :: IO Config\ngetConfig = do\n  home <- Dir.getHomeDirectory\n  let configPath = home <> \"/.config/greenclip.toml\"\n  \n  configExist <- Dir.doesFileExist configPath\n  when (not configExist) $ do \n    config <- Toml.encode (Toml.table configCodec \"greenclip\") <$> defaultConfig\n    writeFile configPath config\n    return ()\n  \n  tomlRes <- Toml.decodeFileEither (Toml.table configCodec \"greenclip\") configPath\n  when (isLeft tomlRes) $ do\n    die . toS $  \"Error parsing the config file at \" <> (show configPath) <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n  \n  let cfg = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes \n  \n  -- Replace $HOME|~|*... in config path\n  cfg <- do\n    imgCachePath <- wordexp . toS $ imageCachePath cfg\n    historyP <- wordexp . toS $ historyPath cfg \n    return $ cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP)}\n    \n  -- if it ends with / we don't create a temp directory\n  -- user is responsible for it\n  -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n  --    then do\n  --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n  --      return $ cfg { imageCachePath = toS dirPath }\n  --    else return cfg\n     \n  return cfg\n\n  where\n    defaultConfig = do \n      homeDir <- toS . fromMaybe mempty . listToMaybe <$> wordexp \"~/\"\n      return $ Config 50 0 (homeDir <> \".cache/greenclip.history\") \"/tmp/greenclip\" False [] True True \n        [\"Greenclip has been updated to v4.1, update your new config file at ~/.config/greenclip.toml\"]\n\n\nparseArgs :: [Text] -> Command\nparseArgs (\"daemon\":_)   = DAEMON\nparseArgs [\"clear\"]      = CLEAR\nparseArgs [\"prune\", p]   = PRUNE $ T.unpack p\nparseArgs [\"print\"]      = PRINT\nparseArgs [\"print\", sel] = COPY sel\nparseArgs _              = HELP\n\nrun :: Command -> IO ()\nrun cmd = do\n  cfg <- getConfig\n  case cmd of\n    DAEMON   -> runReaderT runDaemon cfg\n    PRINT    -> runReaderT printHistoryForRofi cfg\n    CLEAR    -> runReaderT (storeHistory mempty) cfg\n    PRUNE p  -> runReaderT (pruneHistory p) cfg\n    -- Should rename COPY into ADVERTISE but as greenclip is already used I don't want to break configs\n    -- of other people\n    COPY sel -> runReaderT (advertiseSelection sel) cfg\n    HELP     -> putText $ \"greenclip v4.3 -- Recyle your clipboard selections\\n\\n\" <>\n                          \"Available commands\\n\" <>\n                          \"daemon: Spawn the daemon that will listen to selections\\n\" <>\n                          \"print:  Display all selections history\\n\" <>\n                          \"prune FILE: Remove selections in list of md5 hashes in FILE\\n\" <>\n                          \"clear:  Clear history\\n\" <>\n                          \"help:   Display this message\\n\"\n\nmain :: IO ()\nmain = do\n  displayPresent <- lookupEnv \"DISPLAY\"\n  case displayPresent of\n    Nothing -> putText \"X display not available. Please start Xorg before running greenclip\"\n    _       -> getArgs >>= run . parseArgs . fmap toS\n",
              "suggestions": [
                {
                  "location": "/tmp/project_89/pre_refactor/src/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE ViewPatterns          #-}\n\n\nmodule Main where\n\nimport           Protolude             hiding (readFile, to, (<&>), (&), toS)\nimport           Protolude.Conv        (toS)\n\nimport           Control.Monad.Catch   (MonadCatch, catchAll)\nimport qualified Crypto.Hash.MD5       as H\nimport           Data.Binary           (decodeFile, encode)\nimport qualified Data.ByteString       as B\nimport qualified Data.ByteString.Base16 as BB\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.List             (dropWhileEnd)\nimport qualified Data.Text             as T\nimport qualified Data.Text.Encoding    as TE\nimport           Data.Vector           (Vector)\nimport qualified Data.Vector           as V\nimport           Lens.Micro\nimport           Lens.Micro.Mtl    hiding ((.=))\nimport qualified System.Directory      as Dir\nimport           System.Posix.Files    (setFileMode)\nimport           System.Environment    (lookupEnv)\nimport           System.IO             (hClose, hGetContents)\nimport           System.Timeout        (timeout)\nimport           System.Wordexp.Simple (wordexp)\n--import           System.Posix.Temp     (mkdtemp)\n\nimport Toml (TomlCodec, (.=))\nimport qualified Toml\n\nimport qualified Clipboard             as Clip\n\n\ndata Command = DAEMON | PRINT | COPY Text | CLEAR | PRUNE FilePath | HELP deriving (Show, Read)\n\ndata Config = Config\n  { maxHistoryLength           :: Int\n  , maxItemSizeBytes           :: Int\n  , historyPath                :: Text\n  , imageCachePath             :: Text\n  , usePrimarySelectionAsInput :: Bool\n  , blacklistedApps            :: [Text]\n  , trimSpaceFromSelection     :: Bool\n  , enableImageSupport         :: Bool\n  , staticHistory              :: [Text]\n  } deriving (Show, Read)\n\nconfigCodec :: TomlCodec Config\nconfigCodec = Config\n    <$> Toml.int \"max_history_length\"  .= maxHistoryLength\n    <*> Toml.int \"max_selection_size_bytes\" .= maxItemSizeBytes\n    <*> Toml.text \"history_file\" .= historyPath\n    <*> Toml.text \"image_cache_directory\" .= imageCachePath\n    <*> Toml.bool \"use_primary_selection_as_input\" .= usePrimarySelectionAsInput\n    <*> Toml.arrayOf Toml._Text  \"blacklisted_applications\" .= blacklistedApps\n    <*> Toml.bool \"trim_space_from_selection\" .= trimSpaceFromSelection\n    <*> Toml.bool \"enable_image_support\" .= enableImageSupport\n    <*> Toml.arrayOf Toml._Text  \"static_history\" .= staticHistory\n\n\ntype ClipHistory = Vector Clip.Selection\n\nreadFile :: FilePath -> IO ByteString\nreadFile filepath = bracket (openFile filepath ReadMode) hClose $ \\h -> do\n  str <- hGetContents h\n  return $! toS str\n\n\ngetHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetHistory = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ (V.fromList <$> decodeFile storePath) `catchAll` const mempty\n\n\ngetStaticHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetStaticHistory = do\n  history <- view $ to staticHistory\n  return . V.fromList $ Clip.Selection \"greenclip\" . Clip.UTF8 <$> history\n\n\n\nstoreHistory :: (MonadIO m, MonadReader Config m) => ClipHistory -> m ()\nstoreHistory history = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ writeH storePath history\n  where\n    writeH storePath = B.writeFile storePath . toS . encode . V.toList\n\n\npruneHistory :: (MonadIO m, MonadReader Config m) => FilePath -> m ()\npruneHistory path = do\n  targets <- liftIO $ BC.lines <$> readFile path\n  history <- getHistory\n  storeHistory $ V.filter (go targets) history\n  where\n    go ts (Clip.Selection _ (Clip.UTF8 x)) = hashText x `notElem` ts\n    go _  _                                = False\n    hashText = BB.encode . H.hash . TE.encodeUtf8\n\n\nappendToHistory :: (MonadIO m, MonadReader Config m) => Clip.Selection -> ClipHistory -> m (ClipHistory, ClipHistory)\nappendToHistory sel history' = do\n  trimSelection <- view $ to trimSpaceFromSelection\n  case sel of\n    Clip.Selection appName (Clip.UTF8 txt) -> appendGeneric (if trimSelection then Clip.Selection appName (Clip.UTF8 (T.strip txt)) else sel) history'\n    Clip.Selection _ (Clip.PNG bytes) -> appendImage Clip.PNG \".png\" bytes\n    Clip.Selection _ (Clip.JPEG bytes) -> appendImage Clip.JPEG \".jpeg\" bytes\n    Clip.Selection _ (Clip.BITMAP bytes) -> appendImage Clip.BITMAP \".bmp\" bytes\n\n\n  where\n    appendImage imgCtr extension bytes = do\n      cachePth <- view (to imageCachePath)\n      let imgHash = show $ hash bytes\n      let imgPath = toS $ cachePth <> \"/\" <> imgHash <> extension\n      _ <- liftIO $ writeImage imgPath bytes\n      appendGeneric (sel {Clip.selection = imgCtr $ toS imgHash}) history'\n\n    writeImage path bytes = do\n      fileExist <- Dir.doesFileExist path\n      if fileExist\n        then return False\n        else B.writeFile path bytes >> setFileMode path 0o600 >> return True\n\n    appendGeneric selection history =\n      if maybe False (\\sel' -> Clip.selection sel' == Clip.selection selection) (history V.!? 0)\n        then return (history, mempty)\n        else do\n          maxLen <- view $ to maxHistoryLength\n          return $ V.splitAt maxLen . V.cons selection $ V.filter (\\ori -> Clip.selection ori /= Clip.selection selection) history\n\n\nsetHistoryFilePermission :: (MonadIO m, MonadReader Config m) => m ()\nsetHistoryFilePermission = do\n  storePath <- view $ to (toS . historyPath)\n  fileExist <- liftIO $ Dir.doesFileExist storePath\n  unless fileExist (storeHistory mempty)\n  liftIO $ setFileMode storePath 0o600\n\nprepareDirs :: (MonadIO m, MonadReader Config m) => m ()\nprepareDirs = do\n  historyFile <- view $ to (T.unpack . historyPath)\n  imgDir <- view $ to (T.unpack . imageCachePath)\n  let dirs = [imgDir, dropWhileEnd (/= '/') historyFile]\n  mapM_ (liftIO . Dir.createDirectoryIfMissing True) dirs\n\nrunDaemon:: (MonadIO m, MonadCatch m, MonadReader Config m) => m ()\nrunDaemon = prepareDirs >> setHistoryFilePermission >> forever (go `catchAll` handleError)\n  where\n    _0_5sec :: Int\n    _0_5sec = 5 * 100000\n\n    _5sec :: Int\n    _5sec = 5000000\n\n    go = do\n      history <- getHistory\n      usePrimary <- view $ to usePrimarySelectionAsInput\n      enableImage <- view $ to enableImageSupport\n      cfg <- ask\n\n      liftIO $ bracket Clip.getXorgContext Clip.destroyXorgContext $ \\x11Context -> do\n        let getSelections = (getSelectionFrom (Clip.getClipboardSelection x11Context enableImage), Nothing)\n                          : [(getSelectionFrom (Clip.getPrimarySelection x11Context enableImage), Nothing) | usePrimary]\n        void $ runReaderT (innerloop getSelections history) cfg\n\n    getSelection [] = return ([], Nothing)\n    getSelection ((getSel, lastSel):getSels) = do\n      selection <- liftIO getSel\n      if fmap Clip.selection selection /= fmap Clip.selection lastSel\n         then return ((getSel, selection) : getSels, selection)\n         else getSelection getSels >>= \\(e, sel) -> return ((getSel, lastSel) : e, sel)\n\n    innerloop :: (MonadIO m, MonadReader Config m) => [(IO (Maybe Clip.Selection), Maybe Clip.Selection)] -> ClipHistory -> m ClipHistory\n    innerloop getSelections history = do\n      -- Get selection from enabled clipboards\n      (getSelections', rawSelection) <- liftIO $ getSelection getSelections\n\n      -- Do not store selection items above threshold size\n      maxItemSize <- view (to maxItemSizeBytes)\n      let sel = case rawSelection of\n            Nothing -> Nothing\n            Just selection -> if maxItemSize > 0 && Clip.selectionLength selection >= maxItemSize\n                              then Nothing\n                              else Just selection\n\n      -- Do not use selection coming from blacklisted app\n      liftIO $ when (isJust sel) (print (Clip.appName <$> sel))\n      blacklist <- view (to blacklistedApps)\n      let selection = sel >>= \\s -> if isJust $ find (== Clip.appName s) blacklist\n                                      then Nothing\n                                      else Just s\n\n      -- Append current selection to history and get back entries needed to be purged\n      (history', toBePurged) <- maybe (return (history, mempty)) (`appendToHistory` history) selection\n      traverse_ purgeSelection toBePurged\n\n      -- backup on disk history if it as changed seen last backup\n      when (isJust selection && history' /= history) (storeHistory history')\n\n      -- Getting some rest\n      liftIO $ threadDelay _0_5sec\n      innerloop getSelections' history'\n\n    getSelectionFrom :: IO (Maybe Clip.Selection) -> IO (Maybe Clip.Selection)\n    getSelectionFrom = fmap join . timeout _5sec\n\n    purgeSelection (Clip.Selection _ (Clip.PNG txt)) = purge (toS txt <> \".png\")\n    purgeSelection (Clip.Selection _ (Clip.JPEG txt)) = purge (toS txt <> \".jpeg\")\n    purgeSelection (Clip.Selection _ (Clip.BITMAP txt)) = purge (toS txt <> \".bmp\")\n    purgeSelection _ = return ()\n\n    purge path = do\n      cachePth <- view (to imageCachePath)\n      liftIO $ Dir.removeFile (toS $ cachePth <> \"/\" <> path) `catchAll` const mempty\n\n    handleError ex = do\n      let displayMissing = \"openDisplay\" `T.isInfixOf` show ex\n      if displayMissing\n      then panic \"X display not available. Please start Xorg before running greenclip\"\n      else print ex\n      liftIO $ threadDelay _0_5sec\n\n\ntoRofiStr :: Clip.Selection -> Text\ntoRofiStr (Clip.Selection _ (Clip.UTF8 txt)) = T.map (\\c -> if c == '\\n' || c == '\\r' then '\\xA0' else c) txt\ntoRofiStr (Clip.Selection appName (Clip.PNG txt)) = \"image/png \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.JPEG txt)) = \"image/jpeg \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.BITMAP txt)) = \"image/bmp \" <> appName <> \" \" <> toS txt\n\nfromRofiStr :: Text -> Text -> IO Clip.Selection\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/png \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".png\") <&> Clip.Selection \"greenclip\" . Clip.PNG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/jpeg \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".jpeg\") <&> Clip.Selection \"greenclip\" . Clip.JPEG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/bmp \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".bmp\") <&> Clip.Selection \"greenclip\" . Clip.BITMAP\nfromRofiStr _ txt = return $ Clip.Selection \"greenclip\" (Clip.UTF8 (T.map (\\c -> if c == '\\xA0' then '\\n' else c) txt))\n\ngetHash :: Text -> Text\ngetHash = fromMaybe mempty . lastMay . T.split (== ' ')\n\n\nprintHistoryForRofi :: (MonadIO m, MonadReader Config m) => m ()\nprintHistoryForRofi = do\n  history <- mappend <$> getHistory <*> getStaticHistory\n  _ <- traverse_ (putStrLn . toRofiStr) history\n  return ()\n\n\nadvertiseSelection :: (MonadIO m, MonadReader Config m) => Text -> m ()\nadvertiseSelection txt = do\n  cachePth <- view (to imageCachePath)\n  selection <- liftIO $ fromRofiStr cachePth txt\n  liftIO $ Clip.setClipboardSelection selection\n\n\ngetConfig :: IO Config\ngetConfig = do\n  home <- Dir.getHomeDirectory\n  let configPath = home <> \"/.config/greenclip.toml\"\n\n  configExist <- Dir.doesFileExist configPath\n  unless configExist $ do\n    config <- Toml.encode (Toml.table configCodec \"greenclip\") <$> defaultConfig\n    writeFile configPath config\n    return ()\n\n  tomlRes <- Toml.decodeFileEither (Toml.table configCodec \"greenclip\") configPath\n  when (isLeft tomlRes) $ do\n    die . toS $  \"Error parsing the config file at \" <> show configPath <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n\n  let cfg = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes\n\n  -- Replace $HOME|~|*... in config path\n  cfg <- do\n    imgCachePath <- wordexp . toS $ imageCachePath cfg\n    historyP <- wordexp . toS $ historyPath cfg\n    return $ cfg { imageCachePath = toS $ headDef \"\" imgCachePath, historyPath = toS $ headDef \"\" historyP}\n\n  -- if it ends with / we don't create a temp directory\n  -- user is responsible for it\n  -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n  --    then do\n  --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n  --      return $ cfg { imageCachePath = toS dirPath }\n  --    else return cfg\n\n  return cfg\n\n  where\n    defaultConfig = do\n      homeDir <- toS . fromMaybe mempty . listToMaybe <$> wordexp \"~/\"\n      return $ Config 50 0 (homeDir <> \".cache/greenclip.history\") \"/tmp/greenclip\" False [] True True\n        [\"Greenclip has been updated to v4.1, update your new config file at ~/.config/greenclip.toml\"]\n\n\nparseArgs :: [Text] -> Command\nparseArgs (\"daemon\":_)   = DAEMON\nparseArgs [\"clear\"]      = CLEAR\nparseArgs [\"prune\", p]   = PRUNE $ T.unpack p\nparseArgs [\"print\"]      = PRINT\nparseArgs [\"print\", sel] = COPY sel\nparseArgs _              = HELP\n\nrun :: Command -> IO ()\nrun cmd = do\n  cfg <- getConfig\n  case cmd of\n    DAEMON   -> runReaderT runDaemon cfg\n    PRINT    -> runReaderT printHistoryForRofi cfg\n    CLEAR    -> runReaderT (storeHistory mempty) cfg\n    PRUNE p  -> runReaderT (pruneHistory p) cfg\n    -- Should rename COPY into ADVERTISE but as greenclip is already used I don't want to break configs\n    -- of other people\n    COPY sel -> runReaderT (advertiseSelection sel) cfg\n    HELP     -> putText $ \"greenclip v4.3 -- Recyle your clipboard selections\\n\\n\" <>\n                          \"Available commands\\n\" <>\n                          \"daemon: Spawn the daemon that will listen to selections\\n\" <>\n                          \"print:  Display all selections history\\n\" <>\n                          \"prune FILE: Remove selections in list of md5 hashes in FILE\\n\" <>\n                          \"clear:  Clear history\\n\" <>\n                          \"help:   Display this message\\n\"\n\nmain :: IO ()\nmain = do\n  displayPresent <- lookupEnv \"DISPLAY\"\n  case displayPresent of\n    Nothing -> putText \"X display not available. Please start Xorg before running greenclip\"\n    _       -> getArgs >>= run . parseArgs . fmap toS\n"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 10,
              "average": 52.5,
              "sum": 105
            },
            "hlint_suggestions": {
              "error": 1,
              "warning": 0,
              "suggestion": 1,
              "ignore": 0,
              "total": 2
            },
            "syntax_errors": 13,
            "lines_of_code": 627,
            "homplexity_lines_of_code": 603,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_89/pre_refactor/src/Clipboard.hs",
              "refactored_file_name": "/tmp/project_89/hybrid_refactored/src/Clipboard.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 35
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 12,
              "lines_of_code": 291,
              "homplexity_lines_of_code": 291,
              "code_quality_score": 0.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 35
                },
                "homplexity_loc": 291,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"selectionLength\": 4,\n    \"test\": 1,\n    \"windowNameOfClipboardOwner\": 2,\n    \"isIncrementalTransfert\": 2,\n    \"getSupportedMimes\": 2,\n    \"getClipboardSelection\": 1,\n    \"getPrimarySelection\": 1,\n    \"getSelection\": 4,\n    \"getXorgContext\": 1,\n    \"destroyXorgContext\": 1,\n    \"waitNotify\": 1,\n    \"setClipboardSelection\": 1,\n    \"selectionTypeToMime\": 4,\n    \"getContent\": 4,\n    \"advertiseSelection\": 1,\n    \"handleRequest\": 3,\n    \"sendSelectionNotify\": 1,\n    \"byteStringToCUChars\": 1,\n    \"min\": 1,\n    \"max\": 4,\n    \"average\": 1.9444444444444444,\n    \"sum\": 35\n  },\n  \"homplexity_loc\": 291,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n\nmodule Clipboard where\n\nimport           Protolude                hiding ((<&>))\nimport           Protolude.Unsafe                   (unsafeIndex)\nimport qualified Protolude.Conv as StrConvOld\n\nimport           Graphics.X11.Xlib\nimport           Graphics.X11.Xlib.Extras\n\nimport           Data.Binary              (Binary)\nimport qualified Data.ByteString          as B\nimport qualified Data.Text as T\nimport           Lens.Micro\n\nimport           System.Directory         (setCurrentDirectory)\nimport           System.IO                (hClose)\nimport           System.Posix.Process     (forkProcess)\n\nimport           Data.ByteString          (unpack)\nimport           Foreign                  (alloca, castPtr, peek, peekArray)\nimport           Foreign.C.Types          (CUChar)\nimport           Foreign.Marshal.Array    (withArrayLen)\n\ndata SelectionType = UTF8 Text\n                   | PNG ByteString\n                   | JPEG ByteString\n                   | BITMAP ByteString\n                   deriving (Show, Eq, Generic, Binary)\n\nselectionLength :: Selection -> Int\nselectionLength (Selection _ (UTF8 a)) = T.length a\nselectionLength (Selection _ (PNG a)) = B.length a\nselectionLength (Selection _ (JPEG a)) = B.length a\nselectionLength (Selection _ (BITMAP a)) = B.length a\n\n\ndata Selection = Selection {\n    appName   :: Text\n  , selection :: SelectionType\n} deriving (Show, Eq, Generic, Binary)\n\ndata XorgContext = XorgContext {\n    display          :: Display\n  , ownWindow        :: Window\n  , defaultClipboard :: Atom\n  , primaryClipboard :: Atom\n  , selectionTarget  :: Atom\n  , mimesPriorities  :: [Atom]\n  , defaultMime      :: Atom\n} deriving (Show)\n\ntest :: IO ()\ntest =\n  bracket getXorgContext destroyXorgContext $ \\ctx -> do\n    ret <- getPrimarySelection ctx True\n    print $! ret\n    return ()\n\nwindowNameOfClipboardOwner :: XorgContext -> Atom -> IO Text\nwindowNameOfClipboardOwner XorgContext{..} clipboard = do\n\n  window <- xGetSelectionOwner display clipboard\n\n  if window > 0\n    then fetchName display window <&> toS . fromMaybe mempty\n    else return mempty\n\n\nisIncrementalTransfert :: XorgContext -> IO Bool\nisIncrementalTransfert XorgContext{..}  =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        incr <- internAtom display \"INCR\" False\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0 False anyPropertyType\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        if ret /= 0\n           then return False\n        else do\n            actual_type   <- peek actual_type_return <&> fromIntegral :: IO Atom\n            _ <- peek prop_return >>= xFree\n            return $ actual_type == incr\n\ngetSupportedMimes :: XorgContext -> Atom -> IO [Atom]\ngetSupportedMimes ctx@XorgContext{..} clipboard =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        targets <- internAtom display \"TARGETS\" False\n        xConvertSelection display clipboard targets selectionTarget ownWindow currentTime\n        _ <- waitNotify ctx\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0xFFFFFFFF False aTOM\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        ret2 <- if ret /= 0\n                then return Nothing\n                else do\n                    prop_ptr      <- peek prop_return\n                    actual_format <- peek actual_format_return <&> fromIntegral :: IO Atom\n                    nitems        <- peek nitems_return <&> fromIntegral\n                    getprop prop_ptr nitems actual_format\n        return $ fromMaybe mempty ret2\n\n  where\n    getprop prop_ptr nitems actual_format\n        | actual_format == 0    = return Nothing -- Property not found\n        | otherwise = do\n            retval <- peekArray nitems (castPtr prop_ptr)\n            _ <- xFree prop_ptr\n            return $ Just retval\n\n\ngetClipboardSelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetClipboardSelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage defaultClipboard\n\ngetPrimarySelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetPrimarySelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage primaryClipboard\n\ngetSelection :: XorgContext -> Bool -> Atom -> IO (Maybe Selection)\ngetSelection ctx@XorgContext{..} enableImage clipboard = do\n  mimes <- if enableImage \n            then getSupportedMimes ctx clipboard \n            else return [defaultMime] \n  let targetMime = chooseSelectionType mimes\n\n  xConvertSelection display clipboard targetMime selectionTarget ownWindow currentTime\n  waitNotify ctx\n  isIncremental <- isIncrementalTransfert ctx\n  clipboardContent <- if isIncremental\n                      then return mempty -- Incremental use too much CPU, do not handle it\n                      else getWindowProperty8 display selectionTarget ownWindow\n                           <&> B.pack . map fromIntegral . fromMaybe mempty\n\n  if clipboardContent == mempty\n  then return Nothing\n  else do\n    windowName <- windowNameOfClipboardOwner ctx clipboard\n    return $ Just Selection { appName = windowName\n                            , selection = mimeToSelectionType targetMime clipboardContent\n                            }\n\n where\n   chooseSelectionType mimes =\n     let selectedMime = msum $ (\\mime -> find (== mime) mimes) <$> mimesPriorities\n     in fromMaybe defaultMime selectedMime\n\n   mimeToSelectionType mimeTarget selContent =\n     if      mimeTarget == unsafeIndex mimesPriorities 0 then PNG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 1 then JPEG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 2 then BITMAP selContent\n     else UTF8 $ decodeUtf8 selContent\n\n   -- getContentIncrementally acc = do\n   --   _ <- xDeleteProperty display ownWindow selectionTarget\n   --   flush display\n   --   waitNotify ctx\n   --   content <- getWindowProperty8 display selectionTarget ownWindow\n   --              <&> B.pack . map fromIntegral . fromMaybe mempty\n   --   if content == mempty\n   --      then return acc\n   --      else getContentIncrementally (acc <> content)\n\n\ngetXorgContext :: IO XorgContext\ngetXorgContext = do\n    display <- openDisplay mempty\n    window <- createSimpleWindow display (defaultRootWindow display) 0 0 1 1 0 0 0\n    -- selectInput display window propertyChangeMask\n\n    clipboard <- internAtom display \"CLIPBOARD\" False\n    selTarget <- internAtom display \"GREENCLIP\" False\n    priorities <- traverse (\\atomName -> internAtom display atomName False) [\"image/png\", \"image/jpeg\", \"image/bmp\", \"UTF8_STRING\", \"TEXT\"] \n    defaultM <- internAtom display \"UTF8_STRING\" False\n    return XorgContext {\n        display = display\n      , ownWindow = window\n      , defaultClipboard = clipboard\n      , primaryClipboard = pRIMARY\n      , selectionTarget = selTarget\n      , mimesPriorities = priorities\n      , defaultMime = defaultM\n    }\n\ndestroyXorgContext :: XorgContext -> IO ()\ndestroyXorgContext XorgContext{..} = do\n    destroyWindow display ownWindow\n    closeDisplay display\n\nwaitNotify :: XorgContext -> IO ()\nwaitNotify XorgContext{..} = allocaXEvent (go display ownWindow)\n  where\n  go display' window evPtr = do\n    waitForEvents display'\n    nextEvent display' evPtr\n    ev <- getEvent evPtr\n    when (ev_event_type ev /= selectionNotify\n          &&  not (ev_event_type ev == propertyNotify && ev_atom ev == selectionTarget && ev_propstate ev == 1))\n      (go display' window evPtr)\n\n  waitForEvents display' = do\n    nbEvs <- pending display'\n    when (nbEvs == 0) $ threadDelay _10ms >> waitForEvents display'\n\n  _10ms = 10000\n\n\n\nsetClipboardSelection :: Selection -> IO ()\nsetClipboardSelection sel = void $ forkProcess $ do\n        mapM_ hClose [stdin, stdout, stderr]\n        setCurrentDirectory \"/\"\n        bracket getXorgContext destroyXorgContext $ \\ctx@XorgContext{..} -> do\n          let clipboards = [defaultClipboard, primaryClipboard]\n          mapM_ (\\atom -> xSetSelectionOwner display atom ownWindow currentTime) clipboards\n          advertiseSelection ctx sel\n          return ()\n\n\nselectionTypeToMime :: SelectionType -> ByteString\nselectionTypeToMime (PNG _)    = \"image/png\"\nselectionTypeToMime (JPEG _)   = \"image/jpeg\"\nselectionTypeToMime (BITMAP _) = \"image/bmp\"\nselectionTypeToMime (UTF8 _)   = \"UTF8_STRING\"\n\ngetContent :: SelectionType -> ByteString\ngetContent (PNG bytes)    = bytes\ngetContent (JPEG bytes)   = bytes\ngetContent (BITMAP bytes) = bytes\ngetContent (UTF8 txt)     = encodeUtf8 txt\n\nadvertiseSelection :: XorgContext -> Selection ->  IO ()\nadvertiseSelection ctx@XorgContext{..} sel = allocaXEvent (go [defaultClipboard, primaryClipboard])\n  where\n    go [] _ = return ()\n    go clipboards evPtr = do\n      nextEvent display evPtr\n      ev <- getEvent evPtr\n      case ev of\n          SelectionRequest {..} -> do\n              target' <- getAtomName display ev_target\n              response <- case target' of\n                Nothing -> return none\n                Just atomName -> handleRequest ctx (selection sel) ev_requestor ev_property (toS atomName)\n\n              sendSelectionNotify display ev_requestor ev_selection ev_target response ev_time\n              go clipboards evPtr\n\n          SelectionClear{..} -> go (filter (/= ev_selection) clipboards) evPtr\n\n          _ -> go clipboards evPtr\n\nhandleRequest :: XorgContext -> SelectionType -> Window -> Atom -> Text -> IO Atom\nhandleRequest XorgContext{..} sel requestorWindow selection \"TARGETS\" = do\n  targets <- internAtom display \"TARGETS\" True\n  target <- internAtom display (StrConvOld.toS $ selectionTypeToMime sel) True\n  changeProperty32 display requestorWindow selection aTOM propModeReplace [fromIntegral targets, fromIntegral target]\n  return selection\n\nhandleRequest XorgContext{..} sel req prop targetStr =\n  if targetStr == decodeUtf8 (selectionTypeToMime sel)\n    then do\n      target <- internAtom display (toS targetStr) True\n      void $ withArrayLen (byteStringToCUChars $ getContent sel) $ \\len bytes ->\n          xChangeProperty display req prop target 8 propModeReplace bytes (fromIntegral len)\n      return prop\n    else return none\n\nsendSelectionNotify :: Display -> Window -> Atom -> Atom -> Atom -> Time -> IO ()\nsendSelectionNotify display req sel target prop time = allocaXEvent $ \\ev -> do\n  setEventType ev selectionNotify\n  setSelectionNotify ev req sel target prop time\n  sendEvent display req False 0 ev\n\nbyteStringToCUChars :: ByteString -> [CUChar]\nbyteStringToCUChars = map fromIntegral . unpack\n",
              "suggestions": [
                {
                  "target_snippet": "mimeToSelectionType mimeTarget selContent\n     if      mimeTarget == unsafeIndex mimesPriorities 0 then PNG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 1 then JPEG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 2 then BITMAP selContent\n     else UTF8 $ decodeUtf8 selContent",
                  "refactored_suggestion": "mimeToSelectionType mimeTarget selContent\n    | mimeTarget == unsafeIndex mimesPriorities 0 = PNG selContent\n    | mimeTarget == unsafeIndex mimesPriorities 1 = JPEG selContent\n    | mimeTarget == unsafeIndex mimesPriorities 2 = BITMAP selContent\n    | otherwise = UTF8 $ decodeUtf8 selContent",
                  "confidence": 0.9,
                  "justification": "Using guards makes the code cleaner and more readable compared to multiple nested `if-then-else` statements. This improves maintainability and reduces cognitive load for readers."
                },
                {
                  "target_snippet": "-- getContentIncrementally acc = do\n   --   _ <- xDeleteProperty display ownWindow selectionTarget\n   --   flush display\n   --   waitNotify ctx\n   --   content <- getWindowProperty8 display selectionTarget ownWindow\n   --              <&> B.pack . map fromIntegral . fromMaybe mempty\n   --   if content == mempty\n   --      then return acc\n   --      else getContentIncrementally (acc <> content)",
                  "refactored_suggestion": "-- Removed dead code for incremental content retrieval\n-- Reason: The function `getContentIncrementally` is commented out, unused, and unnecessary as incremental transfers are explicitly not supported (`isIncremental` is always returned as `False`). Hence, it can be safely deleted.",
                  "confidence": 1.0,
                  "justification": "The function `getContentIncrementally` was unused and already commented out. It is irrelevant in the current context as the code explicitly does not handle incremental transfers for performance reasons."
                },
                {
                  "target_snippet": "-- selectInput display window propertyChangeMask",
                  "refactored_suggestion": "-- Removed unused commented-out code for `selectInput`\n-- Reason: The `selectInput` line is commented out and unnecessary in the given program flow.",
                  "confidence": 1.0,
                  "justification": "The `selectInput` line was already commented out and shows no evidence of being needed in the current workflow involving X11 interaction."
                },
                {
                  "target_snippet": "primaryClipboard = pRIMARY",
                  "refactored_suggestion": "primaryClipboard = primaryClipboardAtom",
                  "confidence": 0.8,
                  "justification": "The current code contains a typo (`pRIMARY`) which is not consistent with any declaration in the program. Since we are trying to assign `primaryClipboard` correctly, it should be fixed to point to a defined Atom corresponding to the primary clipboard. The fix assumes an appropriate correction."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n\nmodule Clipboard where\n\nimport           Protolude                hiding ((<&>))\nimport           Protolude.Unsafe                   (unsafeIndex)\nimport qualified Protolude.Conv as StrConvOld\n\nimport           Graphics.X11.Xlib\nimport           Graphics.X11.Xlib.Extras\n\nimport           Data.Binary              (Binary)\nimport qualified Data.ByteString          as B\nimport qualified Data.Text as T\nimport           Lens.Micro\n\nimport           System.Directory         (setCurrentDirectory)\nimport           System.IO                (hClose)\nimport           System.Posix.Process     (forkProcess)\n\nimport           Data.ByteString          (unpack)\nimport           Foreign                  (alloca, castPtr, peek, peekArray)\nimport           Foreign.C.Types          (CUChar)\nimport           Foreign.Marshal.Array    (withArrayLen)\n\ndata SelectionType = UTF8 Text\n                   | PNG ByteString\n                   | JPEG ByteString\n                   | BITMAP ByteString\n                   deriving (Show, Eq, Generic, Binary)\n\nselectionLength :: Selection -> Int\nselectionLength (Selection _ (UTF8 a)) = T.length a\nselectionLength (Selection _ (PNG a)) = B.length a\nselectionLength (Selection _ (JPEG a)) = B.length a\nselectionLength (Selection _ (BITMAP a)) = B.length a\n\n\ndata Selection = Selection {\n    appName   :: Text\n  , selection :: SelectionType\n} deriving (Show, Eq, Generic, Binary)\n\ndata XorgContext = XorgContext {\n    display          :: Display\n  , ownWindow        :: Window\n  , defaultClipboard :: Atom\n  , primaryClipboard :: Atom\n  , selectionTarget  :: Atom\n  , mimesPriorities  :: [Atom]\n  , defaultMime      :: Atom\n} deriving (Show)\n\ntest :: IO ()\ntest =\n  bracket getXorgContext destroyXorgContext $ \\ctx -> do\n    ret <- getPrimarySelection ctx True\n    print $! ret\n    return ()\n\nwindowNameOfClipboardOwner :: XorgContext -> Atom -> IO Text\nwindowNameOfClipboardOwner XorgContext{..} clipboard = do\n\n  window <- xGetSelectionOwner display clipboard\n\n  if window > 0\n    then fetchName display window <&> toS . fromMaybe mempty\n    else return mempty\n\n\nisIncrementalTransfert :: XorgContext -> IO Bool\nisIncrementalTransfert XorgContext{..}  =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        incr <- internAtom display \"INCR\" False\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0 False anyPropertyType\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        if ret /= 0\n           then return False\n        else do\n            actual_type   <- peek actual_type_return <&> fromIntegral :: IO Atom\n            _ <- peek prop_return >>= xFree\n            return $ actual_type == incr\n\ngetSupportedMimes :: XorgContext -> Atom -> IO [Atom]\ngetSupportedMimes ctx@XorgContext{..} clipboard =\n    alloca $ \\actual_type_return ->\n    alloca $ \\actual_format_return ->\n    alloca $ \\nitems_return ->\n    alloca $ \\bytes_after_return ->\n    alloca $ \\prop_return -> do\n        targets <- internAtom display \"TARGETS\" False\n        xConvertSelection display clipboard targets selectionTarget ownWindow currentTime\n        _ <- waitNotify ctx\n        ret <- xGetWindowProperty display ownWindow selectionTarget 0 0xFFFFFFFF False aTOM\n                           actual_type_return\n                           actual_format_return\n                           nitems_return\n                           bytes_after_return\n                           prop_return\n\n        ret2 <- if ret /= 0\n                then return Nothing\n                else do\n                    prop_ptr      <- peek prop_return\n                    actual_format <- peek actual_format_return <&> fromIntegral :: IO Atom\n                    nitems        <- peek nitems_return <&> fromIntegral\n                    getprop prop_ptr nitems actual_format\n        return $ fromMaybe mempty ret2\n\n  where\n    getprop prop_ptr nitems actual_format\n        | actual_format == 0    = return Nothing -- Property not found\n        | otherwise = do\n            retval <- peekArray nitems (castPtr prop_ptr)\n            _ <- xFree prop_ptr\n            return $ Just retval\n\n\ngetClipboardSelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetClipboardSelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage defaultClipboard\n\ngetPrimarySelection :: XorgContext -> Bool -> IO (Maybe Selection)\ngetPrimarySelection ctx@XorgContext{..} enableImage =\n  getSelection ctx enableImage primaryClipboard\n\ngetSelection :: XorgContext -> Bool -> Atom -> IO (Maybe Selection)\ngetSelection ctx@XorgContext{..} enableImage clipboard = do\n  mimes <- if enableImage \n            then getSupportedMimes ctx clipboard \n            else return [defaultMime] \n  let targetMime = chooseSelectionType mimes\n\n  xConvertSelection display clipboard targetMime selectionTarget ownWindow currentTime\n  waitNotify ctx\n  isIncremental <- isIncrementalTransfert ctx\n  clipboardContent <- if isIncremental\n                      then return mempty -- Incremental use too much CPU, do not handle it\n                      else getWindowProperty8 display selectionTarget ownWindow\n                           <&> B.pack . map fromIntegral . fromMaybe mempty\n\n  if clipboardContent == mempty\n  then return Nothing\n  else do\n    windowName <- windowNameOfClipboardOwner ctx clipboard\n    return $ Just Selection { appName = windowName\n                            , selection = mimeToSelectionType targetMime clipboardContent\n                            }\n\n where\n   chooseSelectionType mimes =\n     let selectedMime = msum $ (\\mime -> find (== mime) mimes) <$> mimesPriorities\n     in fromMaybe defaultMime selectedMime\n\n   mimeToSelectionType mimeTarget selContent =\n     if      mimeTarget == unsafeIndex mimesPriorities 0 then PNG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 1 then JPEG selContent\n     else if mimeTarget == unsafeIndex mimesPriorities 2 then BITMAP selContent\n     else UTF8 $ decodeUtf8 selContent\n\n   -- Removed dead code for incremental content retrieval\n-- Reason: The function `getContentIncrementally` is commented out, unused, and unnecessary as incremental transfers are explicitly not supported (`isIncremental` is always returned as `False`). Hence, it can be safely deleted.\n\n\ngetXorgContext :: IO XorgContext\ngetXorgContext = do\n    display <- openDisplay mempty\n    window <- createSimpleWindow display (defaultRootWindow display) 0 0 1 1 0 0 0\n    -- Removed unused commented-out code for `selectInput`\n-- Reason: The `selectInput` line is commented out and unnecessary in the given program flow.\n\n    clipboard <- internAtom display \"CLIPBOARD\" False\n    selTarget <- internAtom display \"GREENCLIP\" False\n    priorities <- traverse (\\atomName -> internAtom display atomName False) [\"image/png\", \"image/jpeg\", \"image/bmp\", \"UTF8_STRING\", \"TEXT\"] \n    defaultM <- internAtom display \"UTF8_STRING\" False\n    return XorgContext {\n        display = display\n      , ownWindow = window\n      , defaultClipboard = clipboard\n      , primaryClipboard = primaryClipboardAtom\n      , selectionTarget = selTarget\n      , mimesPriorities = priorities\n      , defaultMime = defaultM\n    }\n\ndestroyXorgContext :: XorgContext -> IO ()\ndestroyXorgContext XorgContext{..} = do\n    destroyWindow display ownWindow\n    closeDisplay display\n\nwaitNotify :: XorgContext -> IO ()\nwaitNotify XorgContext{..} = allocaXEvent (go display ownWindow)\n  where\n  go display' window evPtr = do\n    waitForEvents display'\n    nextEvent display' evPtr\n    ev <- getEvent evPtr\n    when (ev_event_type ev /= selectionNotify\n          &&  not (ev_event_type ev == propertyNotify && ev_atom ev == selectionTarget && ev_propstate ev == 1))\n      (go display' window evPtr)\n\n  waitForEvents display' = do\n    nbEvs <- pending display'\n    when (nbEvs == 0) $ threadDelay _10ms >> waitForEvents display'\n\n  _10ms = 10000\n\n\n\nsetClipboardSelection :: Selection -> IO ()\nsetClipboardSelection sel = void $ forkProcess $ do\n        mapM_ hClose [stdin, stdout, stderr]\n        setCurrentDirectory \"/\"\n        bracket getXorgContext destroyXorgContext $ \\ctx@XorgContext{..} -> do\n          let clipboards = [defaultClipboard, primaryClipboard]\n          mapM_ (\\atom -> xSetSelectionOwner display atom ownWindow currentTime) clipboards\n          advertiseSelection ctx sel\n          return ()\n\n\nselectionTypeToMime :: SelectionType -> ByteString\nselectionTypeToMime (PNG _)    = \"image/png\"\nselectionTypeToMime (JPEG _)   = \"image/jpeg\"\nselectionTypeToMime (BITMAP _) = \"image/bmp\"\nselectionTypeToMime (UTF8 _)   = \"UTF8_STRING\"\n\ngetContent :: SelectionType -> ByteString\ngetContent (PNG bytes)    = bytes\ngetContent (JPEG bytes)   = bytes\ngetContent (BITMAP bytes) = bytes\ngetContent (UTF8 txt)     = encodeUtf8 txt\n\nadvertiseSelection :: XorgContext -> Selection ->  IO ()\nadvertiseSelection ctx@XorgContext{..} sel = allocaXEvent (go [defaultClipboard, primaryClipboard])\n  where\n    go [] _ = return ()\n    go clipboards evPtr = do\n      nextEvent display evPtr\n      ev <- getEvent evPtr\n      case ev of\n          SelectionRequest {..} -> do\n              target' <- getAtomName display ev_target\n              response <- case target' of\n                Nothing -> return none\n                Just atomName -> handleRequest ctx (selection sel) ev_requestor ev_property (toS atomName)\n\n              sendSelectionNotify display ev_requestor ev_selection ev_target response ev_time\n              go clipboards evPtr\n\n          SelectionClear{..} -> go (filter (/= ev_selection) clipboards) evPtr\n\n          _ -> go clipboards evPtr\n\nhandleRequest :: XorgContext -> SelectionType -> Window -> Atom -> Text -> IO Atom\nhandleRequest XorgContext{..} sel requestorWindow selection \"TARGETS\" = do\n  targets <- internAtom display \"TARGETS\" True\n  target <- internAtom display (StrConvOld.toS $ selectionTypeToMime sel) True\n  changeProperty32 display requestorWindow selection aTOM propModeReplace [fromIntegral targets, fromIntegral target]\n  return selection\n\nhandleRequest XorgContext{..} sel req prop targetStr =\n  if targetStr == decodeUtf8 (selectionTypeToMime sel)\n    then do\n      target <- internAtom display (toS targetStr) True\n      void $ withArrayLen (byteStringToCUChars $ getContent sel) $ \\len bytes ->\n          xChangeProperty display req prop target 8 propModeReplace bytes (fromIntegral len)\n      return prop\n    else return none\n\nsendSelectionNotify :: Display -> Window -> Atom -> Atom -> Atom -> Time -> IO ()\nsendSelectionNotify display req sel target prop time = allocaXEvent $ \\ev -> do\n  setEventType ev selectionNotify\n  setSelectionNotify ev req sel target prop time\n  sendEvent display req False 0 ev\n\nbyteStringToCUChars :: ByteString -> [CUChar]\nbyteStringToCUChars = map fromIntegral . unpack\n"
            },
            {
              "file_name": "/tmp/project_89/pre_refactor/src/Main.hs",
              "refactored_file_name": "/tmp/project_89/hybrid_refactored/src/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 2,
                "sum": 70
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 336,
              "homplexity_lines_of_code": 312,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 2,
                  "sum": 70
                },
                "homplexity_loc": 312,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"configCodec\": 1,\n    \"readFile\": 1,\n    \"getHistory\": 1,\n    \"getStaticHistory\": 1,\n    \"storeHistory\": 1,\n    \"pruneHistory\": 1,\n    \"appendToHistory\": 5,\n    \"appendToHistory.appendImage\": 1,\n    \"appendToHistory.writeImage\": 2,\n    \"appendToHistory.appendGeneric\": 3,\n    \"setHistoryFilePermission\": 2,\n    \"prepareDirs\": 1,\n    \"runDaemon\": 1,\n    \"runDaemon.go\": 1,\n    \"runDaemon.getSelection\": 3,\n    \"runDaemon.innerloop\": 6,\n    \"runDaemon.getSelectionFrom\": 1,\n    \"runDaemon.purgeSelection\": 4,\n    \"runDaemon.purge\": 1,\n    \"runDaemon.handleError\": 2,\n    \"toRofiStr\": 5,\n    \"fromRofiStr\": 5,\n    \"getHash\": 1,\n    \"printHistoryForRofi\": 1,\n    \"advertiseSelection\": 1,\n    \"getConfig\": 3,\n    \"getConfig.defaultConfig\": 1,\n    \"parseArgs\": 6,\n    \"run\": 6,\n    \"main\": 2,\n    \"min\": 1,\n    \"max\": 6,\n    \"average\": 2.33,\n    \"sum\": 70\n  },\n  \"homplexity_loc\": 312,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE ViewPatterns          #-}\n\n\nmodule Main where\n\nimport           Protolude             hiding (readFile, to, (<&>), (&), toS)\nimport           Protolude.Conv        (toS)\n\nimport           Control.Monad.Catch   (MonadCatch, catchAll)\nimport qualified Crypto.Hash.MD5       as H\nimport           Data.Binary           (decodeFile, encode)\nimport qualified Data.ByteString       as B\nimport qualified Data.ByteString.Base16 as BB\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.List             (dropWhileEnd)\nimport qualified Data.Text             as T\nimport qualified Data.Text.Encoding    as TE\nimport           Data.Vector           (Vector)\nimport qualified Data.Vector           as V\nimport           Lens.Micro\nimport           Lens.Micro.Mtl    hiding ((.=))\nimport qualified System.Directory      as Dir\nimport           System.Posix.Files    (setFileMode)\nimport           System.Environment    (lookupEnv)\nimport           System.IO             (hClose, hGetContents)\nimport           System.Timeout        (timeout)\nimport           System.Wordexp.Simple (wordexp)\n--import           System.Posix.Temp     (mkdtemp)\n\nimport Toml (TomlCodec, (.=))\nimport qualified Toml\n\nimport qualified Clipboard             as Clip\n\n\ndata Command = DAEMON | PRINT | COPY Text | CLEAR | PRUNE FilePath | HELP deriving (Show, Read)\n\ndata Config = Config\n  { maxHistoryLength           :: Int\n  , maxItemSizeBytes           :: Int\n  , historyPath                :: Text\n  , imageCachePath             :: Text\n  , usePrimarySelectionAsInput :: Bool\n  , blacklistedApps            :: [Text]\n  , trimSpaceFromSelection     :: Bool\n  , enableImageSupport         :: Bool\n  , staticHistory              :: [Text]\n  } deriving (Show, Read)\n\nconfigCodec :: TomlCodec Config\nconfigCodec = Config\n    <$> Toml.int \"max_history_length\"  .= maxHistoryLength\n    <*> Toml.int \"max_selection_size_bytes\" .= maxItemSizeBytes\n    <*> Toml.text \"history_file\" .= historyPath\n    <*> Toml.text \"image_cache_directory\" .= imageCachePath\n    <*> Toml.bool \"use_primary_selection_as_input\" .= usePrimarySelectionAsInput\n    <*> Toml.arrayOf Toml._Text  \"blacklisted_applications\" .= blacklistedApps\n    <*> Toml.bool \"trim_space_from_selection\" .= trimSpaceFromSelection\n    <*> Toml.bool \"enable_image_support\" .= enableImageSupport\n    <*> Toml.arrayOf Toml._Text  \"static_history\" .= staticHistory\n\n\ntype ClipHistory = Vector Clip.Selection\n\nreadFile :: FilePath -> IO ByteString\nreadFile filepath = bracket (openFile filepath ReadMode) hClose $ \\h -> do\n  str <- hGetContents h\n  return $! toS str\n\n\ngetHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetHistory = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ (V.fromList <$> decodeFile storePath) `catchAll` const mempty\n\n\ngetStaticHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetStaticHistory = do\n  history <- view $ to (staticHistory)\n  return . V.fromList $ Clip.Selection \"greenclip\" . Clip.UTF8 <$> history\n\n\n\nstoreHistory :: (MonadIO m, MonadReader Config m) => ClipHistory -> m ()\nstoreHistory history = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ writeH storePath history\n  where\n    writeH storePath = B.writeFile storePath . toS . encode . V.toList\n\n\npruneHistory :: (MonadIO m, MonadReader Config m) => FilePath -> m ()\npruneHistory path = do\n  targets <- liftIO $ BC.lines <$> readFile path\n  history <- getHistory\n  storeHistory $ V.filter (go targets) history\n  where\n    go ts (Clip.Selection _ (Clip.UTF8 x)) = hashText x `notElem` ts\n    go _  _                                = False\n    hashText = BB.encode . H.hash . TE.encodeUtf8\n\n\nappendToHistory :: (MonadIO m, MonadReader Config m) => Clip.Selection -> ClipHistory -> m (ClipHistory, ClipHistory)\nappendToHistory sel history' = do\n  trimSelection <- view $ to trimSpaceFromSelection\n  case sel of\n    Clip.Selection appName (Clip.UTF8 txt) -> appendGeneric (if trimSelection then Clip.Selection appName (Clip.UTF8 (T.strip txt)) else sel) history'\n    Clip.Selection _ (Clip.PNG bytes) -> appendImage Clip.PNG \".png\" bytes\n    Clip.Selection _ (Clip.JPEG bytes) -> appendImage Clip.JPEG \".jpeg\" bytes\n    Clip.Selection _ (Clip.BITMAP bytes) -> appendImage Clip.BITMAP \".bmp\" bytes\n\n\n  where\n    appendImage imgCtr extension bytes = do\n      cachePth <- view (to imageCachePath)\n      let imgHash = show $ hash bytes\n      let imgPath = toS $ cachePth <> \"/\" <> imgHash <> extension\n      _ <- liftIO $ writeImage imgPath bytes\n      appendGeneric (sel {Clip.selection = imgCtr $ toS imgHash}) history'\n\n    writeImage path bytes = do\n      fileExist <- Dir.doesFileExist path\n      if fileExist\n        then return False\n        else B.writeFile path bytes >> setFileMode path 0o600 >> return True\n\n    appendGeneric selection history =\n      if maybe False (\\sel' -> Clip.selection sel' == Clip.selection selection) (history V.!? 0)\n        then return (history, mempty)\n        else do\n          maxLen <- view $ to maxHistoryLength\n          return $ V.splitAt maxLen . V.cons selection $ V.filter (\\ori -> Clip.selection ori /= Clip.selection selection) history\n\n\nsetHistoryFilePermission :: (MonadIO m, MonadReader Config m) => m ()\nsetHistoryFilePermission = do\n  storePath <- view $ to (toS . historyPath)\n  fileExist <- liftIO $ Dir.doesFileExist storePath\n  when (not fileExist) (storeHistory mempty)\n  liftIO $ setFileMode storePath 0o600\n\nprepareDirs :: (MonadIO m, MonadReader Config m) => m ()\nprepareDirs = do\n  historyFile <- view $ to (T.unpack . historyPath)\n  imgDir <- view $ to (T.unpack . imageCachePath)\n  let dirs = [imgDir, dropWhileEnd (/= '/') historyFile]\n  mapM_ (liftIO . Dir.createDirectoryIfMissing True) dirs\n\nrunDaemon:: (MonadIO m, MonadCatch m, MonadReader Config m) => m ()\nrunDaemon = prepareDirs >> setHistoryFilePermission >> (forever $ go `catchAll` handleError)\n  where\n    _0_5sec :: Int\n    _0_5sec = 5 * 100000\n\n    _5sec :: Int\n    _5sec = 5000000\n\n    go = do\n      history <- getHistory\n      usePrimary <- view $ to usePrimarySelectionAsInput\n      enableImage <- view $ to enableImageSupport\n      cfg <- ask\n\n      liftIO $ bracket Clip.getXorgContext Clip.destroyXorgContext $ \\x11Context -> do\n        let getSelections = (getSelectionFrom (Clip.getClipboardSelection x11Context enableImage), Nothing)\n                          : [(getSelectionFrom (Clip.getPrimarySelection x11Context enableImage), Nothing) | usePrimary]\n        void $ runReaderT (innerloop getSelections history) cfg\n\n    getSelection [] = return ([], Nothing)\n    getSelection ((getSel, lastSel):getSels) = do\n      selection <- liftIO getSel\n      if fmap Clip.selection selection /= fmap Clip.selection lastSel\n         then return ((getSel, selection) : getSels, selection)\n         else getSelection getSels >>= \\(e, sel) -> return ((getSel, lastSel) : e, sel)\n\n    innerloop :: (MonadIO m, MonadReader Config m) => [(IO (Maybe Clip.Selection), Maybe Clip.Selection)] -> ClipHistory -> m ClipHistory\n    innerloop getSelections history = do\n      -- Get selection from enabled clipboards\n      (getSelections', rawSelection) <- liftIO $ getSelection getSelections\n\n      -- Do not store selection items above threshold size\n      maxItemSize <- view (to maxItemSizeBytes)\n      let sel = case rawSelection of\n            Nothing -> Nothing\n            Just selection -> if maxItemSize > 0 && Clip.selectionLength selection >= maxItemSize\n                              then Nothing\n                              else Just selection\n             \n      -- Do not use selection coming from blacklisted app\n      liftIO $ when (isJust sel) (print (Clip.appName <$> sel))\n      blacklist <- view (to blacklistedApps)\n      let selection = sel >>= \\s -> if isJust $ find (== Clip.appName s) blacklist\n                                      then Nothing\n                                      else Just s\n\n      -- Append current selection to history and get back entries needed to be purged\n      (history', toBePurged) <- maybe (return (history, mempty)) (`appendToHistory` history) selection\n      traverse_ purgeSelection toBePurged\n\n      -- backup on disk history if it as changed seen last backup\n      when (isJust selection && history' /= history) (storeHistory history')\n\n      -- Getting some rest\n      liftIO $ threadDelay _0_5sec\n      innerloop getSelections' history'\n\n    getSelectionFrom :: IO (Maybe Clip.Selection) -> IO (Maybe Clip.Selection)\n    getSelectionFrom = fmap join . timeout _5sec\n\n    purgeSelection (Clip.Selection _ (Clip.PNG txt)) = purge (toS txt <> \".png\")\n    purgeSelection (Clip.Selection _ (Clip.JPEG txt)) = purge (toS txt <> \".jpeg\")\n    purgeSelection (Clip.Selection _ (Clip.BITMAP txt)) = purge (toS txt <> \".bmp\")\n    purgeSelection _ = return ()\n\n    purge path = do\n      cachePth <- view (to imageCachePath)\n      liftIO $ Dir.removeFile (toS $ cachePth <> \"/\" <> path) `catchAll` const mempty\n\n    handleError ex = do\n      let displayMissing = \"openDisplay\" `T.isInfixOf` show ex\n      if displayMissing\n      then panic \"X display not available. Please start Xorg before running greenclip\"\n      else print ex\n      liftIO $ threadDelay _0_5sec\n\n\ntoRofiStr :: Clip.Selection -> Text\ntoRofiStr (Clip.Selection _ (Clip.UTF8 txt)) = T.map (\\c -> if c == '\\n' || c == '\\r' then '\\xA0' else c) txt\ntoRofiStr (Clip.Selection appName (Clip.PNG txt)) = \"image/png \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.JPEG txt)) = \"image/jpeg \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.BITMAP txt)) = \"image/bmp \" <> appName <> \" \" <> toS txt\n\nfromRofiStr :: Text -> Text -> IO Clip.Selection\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/png \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".png\") <&> Clip.Selection \"greenclip\" . Clip.PNG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/jpeg \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".jpeg\") <&> Clip.Selection \"greenclip\" . Clip.JPEG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/bmp \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".bmp\") <&> Clip.Selection \"greenclip\" . Clip.BITMAP\nfromRofiStr _ txt = return $ Clip.Selection \"greenclip\" (Clip.UTF8 (T.map (\\c -> if c == '\\xA0' then '\\n' else c) txt))\n\ngetHash :: Text -> Text\ngetHash = fromMaybe mempty . lastMay . T.split (== ' ')\n\n\nprintHistoryForRofi :: (MonadIO m, MonadReader Config m) => m ()\nprintHistoryForRofi = do\n  history <- mappend <$> getHistory <*> getStaticHistory\n  _ <- traverse (putStrLn . toRofiStr) history\n  return ()\n\n\nadvertiseSelection :: (MonadIO m, MonadReader Config m) => Text -> m ()\nadvertiseSelection txt = do\n  cachePth <- view (to imageCachePath)\n  selection <- liftIO $ fromRofiStr cachePth txt\n  liftIO $ Clip.setClipboardSelection selection\n\n\ngetConfig :: IO Config\ngetConfig = do\n  home <- Dir.getHomeDirectory\n  let configPath = home <> \"/.config/greenclip.toml\"\n  \n  configExist <- Dir.doesFileExist configPath\n  when (not configExist) $ do \n    config <- Toml.encode (Toml.table configCodec \"greenclip\") <$> defaultConfig\n    writeFile configPath config\n    return ()\n  \n  tomlRes <- Toml.decodeFileEither (Toml.table configCodec \"greenclip\") configPath\n  when (isLeft tomlRes) $ do\n    die . toS $  \"Error parsing the config file at \" <> (show configPath) <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n  \n  let cfg = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes \n  \n  -- Replace $HOME|~|*... in config path\n  cfg <- do\n    imgCachePath <- wordexp . toS $ imageCachePath cfg\n    historyP <- wordexp . toS $ historyPath cfg \n    return $ cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP)}\n    \n  -- if it ends with / we don't create a temp directory\n  -- user is responsible for it\n  -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n  --    then do\n  --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n  --      return $ cfg { imageCachePath = toS dirPath }\n  --    else return cfg\n     \n  return cfg\n\n  where\n    defaultConfig = do \n      homeDir <- toS . fromMaybe mempty . listToMaybe <$> wordexp \"~/\"\n      return $ Config 50 0 (homeDir <> \".cache/greenclip.history\") \"/tmp/greenclip\" False [] True True \n        [\"Greenclip has been updated to v4.1, update your new config file at ~/.config/greenclip.toml\"]\n\n\nparseArgs :: [Text] -> Command\nparseArgs (\"daemon\":_)   = DAEMON\nparseArgs [\"clear\"]      = CLEAR\nparseArgs [\"prune\", p]   = PRUNE $ T.unpack p\nparseArgs [\"print\"]      = PRINT\nparseArgs [\"print\", sel] = COPY sel\nparseArgs _              = HELP\n\nrun :: Command -> IO ()\nrun cmd = do\n  cfg <- getConfig\n  case cmd of\n    DAEMON   -> runReaderT runDaemon cfg\n    PRINT    -> runReaderT printHistoryForRofi cfg\n    CLEAR    -> runReaderT (storeHistory mempty) cfg\n    PRUNE p  -> runReaderT (pruneHistory p) cfg\n    -- Should rename COPY into ADVERTISE but as greenclip is already used I don't want to break configs\n    -- of other people\n    COPY sel -> runReaderT (advertiseSelection sel) cfg\n    HELP     -> putText $ \"greenclip v4.3 -- Recyle your clipboard selections\\n\\n\" <>\n                          \"Available commands\\n\" <>\n                          \"daemon: Spawn the daemon that will listen to selections\\n\" <>\n                          \"print:  Display all selections history\\n\" <>\n                          \"prune FILE: Remove selections in list of md5 hashes in FILE\\n\" <>\n                          \"clear:  Clear history\\n\" <>\n                          \"help:   Display this message\\n\"\n\nmain :: IO ()\nmain = do\n  displayPresent <- lookupEnv \"DISPLAY\"\n  case displayPresent of\n    Nothing -> putText \"X display not available. Please start Xorg before running greenclip\"\n    _       -> getArgs >>= run . parseArgs . fmap toS\n",
              "suggestions": [
                {
                  "target_snippet": "-- import           System.Posix.Temp     (mkdtemp)",
                  "refactored_suggestion": "-- System.Posix.Temp (mkdtemp) is commented and appears unused. Considering removing all traces if unused elsewhere.",
                  "confidence": 0.9,
                  "justification": "The commented-out `System.Posix.Temp (mkdtemp)` import is completely unused in the code. Removing it would improve code readability without any functional changes."
                },
                {
                  "target_snippet": "-- if it ends with / we don't create a temp directory\n      -- user is responsible for it\n      -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n      --    then do\n      --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n      --      return $ cfg { imageCachePath = toS dirPath }\n      --    else return cfg",
                  "refactored_suggestion": "-- This commented-out section can be considered for complete removal if tracing proves it's obsolete and unnecessary.",
                  "confidence": 0.8,
                  "justification": "The commented-out code section with `mkdtemp` logic appears unused and does not align with the current operational flow of `getConfig`. Removing it would reduce the codebase clutter while preserving operational functionality."
                },
                {
                  "target_snippet": "readFile :: FilePath -> IO ByteString\nreadFile filepath = bracket (openFile filepath ReadMode) hClose $ \\h -> do\n  str <- hGetContents h\n  return $! toS str",
                  "refactored_suggestion": "import qualified Data.ByteString as BS\n\nreadFile :: FilePath -> IO ByteString\nreadFile = BS.readFile",
                  "confidence": 1.0,
                  "justification": "The implementation of `readFile` can be replaced by `Data.ByteString.readFile`, which is more idiomatic, concise, and optimized for reading a `ByteString` directly from a file."
                },
                {
                  "target_snippet": "when (not fileExist) (storeHistory mempty)",
                  "refactored_suggestion": "unless fileExist (storeHistory mempty)",
                  "confidence": 1.0,
                  "justification": "`unless` is a more idiomatic and readable replacement for `when (not ...)`. It helps to clearly articulate the intent of the negative condition."
                },
                {
                  "target_snippet": "if maybe False (\\sel' -> Clip.selection sel' == Clip.selection selection) (history V.!? 0)\n        then return (history, mempty)\n        else do",
                  "refactored_suggestion": "case history V.!? 0 of\n        Just sel' | Clip.selection sel' == Clip.selection selection -> return (history, mempty)\n        _ -> do",
                  "confidence": 0.9,
                  "justification": "Using a `case` expression instead of `if maybe` improves readability and avoids unnecessary ad-hoc branching, especially when using `Maybe`."
                },
                {
                  "target_snippet": "when (isJust selection && history' /= history) (storeHistory history')",
                  "refactored_suggestion": "unless (isNothing selection || history' == history) (storeHistory history')",
                  "confidence": 1.0,
                  "justification": "Using `unless` to combine the negation of the conditions is more readable than combining with `when`."
                },
                {
                  "target_snippet": "_ <- traverse (putStrLn . toRofiStr) history",
                  "refactored_suggestion": "traverse_ (putStrLn . toRofiStr) history",
                  "confidence": 1.0,
                  "justification": "`traverse_` is preferred when the result of `traverse` is discarded, as it avoids retaining unnecessary intermediate structures."
                },
                {
                  "target_snippet": "cfg <- do\n    imgCachePath <- wordexp . toS $ imageCachePath cfg\n    historyP <- wordexp . toS $ historyPath cfg \n    return $ cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP)}",
                  "refactored_suggestion": "cfg <- liftA2\n    (\\imgCachePath historyP -> cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP) })\n    (wordexp . toS $ imageCachePath cfg)\n    (wordexp . toS $ historyPath cfg)",
                  "confidence": 0.85,
                  "justification": "Using `liftA2` avoids explicit multiple bindings and results in more concise and functional code."
                }
              ],
              "refactored_code": "\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE ViewPatterns          #-}\n\n\nmodule Main where\n\nimport           Protolude             hiding (readFile, to, (<&>), (&), toS)\nimport           Protolude.Conv        (toS)\n\nimport           Control.Monad.Catch   (MonadCatch, catchAll)\nimport qualified Crypto.Hash.MD5       as H\nimport           Data.Binary           (decodeFile, encode)\nimport qualified Data.ByteString       as B\nimport qualified Data.ByteString.Base16 as BB\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.List             (dropWhileEnd)\nimport qualified Data.Text             as T\nimport qualified Data.Text.Encoding    as TE\nimport           Data.Vector           (Vector)\nimport qualified Data.Vector           as V\nimport           Lens.Micro\nimport           Lens.Micro.Mtl    hiding ((.=))\nimport qualified System.Directory      as Dir\nimport           System.Posix.Files    (setFileMode)\nimport           System.Environment    (lookupEnv)\nimport           System.IO             (hClose, hGetContents)\nimport           System.Timeout        (timeout)\nimport           System.Wordexp.Simple (wordexp)\n--import           System.Posix.Temp     (mkdtemp)\n\nimport Toml (TomlCodec, (.=))\nimport qualified Toml\n\nimport qualified Clipboard             as Clip\n\n\ndata Command = DAEMON | PRINT | COPY Text | CLEAR | PRUNE FilePath | HELP deriving (Show, Read)\n\ndata Config = Config\n  { maxHistoryLength           :: Int\n  , maxItemSizeBytes           :: Int\n  , historyPath                :: Text\n  , imageCachePath             :: Text\n  , usePrimarySelectionAsInput :: Bool\n  , blacklistedApps            :: [Text]\n  , trimSpaceFromSelection     :: Bool\n  , enableImageSupport         :: Bool\n  , staticHistory              :: [Text]\n  } deriving (Show, Read)\n\nconfigCodec :: TomlCodec Config\nconfigCodec = Config\n    <$> Toml.int \"max_history_length\"  .= maxHistoryLength\n    <*> Toml.int \"max_selection_size_bytes\" .= maxItemSizeBytes\n    <*> Toml.text \"history_file\" .= historyPath\n    <*> Toml.text \"image_cache_directory\" .= imageCachePath\n    <*> Toml.bool \"use_primary_selection_as_input\" .= usePrimarySelectionAsInput\n    <*> Toml.arrayOf Toml._Text  \"blacklisted_applications\" .= blacklistedApps\n    <*> Toml.bool \"trim_space_from_selection\" .= trimSpaceFromSelection\n    <*> Toml.bool \"enable_image_support\" .= enableImageSupport\n    <*> Toml.arrayOf Toml._Text  \"static_history\" .= staticHistory\n\n\ntype ClipHistory = Vector Clip.Selection\n\nimport qualified Data.ByteString as BS\n\nreadFile :: FilePath -> IO ByteString\nreadFile = BS.readFile\n\n\ngetHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetHistory = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ (V.fromList <$> decodeFile storePath) `catchAll` const mempty\n\n\ngetStaticHistory :: (MonadIO m, MonadReader Config m) => m ClipHistory\ngetStaticHistory = do\n  history <- view $ to (staticHistory)\n  return . V.fromList $ Clip.Selection \"greenclip\" . Clip.UTF8 <$> history\n\n\n\nstoreHistory :: (MonadIO m, MonadReader Config m) => ClipHistory -> m ()\nstoreHistory history = do\n  storePath <- view $ to (toS . historyPath)\n  liftIO $ writeH storePath history\n  where\n    writeH storePath = B.writeFile storePath . toS . encode . V.toList\n\n\npruneHistory :: (MonadIO m, MonadReader Config m) => FilePath -> m ()\npruneHistory path = do\n  targets <- liftIO $ BC.lines <$> readFile path\n  history <- getHistory\n  storeHistory $ V.filter (go targets) history\n  where\n    go ts (Clip.Selection _ (Clip.UTF8 x)) = hashText x `notElem` ts\n    go _  _                                = False\n    hashText = BB.encode . H.hash . TE.encodeUtf8\n\n\nappendToHistory :: (MonadIO m, MonadReader Config m) => Clip.Selection -> ClipHistory -> m (ClipHistory, ClipHistory)\nappendToHistory sel history' = do\n  trimSelection <- view $ to trimSpaceFromSelection\n  case sel of\n    Clip.Selection appName (Clip.UTF8 txt) -> appendGeneric (if trimSelection then Clip.Selection appName (Clip.UTF8 (T.strip txt)) else sel) history'\n    Clip.Selection _ (Clip.PNG bytes) -> appendImage Clip.PNG \".png\" bytes\n    Clip.Selection _ (Clip.JPEG bytes) -> appendImage Clip.JPEG \".jpeg\" bytes\n    Clip.Selection _ (Clip.BITMAP bytes) -> appendImage Clip.BITMAP \".bmp\" bytes\n\n\n  where\n    appendImage imgCtr extension bytes = do\n      cachePth <- view (to imageCachePath)\n      let imgHash = show $ hash bytes\n      let imgPath = toS $ cachePth <> \"/\" <> imgHash <> extension\n      _ <- liftIO $ writeImage imgPath bytes\n      appendGeneric (sel {Clip.selection = imgCtr $ toS imgHash}) history'\n\n    writeImage path bytes = do\n      fileExist <- Dir.doesFileExist path\n      if fileExist\n        then return False\n        else B.writeFile path bytes >> setFileMode path 0o600 >> return True\n\n    appendGeneric selection history =\n      case history V.!? 0 of\n        Just sel' | Clip.selection sel' == Clip.selection selection -> return (history, mempty)\n        _ -> do\n          maxLen <- view $ to maxHistoryLength\n          return $ V.splitAt maxLen . V.cons selection $ V.filter (\\ori -> Clip.selection ori /= Clip.selection selection) history\n\n\nsetHistoryFilePermission :: (MonadIO m, MonadReader Config m) => m ()\nsetHistoryFilePermission = do\n  storePath <- view $ to (toS . historyPath)\n  fileExist <- liftIO $ Dir.doesFileExist storePath\n  unless fileExist (storeHistory mempty)\n  liftIO $ setFileMode storePath 0o600\n\nprepareDirs :: (MonadIO m, MonadReader Config m) => m ()\nprepareDirs = do\n  historyFile <- view $ to (T.unpack . historyPath)\n  imgDir <- view $ to (T.unpack . imageCachePath)\n  let dirs = [imgDir, dropWhileEnd (/= '/') historyFile]\n  mapM_ (liftIO . Dir.createDirectoryIfMissing True) dirs\n\nrunDaemon:: (MonadIO m, MonadCatch m, MonadReader Config m) => m ()\nrunDaemon = prepareDirs >> setHistoryFilePermission >> (forever $ go `catchAll` handleError)\n  where\n    _0_5sec :: Int\n    _0_5sec = 5 * 100000\n\n    _5sec :: Int\n    _5sec = 5000000\n\n    go = do\n      history <- getHistory\n      usePrimary <- view $ to usePrimarySelectionAsInput\n      enableImage <- view $ to enableImageSupport\n      cfg <- ask\n\n      liftIO $ bracket Clip.getXorgContext Clip.destroyXorgContext $ \\x11Context -> do\n        let getSelections = (getSelectionFrom (Clip.getClipboardSelection x11Context enableImage), Nothing)\n                          : [(getSelectionFrom (Clip.getPrimarySelection x11Context enableImage), Nothing) | usePrimary]\n        void $ runReaderT (innerloop getSelections history) cfg\n\n    getSelection [] = return ([], Nothing)\n    getSelection ((getSel, lastSel):getSels) = do\n      selection <- liftIO getSel\n      if fmap Clip.selection selection /= fmap Clip.selection lastSel\n         then return ((getSel, selection) : getSels, selection)\n         else getSelection getSels >>= \\(e, sel) -> return ((getSel, lastSel) : e, sel)\n\n    innerloop :: (MonadIO m, MonadReader Config m) => [(IO (Maybe Clip.Selection), Maybe Clip.Selection)] -> ClipHistory -> m ClipHistory\n    innerloop getSelections history = do\n      -- Get selection from enabled clipboards\n      (getSelections', rawSelection) <- liftIO $ getSelection getSelections\n\n      -- Do not store selection items above threshold size\n      maxItemSize <- view (to maxItemSizeBytes)\n      let sel = case rawSelection of\n            Nothing -> Nothing\n            Just selection -> if maxItemSize > 0 && Clip.selectionLength selection >= maxItemSize\n                              then Nothing\n                              else Just selection\n             \n      -- Do not use selection coming from blacklisted app\n      liftIO $ when (isJust sel) (print (Clip.appName <$> sel))\n      blacklist <- view (to blacklistedApps)\n      let selection = sel >>= \\s -> if isJust $ find (== Clip.appName s) blacklist\n                                      then Nothing\n                                      else Just s\n\n      -- Append current selection to history and get back entries needed to be purged\n      (history', toBePurged) <- maybe (return (history, mempty)) (`appendToHistory` history) selection\n      traverse_ purgeSelection toBePurged\n\n      -- backup on disk history if it as changed seen last backup\n      unless (isNothing selection || history' == history) (storeHistory history')\n\n      -- Getting some rest\n      liftIO $ threadDelay _0_5sec\n      innerloop getSelections' history'\n\n    getSelectionFrom :: IO (Maybe Clip.Selection) -> IO (Maybe Clip.Selection)\n    getSelectionFrom = fmap join . timeout _5sec\n\n    purgeSelection (Clip.Selection _ (Clip.PNG txt)) = purge (toS txt <> \".png\")\n    purgeSelection (Clip.Selection _ (Clip.JPEG txt)) = purge (toS txt <> \".jpeg\")\n    purgeSelection (Clip.Selection _ (Clip.BITMAP txt)) = purge (toS txt <> \".bmp\")\n    purgeSelection _ = return ()\n\n    purge path = do\n      cachePth <- view (to imageCachePath)\n      liftIO $ Dir.removeFile (toS $ cachePth <> \"/\" <> path) `catchAll` const mempty\n\n    handleError ex = do\n      let displayMissing = \"openDisplay\" `T.isInfixOf` show ex\n      if displayMissing\n      then panic \"X display not available. Please start Xorg before running greenclip\"\n      else print ex\n      liftIO $ threadDelay _0_5sec\n\n\ntoRofiStr :: Clip.Selection -> Text\ntoRofiStr (Clip.Selection _ (Clip.UTF8 txt)) = T.map (\\c -> if c == '\\n' || c == '\\r' then '\\xA0' else c) txt\ntoRofiStr (Clip.Selection appName (Clip.PNG txt)) = \"image/png \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.JPEG txt)) = \"image/jpeg \" <> appName <> \" \" <> toS txt\ntoRofiStr (Clip.Selection appName (Clip.BITMAP txt)) = \"image/bmp \" <> appName <> \" \" <> toS txt\n\nfromRofiStr :: Text -> Text -> IO Clip.Selection\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/png \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".png\") <&> Clip.Selection \"greenclip\" . Clip.PNG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/jpeg \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".jpeg\") <&> Clip.Selection \"greenclip\" . Clip.JPEG\nfromRofiStr cachePth txt@(T.isPrefixOf \"image/bmp \" -> True) = B.readFile (toS $ cachePth <> \"/\" <> getHash txt <> \".bmp\") <&> Clip.Selection \"greenclip\" . Clip.BITMAP\nfromRofiStr _ txt = return $ Clip.Selection \"greenclip\" (Clip.UTF8 (T.map (\\c -> if c == '\\xA0' then '\\n' else c) txt))\n\ngetHash :: Text -> Text\ngetHash = fromMaybe mempty . lastMay . T.split (== ' ')\n\n\nprintHistoryForRofi :: (MonadIO m, MonadReader Config m) => m ()\nprintHistoryForRofi = do\n  history <- mappend <$> getHistory <*> getStaticHistory\n  traverse_ (putStrLn . toRofiStr) history\n  return ()\n\n\nadvertiseSelection :: (MonadIO m, MonadReader Config m) => Text -> m ()\nadvertiseSelection txt = do\n  cachePth <- view (to imageCachePath)\n  selection <- liftIO $ fromRofiStr cachePth txt\n  liftIO $ Clip.setClipboardSelection selection\n\n\ngetConfig :: IO Config\ngetConfig = do\n  home <- Dir.getHomeDirectory\n  let configPath = home <> \"/.config/greenclip.toml\"\n  \n  configExist <- Dir.doesFileExist configPath\n  when (not configExist) $ do \n    config <- Toml.encode (Toml.table configCodec \"greenclip\") <$> defaultConfig\n    writeFile configPath config\n    return ()\n  \n  tomlRes <- Toml.decodeFileEither (Toml.table configCodec \"greenclip\") configPath\n  when (isLeft tomlRes) $ do\n    die . toS $  \"Error parsing the config file at \" <> (show configPath) <> \"\\n\" <> Toml.prettyTomlDecodeErrors (fromLeft mempty tomlRes)\n  \n  let cfg = fromRight (Config 50 0 \"\" \"\" False [] True True []) tomlRes \n  \n  -- Replace $HOME|~|*... in config path\n  cfg <- liftA2\n    (\\imgCachePath historyP -> cfg { imageCachePath = (toS $ headDef \"\" imgCachePath), historyPath = (toS $ headDef \"\" historyP) })\n    (wordexp . toS $ imageCachePath cfg)\n    (wordexp . toS $ historyPath cfg)\n    \n  -- if it ends with / we don't create a temp directory\n  -- user is responsible for it\n  -- cfg <- if (lastDef ' ' (toS $ imageCachePath cfg) /= '/')\n  --    then do\n  --      dirPath <- mkdtemp $ (toS $ imageCachePath cfg)\n  --      return $ cfg { imageCachePath = toS dirPath }\n  --    else return cfg\n     \n  return cfg\n\n  where\n    defaultConfig = do \n      homeDir <- toS . fromMaybe mempty . listToMaybe <$> wordexp \"~/\"\n      return $ Config 50 0 (homeDir <> \".cache/greenclip.history\") \"/tmp/greenclip\" False [] True True \n        [\"Greenclip has been updated to v4.1, update your new config file at ~/.config/greenclip.toml\"]\n\n\nparseArgs :: [Text] -> Command\nparseArgs (\"daemon\":_)   = DAEMON\nparseArgs [\"clear\"]      = CLEAR\nparseArgs [\"prune\", p]   = PRUNE $ T.unpack p\nparseArgs [\"print\"]      = PRINT\nparseArgs [\"print\", sel] = COPY sel\nparseArgs _              = HELP\n\nrun :: Command -> IO ()\nrun cmd = do\n  cfg <- getConfig\n  case cmd of\n    DAEMON   -> runReaderT runDaemon cfg\n    PRINT    -> runReaderT printHistoryForRofi cfg\n    CLEAR    -> runReaderT (storeHistory mempty) cfg\n    PRUNE p  -> runReaderT (pruneHistory p) cfg\n    -- Should rename COPY into ADVERTISE but as greenclip is already used I don't want to break configs\n    -- of other people\n    COPY sel -> runReaderT (advertiseSelection sel) cfg\n    HELP     -> putText $ \"greenclip v4.3 -- Recyle your clipboard selections\\n\\n\" <>\n                          \"Available commands\\n\" <>\n                          \"daemon: Spawn the daemon that will listen to selections\\n\" <>\n                          \"print:  Display all selections history\\n\" <>\n                          \"prune FILE: Remove selections in list of md5 hashes in FILE\\n\" <>\n                          \"clear:  Clear history\\n\" <>\n                          \"help:   Display this message\\n\"\n\nmain :: IO ()\nmain = do\n  displayPresent <- lookupEnv \"DISPLAY\"\n  case displayPresent of\n    Nothing -> putText \"X display not available. Please start Xorg before running greenclip\"\n    _       -> getArgs >>= run . parseArgs . fmap toS\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}