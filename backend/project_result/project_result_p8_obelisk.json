{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 51,
          "max": 194,
          "average": 19.386363636363637,
          "sum": 853
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 37,
          "suggestion": 46,
          "ignore": 0,
          "total": 83
        },
        "syntax_errors": 489,
        "lines_of_code": 8551,
        "homplexity_lines_of_code": 9613,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "855.1MB",
          "runtime": "1.31 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 12,
          "code_quality_score": 96.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 12,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 1 1: <unnamed module> has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 7 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 7 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 8 1: function main has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 8 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs\" 8 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Frontend\nimport Common.Route\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport Reflex.Dom\n\nmain :: IO ()\nmain = do\n  let Right validFullEncoder = checkEncoder fullRouteEncoder\n  run $ runFrontend validFullEncoder frontend\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/frontend/src-bin/main.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/frontend/src-bin/main.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs",
          "cyclomatic_complexity": {
            "min": 3,
            "max": 3,
            "average": 3.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 11,
          "lines_of_code": 58,
          "homplexity_lines_of_code": 64,
          "code_quality_score": 87.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 3,
              "max": 3,
              "average": 3.0,
              "sum": 3
            },
            "homplexity_loc": 64,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 1 1: module Frontend has 41 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 28 1: type signature for frontend has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 28 1: type signature for frontend has 1 arguments \nWarning:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has 23 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has branching depth of 2 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Frontend where\n\nimport Control.Lens ((^.))\nimport Control.Monad\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle (liftJSM, js, js1, jsg)\n\nimport Obelisk.Frontend\nimport Obelisk.Configs\nimport Obelisk.Route\nimport Obelisk.Generated.Static\n\nimport Reflex.Dom.Core\n\nimport Common.Api\nimport Common.Route\n\n\n-- This runs in a monad that can be run on the client or the server.\n-- To run code in a pure client or pure server context, use one of the\n-- `prerender` functions.\nfrontend :: Frontend (R FrontendRoute)\nfrontend = Frontend\n  { _frontend_head = do\n      el \"title\" $ text \"Obelisk Minimal Example\"\n      elAttr \"script\" (\"type\" =: \"application/javascript\" <> \"src\" =: $(static \"lib.js\")) blank\n      elAttr \"link\" (\"href\" =: $(static \"main.css\") <> \"type\" =: \"text/css\" <> \"rel\" =: \"stylesheet\") blank\n  , _frontend_body = do\n      el \"h1\" $ text \"Welcome to Obelisk!\"\n      el \"p\" $ text $ T.pack commonStuff\n\n      -- `prerender` and `prerender_` let you choose a widget to run on the server\n      -- during prerendering and a different widget to run on the client with\n      -- JavaScript. The following will generate a `blank` widget on the server and\n      -- print \"Hello, World!\" on the client.\n      prerender_ blank $ liftJSM $ void\n        $ jsg (\"window\" :: T.Text)\n        ^. js (\"skeleton_lib\" :: T.Text)\n        ^. js1 (\"log\" :: T.Text) (\"Hello, World!\" :: T.Text)\n\n      elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n      el \"div\" $ do\n        let\n          cfg = \"common/example\"\n          path = \"config/\" <> cfg\n        getConfig cfg >>= \\case\n          Nothing -> text $ \"No config file found in \" <> path\n          Just bytes -> case T.decodeUtf8' bytes of\n            Left ue -> text $ \"Couldn't decode \" <> path <> \" : \" <> T.pack (show ue)\n            Right s -> text s\n      return ()\n  }\n",
          "suggestions": [
            {
              "module": [
                "Frontend"
              ],
              "decl": [
                "frontend"
              ],
              "severity": "Warning",
              "hint": "Redundant ^.",
              "file": "/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs",
              "startLine": 43,
              "startColumn": 11,
              "endLine": 45,
              "endColumn": 61,
              "from": "jsg (\"window\" :: T.Text) ^. js (\"skeleton_lib\" :: T.Text)\n  ^. js1 (\"log\" :: T.Text) (\"Hello, World!\" :: T.Text)",
              "to": "(jsg (\"window\" :: T.Text)\n   ^.\n     (js (\"skeleton_lib\" :: T.Text)\n        . js1 (\"log\" :: T.Text) (\"Hello, World!\" :: T.Text)))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 43, startCol = 11, endLine = 45, endCol = 61}, subts = [(\"a\",SrcSpan {startLine = 43, startCol = 11, endLine = 43, endCol = 35}),(\"b\",SrcSpan {startLine = 44, startCol = 12, endLine = 44, endCol = 41}),(\"c\",SrcSpan {startLine = 45, startCol = 12, endLine = 45, endCol = 61})], orig = \"(a ^. (b . c))\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/frontend/src/Frontend.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/frontend/src/Frontend.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 6,
          "homplexity_lines_of_code": 6,
          "code_quality_score": 97.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 6,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 1 1: <unnamed module> has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 5 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 5 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 6 1: function main has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 6 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs\" 6 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Backend\nimport Frontend\nimport Obelisk.Backend\n\nmain :: IO ()\nmain = runBackend backend frontend\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/backend/src-bin/main.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/backend/src-bin/main.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 2,
          "lines_of_code": 10,
          "homplexity_lines_of_code": 10,
          "code_quality_score": 97.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 10,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 1 1: module Backend has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 6 1: type signature for backend has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 6 1: type signature for backend has 1 arguments \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 7 1: function backend has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 7 1: function backend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs\" 7 1: function backend has branching depth of 0 \n"
          },
          "original_code": "module Backend where\n\nimport Common.Route\nimport Obelisk.Backend\n\nbackend :: Backend BackendRoute FrontendRoute\nbackend = Backend\n  { _backend_run = \\serve -> serve $ const $ return ()\n  , _backend_routeEncoder = fullRouteEncoder\n  }\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/backend/src/Backend.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/backend/src/Backend.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 0,
          "lines_of_code": 4,
          "homplexity_lines_of_code": 4,
          "code_quality_score": 97.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 4,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 1 1: module Common.Api has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 3 1: type signature for commonStuff has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 3 1: type signature for commonStuff has 1 arguments \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has branching depth of 0 \n"
          },
          "original_code": "module Common.Api where\n\ncommonStuff :: String\ncommonStuff = \"Here is a string defined in Common.Api\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/common/src/Common/Api.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Api.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 2,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 3,
          "lines_of_code": 48,
          "homplexity_lines_of_code": 38,
          "code_quality_score": 94.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 38,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 1 1: module Common.Route has 32 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 28 3: data BackendRoute has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 33 3: data FrontendRoute has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has 1 arguments \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule Common.Route where\n\n{- -- You will probably want these imports for composing Encoders.\nimport Prelude hiding (id, (.))\nimport Control.Category\n-}\n\nimport Data.Text (Text)\nimport Data.Functor.Identity\n\nimport Obelisk.Route\nimport Obelisk.Route.TH\n\ndata BackendRoute :: * -> * where\n  -- | Used to handle unparseable routes.\n  BackendRoute_Missing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.\n\ndata FrontendRoute :: * -> * where\n  FrontendRoute_Main :: FrontendRoute ()\n  -- This type is used to define frontend routes, i.e. ones for which the backend will serve the frontend.\n\nfullRouteEncoder\n  :: Encoder (Either Text) Identity (R (FullRoute BackendRoute FrontendRoute)) PageName\nfullRouteEncoder = mkFullRouteEncoder\n  (FullRoute_Backend BackendRoute_Missing :/ ())\n  (\\case\n      BackendRoute_Missing -> PathSegment \"missing\" $ unitEncoder mempty)\n  (\\case\n      FrontendRoute_Main -> PathEnd $ unitEncoder mempty)\n\nconcat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ]\n",
          "suggestions": [
            {
              "module": [
                "Common.Route"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
              "startLine": 6,
              "startColumn": 1,
              "endLine": 6,
              "endColumn": 32,
              "from": "{-# LANGUAGE KindSignatures #-}",
              "to": "",
              "note": [
                "Extension KindSignatures is implied by TypeFamilies"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 6, startCol = 1, endLine = 6, endCol = 32}, newComment = \"\"}]"
            },
            {
              "module": [
                "Common.Route"
              ],
              "decl": [
                "BackendRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
              "startLine": 26,
              "startColumn": 1,
              "endLine": 28,
              "endColumn": 42,
              "from": "data BackendRoute :: * -> *\n  where BackendRoute_Missing :: BackendRoute ()",
              "to": "data BackendRoute :: * -> *\n  where BackendRouteMissing :: BackendRoute ()",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Common.Route"
              ],
              "decl": [
                "FrontendRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
              "startLine": 32,
              "startColumn": 1,
              "endLine": 33,
              "endColumn": 41,
              "from": "data FrontendRoute :: * -> *\n  where FrontendRoute_Main :: FrontendRoute ()",
              "to": "data FrontendRoute :: * -> *\n  where FrontendRouteMain :: FrontendRoute ()",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/skeleton/common/src/Common/Route.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 1.7142857142857142,
            "sum": 12
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 26,
          "lines_of_code": 261,
          "homplexity_lines_of_code": 297,
          "code_quality_score": 46.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 1.7142857142857142,
              "sum": 12
            },
            "homplexity_loc": 297,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): module Obelisk.Frontend has 210 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): data Frontend has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 133 1: type signature for setInitialRoute has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 133 1: type signature for setInitialRoute has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has 8 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 143 21: data FrontendMode has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has 11 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has 5 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has type constructor nesting of 1 \nCritical:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has 43 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 239 1: type signature for renderFrontendHtml has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 239 1: type signature for renderFrontendHtml has 8 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has 12 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Frontend\n  ( ObeliskWidget\n  , Frontend (..)\n  , runFrontend\n  , runFrontendWithConfigsAndCurrentRoute\n  , renderFrontendHtml\n  , removeHTMLConfigs\n  , FrontendMode (..)\n  , FrontendWidgetT\n  , module Obelisk.Frontend.Cookie\n  ) where\n\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Prelude hiding ((.))\n\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Maybe (MaybeT(..), runMaybeT)\nimport Data.ByteString (ByteString)\nimport Data.Foldable (for_)\nimport Data.Map (Map)\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.History as DOM\nimport qualified GHCJS.DOM.Window as DOM\nimport Language.Javascript.JSaddle (MonadJSM, JSM, jsNull)\nimport GHCJS.DOM (currentDocument)\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.Node (Node, removeChild_)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport Obelisk.Frontend.Cookie\nimport Obelisk.Route.Frontend\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Obelisk.Configs\nimport Obelisk.ExecutableConfig.Inject (injectExecutableConfigs)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport System.Info (os)\nimport Web.Cookie\n\nimport Debug.Trace\n\ntype ObeliskWidget t route m =\n  ( DomBuilder t m\n  , MonadFix m\n  , MonadHold t m\n  , MonadSample t (Performable m)\n  , MonadReflexCreateTrigger t m\n  , PostBuild t m\n  , PerformEvent t m\n  , TriggerEvent t m\n  , HasDocument m\n  , MonadRef m\n  , Ref m ~ Ref IO\n  , MonadRef (Performable m)\n  , Ref (Performable m) ~ Ref IO\n  , MonadFix (Performable m)\n  , PrimMonad m\n  , Prerender t m\n  , PrebuildAgnostic t route m\n  , PrebuildAgnostic t route (Client m)\n  , HasConfigs m\n  , HasCookies m\n  , MonadIO (Performable m)\n  )\n\ntype PrebuildAgnostic t route m =\n  ( SetRoute t route m\n  , RouteToUrl route m\n  , MonadFix m\n  , HasConfigs m\n  , HasConfigs (Performable m)\n  )\n\ndata Frontend route = Frontend\n  { _frontend_head :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  , _frontend_body :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  }\n\nbaseTag :: forall route t m. ObeliskWidget t route m => RoutedT t route m ()\nbaseTag =\n  if os == \"ios\"\n    then blank\n    else elAttr \"base\" (\"href\" =: \"/\") blank --TODO: Figure out the base URL from the routes\n\nremoveHTMLConfigs :: JSM ()\nremoveHTMLConfigs = void $ runMaybeT $ do\n  doc <- MaybeT currentDocument\n  hd <- MaybeT $ getHead doc\n  es <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  for_ es $ removeChild_ hd\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in exe-config/ghcjs/lookup should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n\nsetInitialRoute :: Bool -> JSM ()\nsetInitialRoute useHash = do\n  traceM \"setInitialRoute\"\n  window <- DOM.currentWindowUnchecked\n  initialLocation <- DOM.getLocation window\n  initialUri <- getLocationUri initialLocation\n  history <- DOM.getHistory window\n  DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n    show $ setAdaptedUriPath useHash \"/\" initialUri\n\ndata FrontendMode = FrontendMode\n  { _frontendMode_hydrate :: Bool\n    -- ^ There is already a rendering of the DOM in place; hydrate it rather\n    -- than building new DOM\n  , _frontendMode_adjustRoute :: Bool\n    -- ^ The page can't use regular routes, so encode routes into the hash\n    -- instead\n  }\n\n-- | Run the frontend, setting the initial route to \"/\" on platforms where no\n-- route exists ambiently in the context (e.g. anything but web).\n-- Selects FrontendMode based on platform; this doesn't work for jsaddle-warp\nrunFrontend\n  :: forall backendRoute route\n  .  Encoder Identity Identity (R (FullRoute backendRoute route)) PageName\n  -> Frontend (R route)\n  -> JSM ()\nrunFrontend validFullEncoder frontend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate =\n#ifdef ghcjs_HOST_OS\n          True\n#else\n          False\n#endif\n        , _frontendMode_adjustRoute =\n#ifdef ghcjs_HOST_OS\n          False\n#else\n          True\n#endif\n        }\n  configs <- liftIO Lookup.getConfigs\n  when (_frontendMode_hydrate mode) removeHTMLConfigs\n  -- There's no fundamental reason that adjustRoute needs to control setting the\n  -- initial route and *also* the useHash parameter; that's why these are\n  -- separate here.  However, currently, they are always the same.\n  when (_frontendMode_adjustRoute mode) $ do\n    setInitialRoute $ _frontendMode_adjustRoute mode\n  runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n\nrunFrontendWithConfigsAndCurrentRoute\n  :: forall backendRoute frontendRoute\n  .  FrontendMode\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> Frontend (R frontendRoute)\n  -> JSM ()\nrunFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend = do\n  let ve = validFullEncoder . hoistParse errorLeft (reviewEncoder (rPrism $ _FullRoute_Frontend . _ObeliskRoute_App))\n      errorLeft = \\case\n        Left _ -> error \"runFrontend: Unexpected non-app ObeliskRoute reached the frontend. This shouldn't happen.\"\n        Right x -> Identity x\n      w :: ( RawDocument (DomBuilderSpace (HydrationDomBuilderT s DomTimeline m)) ~ DOM.Document\n           , Ref (Performable m) ~ Ref IO\n           , Ref m ~ Ref IO\n           , DomBuilder DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadHold DomTimeline m\n           , MonadRef m\n           , MonadRef (Performable m)\n           , MonadReflexCreateTrigger DomTimeline m\n           , PerformEvent DomTimeline m\n           , PostBuild DomTimeline m\n           , PrimMonad m\n           , MonadSample DomTimeline (Performable m)\n           , DOM.MonadJSM m\n           , MonadFix (Client (HydrationDomBuilderT s DomTimeline m))\n           , MonadFix (Performable m)\n           , MonadFix m\n           , Prerender DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadIO (Performable m)\n           )\n        => (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> FloatingWidget () ()\n      w appendHead appendBody = do\n        rec switchover <- runRouteViewT ve switchover (_frontendMode_adjustRoute mode) $ do\n              (switchover'', fire) <- newTriggerEvent\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendHead . runConfigsT configs))) $ do\n                -- The order here is important - baseTag has to be before headWidget!\n                baseTag\n                _frontend_head frontend\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendBody . runConfigsT configs))) $ do\n                _frontend_body frontend\n                switchover' <- case _frontendMode_hydrate mode of\n                  True -> lift $ lift $ lift $ lift $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n                  False -> getPostBuild\n                performEvent_ $ liftIO (fire ()) <$ switchover'\n              pure switchover''\n        pure ()\n  if _frontendMode_hydrate mode\n    then runHydrationWidgetWithHeadAndBody (pure ()) w\n    else runImmediateWidgetWithHeadAndBody w\n\ntype FrontendWidgetT r = RoutedT DomTimeline r (SetRouteT DomTimeline r (RouteToUrlT r (ConfigsT (CookiesT (HydratableT (PostBuildT DomTimeline (StaticDomBuilderT DomTimeline (PerformEventT DomTimeline DomHost))))))))\n\nrenderFrontendHtml\n  :: MonadIO m\n  => Map Text ByteString\n  -> Cookies\n  -> (r -> Text)\n  -> r\n  -> Frontend r\n  -> FrontendWidgetT r ()\n  -> FrontendWidgetT r ()\n  -> m ByteString\nrenderFrontendHtml configs cookies urlEnc route frontend headExtra bodyExtra = do\n  --TODO: We should probably have a \"NullEventWriterT\" or a frozen reflex timeline\n  html <- fmap snd $ liftIO $ renderStatic $ runHydratableT $ fmap fst $ runCookiesT cookies $ runConfigsT configs $ flip runRouteToUrlT urlEnc $ runSetRouteT $ flip runRoutedT (pure route) $\n    el \"html\" $ do\n      el \"head\" $ do\n        baseTag\n        injectExecutableConfigs configs\n        _frontend_head frontend\n        headExtra\n      el \"body\" $ do\n        _frontend_body frontend\n        bodyExtra\n  return $ \"<!DOCTYPE html>\" <> html\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Frontend"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs",
              "startLine": 12,
              "startColumn": 1,
              "endLine": 12,
              "endColumn": 33,
              "from": "{-# LANGUAGE TemplateHaskell #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 12, startCol = 1, endLine = 12, endCol = 33}, newComment = \"\"}]"
            },
            {
              "module": [
                "Obelisk.Frontend"
              ],
              "decl": [
                "runFrontendWithConfigsAndCurrentRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs",
              "startLine": 227,
              "startColumn": 32,
              "endLine": 229,
              "endColumn": 40,
              "from": "case _frontendMode_hydrate mode of\n  True\n    -> lift\n         $ lift\n             $ lift\n                 $ lift\n                     $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n  False -> getPostBuild",
              "to": "(if _frontendMode_hydrate mode then\n     lift\n       $ lift\n           $ lift\n               $ lift\n                   $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n else\n     getPostBuild)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 227, startCol = 32, endLine = 229, endCol = 40}, subts = [(\"a\",SrcSpan {startLine = 227, startCol = 37, endLine = 227, endCol = 63}),(\"f\",SrcSpan {startLine = 229, startCol = 28, endLine = 229, endCol = 40}),(\"t\",SrcSpan {startLine = 228, startCol = 27, endLine = 228, endCol = 117})], orig = \"(if a then t else f)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/frontend/src/Obelisk/Frontend.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 13,
          "lines_of_code": 103,
          "homplexity_lines_of_code": 90,
          "code_quality_score": 87.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 90,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 1 1: module Obelisk.Frontend.Cookie has 88 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 34 3: type class HasCookies has method + value count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 34 3: type class HasCookies has associated type count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 53 24: data CookiesT has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 87 1: type signature for runCookiesT has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 87 1: type signature for runCookiesT has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 96 1: type signature for mapCookiesT has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 96 1: type signature for mapCookiesT has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Obelisk.Frontend.Cookie where\n\nimport Control.Monad.Fix\nimport Control.Monad.Primitive\nimport Control.Monad.Ref\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Reader\nimport Data.Text.Encoding (encodeUtf8)\nimport Reflex\nimport Reflex.Host.Class\nimport Reflex.Dom.Core\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getCookie, Document)\nimport GHCJS.DOM.Types (MonadJSM)\nimport Web.Cookie\n\nimport Obelisk.Configs\nimport Obelisk.Route.Frontend\n\nclass Monad m => HasCookies m where\n  askCookies :: m Cookies\n  default askCookies :: (HasCookies m', m ~ t m', MonadTrans t) => m Cookies\n  askCookies = lift askCookies\n\ninstance HasCookies m => HasCookies (BehaviorWriterT t w m)\ninstance HasCookies m => HasCookies (DynamicWriterT t w m)\ninstance HasCookies m => HasCookies (EventWriterT t w m)\ninstance HasCookies m => HasCookies (PostBuildT t m)\ninstance HasCookies m => HasCookies (QueryT t q m)\ninstance HasCookies m => HasCookies (ReaderT r m)\ninstance HasCookies m => HasCookies (RequesterT t request response m)\ninstance HasCookies m => HasCookies (RouteToUrlT t m)\ninstance HasCookies m => HasCookies (SetRouteT t r m)\ninstance HasCookies m => HasCookies (StaticDomBuilderT t m)\ninstance HasCookies m => HasCookies (TriggerEventT t m)\ninstance HasCookies m => HasCookies (RoutedT t r m)\ninstance HasCookies m => HasCookies (ConfigsT m)\ninstance HasConfigs m => HasConfigs (CookiesT m)\n\nnewtype CookiesT m a = CookiesT { unCookiesT :: ReaderT Cookies m a }\n  deriving\n    ( Functor\n    , Applicative\n    , DomBuilder t\n    , Monad\n    , MonadFix\n    , MonadHold t\n    , MonadIO\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    , MonadRef\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , MonadTrans\n    , NotReady t\n    , PerformEvent t\n    , PostBuild t\n    , Prerender t\n    , TriggerEvent t\n    , HasDocument\n    )\n\ninstance Adjustable t m => Adjustable t (CookiesT m) where\n  runWithReplace a e = CookiesT $ runWithReplace (unCookiesT a) (unCookiesT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = CookiesT $ traverseDMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = CookiesT $ traverseIntMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = CookiesT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unCookiesT $ f k v) m e\n\ninstance PrimMonad m => PrimMonad (CookiesT m) where\n  type PrimState (CookiesT m) = PrimState m\n  primitive = lift . primitive\n\nrunCookiesT\n  :: Cookies\n  -> CookiesT m a\n  -> m a\nrunCookiesT cs child = runReaderT (unCookiesT child) cs\n\ninstance Monad m => HasCookies (CookiesT m) where\n  askCookies = CookiesT ask\n\nmapCookiesT\n  :: (forall x. m x -> n x)\n  -> CookiesT m a\n  -> CookiesT n a\nmapCookiesT f (CookiesT x) = CookiesT $ mapReaderT f x\n\ninstance (MonadJSM m, RawDocument (DomBuilderSpace (HydrationDomBuilderT s t m)) ~ Document) => HasCookies (HydrationDomBuilderT s t m) where\n  askCookies = fmap (parseCookies . encodeUtf8) $ getCookie =<< askDocument\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 6,
            "average": 3,
            "sum": 102
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 4,
            "suggestion": 10,
            "ignore": 0,
            "total": 14
          },
          "syntax_errors": 36,
          "lines_of_code": 1290,
          "homplexity_lines_of_code": 869,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 6,
              "average": 3,
              "sum": 102
            },
            "homplexity_loc": 869,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 6,\n        \"average\": 2.55,\n        \"sum\": 102\n    },\n    \"homplexity_loc\": 869\n}\n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-|\n\nTypes and functions for defining routes and 'Encoder's.\n\n-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE EmptyDataDecls #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.Route\n  ( -- * Primary Types\n    R\n  , PageName\n  , PathQuery\n  , Encoder\n  , EncoderImpl (..)\n  , EncoderFunc (..)\n\n  -- * Patterns, operators, and utilities\n  , (:.)\n  , (?/)\n  , hoistR\n  , pattern (:.)\n  , pattern (:/)\n  , unsafeEncoder\n  , checkEncoder\n  , unsafeMkEncoder\n  , encode\n  , decode\n  , tryDecode\n  , hoistCheck\n  , hoistParse\n  , mapSome\n  , rPrism\n  , _R\n  , renderObeliskRoute\n  , renderBackendRoute\n  , renderFrontendRoute\n  , byteStringsToPageName\n\n  -- * Collating Routes\n  , SegmentResult (..)\n  , pathComponentEncoder\n\n  , FullRoute (..)\n  , _FullRoute_Frontend\n  , _FullRoute_Backend\n  , mkFullRouteEncoder\n\n  , ObeliskRoute (..)\n  , _ObeliskRoute_App\n  , _ObeliskRoute_Resource\n  , ResourceRoute (..)\n\n  , JSaddleWarpRoute (..)\n  , jsaddleWarpRouteEncoder\n\n  , IndexOnlyRoute (..)\n  , indexOnlyRouteSegment\n  , indexOnlyRouteEncoder\n\n  -- * Provided Encoders\n  , enumEncoder\n  , enum1Encoder\n  , checkEnum1EncoderFunc\n  , unitEncoder\n  , pathOnlyEncoder\n  , addPathSegmentEncoder\n  , pathParamEncoder\n  , pathLiteralEncoder\n  , singletonListEncoder\n  , packTextEncoder\n  , unpackTextEncoder\n  , prefixTextEncoder\n  , unsafeTshowEncoder\n  , unsafeShowEncoder\n  , readShowEncoder\n  , someConstEncoder\n  , singlePathSegmentEncoder\n  , maybeEncoder\n  , maybeToEitherEncoder\n  , justEncoder\n  , nothingEncoder\n  , isoEncoder\n  , viewEncoder\n  , wrappedEncoder\n  , unwrappedEncoder\n  , listToNonEmptyEncoder\n  , prefixNonemptyTextEncoder\n  , joinPairTextEncoder\n  , toListMapEncoder\n  , shadowEncoder\n  , prismEncoder\n  , reviewEncoder\n  , obeliskRouteEncoder\n  , obeliskRouteSegment\n  , pageNameEncoder\n  , handleEncoder\n  , someSumEncoder\n  , Void1\n  , void1Encoder\n  , pathSegmentsTextEncoder\n  , queryParametersTextEncoder\n  , integralEncoder\n  , pathSegmentEncoder\n  , queryOnlyEncoder\n  , Decoder(..)\n  , dmapEncoder\n  , fieldMapEncoder\n  , pathFieldEncoder\n  , jsonEncoder\n  ) where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Applicative\nimport Control.Category (Category (..))\nimport qualified Control.Categorical.Functor as Cat\nimport Control.Categorical.Bifunctor\nimport Control.Category.Associative\nimport Control.Category.Monoidal\nimport Control.Category.Braided\nimport Control.Lens\n  ( Identity (..)\n  , (^.)\n  , (^?)\n  , _Just\n  , _Nothing\n  , Cons(..)\n  , from\n  , imap\n  , iso\n  , Iso'\n  , itraverse\n  , makePrisms\n  , Prism'\n  , prism'\n  , re\n  , review\n  , view\n  , Wrapped (..)\n  )\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Trans (lift)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad.Except\nimport qualified Control.Monad.State.Strict as State\nimport Control.Monad.Writer (execWriter, tell)\nimport Data.Aeson (FromJSON, ToJSON)\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Dependent.Map (DMap)\nimport qualified Data.Dependent.Map as DMap\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Either.Validation (Validation (..))\nimport Data.Foldable\nimport Data.Functor (($>))\nimport Data.Functor.Sum\nimport Data.GADT.Compare\nimport Data.GADT.Compare.TH\nimport Data.GADT.Show\nimport Data.List.NonEmpty (NonEmpty (..))\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport Data.Monoid (Ap(..))\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.Semigroupoid\nimport Data.Some (Some(Some), mapSome)\nimport Data.Tabulation\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Text.Lens (IsText, packed, unpacked)\nimport Data.Type.Equality\nimport Data.Universe\nimport Data.Universe.Some\nimport Network.HTTP.Types.URI\nimport qualified Numeric.Lens\nimport Obelisk.Route.TH\nimport Text.Read (readMaybe)\n\n-- Design goals:\n-- No start-up time on the frontend (not yet met)\n-- Able to ensure that there aren't overlapping routes prior to deployment\n-- Easy to write common types of parsers\n--   Completeness checking\n\n-- Laws:\n-- We statically know that all valid Routes can be turned into valid URIs\n--   - This means we need to know whether there are any overlaps, e.g. with the static file namespace\n\n--TODO:\n-- Backend:\n--  Redirect the user to a canonical route\n--  Pre-render\n-- Frontend:\n--  Intercept links that can be kept within the app\n--  Fragments\n\n--------------------------------------------------------------------------------\n-- Subroutes/paths\n--------------------------------------------------------------------------------\n\n-- | This alias is used to wrap the type of a route GADT so that the type variable of the GADT is existentially quantified.\n--\n-- Given the following route type :\n--\n-- @\n--\n-- data MyRoutes a where\n--   MyRoutes_Main :: MyRoutes ()\n--   MyRoutes_A :: MyRoutes Text\n--   MyRoutes_B :: MyRoutes Int\n-- @\n--\n-- Using 'R' we're able to write type signatures without worrying about the 'a':\n--\n-- @\n-- myRoutesWidget :: RoutedT t (R MyRoutes) m ()\n-- @\n--\ntype R f = DSum f Identity --TODO: Better name\n\n-- | Convenience builder for an 'R' using 'Identity' for the functor.\npattern (:/) :: f a -> a -> R f\npattern a :/ b = a :=> Identity b\n{-# COMPLETE (:/) #-}\ninfixr 5 :/\n\n-- | Like '(:/)' but adds a 'Just' wrapper around the right-hand side.\n(?/) :: f (Maybe a) -> a -> R f\nr ?/ a = r :/ Just a\ninfixr 5 ?/\n\nhoistR :: (forall x. f x -> g x) -> R f -> R g\nhoistR f (x :=> Identity y) = f x :/ y\n\n--------------------------------------------------------------------------------\n-- Dealing with pairs (i.e. non-dependently-typed subroutes/paths)\n--------------------------------------------------------------------------------\n\ninfixr 5 :.\ntype (:.) = (,)\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ >= 810\n{-# COMPLETE (:.) #-}\n#else\n{-# WARNING (:.)\n  [ \"Use of this pattern in GHC < 8.10 will result in spurious non-exhaustive warnings at every use site.\"\n  , \"We cannot provide a COMPLETE pragma to silence these due to a GHC bug: https://gitlab.haskell.org/ghc/ghc/issues/17729.\"\n  , \"The bug hides incompleteness warnings for all two tuples when the COMPLETE pattern is in scope.\"\n  , \"Instead, you should use (,) directly until you can switch to GHC >= 8.10, where the COMPLETE pragma is reinstated.\"\n  ]\n  #-}\n#endif\n#endif\npattern (:.) :: a -> b -> a :. b\npattern a :. b = (a, b)\n\naddPathSegmentEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse (Text, PageName) PageName\naddPathSegmentEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(ph, (pt, q)) -> (ph : pt, q)\n  , _encoderImpl_decode = \\(p, q) -> case p of\n      [] -> throwError \"Expected a path segment\"\n      ph : pt -> pure (ph, (pt, q))\n  }\n\npathParamEncoder\n  :: forall check parse item rest.\n     ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse item Text\n  -> Encoder check parse rest PageName\n  -> Encoder check parse (item :. rest) PageName\npathParamEncoder itemUnchecked restUnchecked = addPathSegmentEncoder . bimap itemUnchecked restUnchecked\n\npathLiteralEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Text\n  -> Encoder check parse a PageName\n  -> Encoder check parse a PageName\npathLiteralEncoder t e = addPathSegmentEncoder . bimap (unitEncoder t) e . coidl\n\n--------------------------------------------------------------------------------\n-- Encoder fundamentals\n--------------------------------------------------------------------------------\n\n-- | This is the type of route encoder/decoders. It is parameterised over two monads: Firstly, the monad\n-- used to check the validity of the encoder (i.e. that it is total), secondly the monad used for parsing\n-- during the decode phase. The following two parameters are respectively the type of decoded data, and the\n-- encoded type.\nnewtype Encoder check parse decoded encoded =\n  Encoder { unEncoder :: check (EncoderImpl parse decoded encoded) }\n\nunsafeEncoder :: check (EncoderImpl parse decoded encoded) -> Encoder check parse decoded encoded\nunsafeEncoder = Encoder\n\n-- | The internal type used to construct primitive 'Encoder' values.\n-- Law:\n-- forall p. _encoderImpl_decode ve . _encoderImpl_encode ve p == pure\n-- Note that the reverse may not be the case: when parsing, a route may be canonicalized, and erroneous routes may be collapsed to a single 404 route.  However, as a consequence of the law, encode . decode must be idempotent.\ndata EncoderImpl parse decoded encoded = EncoderImpl\n  { _encoderImpl_decode :: !(encoded -> parse decoded) -- Can fail; can lose information; must always succeed on outputs of `_encoderImpl_encode` and result in the original value\n  , _encoderImpl_encode :: !(decoded -> encoded) -- Must be injective\n  }\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', and its parser is total\n-- so that its parse monad is also 'Identity', it may be used to actually decode by applying this function.\ndecode :: Encoder Identity Identity decoded encoded -> encoded -> decoded\ndecode e x = runIdentity (tryDecode e x)\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', even if the same is not true of the\n-- parse monad, we may still attempt to decode with it in its parse monad.\ntryDecode :: Encoder Identity parse decoded encoded -> encoded -> parse decoded\ntryDecode (Encoder (Identity impl)) = _encoderImpl_decode impl\n\n-- | Similar to 'decode', once an encoder has been checked so that its check monad is Identity, it\n-- can be used to actually encode by using this. Note that while there's no constraint on the parse monad here,\n-- one should usually be applying decode and encode to the same 'Encoder'\nencode :: Encoder Identity parse decoded encoded -> decoded -> encoded\nencode (Encoder (Identity impl)) = _encoderImpl_encode impl\n\n-- | This is a primitive used to build encoders which can't fail to check. It should not be used unless one is\n-- reasonably certain that the law given for 'EncoderImpl' above holds.\nunsafeMkEncoder :: (Applicative check) => EncoderImpl parse decoded encoded -> Encoder check parse decoded encoded\nunsafeMkEncoder impl = Encoder (pure impl)\n\n-- | Transform the check monad of an 'Encoder' by applying a natural transformation.\nhoistCheck :: (forall t. check t -> check' t) -> Encoder check parse a b -> Encoder check' parse a b\nhoistCheck f (Encoder x) = Encoder (f x)\n\n-- | Transform the parse monad of an 'Encoder' by applying a natural transformation.\nhoistParse :: (Functor check)\n  => (forall t. parse t -> parse' t) -> Encoder check parse a b -> Encoder check parse' a b\nhoistParse f (Encoder x) = Encoder (fmap (\\(EncoderImpl dec enc) -> EncoderImpl (f . dec) enc) x)\n\n-- | Check an 'Encoder', transforming it into one whose check monad is anything we want (usually Identity).\ncheckEncoder :: (Applicative check', Functor check)\n  => Encoder check parse decoded encoded\n  -> check (Encoder check' parse decoded encoded)\ncheckEncoder = fmap unsafeMkEncoder . unEncoder\n\ninstance (Applicative check, Monad parse) => Semigroupoid (Encoder check parse) where\n  Encoder f `o` Encoder g = Encoder $ liftA2 (.) f g\n\ninstance (Applicative check, Monad parse) => Category (Encoder check parse) where\n  id = Encoder $ pure id\n  (.) = o\n\ninstance Monad parse => Category (EncoderImpl parse) where\n  id = EncoderImpl\n    { _encoderImpl_decode = pure\n    , _encoderImpl_encode = id\n    }\n  f . g = EncoderImpl\n    { _encoderImpl_decode = _encoderImpl_decode g <=< _encoderImpl_decode f\n    , _encoderImpl_encode = _encoderImpl_encode f . _encoderImpl_encode g\n    }\n\ninstance Monad parse => PFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  second g = bimap id g\ninstance Monad parse => Bifunctor (,) (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\(a, b) -> liftA2 (,) (_encoderImpl_decode f a) (_encoderImpl_decode g b)\n    }\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) (,) where\n  braid = viewEncoder (iso swap swap)\n\n\ninstance (Applicative check, Monad parse) => PFunctor (,) (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Applicative check, Monad parse) => QFunctor (,) (Encoder check parse) (Encoder check parse) where\n  second g = bimap id g\ninstance (Applicative check, Monad parse) => Bifunctor (,) (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Traversable f, Monad parse) => Cat.Functor f (EncoderImpl parse) (EncoderImpl parse) where\n  fmap ve = EncoderImpl\n    { _encoderImpl_encode = fmap $ _encoderImpl_encode ve\n    , _encoderImpl_decode = traverse $ _encoderImpl_decode ve\n    }\n\ninstance Monad parse => PFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  second g = bimap id g\ninstance Monad parse => Bifunctor Either (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\case\n      Left a -> Left <$> _encoderImpl_decode f a\n      Right b -> Right <$> _encoderImpl_decode g b\n    }\n\ninstance (Monad parse, Applicative check) => QFunctor Either (Encoder check parse) (Encoder check parse) where\n  second g = bimap id g\ninstance (Monad parse, Applicative check) => PFunctor Either (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Monad parse, Applicative check) => Bifunctor Either (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) Either where\n  associate = viewEncoder (iso (associate @(->) @Either) disassociate)\n  disassociate = viewEncoder (iso disassociate associate)\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) Either where\n  braid = viewEncoder (iso swap swap)\n\n\n\ninstance (Traversable f, Monad check, Monad parse) => Cat.Functor f (Encoder check parse) (Encoder check parse) where\n  fmap e = Encoder $ do\n    ve <- unEncoder e\n    pure $ Cat.fmap ve\n\ninstance Monad parse => Associative (EncoderImpl parse) (,) where\n  associate = EncoderImpl\n    { _encoderImpl_encode = associate\n    , _encoderImpl_decode = pure . disassociate\n    }\n  disassociate = EncoderImpl\n    { _encoderImpl_encode = disassociate\n    , _encoderImpl_decode = pure . associate\n    }\n\ninstance Monad parse => Monoidal (EncoderImpl parse) (,) where\n  type Id (EncoderImpl parse) (,) = ()\n  idl = EncoderImpl\n    { _encoderImpl_encode = idl\n    , _encoderImpl_decode = pure . coidl\n    }\n  idr = EncoderImpl\n    { _encoderImpl_encode = idr\n    , _encoderImpl_decode = pure . coidr\n    }\n  coidl = EncoderImpl\n    { _encoderImpl_encode = coidl\n    , _encoderImpl_decode = pure . idl\n    }\n  coidr = EncoderImpl\n    { _encoderImpl_encode = coidr\n    , _encoderImpl_decode = pure . idr\n    }\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) (,) where\n  associate = Encoder $ pure associate\n  disassociate = Encoder $ pure disassociate\n\ninstance (Applicative check, Monad parse) => Monoidal (Encoder check parse) (,) where\n  type Id (Encoder check parse) (,) = ()\n  idl = Encoder $ pure idl\n  idr = Encoder $ pure idr\n  coidl = Encoder $ pure coidl\n  coidr = Encoder $ pure coidr\n\n--------------------------------------------------------------------------------\n-- Specific instances of encoders\n--------------------------------------------------------------------------------\n\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nviewEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nviewEncoder f = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = view f\n  , _encoderImpl_decode = pure . view (from f)\n  }\n\nwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse (Unwrapped a) a\nwrappedEncoder = viewEncoder $ from _Wrapped'\n\nunwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse a (Unwrapped a)\nunwrappedEncoder = viewEncoder $ _Wrapped'\n\nmaybeToEitherEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a) (Either () a)\nmaybeToEitherEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Nothing -> Left ()\n      Just a -> Right a\n  , _encoderImpl_decode = pure . \\case\n      Left _ -> Nothing\n      Right a -> Just a\n  }\n\nmaybeEncoder\n  :: ( MonadError Text check\n     , Show a\n     , Show b\n     , check ~ parse\n     )\n  => Encoder check parse () b\n  -> Encoder check parse a b\n  -> Encoder check parse (Maybe a) b\nmaybeEncoder f g = shadowEncoder f g . maybeToEitherEncoder\n\n-- | Encode a value by simply applying 'Just'\njustEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a (Maybe a)\njustEncoder = reviewEncoder _Just\n\n-- | Encode () to 'Nothing'.\nnothingEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse () (Maybe a)\nnothingEncoder = reviewEncoder _Nothing\n\nsomeConstEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Const a)) a\nsomeConstEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(Some (Const a)) -> a\n  , _encoderImpl_decode = pure . Some . Const\n  }\n\n-- | WARNING: This is only safe if the Show and Read instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeTshowEncoder :: (Show a, Read a, Applicative check, MonadError Text parse) => Encoder check parse a Text\nunsafeTshowEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = tshow\n  , _encoderImpl_decode = \\raw -> case readMaybe $ T.unpack raw of\n      Nothing -> throwError $ \"unsafeTshowEncoderImpl: couldn't decode \" <> tshow raw\n      Just parsed -> pure parsed\n  }\n\nnewtype EncoderFunc check parse p r = EncoderFunc { runEncoderImplFunc :: forall a. p a -> Encoder check parse a r }\n\nnewtype Flip f a b = Flip { unFlip :: f b a }\n\ncheckEnum1EncoderFunc\n  :: forall check check' parse p r.\n     ( Universe (Some p)\n     , GCompare p\n     , Monad check\n     , Applicative check'\n     )\n  => (forall a. p a -> Encoder check parse a r)\n  -> check (EncoderFunc check' parse p r)\ncheckEnum1EncoderFunc f = do\n  (encoderImpls :: DMap p (Flip (EncoderImpl parse) r)) <- DMap.fromList <$>\n    traverse (\\(Some p) -> (p :=>) . Flip <$> unEncoder (f p)) universe\n  pure $ EncoderFunc $ \\p -> unsafeMkEncoder . unFlip $\n    DMap.findWithDefault (error \"checkEnum1EncoderFunc: EncoderImpl not found (should be impossible)\") p encoderImpls\n\n-- | This type is used by pathComponentEncoder to allow the user to indicate how to treat\n-- various cases when encoding a dependent sum of type `(R p)`.\ndata SegmentResult check parse a =\n    PathEnd (Encoder check parse a (Map Text (Maybe Text)))\n    -- ^ Indicate that the path is finished, with an Encoder that translates the\n    -- corresponding value into query parameters\n  | PathSegment Text (Encoder check parse a PageName)\n    -- ^ Indicate that the key should be represented by an additional path segment with\n    -- the given 'Text', and give an Encoder for translating the corresponding value into\n    -- the remainder of the route.\n\n-- | Encode a dependent sum of type `(R p)` into a PageName (i.e. the path and query part of a URL) by using the\n-- supplied function to decide how to encode the constructors of p using the SegmentResult type. It is important\n-- that the number of values of type `(Some p)` be relatively small in order for checking to complete quickly.\npathComponentEncoder\n  :: forall check parse p.\n     ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse )\n  => (forall a. p a -> SegmentResult check parse a)\n  -> Encoder check parse (R p) PageName\npathComponentEncoder f = Encoder $ do\n  let extractEncoder = \\case\n        PathEnd e -> first (unitEncoder []) . coidl . e\n        PathSegment _ e -> e\n      extractPathSegment = \\case\n        PathEnd _ -> Nothing\n        PathSegment t _ -> Just t\n  EncoderFunc f' <- checkEnum1EncoderFunc (extractEncoder . f)\n  unEncoder (pathComponentEncoderImpl (enum1Encoder (extractPathSegment . f)) f')\n\npathComponentEncoderImpl :: forall check parse p. (Monad check, Monad parse)\n  => Encoder check parse (Some p) (Maybe Text)\n  -> (forall a. p a -> Encoder Identity parse a PageName)\n  -> Encoder check parse (R p) PageName\npathComponentEncoderImpl =\n  chainEncoder (lensEncoder (\\(_, b) a -> (a, b)) Prelude.fst consEncoder)\n\n--NOTE: Naming convention in this module is to always talk about things in the *encoding* direction, never in the *decoding* direction\n\nchainEncoder\n  :: forall check parse p r b.\n     ( Monad check\n     , Monad parse\n     )\n  => Encoder check parse (b, r) r\n  -> Encoder check parse (Some p) b\n  -> (forall a. p a -> Encoder Identity parse a r)\n  -> Encoder check parse (R p) r\nchainEncoder cons this rest = Encoder $ do\n  consValid <- unEncoder cons\n  thisValid <- unEncoder this\n  pure $ EncoderImpl\n    { _encoderImpl_decode = \\v -> do\n        (here, following) <- _encoderImpl_decode consValid v\n        _encoderImpl_decode thisValid here >>= \\case\n          Some r ->\n            (r :/) <$> _encoderImpl_decode (runIdentity . unEncoder $ rest r) following\n    , _encoderImpl_encode = \\(r :/ s) ->\n        _encoderImpl_encode consValid\n          ( _encoderImpl_encode thisValid $ Some r\n          , _encoderImpl_encode (runIdentity . unEncoder $ rest r) s)\n    }\n\n--TODO: Do this in terms of a lens instead\nlensEncoder :: (Applicative check, Monad parse)\n  => (b -> [a] -> b) -> (b -> [a]) -> Encoder check parse (c, [a]) [a] -> Encoder check parse (c, b) b\nlensEncoder set get g = Encoder $ do\n  gImpl <- unEncoder g\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(ma, b) -> set b $ _encoderImpl_encode gImpl (ma, get b)\n    , _encoderImpl_decode = \\b -> do\n        (ma, la) <- _encoderImpl_decode gImpl $ get b\n        pure (ma, set b la)\n    }\n\nconsEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a, [a]) [a] --TODO: Really shouldn't *always* have the [a], even in the Nothing case\nconsEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(h, t) -> maybeToList h <> t\n  , _encoderImpl_decode = pure . \\case\n      [] -> (Nothing, [])\n      h:t -> (Just h, t)\n  }\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\nshadowEncoder\n  :: ( Universe a\n     , MonadError Text check\n     , Show a\n     , Show b\n     , Show c\n     , check ~ parse --TODO: Get rid of this\n     )\n  => Encoder check parse a c -- ^ Overlaps; should have a small number of possible routes\n  -> Encoder check parse b c -- ^ Gets overlapped\n  -> Encoder check parse (Either a b) c\nshadowEncoder f g = Encoder $ do\n  vf <- unEncoder f\n  vg <- unEncoder g\n  let gCanParse c = catchError (Just <$> _encoderImpl_decode vg c) (\\_ -> pure Nothing)\n  overlaps <- fmap catMaybes $ forM universe $ \\a -> do\n    let c = _encoderImpl_encode vf a\n    mb <- gCanParse c\n    pure $ fmap (\\b -> (a, b, c)) mb\n  case overlaps of\n    [] -> pure ()\n    _ -> throwError $ \"shadowEncoder: overlap detected: \" <> T.unlines\n      (flip fmap overlaps $ \\(a, b, c) -> \"first encoder encodes \" <> tshow a <> \" as \" <> tshow c <> \", which second encoder decodes as \" <> tshow b)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\case\n        Left a -> _encoderImpl_encode vf a\n        Right b -> _encoderImpl_encode vg b\n    , _encoderImpl_decode = \\c -> (Left <$> _encoderImpl_decode vf c) `catchError` \\_ -> Right <$> _encoderImpl_decode vg c\n    }\n\nenum1Encoder\n  :: ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse\n     , Ord r\n     , Show r\n     )\n  => (forall a. p a -> r) -> Encoder check parse (Some p) r\nenum1Encoder f = enumEncoder $ \\(Some p) -> f p\n\n-- | Encode an enumerable, bounded type.  WARNING: Don't use this on types that\n-- have a large number of values - it will use a lot of memory.\nenumEncoder :: forall parse check p r. (Universe p, Show p, Ord p, Ord r, MonadError Text parse, MonadError Text check, Show r) => (p -> r) -> Encoder check parse p r\nenumEncoder f = Encoder $ do\n  let reversed = Map.fromListWith (<>) [ (f p, Set.singleton p) | p <- universe ]\n      checkSingleton k vs = case Set.toList vs of\n        [] -> error \"enumEncoder: empty reverse mapping; should be impossible\"\n        [e] -> Success e\n        _ -> Failure $ Map.singleton k vs\n      showRedundant :: r -> Set p -> [Text]\n      showRedundant k vs = (\"  \" <> tshow k <> \" can decode to any of:\")\n        : fmap ((\"    \"<>) . tshow) (Set.toList vs)\n  case itraverse checkSingleton reversed :: Validation (Map r (Set p)) (Map r p) of\n    Failure ambiguousEntries -> throwError $ T.unlines $\n      \"enumEncoder: ambiguous encodings detected:\" : concat (Map.elems $ imap showRedundant ambiguousEntries)\n    Success m -> pure $ EncoderImpl\n      { _encoderImpl_decode = \\r -> case Map.lookup r m of\n          Just a -> pure a\n          Nothing -> throwError $ \"enumEncoder: not recognized: \" <> tshow r --TODO: Report this as a better type\n      , _encoderImpl_encode = f\n      }\n\nunitEncoder :: (Applicative check, MonadError Text parse, Show r, Eq r) => r -> Encoder check parse () r\nunitEncoder expected = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\obtained ->\n      if obtained == expected\n      then pure ()\n      else throwError $ \"endEncoderImpl: expected \" <> tshow expected <> \", got \" <> tshow obtained\n  , _encoderImpl_encode = \\_ -> expected\n  }\n\nsinglePathSegmentEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse Text PageName\nsinglePathSegmentEncoder = pathOnlyEncoder . singletonListEncoder\n\npathOnlyEncoderIgnoringQuery :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoderIgnoringQuery = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\(path, _query) -> pure path\n  , _encoderImpl_encode = \\path -> (path, mempty)\n  }\n\npathOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoder = second (unitEncoder mempty) . coidr\n\nqueryOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Map Text (Maybe Text)) PageName\nqueryOnlyEncoder = first (unitEncoder []) . coidl\n\nsingletonListEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a [a]\nsingletonListEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\case\n      [a] -> pure a\n      l -> throwError $ \"singletonListEncoderImpl: expected one item, got \" <> tshow (length l)\n  , _encoderImpl_encode = (:[])\n  }\n\nsplitTextNonEmpty :: Text -> Text -> NonEmpty Text\nsplitTextNonEmpty separator v = case T.splitOn separator v of\n  [] -> error \"splitTextNonEmpty: Data.Text.splitOn should never return an empty list\"\n  h : t -> h :| t\n\n--TODO: To know this is reversible, we must know that the separator isn't included anywhere in the input text\npathSegmentsTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse (NonEmpty Text) Text\npathSegmentsTextEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = T.intercalate \"/\" . fmap (urlEncodeText False) . toList\n  , _encoderImpl_decode = pure . fmap (urlDecodeText False) . splitTextNonEmpty \"/\"\n  }\n\nqueryParametersTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse [(Text, Maybe Text)] Text\nqueryParametersTextEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> \"\"\n      params -> T.intercalate \"&\" (fmap encodeParameter params)\n  , _encoderImpl_decode = pure . \\case\n      \"\" -> []\n      encoded ->\n        let h :| t = splitTextNonEmpty \"&\" encoded\n        in fmap decodeParameter $ h : t\n  }\n  where\n    encodeParameter (k, mv) = urlEncodeText True k <> case mv of\n      Nothing -> \"\"\n      Just v -> \"=\" <> urlEncodeText True v\n    decodeParameter t =\n      let (k, eqV) = T.breakOn \"=\" t\n          mv = T.stripPrefix \"=\" eqV\n      in (urlDecodeText True k, urlDecodeText True <$> mv)\n\nurlEncodeText :: Bool -> Text -> Text\nurlEncodeText q = T.decodeUtf8 . urlEncode q . T.encodeUtf8\n\nurlDecodeText :: Bool -> Text -> Text\nurlDecodeText q = T.decodeUtf8 . urlDecode q . T.encodeUtf8\n\nlistToNonEmptyEncoder :: (Applicative check, Applicative parse, Monoid a, Eq a) => Encoder check parse [a] (NonEmpty a)\nlistToNonEmptyEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> mempty :| []\n      h : t -> h :| t\n  , _encoderImpl_decode = \\(h :| t) -> pure $\n      if h == mempty\n      then []\n      else h : t\n  }\n\nprefixTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = mappend p\n  , _encoderImpl_decode = \\v -> case T.stripPrefix p v of\n      Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p <> \", got \" <> tshow (T.take (T.length p) v)\n      Just stripped -> pure stripped\n  }\n\nprefixNonemptyTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixNonemptyTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      \"\" -> \"\"\n      v -> p <> v\n  , _encoderImpl_decode = \\case\n      \"\" -> pure \"\"\n      v -> case T.stripPrefix p v of\n        Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p\n        Just stripped -> pure stripped\n  }\n\npackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse String text\npackTextEncoder = isoEncoder packed\n\nunpackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse text String\nunpackTextEncoder = isoEncoder unpacked\n\ntoListMapEncoder :: (Applicative check, Applicative parse, Ord k) => Encoder check parse (Map k v) [(k, v)]\ntoListMapEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = Map.toList\n  , _encoderImpl_decode = pure . Map.fromList --TODO: Should we be stricter about repeated keys?\n  }\n\njoinPairTextEncoder :: (MonadError Text check, MonadError Text parse) => Text -> Encoder check parse (Text, Text) Text\njoinPairTextEncoder = Encoder . \\case\n  \"\" -> throwError \"joinPairTextEncoder: empty separator\"\n  separator -> pure $ EncoderImpl\n    { _encoderImpl_encode = \\(k, v) -> k <> separator <> v\n    , _encoderImpl_decode = \\r ->\n        let (kt, vt) = T.breakOn separator r\n        in case vt of\n          -- The separator was not found\n          \"\" -> throwError $ \"joinPairTextEncoder: separator not found; expected \" <> tshow separator\n          _ -> return (kt, T.drop (T.length separator) vt)\n    }\n\n-- This slight generalization of 'rPrism' happens to be enough to write all our\n-- prism combinators so far.\ndSumPrism\n  :: forall f f' g\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (DSum f g) (DSum f' g)\ndSumPrism p = prism'\n  (\\(f' :=> x) -> f' ^. re p :=> x)\n  (\\(f :=> x) -> (:=> x) <$> (f ^? p))\n\n-- already in obelisk\nrPrism\n  :: forall f f'\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (R f) (R f')\nrPrism = dSumPrism\n\ndSumPrism'\n  :: forall f g a\n  .  (forall b. Prism' (f b) (a :~: b))\n  -> Prism' (DSum f g) (g a)\ndSumPrism' p = dSumPrism p . iso (\\(Refl :=> b) -> b) (Refl :=>)\n\ndSumGEqPrism\n  :: GEq f\n  => f a\n  -> Prism' (DSum f g) (g a)\ndSumGEqPrism variant = dSumPrism' $ prism' (\\Refl -> variant) (geq variant)\n\n-- | Given a 'tag :: f a', make a prism for 'R f'. This generalizes the usual\n-- prisms for a sum type (the ones that 'mkPrisms' would make), just as 'R'\n-- generalized a usual sum type.\n--\n-- [This is given the '_R' name of the \"cannonical\" prism not because it is the\n-- most general, but because it seems the most useful for routes, and 'R' itself\n-- trades generality for route-specificity.]\n_R\n  :: GEq f\n  => f a\n  -> Prism' (R f) a\n_R variant = dSumGEqPrism variant . iso runIdentity Identity\n\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'reviewEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @reviewEncoder (f . g) = reviewEncoder g . reviewEncoder f@.\nreviewEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nreviewEncoder p = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = review p\n  , _encoderImpl_decode = \\r -> case r ^? p of\n      Just a -> pure a\n      Nothing -> throwError \"reviewEncoder: value is not present in the prism\"\n  }\n\n-- | A URL path and query string, in which trailing slashes don't matter in the path\n-- and duplicate query parameters are not allowed. A final goal of encoders using this library\n-- will frequently be to produce this.\ntype PageName = ([Text], Map Text (Maybe Text))\n\n-- | A path (separated by slashes), and a query string.\ntype PathQuery = (String, String)\n\n-- | Encode a PageName into a path and query string.\npageNameEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse PageName PathQuery\npageNameEncoder = bimap\n  (unpackTextEncoder . prefixTextEncoder \"/\" . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n  (unpackTextEncoder . prefixNonemptyTextEncoder \"?\" . queryParametersTextEncoder . toListMapEncoder)\n\n-- | Handle an error in parsing, for example, in order to redirect to a 404 page.\nhandleEncoder\n  :: (Functor check)\n  => (e -> a)\n  -> Encoder check (Either e) a b\n  -> Encoder check Identity a b\nhandleEncoder recover e = Encoder $ do\n  i <- unEncoder e\n  return $ i\n    { _encoderImpl_decode = \\a -> pure $ case _encoderImpl_decode i a of\n      Right r -> r\n      Left err -> recover err\n    }\n\n--------------------------------------------------------------------------------\n-- Actual obelisk route info\n--------------------------------------------------------------------------------\n\n-- | The typical full route type comprising all of an Obelisk application's routes.\n-- Parameterised by the top level GADTs that define backend and frontend routes, respectively.\ndata FullRoute :: (* -> *) -> (* -> *) -> * -> * where\n  FullRoute_Backend :: br a -> FullRoute br fr a\n  FullRoute_Frontend :: ObeliskRoute fr a -> FullRoute br fr a\n\ninstance (GShow br, GShow fr) => GShow (FullRoute br fr) where\n  gshowsPrec p = \\case\n    FullRoute_Backend x -> showParen (p > 10) (showString \"FullRoute_Backend \" . gshowsPrec 11 x)\n    FullRoute_Frontend x -> showParen (p > 10) (showString \"FullRoute_Frontend \" . gshowsPrec 11 x)\n\ninstance (GEq br, GEq fr) => GEq (FullRoute br fr) where\n  geq (FullRoute_Backend x) (FullRoute_Backend y) = geq x y\n  geq (FullRoute_Frontend x) (FullRoute_Frontend y) = geq x y\n  geq _ _ = Nothing\n\ninstance (GCompare br, GCompare fr) => GCompare (FullRoute br fr) where\n  gcompare (FullRoute_Backend _) (FullRoute_Frontend _) = GLT\n  gcompare (FullRoute_Frontend _) (FullRoute_Backend _) = GGT\n  gcompare (FullRoute_Backend x) (FullRoute_Backend y) = gcompare x y\n  gcompare (FullRoute_Frontend x) (FullRoute_Frontend y) = gcompare x y\n\ninstance  (UniverseSome br, UniverseSome fr) => UniverseSome (FullRoute br fr) where\n  universeSome = [Some (FullRoute_Backend x) | Some x <- universeSome]\n              ++ [Some (FullRoute_Frontend x) | Some x <- universeSome]\n\n-- | Build the typical top level application route encoder from a route for handling 404's,\n-- and segment encoders for backend and frontend routes.\nmkFullRouteEncoder\n  :: (GCompare br, GCompare fr, GShow br, GShow fr, UniverseSome br, UniverseSome fr)\n  => R (FullRoute br fr) -- ^ 404 handler\n  -> (forall a. br a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single backend route segment\n  -> (forall a. fr a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single frontend route segment\n  -> Encoder (Either Text) Identity (R (FullRoute br fr)) PageName\nmkFullRouteEncoder missing backendSegment frontendSegment = handleEncoder (const missing) $\n  pathComponentEncoder $ \\case\n    FullRoute_Backend backendRoute -> backendSegment backendRoute\n    FullRoute_Frontend obeliskRoute -> obeliskRouteSegment obeliskRoute frontendSegment\n\n-- | A type which can represent Obelisk-specific resource routes, in addition to application specific routes which serve your\n-- frontend.\ndata ObeliskRoute :: (* -> *) -> * -> * where\n  -- We need to have the `f a` as an argument here, because otherwise we have no way to specifically check for overlap between us and the given encoder\n  ObeliskRoute_App :: f a -> ObeliskRoute f a\n  ObeliskRoute_Resource :: ResourceRoute a -> ObeliskRoute f a\n\ninstance UniverseSome f => UniverseSome (ObeliskRoute f) where\n  universeSome = concat\n    [ (\\(Some x) -> Some (ObeliskRoute_App x)) <$> universe\n    , (\\(Some x) -> Some (ObeliskRoute_Resource x)) <$> (universe @(Some ResourceRoute))\n    ]\n\ninstance GEq f => GEq (ObeliskRoute f) where\n  geq (ObeliskRoute_App x) (ObeliskRoute_App y) = geq x y\n  geq (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = geq x y\n  geq _ _ = Nothing\n\ninstance GCompare f => GCompare (ObeliskRoute f) where\n  gcompare (ObeliskRoute_App x) (ObeliskRoute_App y) = gcompare x y\n  gcompare (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = gcompare x y\n  gcompare (ObeliskRoute_App _) (ObeliskRoute_Resource _) = GLT\n  gcompare (ObeliskRoute_Resource _) (ObeliskRoute_App _) = GGT\n\n-- | A type representing the various resource routes served by Obelisk. These can in principle map to any physical routes you want,\n-- but sane defaults are provided by 'resourceRouteSegment'\ndata ResourceRoute :: * -> * where\n  ResourceRoute_Static :: ResourceRoute [Text] -- This [Text] represents the *path in our static files directory*, not necessarily the URL path that the asset gets served at (although that will often be \"/static/this/text/thing\")\n  ResourceRoute_Ghcjs :: ResourceRoute [Text]\n  ResourceRoute_JSaddleWarp :: ResourceRoute (R JSaddleWarpRoute)\n  ResourceRoute_Version :: ResourceRoute ()\n\n-- | If there are no additional backend routes in your app (i.e. ObeliskRoute gives you all the routes you need),\n-- this constructs a suitable 'Encoder' to use for encoding routes to 'PageName's. If you do have additional backend routes,\n-- you'll want to use 'pathComponentEncoder' yourself, applied to a function that will likely use obeliskRouteSegment in order to\n-- handle the ObeliskRoute case (i.e. Obelisk resource routes and app frontend routes).\nobeliskRouteEncoder :: forall check parse appRoute.\n     ( Universe (Some (ObeliskRoute appRoute))\n     , GCompare (ObeliskRoute appRoute)\n     , GShow appRoute\n     , MonadError Text check\n     , check ~ parse --TODO: Get rid of this\n     )\n  => (forall a. appRoute a -> SegmentResult check parse a)\n  -> Encoder check parse (R (ObeliskRoute appRoute)) PageName\nobeliskRouteEncoder appRouteSegment = pathComponentEncoder $ \\r ->\n  obeliskRouteSegment r appRouteSegment\n\n-- | From a function which explains how app-specific frontend routes translate into segments, produce a function which does the\n-- same for ObeliskRoute. This uses the given function for the 'ObeliskRoute_App' case, and 'resourceRouteSegment' for the\n-- 'ObeliskRoute_Resource' case.\nobeliskRouteSegment :: forall check parse appRoute a.\n     (MonadError Text check, MonadError Text parse)\n  => ObeliskRoute appRoute a\n  -> (forall b. appRoute b -> SegmentResult check parse b)\n  -> SegmentResult check parse a\nobeliskRouteSegment r appRouteSegment = case r of\n  ObeliskRoute_App appRoute -> appRouteSegment appRoute\n  ObeliskRoute_Resource resourceRoute -> resourceRouteSegment resourceRoute\n\n-- | A function which gives a sane default for how to encode Obelisk resource routes. It's given in this form, because it will\n-- be combined with other such segment encoders before 'pathComponentEncoder' turns it into a proper 'Encoder'.\nresourceRouteSegment :: (MonadError Text check, MonadError Text parse) => ResourceRoute a -> SegmentResult check parse a\nresourceRouteSegment = \\case\n  ResourceRoute_Static -> PathSegment \"static\" pathOnlyEncoderIgnoringQuery\n  ResourceRoute_Ghcjs -> PathSegment \"ghcjs\" pathOnlyEncoder\n  ResourceRoute_JSaddleWarp -> PathSegment \"jsaddle\" jsaddleWarpRouteEncoder\n  ResourceRoute_Version -> PathSegment \"version\" $ unitEncoder mempty\n\ndata JSaddleWarpRoute :: * -> * where\n  JSaddleWarpRoute_JavaScript :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_WebSocket :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_Sync :: JSaddleWarpRoute [Text]\n\njsaddleWarpRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R JSaddleWarpRoute) PageName\njsaddleWarpRouteEncoder = pathComponentEncoder $ \\case\n  JSaddleWarpRoute_JavaScript -> PathSegment \"jsaddle.js\" $ unitEncoder mempty\n  JSaddleWarpRoute_WebSocket ->  PathEnd $ unitEncoder mempty\n  JSaddleWarpRoute_Sync -> PathSegment \"sync\" pathOnlyEncoder\n\ninstance GShow appRoute => GShow (ObeliskRoute appRoute) where\n  gshowsPrec prec = \\case\n    ObeliskRoute_App appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_App \" . gshowsPrec 11 appRoute\n    ObeliskRoute_Resource appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_Resource \" . gshowsPrec 11 appRoute\n\ndata IndexOnlyRoute :: * -> * where\n  IndexOnlyRoute :: IndexOnlyRoute ()\n\nindexOnlyRouteSegment :: (Applicative check, MonadError Text parse) => IndexOnlyRoute a -> SegmentResult check parse a\nindexOnlyRouteSegment = \\case\n  IndexOnlyRoute -> PathEnd $ unitEncoder mempty\n\nindexOnlyRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R IndexOnlyRoute) PageName\nindexOnlyRouteEncoder = pathComponentEncoder indexOnlyRouteSegment\n\nsomeSumEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Sum a b)) (Either (Some a) (Some b))\nsomeSumEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\(Some t) -> case t of\n      InL l -> Left $ Some l\n      InR r -> Right $ Some r\n  , _encoderImpl_decode = pure . \\case\n      Left (Some l) -> Some (InL l)\n      Right (Some r) -> Some (InR r)\n  }\n\ndata Void1 :: * -> * where {}\n\ninstance UniverseSome Void1 where\n  universeSome = []\n\nvoid1Encoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Some Void1) a\nvoid1Encoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Some f -> case f of {}\n  , _encoderImpl_decode = \\_ -> throwError \"void1Encoder: can't decode anything\"\n  }\n\ninstance GShow Void1 where\n  gshowsPrec _ = \\case {}\n\n-- | Given a backend route and a checked route encoder, render the route (path\n-- and query string). See 'checkEncoder' for how to produce a checked encoder.\nrenderBackendRoute\n  :: forall br a.\n     Encoder Identity Identity (R (FullRoute br a)) PageName\n  -> R br\n  -> Text\nrenderBackendRoute enc = renderObeliskRoute enc . hoistR FullRoute_Backend\n\n-- | Renders a frontend route with the supplied checked encoder\nrenderFrontendRoute\n  :: forall a fr.\n     Encoder Identity Identity (R (FullRoute a fr)) PageName\n  -> R fr\n  -> Text\nrenderFrontendRoute enc = renderObeliskRoute enc . hoistR (FullRoute_Frontend . ObeliskRoute_App)\n\n-- | Renders a route of the form typically found in an Obelisk project\nrenderObeliskRoute\n  :: forall a b.\n     Encoder Identity Identity (R (FullRoute a b)) PageName\n  -> R (FullRoute a b)\n  -> Text\nrenderObeliskRoute e r =\n  let enc :: Encoder Identity (Either Text) (R (FullRoute a b)) PathQuery\n      enc = (pageNameEncoder . hoistParse (pure . runIdentity) e)\n  in (T.pack . uncurry (<>)) $ encode enc r\n\n-- | As per the 'unsafeTshowEncoder' but does not use the 'Text' type.\n--\n-- WARNING: Just like 'unsafeTshowEncoder' this is only safe if the Show and Read\n-- instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nunsafeShowEncoder = singlePathSegmentEncoder . unsafeTshowEncoder\n\n-- | This 'Encoder' does not properly indicate that its use may be unsafe and is being renamed to 'unsafeShowEncoder'\nreadShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nreadShowEncoder = unsafeShowEncoder\n{-# DEPRECATED readShowEncoder \"This function has been renamed to 'unsafeShowEncoder'. 'readShowEncoder' will be removed in a future release\" #-}\n\nintegralEncoder :: (MonadError Text parse, Applicative check, Integral a) => Encoder check parse a Integer\nintegralEncoder = reviewEncoder Numeric.Lens.integral\n\npathSegmentEncoder :: (MonadError Text parse, Applicative check, Cons as as a a) =>\n  Encoder check parse (a, (as, b)) (as, b)\npathSegmentEncoder = first (reviewEncoder _Cons) . disassociate\n\nnewtype Decoder check parse b a = Decoder { toEncoder :: Encoder check parse a b }\n\ndmapEncoder :: forall check parse k k' v.\n   ( Monad check\n   , MonadError Text parse\n   , Universe (Some k')\n   , Ord k\n   , GCompare k'\n   , GShow k'\n   )\n  => Encoder check parse (Some k') k\n  -> (forall v'. k' v' -> Encoder check parse v' v)\n  -> Encoder check parse (DMap k' Identity) (Map k v)\ndmapEncoder keyEncoder' valueEncoderFor = unsafeEncoder $ do\n  keyEncoder :: Encoder Identity parse (Some k') k <- checkEncoder keyEncoder'\n  valueDecoders :: DMap k' (Decoder Identity parse v) <- fmap DMap.fromList . forM universe $ \\(Some (k' :: k' t)) -> do\n    ve :: Encoder Identity parse t v <- checkEncoder (valueEncoderFor k')\n    return $ (k' :: k' t) :=> (Decoder ve :: Decoder Identity parse v t)\n  let keyError k = \"dmapEncoder: key `\" <> k <> \"' was missing from the Universe instance for its type.\"\n  return $ EncoderImpl\n    { _encoderImpl_encode = \\dm -> Map.fromList $ do\n        ((k' :: k' t) :=> Identity v') <- DMap.toList dm\n        return ( encode keyEncoder (Some k')\n               , encode (toEncoder (DMap.findWithDefault (error . keyError $ gshow k') k' valueDecoders)) v'\n               )\n    , _encoderImpl_decode = \\m -> fmap DMap.fromList . forM (Map.toList m) $ \\(k,v) -> do\n          tryDecode keyEncoder k >>= \\case\n            Some (k' :: k' t) -> case DMap.lookup k' valueDecoders of\n              Nothing -> throwError . T.pack . keyError $ gshow k'\n              Just (Decoder e) -> do\n                v' <- tryDecode e v\n                return (k' :=> Identity v')\n    }\n\nfieldMapEncoder :: forall check parse r.\n   ( Applicative check\n   , MonadError Text parse\n   , HasFields r\n   , Universe (Some (Field r))\n   , GShow (Field r)\n   , GCompare (Field r)\n   )\n  => Encoder check parse r (DMap (Field r) Identity)\nfieldMapEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\r -> DMap.fromList [ f :=> Identity (indexField r f) | Some f <- universe ]\n    , _encoderImpl_decode = \\dm -> tabulateFieldsA $ \\f -> do\n      case DMap.lookup f dm of\n        Nothing -> throwError $ \"fieldMapEncoder: Couldn't find key for `\" <> T.pack (gshow f) <> \"' in DMap.\"\n        Just (Identity v) -> return v\n    }\n\npathFieldEncoder :: forall a p check parse . (HasFields a, Monad check, MonadError Text parse, GCompare (Field a)) => (forall x. Field a x -> Encoder check parse x p) -> Encoder check parse (a, [p]) [p]\npathFieldEncoder fieldEncoder = unsafeEncoder $ do\n  fieldEncoderPureMap :: DMap.DMap (Field a) (Decoder Identity parse p) <- getAp $ getConst $ tabulateFieldsA @a $ \\f -> Const (Ap $ fmap (DMap.singleton f . Decoder) $ (checkEncoder @Identity) $ fieldEncoder f)\n  let fieldEncoderPure :: forall x. Field a x -> Encoder Identity parse x p\n      fieldEncoderPure f = toEncoder (DMap.findWithDefault (error \"bad\") f fieldEncoderPureMap)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(x, rest) -> execWriter $ do\n      _ <- traverseWithField (\\f x_i -> tell (pure $ encode (fieldEncoderPure f) x_i) $> x_i) x\n      tell rest\n    , _encoderImpl_decode = State.runStateT $ tabulateFieldsA $ \\f -> State.get >>= \\case\n      [] -> throwError $ T.pack \"not enough path components\"\n      p:ps -> do\n        State.put ps\n        lift $ tryDecode (fieldEncoderPure f) p\n    }\n\n-- | Use ToJSON/FromJSON to encode to Text. The correctness of this encoder is dependent on the encoding being injective and round-tripping correctly.\njsonEncoder :: forall check parse r.\n  ( ToJSON r\n  , FromJSON r\n  , Applicative check\n  , MonadError Text parse\n  )\n  => Encoder check parse r Text\njsonEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\r -> T.decodeUtf8 . BSL.toStrict $ Aeson.encode r\n    , _encoderImpl_decode = \\t -> case Aeson.eitherDecodeStrict $ T.encodeUtf8 t of\n        Left err -> throwError (\"jsonEncoder: \" <> T.pack err)\n        Right x -> return x\n    }\n\n-- Useful for app server integration.\n-- p must not start with slashes\nbyteStringsToPageName :: BS.ByteString -> BS.ByteString -> PageName\nbyteStringsToPageName p q =\n  let pageNameEncoder' :: Encoder Identity Identity PageName (String, String)\n      pageNameEncoder' = bimap\n        (unpackTextEncoder . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n        (unpackTextEncoder . queryParametersTextEncoder . toListMapEncoder)\n  in decode pageNameEncoder' (T.unpack (T.decodeUtf8 p), T.unpack (T.decodeUtf8 q))\n\n--TODO: decodeURIComponent as appropriate\n\n\n{-# DEPRECATED isoEncoder \"Instead of 'isoEncoder f', use 'viewEncoder f'\" #-}\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nisoEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nisoEncoder = viewEncoder\n\n{-# DEPRECATED prismEncoder \"Instead of 'prismEncoder f', use 'reviewEncoder f'\" #-}\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'prismEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @prismEncoder (f . g) = prismEncoder g . prismEncoder f@.\nprismEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nprismEncoder = reviewEncoder\n\n\nconcat <$> mapM deriveRouteComponent\n  [ ''ResourceRoute\n  , ''JSaddleWarpRoute\n  , ''IndexOnlyRoute\n  ]\n\nmakePrisms ''ObeliskRoute\nmakePrisms ''FullRoute\nderiveGEq ''Void1\nderiveGCompare ''Void1\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 396,
              "startColumn": 3,
              "endLine": 396,
              "endColumn": 24,
              "from": "second g = bimap id g",
              "to": "second = bimap id",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 396, startCol = 3, endLine = 396, endCol = 24}, subts = [(\"body\",SrcSpan {startLine = 396, startCol = 14, endLine = 396, endCol = 22})], orig = \"second = body\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 410,
              "startColumn": 3,
              "endLine": 410,
              "endColumn": 24,
              "from": "second g = bimap id g",
              "to": "second = bimap id",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 410, startCol = 3, endLine = 410, endCol = 24}, subts = [(\"body\",SrcSpan {startLine = 410, startCol = 14, endLine = 410, endCol = 22})], orig = \"second = body\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 423,
              "startColumn": 3,
              "endLine": 423,
              "endColumn": 24,
              "from": "second g = bimap id g",
              "to": "second = bimap id",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 423, startCol = 3, endLine = 423, endCol = 24}, subts = [(\"body\",SrcSpan {startLine = 423, startCol = 14, endLine = 423, endCol = 22})], orig = \"second = body\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 433,
              "startColumn": 3,
              "endLine": 433,
              "endColumn": 24,
              "from": "second g = bimap id g",
              "to": "second = bimap id",
              "note": [],
              "refactorings": "[Replace {rtype = Bind, pos = SrcSpan {startLine = 433, startCol = 3, endLine = 433, endCol = 24}, subts = [(\"body\",SrcSpan {startLine = 433, startCol = 14, endLine = 433, endCol = 22})], orig = \"second = body\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "unwrappedEncoder"
              ],
              "severity": "Suggestion",
              "hint": "Redundant $",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 508,
              "startColumn": 32,
              "endLine": 508,
              "endColumn": 33,
              "from": "viewEncoder $ _Wrapped'",
              "to": "viewEncoder _Wrapped'",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 508, startCol = 20, endLine = 508, endCol = 43}, subts = [(\"a\",SrcSpan {startLine = 508, startCol = 20, endLine = 508, endCol = 31}),(\"b\",SrcSpan {startLine = 508, startCol = 34, endLine = 508, endCol = 43})], orig = \"a b\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "shadowEncoder"
              ],
              "severity": "Suggestion",
              "hint": "Use tuple-section",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 687,
              "startColumn": 18,
              "endLine": 687,
              "endColumn": 33,
              "from": "\\ b -> (a, b, c)",
              "to": "(a,, c)",
              "note": [
                "may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file"
              ],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "unitEncoder"
              ],
              "severity": "Suggestion",
              "hint": "Use const",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 739,
              "startColumn": 27,
              "endLine": 739,
              "endColumn": 41,
              "from": "\\ _ -> expected",
              "to": "const expected",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 739, startCol = 27, endLine = 739, endCol = 41}, subts = [], orig = \"const expected\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "pathOnlyEncoderIgnoringQuery"
              ],
              "severity": "Suggestion",
              "hint": "Use tuple-section",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 748,
              "startColumn": 27,
              "endLine": 748,
              "endColumn": 50,
              "from": "\\ path -> (path, mempty)",
              "to": "(, mempty)",
              "note": [
                "may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file"
              ],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "FullRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 952,
              "startColumn": 1,
              "endLine": 954,
              "endColumn": 63,
              "from": "data FullRoute :: (* -> *) -> (* -> *) -> * -> *\n  where\n    FullRoute_Backend :: br a -> FullRoute br fr a\n    FullRoute_Frontend :: ObeliskRoute fr a -> FullRoute br fr a",
              "to": "data FullRoute :: (* -> *) -> (* -> *) -> * -> *\n  where\n    FullRouteBackend :: br a -> FullRoute br fr a\n    FullRouteFrontend :: ObeliskRoute fr a -> FullRoute br fr a",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "ObeliskRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 991,
              "startColumn": 1,
              "endLine": 994,
              "endColumn": 63,
              "from": "data ObeliskRoute :: (* -> *) -> * -> *\n  where\n    ObeliskRoute_App :: f a -> ObeliskRoute f a\n    ObeliskRoute_Resource :: ResourceRoute a -> ObeliskRoute f a",
              "to": "data ObeliskRoute :: (* -> *) -> * -> *\n  where\n    ObeliskRouteApp :: f a -> ObeliskRoute f a\n    ObeliskRouteResource :: ResourceRoute a -> ObeliskRoute f a",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [],
              "severity": "Suggestion",
              "hint": "Use ++",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 997,
              "startColumn": 18,
              "endLine": 1000,
              "endColumn": 6,
              "from": "concat\n  [(\\ (Some x) -> Some (ObeliskRoute_App x)) <$> universe,\n   (\\ (Some x) -> Some (ObeliskRoute_Resource x))\n     <$> (universe @(Some ResourceRoute))]",
              "to": "((\\ (Some x) -> Some (ObeliskRoute_App x)) <$> universe)\n  ++\n    ((\\ (Some x) -> Some (ObeliskRoute_Resource x))\n       <$> (universe @(Some ResourceRoute)))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 997, startCol = 18, endLine = 1000, endCol = 6}, subts = [(\"a\",SrcSpan {startLine = 998, startCol = 7, endLine = 998, endCol = 60}),(\"b\",SrcSpan {startLine = 999, startCol = 7, endLine = 999, endCol = 89})], orig = \"(a) ++ (b)\"}]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "ResourceRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 1015,
              "startColumn": 1,
              "endLine": 1019,
              "endColumn": 44,
              "from": "data ResourceRoute :: * -> *\n  where\n    ResourceRoute_Static :: ResourceRoute [Text]\n    ResourceRoute_Ghcjs :: ResourceRoute [Text]\n    ResourceRoute_JSaddleWarp :: ResourceRoute (R JSaddleWarpRoute)\n    ResourceRoute_Version :: ResourceRoute ()",
              "to": "data ResourceRoute :: * -> *\n  where\n    ResourceRouteStatic :: ResourceRoute [Text]\n    ResourceRouteGhcjs :: ResourceRoute [Text]\n    ResourceRouteJSaddleWarp :: ResourceRoute (R JSaddleWarpRoute)\n    ResourceRouteVersion :: ResourceRoute ()",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "JSaddleWarpRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 1058,
              "startColumn": 1,
              "endLine": 1061,
              "endColumn": 51,
              "from": "data JSaddleWarpRoute :: * -> *\n  where\n    JSaddleWarpRoute_JavaScript :: JSaddleWarpRoute ()\n    JSaddleWarpRoute_WebSocket :: JSaddleWarpRoute ()\n    JSaddleWarpRoute_Sync :: JSaddleWarpRoute [Text]",
              "to": "data JSaddleWarpRoute :: * -> *\n  where\n    JSaddleWarpRouteJavaScript :: JSaddleWarpRoute ()\n    JSaddleWarpRouteWebSocket :: JSaddleWarpRoute ()\n    JSaddleWarpRouteSync :: JSaddleWarpRoute [Text]",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Route"
              ],
              "decl": [
                "jsonEncoder"
              ],
              "severity": "Suggestion",
              "hint": "Avoid lambda",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "startLine": 1243,
              "startColumn": 29,
              "endLine": 1243,
              "endColumn": 79,
              "from": "\\ r -> T.decodeUtf8 . BSL.toStrict $ Aeson.encode r",
              "to": "T.decodeUtf8 . BSL.toStrict . Aeson.encode",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 1243, startCol = 29, endLine = 1243, endCol = 79}, subts = [(\"a\",SrcSpan {startLine = 1243, startCol = 35, endLine = 1243, endCol = 62}),(\"b\",SrcSpan {startLine = 1243, startCol = 65, endLine = 1243, endCol = 77})], orig = \"a . b\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/route/src/Obelisk/Route.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/route/src/Obelisk/Route.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 19,
          "code_quality_score": 96.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 19,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 1 1: module Obelisk.Route.TH has 13 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 10 1: type signature for deriveRouteComponent has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 10 1: type signature for deriveRouteComponent has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has branching depth of 0 \n"
          },
          "original_code": "module Obelisk.Route.TH (deriveRouteComponent) where\n\nimport Data.Constraint.Extras.TH\nimport Data.GADT.Show.TH\nimport Data.GADT.Compare.TH\nimport Data.Universe.Some.TH\nimport Language.Haskell.TH\n\n-- | Derive all the typeclasses needed for a RouteComponent type.  The argument should be the name of a type of kind @k -> *@\nderiveRouteComponent :: Name -> Q [Dec]\nderiveRouteComponent x = concat <$> traverse ($ x)\n  [ deriveGShow\n  , deriveGEq\n  , deriveGCompare\n  , deriveUniverseSome\n  , deriveArgDict\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/route/src/Obelisk/Route/TH.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/route/src/Obelisk/Route/TH.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
          "cyclomatic_complexity": {
            "min": 0,
            "max": 0,
            "average": 0,
            "sum": 0
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 1,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 24,
          "lines_of_code": 672,
          "homplexity_lines_of_code": 931,
          "code_quality_score": 6.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 0,
              "max": 0,
              "average": 0,
              "sum": 0
            },
            "homplexity_loc": 931,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"askRoute\": 1,\n        \"runRoutedT\": 1,\n        \"mapRoutedT\": 1,\n        \"withRoutedT\": 1,\n        \"subRoute_\": 2,\n        \"subPairRoute_\": 3,\n        \"subRoute\": 2,\n        \"subPairRoute\": 3,\n        \"maybeRoute_\": 2,\n        \"maybeRoute\": 2,\n        \"eitherRoute_\": 3,\n        \"eitherRoute\": 3,\n        \"routeLink\": 3,\n        \"routeLinkAttr\": 4,\n        \"routeLinkImpl\": 4,\n        \"scrollToTop\": 4,\n        \"dynRouteLink\": 3,\n        \"dynRouteLinkImpl\": 3,\n        \"routeLinkDynAttr\": 5,\n        \"routeLinkDynAttrImpl\": 5,\n        \"adaptedUriPath\": 2,\n        \"setAdaptedUriPath\": 2,\n        \"pathToHash\": 1,\n        \"hashToPath\": 1\n    },\n    \"min\": 1,\n    \"max\": 5,\n    \"average\": 2.5,\n    \"sum\": 57,\n    \"homplexity_loc\": 931,\n    \"homplexity_output\": \"\"\n}\n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Obelisk.Route.Frontend\n  ( module Obelisk.Route\n  , pattern (:~)\n  , Routed\n  , RoutedT\n  , runRoutedT\n  , askRoute\n  , withRoutedT\n  , mapRoutedT\n  , subRoute\n  , subRoute_\n  , subPairRoute\n  , subPairRoute_\n  , maybeRoute\n  , maybeRoute_\n  , maybeRouted\n  , eitherRoute\n  , eitherRoute_\n  , eitherRouted\n  , runRouteViewT\n  , SetRouteT(..)\n  , SetRoute(..)\n  , runSetRouteT\n  , mapSetRouteT\n  , RouteToUrl(..)\n  , RouteToUrlT(..)\n  , runRouteToUrlT\n  , mapRouteToUrlT\n  , routeLink\n  , routeLinkAttr\n  , routeLinkDynAttr\n  , dynRouteLink\n  , adaptedUriPath\n  , setAdaptedUriPath\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad ((<=<))\n#endif\n#endif\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category (Category (..), (.))\nimport Control.Category.Cartesian ((&&&))\nimport Control.Lens hiding (Bifunctor, bimap, universe, element)\nimport Control.Monad.Fix\nimport Control.Monad.Morph\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Control\nimport Data.Coerce\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Functor.Compose\nimport Data.Functor.Misc\nimport Data.GADT.Compare\nimport qualified Data.List as L\nimport Data.Map as Map (Map, lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Type.Coercion\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.Window as Window\nimport Language.Javascript.JSaddle (MonadJSM, jsNull, liftJSM) --TODO: Get rid of this - other platforms can also be routed\nimport Network.URI\nimport Reflex.Class\nimport Reflex.Dom.Builder.Class\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Unsafe.Coerce\n\nimport Obelisk.Configs\nimport Obelisk.Route\n\ninfixr 5 :~\npattern (:~) :: Reflex t => f a -> Dynamic t a -> DSum f (Compose (Dynamic t) Identity)\npattern a :~ b <- a :=> (coerceDynamic . getCompose -> b)\n\nclass Routed t r m | m -> t r where\n  askRoute :: m (Dynamic t r)\n  default askRoute :: (Monad m', MonadTrans f, Routed t r m', m ~ f m') => m (Dynamic t r)\n  askRoute = lift askRoute\n\ninstance Monad m => Routed t r (RoutedT t r m) where\n  askRoute = RoutedT ask\n\ninstance (Monad m, Routed t r m) => Routed t r (ReaderT r' m)\n\nnewtype RoutedT t r m a = RoutedT { unRoutedT :: ReaderT (Dynamic t r) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadFix\n    , MonadTrans\n    , MFunctor\n    , NotReady t\n    , MonadHold t\n    , MonadSample t\n    , PostBuild t\n    , TriggerEvent t\n    , MonadIO\n    , MonadReflexCreateTrigger t\n    , HasDocument\n    , DomRenderHook t\n    )\n\ninstance MonadReader r' m => MonadReader r' (RoutedT t r m) where\n  ask = lift ask\n  local = mapRoutedT . local\n\ninstance (Prerender t m, Monad m) => Prerender t (RoutedT t r m) where\n  type Client (RoutedT t r m) = RoutedT t r (Client m)\n  prerender server client = RoutedT $ do\n    r <- ask\n    lift $ prerender (runRoutedT server r) (runRoutedT client r)\n\ninstance Requester t m => Requester t (RoutedT t r m) where\n  type Request (RoutedT t r m) = Request m\n  type Response (RoutedT t r m) = Response m\n  requesting = RoutedT . requesting\n  requesting_ = RoutedT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RoutedT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RoutedT t r m) where\n  type Performable (RoutedT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RoutedT t r m) where\n  type Ref (RoutedT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\nderiving instance EventWriter t w m => EventWriter t w (RoutedT t r m)\n\ninstance MonadTransControl (RoutedT t r) where\n  type StT (RoutedT t r) a = StT (ReaderT (Dynamic t r)) a\n  liftWith = defaultLiftWith RoutedT unRoutedT\n  restoreT = defaultRestoreT RoutedT\n\ninstance PrimMonad m => PrimMonad (RoutedT t r m ) where\n  type PrimState (RoutedT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RoutedT t r m) where\n  type DomBuilderSpace (RoutedT t r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RoutedT t r m) where\n  runWithReplace a0 a' = RoutedT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RoutedT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RoutedT t r m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (QueryT t q m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (QueryT t q m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (EventWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (EventWriterT t w m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (DynamicWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (DynamicWriterT t w m)\n\nrunRoutedT :: RoutedT t r m a -> Dynamic t r -> m a\nrunRoutedT = runReaderT . unRoutedT\n\nmapRoutedT :: (m a -> n b) -> RoutedT t r m a -> RoutedT t r n b\nmapRoutedT f = RoutedT . mapReaderT f . unRoutedT\n\nwithRoutedT :: (Dynamic t r -> Dynamic t r') -> RoutedT t r' m a -> RoutedT t r m a\nwithRoutedT f = RoutedT . withReaderT f . unRoutedT\n\nsubRoute_ :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m ()) -> RoutedT t (R r) m ()\nsubRoute_ f = factorRouted $ strictDynWidget_ $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute_ :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m ()) -> RoutedT t (a, b) m ()\nsubPairRoute_ f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute_ (\\(Const2 a) -> f a)\n\nsubRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m b) -> RoutedT t (R r) m (Dynamic t b)\nsubRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m c) -> RoutedT t (a, b) m (Dynamic t c)\nsubPairRoute f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute (\\(Const2 a) -> f a)\n\nmaybeRoute_ :: (MonadFix m, MonadHold t m, Adjustable t m) => m () -> RoutedT t r m () -> RoutedT t (Maybe r) m ()\nmaybeRoute_ n j = maybeRouted $ strictDynWidget_ $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\nmaybeRoute :: (MonadFix m, MonadHold t m, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m (Dynamic t a)\nmaybeRoute n j = maybeRouted $ strictDynWidget $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\n{-\nmaybeRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m a\nmaybeRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n-}\n\neitherRoute_\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m ()\n  -> RoutedT t r m ()\n  -> RoutedT t (Either l r) m ()\neitherRoute_ l r = eitherRouted $ strictDynWidget_ $ either (runRoutedT l) (runRoutedT r)\n\neitherRoute\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m a\n  -> RoutedT t r m a\n  -> RoutedT t (Either l r) m (Dynamic t a)\neitherRoute l r = eitherRouted $ strictDynWidget $ either (runRoutedT l) (runRoutedT r)\n\ndsumValueCoercion :: Coercion f g -> Coercion (DSum k f) (DSum k g)\ndsumValueCoercion Coercion = Coercion\n\ndynamicIdentityCoercion :: Coercion (Compose (Dynamic t) Identity) (Dynamic t)\ndynamicIdentityCoercion = unsafeCoerce (Coercion :: Coercion (Identity ()) ()) --TODO: Is it possible to prove this?\n\nfactorRouted :: (Reflex t, MonadFix m, MonadHold t m, GEq f) => RoutedT t (DSum f (Dynamic t)) m a -> RoutedT t (DSum f Identity) m a\nfactorRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- factorDyn d\n  runRoutedT r $ coerceWith (dynamicCoercion $ dsumValueCoercion dynamicIdentityCoercion) d'\n\nmaybeRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Maybe (Dynamic t a)) m b -> RoutedT t (Maybe a) m b\nmaybeRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- maybeDyn d\n  runRoutedT r d'\n\neitherRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Either (Dynamic t a) (Dynamic t b)) m c -> RoutedT t (Either a b) m c\neitherRouted r = RoutedT $ ReaderT $ runRoutedT r <=< eitherDyn\n\n-- | WARNING: The input 'Dynamic' must be fully constructed when this is run\nstrictDynWidget :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m b) -> RoutedT t a m (Dynamic t b)\nstrictDynWidget f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (result0, result') <- runWithReplace (f r0) $ f <$> updated r\n  holdDyn result0 result'\n\nstrictDynWidget_ :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m ()) -> RoutedT t a m ()\nstrictDynWidget_ f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (_, _) <- runWithReplace (f r0) $ f <$> updated r\n  pure ()\n\nnewtype SetRouteT t r m a = SetRouteT { unSetRouteT :: EventWriterT t (Endo r) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, MonadIO, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\ninstance (MonadFix m, MonadHold t m, DomBuilder t m) => DomBuilder t (SetRouteT t r m) where\n  type DomBuilderSpace (SetRouteT t r m) = DomBuilderSpace m\n  element t cfg child = SetRouteT $ element t cfg $ unSetRouteT child\n  inputElement = lift . inputElement\n  textAreaElement = lift . textAreaElement\n  selectElement cfg child = SetRouteT $ selectElement cfg $ unSetRouteT child\n\nmapSetRouteT :: (forall x. m x -> n x) -> SetRouteT t r m a -> SetRouteT t r n a\nmapSetRouteT f (SetRouteT x) = SetRouteT (mapEventWriterT f x)\n\nrunSetRouteT :: (Reflex t, Monad m) => SetRouteT t r m a -> m (a, Event t (Endo r))\nrunSetRouteT = runEventWriterT . unSetRouteT\n\nclass Reflex t => SetRoute t r m | m -> t r where\n  setRoute :: Event t r -> m ()\n  modifyRoute :: Event t (r -> r) -> m ()\n  default modifyRoute :: (Monad m', MonadTrans f, SetRoute t r m', m ~ f m') => Event t (r -> r) -> m ()\n  modifyRoute = lift . modifyRoute\n\n  setRoute = modifyRoute . fmap const\n\ninstance (Reflex t, Monad m) => SetRoute t r (SetRouteT t r m) where\n  modifyRoute = SetRouteT . tellEvent . fmap Endo\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RoutedT t r' m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (ReaderT r' m)\n\ninstance (PerformEvent t m, Prerender t m, Monad m, Reflex t) => Prerender t (SetRouteT t r m) where\n  type Client (SetRouteT t r m) = SetRouteT t r (Client m)\n  prerender server client = do\n    d <- lift $ prerender (runSetRouteT server) (runSetRouteT client)\n    let (a, r) = splitDynPure d\n    -- Must be prompt here\n    SetRouteT . tellEvent $ switchPromptlyDyn r\n    pure a\n\ninstance Requester t m => Requester t (SetRouteT t r m) where\n  type Request (SetRouteT t r m) = Request m\n  type Response (SetRouteT t r m) = Response m\n  requesting = SetRouteT . requesting\n  requesting_ = SetRouteT . requesting_\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RequesterT t req rsp m)\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (SetRouteT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (SetRouteT t r m) where\n  type Performable (SetRouteT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (SetRouteT t r m) where\n  type Ref (SetRouteT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance PrimMonad m => PrimMonad (SetRouteT t r m ) where\n  type PrimState (SetRouteT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance HasConfigs m => HasConfigs (SetRouteT t r m)\n\ninstance (MonadHold t m, Adjustable t m) => Adjustable t (SetRouteT t r m) where\n  runWithReplace a0 a' = SetRouteT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (SetRouteT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\nclass RouteToUrl r m | m -> r where\n  askRouteToUrl :: m (r -> Text)\n  default askRouteToUrl :: (Monad m', MonadTrans f, RouteToUrl r m', m ~ f m') => m (r -> Text)\n  askRouteToUrl = lift askRouteToUrl\n\nnewtype RouteToUrlT r m a = RouteToUrlT { unRouteToUrlT :: ReaderT (r -> Text) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadIO, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\nrunRouteToUrlT\n  :: RouteToUrlT r m a\n  -> (r -> Text)\n  -> m a\nrunRouteToUrlT a = runReaderT (unRouteToUrlT a)\n\nmapRouteToUrlT :: (forall x. m x -> n x) -> RouteToUrlT r m a -> RouteToUrlT r n a\nmapRouteToUrlT f (RouteToUrlT m) = RouteToUrlT $ mapReaderT f m\n\ninstance Monad m => RouteToUrl r (RouteToUrlT r m) where\n  askRouteToUrl = RouteToUrlT ask\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (SetRouteT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RoutedT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (ReaderT r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RequesterT t req rsp m)\n\ninstance (Prerender t m, Monad m) => Prerender t (RouteToUrlT r m) where\n  type Client (RouteToUrlT r m) = RouteToUrlT r (Client m)\n  prerender server client = do\n    r <- RouteToUrlT ask\n    lift $ prerender (runRouteToUrlT server r) (runRouteToUrlT client r)\n\ninstance Requester t m => Requester t (RouteToUrlT r m) where\n  type Request (RouteToUrlT r m) = Request m\n  type Response (RouteToUrlT r m) = Response m\n  requesting = RouteToUrlT . requesting\n  requesting_ = RouteToUrlT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RouteToUrlT r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RouteToUrlT r m) where\n  type Performable (RouteToUrlT r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RouteToUrlT r m) where\n  type Ref (RouteToUrlT r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance MonadTransControl (RouteToUrlT r) where\n  type StT (RouteToUrlT r) a = StT (ReaderT (r -> Text)) a\n  liftWith = defaultLiftWith RouteToUrlT unRouteToUrlT\n  restoreT = defaultRestoreT RouteToUrlT\n\ninstance PrimMonad m => PrimMonad (RouteToUrlT r m ) where\n  type PrimState (RouteToUrlT r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RouteToUrlT r m) where\n  type DomBuilderSpace (RouteToUrlT r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RouteToUrlT r m) where\n  runWithReplace a0 a' = RouteToUrlT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RouteToUrlT r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RouteToUrlT t m)\n\nrunRouteViewT\n  :: forall t m r a.\n     ( TriggerEvent t m\n     , PerformEvent t m\n     , MonadHold t m\n     , MonadJSM m\n     , MonadJSM (Performable m)\n     , MonadFix m\n     )\n  => Encoder Identity Identity r PageName\n  --TODO: Get rid of the switchover and useHash arguments\n  -- useHash can probably be baked into the encoder\n  -> Event t () -- ^ Switchover event, nothing is done until this event fires. Used to prevent incorrect DOM expectations at hydration switchover time\n  -> Bool\n  -> RoutedT t r (SetRouteT t r (RouteToUrlT r m)) a\n  -> m a\nrunRouteViewT routeEncoder switchover useHash a = do\n  rec historyState <- manageHistory' switchover $ HistoryCommand_PushState <$> setState\n      let theEncoder = pageNameEncoder . hoistParse (pure . runIdentity) routeEncoder\n          -- NB: The can only fail if the uriPath doesn't begin with a '/' or if the uriQuery\n          -- is nonempty, but begins with a character that isn't '?'. Since we don't expect\n          -- this ever to happen, we'll just handle it by failing completely with 'error'.\n          route :: Dynamic t r\n          route = fmap (errorLeft . tryDecode theEncoder . (adaptedUriPath useHash &&& uriQuery) . _historyItem_uri) historyState\n            where\n              errorLeft (Left e) = error (T.unpack e)\n              errorLeft (Right x) = x\n      (result, changeState) <- runRouteToUrlT (runSetRouteT $ runRoutedT a route) $ (\\(p, q) -> T.pack $ p <> q) . encode theEncoder\n      let f (currentHistoryState, oldRoute) change =\n            let newRoute = appEndo change oldRoute\n                (newPath, newQuery) = encode theEncoder newRoute\n            in HistoryStateUpdate\n               { _historyStateUpdate_state = DOM.SerializedScriptValue jsNull\n                 -- We always provide \"\" as the title.  On Firefox, Chrome, and\n                 -- Edge, this parameter does nothing.  On Safari, \"\" has the\n                 -- same behavior as other browsers (as far as I can tell), but\n                 -- anything else sets the title for the back button list item\n                 -- the *next* time pushState is called, unless the page title\n                 -- is changed in the interim.  Since the Safari functionality\n                 -- is near-pointless and also confusing, I'm not going to even\n                 -- bother exposing it; if there ends up being a real use case,\n                 -- we can change this function later to accommodate.\n                 -- See: https://github.com/whatwg/html/issues/2174\n               , _historyStateUpdate_title = \"\"\n               , _historyStateUpdate_uri = Just $ setAdaptedUriPath useHash newPath $ (_historyItem_uri currentHistoryState)\n                 { uriQuery = newQuery\n                 }\n               }\n          setState = attachWith f ((,) <$> current historyState <*> current route) changeState\n  return result\n\n-- | A link widget that, when clicked, sets the route to the provided route. In non-javascript\n-- contexts, this widget falls back to using @href@s to control navigation\nrouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLink r w = do\n  (e, a) <- routeLinkImpl mempty r w\n  scrollToTop e\n  return a\n\n-- | Like 'routeLink', but takes additional attributes as argument.\n--\nrouteLinkAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Map AttributeName Text -- ^ Additional attributes\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLinkAttr attrs r w = do\n  (e, a) <- routeLinkImpl attrs r w\n  let\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n  when (not targetBlank) $ scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLink'. Does not scroll to the top of the page on clicks.\nrouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Map AttributeName Text\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\nrouteLinkImpl attrs r w = do\n  enc <- askRouteToUrl\n  let\n    -- If targetBlank == True, the link will be opened in another page. In that\n    -- case, we don't prevent the default behaviour, and we don't need to\n    -- setRoute.\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n    cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_initialAttributes .~ (\"href\" =: enc r <> attrs)\n        & (if targetBlank\n           then id\n           else elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault))\n  (e, a) <- element \"a\" cfg w\n  when (not targetBlank) $ setRoute $ r <$ domEvent Click e\n  return (domEvent Click e, a)\n\nscrollToTop :: forall m t. (Prerender t m, Monad m) => Event t () -> m ()\nscrollToTop e = prerender_ blank $ performEvent_ $ ffor e $ \\_ -> liftJSM $ DOM.currentWindow >>= \\case\n  Nothing -> pure ()\n  Just win -> Window.scrollTo win 0 0\n\n-- | Like 'routeLinkDynAttr' but without custom attributes.\ndynRouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\ndynRouteLink r w = do\n  (e, a) <- dynRouteLinkImpl r w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'dynRouteLink'. Does not scroll to the top of the page on clicks.\ndynRouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\ndynRouteLinkImpl dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ (\"href\" =:) . enc <$> dr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- | An @a@-tag link widget that, when clicked, sets the route to current value of the\n-- provided dynamic route. In non-JavaScript contexts the value of the dynamic post\n-- build is used so the link still works like 'routeLink'.\nrouteLinkDynAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     , Prerender t m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m a\nrouteLinkDynAttr dAttr dr w = do\n  (e, a) <- routeLinkDynAttrImpl dAttr dr w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLinkDynAttr'. Does not scroll to the top of the page on clicks.\nrouteLinkDynAttrImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m (Event t (), a)\nrouteLinkDynAttrImpl dAttr dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ zipDynWith (<>) ((\"href\" =:) . enc <$> dr) dAttr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- On ios due to sandboxing when loading the page from a file adapt the\n-- path to be based on the hash.\n\nadaptedUriPath :: Bool -> URI -> String\nadaptedUriPath = \\case\n  True -> hashToPath . uriFragment\n  False -> uriPath\n\nsetAdaptedUriPath :: Bool -> String -> URI -> URI\nsetAdaptedUriPath useHash s u = case useHash of\n  True -> u { uriFragment = pathToHash s }\n  False -> u { uriPath = s }\n\npathToHash :: String -> String\npathToHash = ('#' :) . fromMaybe \"\" . L.stripPrefix \"/\"\n\nhashToPath :: String -> String\nhashToPath = ('/' :) . fromMaybe \"\" . L.stripPrefix \"#\"\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Route.Frontend"
              ],
              "decl": [
                "routeLinkAttr"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
              "startLine": 538,
              "startColumn": 3,
              "endLine": 538,
              "endColumn": 25,
              "from": "when (not targetBlank)",
              "to": "unless targetBlank",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 538, startCol = 3, endLine = 538, endCol = 25}, subts = [(\"x\",SrcSpan {startLine = 538, startCol = 13, endLine = 538, endCol = 24})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Obelisk.Route.Frontend"
              ],
              "decl": [
                "routeLinkImpl"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
              "startLine": 565,
              "startColumn": 3,
              "endLine": 565,
              "endColumn": 25,
              "from": "when (not targetBlank)",
              "to": "unless targetBlank",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 565, startCol = 3, endLine = 565, endCol = 25}, subts = [(\"x\",SrcSpan {startLine = 565, startCol = 13, endLine = 565, endCol = 24})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Obelisk.Route.Frontend"
              ],
              "decl": [
                "setAdaptedUriPath"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
              "startLine": 664,
              "startColumn": 33,
              "endLine": 666,
              "endColumn": 29,
              "from": "case useHash of\n  True -> u {uriFragment = pathToHash s}\n  False -> u {uriPath = s}",
              "to": "if useHash then u {uriFragment = pathToHash s} else u {uriPath = s}",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 664, startCol = 33, endLine = 666, endCol = 29}, subts = [(\"a\",SrcSpan {startLine = 664, startCol = 38, endLine = 664, endCol = 45}),(\"f\",SrcSpan {startLine = 666, startCol = 12, endLine = 666, endCol = 29}),(\"t\",SrcSpan {startLine = 665, startCol = 11, endLine = 665, endCol = 43})], orig = \"if a then t else f\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/Frontend.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/route/src/Obelisk/Route/Frontend.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/route/src/Obelisk/Route/Frontend.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 1.4545454545454546,
            "sum": 32
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 6,
          "lines_of_code": 259,
          "homplexity_lines_of_code": 273,
          "code_quality_score": 8.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 1.4545454545454546,
              "sum": 32
            },
            "homplexity_loc": 273,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 1 1: module Obelisk.Asset.Accept has 167 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 55 20: data Encoding has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 63 18: data QValue has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 69 28: data AcceptableEncodings has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 77 1: type signature for missingAcceptableEncodings has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 77 1: type signature for missingAcceptableEncodings has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 93 1: type signature for chooseEncoding has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 93 1: type signature for chooseEncoding has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 100 1: type signature for encodingQValue has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 100 1: type signature for encodingQValue has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 106 1: type signature for acceptEncodingBody has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 106 1: type signature for acceptEncodingBody has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 135 1: type signature for qvalue has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 135 1: type signature for qvalue has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has 18 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 156 1: type signature for contentCoding has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 156 1: type signature for contentCoding has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 160 1: type signature for token has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 160 1: type signature for token has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for literal has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for literal has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for isTokenChar has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for isTokenChar has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for isChar has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for isChar has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isCtl has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isCtl has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isSeparator has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isSeparator has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: type signature for liftM2' has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: type signature for liftM2' has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 193 1: type signature for starRule has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 193 1: type signature for starRule has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 194 1: function starRule has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 194 1: function starRule has 10 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 194 1: function starRule has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 207 1: type signature for hashRule has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 207 1: type signature for hashRule has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 208 1: function hashRule has cyclomatic complexity of 5 \nWarning:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 208 1: function hashRule has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 208 1: function hashRule has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 233 1: type signature for lws has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 233 1: type signature for lws has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 234 1: function lws has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 234 1: function lws has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 234 1: function lws has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 240 1: type signature for cr has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 240 1: type signature for cr has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 241 1: function cr has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 241 1: function cr has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 241 1: function cr has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 244 1: type signature for lf has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 244 1: type signature for lf has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 245 1: function lf has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 245 1: function lf has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 245 1: function lf has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: type signature for sp has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: type signature for sp has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function sp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function sp has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function sp has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 251 1: type signature for spVal has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 251 1: type signature for spVal has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 252 1: function spVal has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 252 1: function spVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 252 1: function spVal has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: type signature for ht has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: type signature for ht has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function ht has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function ht has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function ht has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 258 1: type signature for htVal has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 258 1: type signature for htVal has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 259 1: function htVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 259 1: function htVal has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 259 1: function htVal has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving  #-}\n\n-- | Module containing parsers and utilities for managing @Accept-Encoding@ headers and the overall process of encoding selection.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nmodule Obelisk.Asset.Accept\n  ( AcceptableEncodings(..)\n  , Encoding(..)\n  , QValue(..)\n  , QValueResolution\n  , acceptEncodingBody\n  , chooseEncoding\n  , missingAcceptableEncodings\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 710\nimport Prelude hiding (takeWhile, sequence)\nimport Data.Traversable (sequence)\n#elif __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#else\nimport Prelude hiding (takeWhile)\n#endif\n#else\nimport Prelude hiding (takeWhile)\n#endif\n\nimport Control.Applicative ((<|>), optional)\nimport Control.Arrow (second)\nimport Control.Monad (replicateM, void)\nimport Data.Attoparsec.ByteString as AttoBS\nimport Data.Attoparsec.ByteString.Char8 as AC8\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Either (partitionEithers)\nimport Data.Fixed (E3, Fixed(..), resolution)\nimport Data.List (sort)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes, fromMaybe, listToMaybe)\nimport Data.Ord (Down(..))\nimport Data.Proxy (Proxy(..))\nimport Data.String (IsString)\nimport Data.Word (Word8)\n\n\n-- | Type of a particular named encoding technique, such as @gzip@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5\nnewtype Encoding = Encoding { unEncoding :: ByteString } deriving (Show, Read, Eq, Ord, IsString)\n\n-- | Maximum precision of a Q value, in particular 3 decimal places of precision as given by the standard.\ntype QValueResolution = E3\n\n-- | Type of an HTTP @qvalue@ or quality value indicating how preferred some encoding is relative to some other one.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nnewtype QValue = QValue { unQValue :: Fixed QValueResolution } deriving (Show, Read, Eq, Ord)\n\n-- | Structure used for picking a mutually acceptable encoding, holding a default 'QValue' along with 'QValue's for a number of 'Encoding's and typically\n-- represented in HTTP as a string like gzip; q=1.0, identity; q=0.5, *; q=0.0@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\ndata AcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue :: QValue\n  -- ^The 'QValue' associated with the default encoding value @*@, indicating any unmentioned encoding.\n  , _acceptableEncodings_byEncoding :: Map Encoding QValue\n  -- ^'QValue's for each 'Encoding'.\n  } deriving (Show, Read, Eq, Ord)\n\n-- | When no Accept-Encoding header is present, prefer identity, then gzip or compress, then anything else available.\nmissingAcceptableEncodings :: AcceptableEncodings\nmissingAcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue = QValue 0.001\n  , _acceptableEncodings_byEncoding = Map.fromList\n      [ (Encoding \"identity\", QValue 1)\n      , (Encoding \"gzip\", QValue 0.5)\n      , (Encoding \"compress\", QValue 0.5)\n      ]\n  }\n\n-- | Takes a list of 'Encoding's and an 'AcceptableEncodings' representing preferences and returns @Just 'Encoding'@ to use of the given list based on those\n-- preferences. An 'Encoding' is preferred if it has a higher 'QValue' or in the case of ties if it comes first in the given list of encodings. An encoding\n-- with a @QValue@ of 0 will never be chosen. If no encoding could be chosen, either because no encodings were given or because 0 @QValue@s suppressed them,\n-- then @Nothing@ is returned.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nchooseEncoding :: [Encoding] -> AcceptableEncodings -> Maybe Encoding\nchooseEncoding es ae = fmap snd $ listToMaybe $ sort $ catMaybes $ zipWith f es [(1::Int)..]\n  where f e n = case encodingQValue e ae of\n          QValue 0 -> Nothing\n          q -> Just ((Down q, n), e) -- Choose by quality first (in descending order), then by the server's preference order\n\n-- | Helper function for 'chooseEncoding' that returns the default AcceptableEncoding if requested encoding is unavailable\nencodingQValue :: Encoding -> AcceptableEncodings -> QValue\nencodingQValue e ae = Map.findWithDefault (_acceptableEncodings_defaultQValue ae) e $ _acceptableEncodings_byEncoding ae\n\n-- | Attoparsec 'Parser' for parsing an 'AcceptableEncodings' from the value of an @Accept-Encoding@ header, as specified by HTTP/1.1 / RFC2616.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nacceptEncodingBody :: Parser AcceptableEncodings\nacceptEncodingBody = do\n  l <- hashRule (Just 1) Nothing $ do -- partially applied hashRule awaiting to be passed Parser a\n    c <- (Nothing <$ literal \"*\") <|> (Just <$> contentCoding) -- Parser Nothing <|> Parser Encoding\n    mq <- optional $ do\n      literal \";\"\n      literal \"q\"\n      literal \"=\"\n      qvalue\n    let q = fromMaybe (QValue 1) mq\n    return (c, q)\n  let (stars, specificEncodings) = partitionEithers $ flip map l $ \\(c, q) -> case c of\n        Nothing -> Left q\n        Just n -> Right (n, q)\n  starQValue <- case stars of\n    [] -> return Nothing\n    [q] -> return $ Just q\n    _ -> fail \"acceptEncodingBody: multiple * values provided\"\n  byEncodingProvided <- sequence $ Map.fromListWithKey (\\k _ _ -> fail $ \"acceptEncodingBody: encoding \" <> show k <> \" repeated multiple times\") $ map (second return) specificEncodings\n  let defaultIdentityQValue = fromMaybe (QValue 1) starQValue -- identity has a default qvalue of 1 unless * is given a different qvalue explicitly\n      defaultQValue = fromMaybe (QValue 0) starQValue\n      byEncoding = Map.filter (/= defaultQValue) -- Canonicalize: qvalues equal to the default are redundant\n                 . Map.alter (Just . fromMaybe defaultIdentityQValue) \"identity\" -- Add implicit \"identity\" encoding, unless it has been explicitly added\n                 $ byEncodingProvided\n  return $ AcceptableEncodings defaultQValue byEncoding\n\n-- | Parser for a 'QValue'.\n--\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nqvalue :: Parser QValue\nqvalue = do\n  skipMany lws\n  q0 <|> q1\n  where q0 = do\n          _ <- char '0'\n          decimals <- option [] $ do\n            _ <- char '.'\n            starRule (Just 0) (Just numAllowedDigits) digit\n          return $ QValue $ MkFixed $ fromIntegral $ (read ('0' : decimals) :: Int) * 10 ^ (numAllowedDigits - length decimals)\n        q1 = do\n          _ <- char '1'\n          option () $ do\n            _ <- char '.'\n            _ <- starRule (Just 0) (Just numAllowedDigits) $ char '0'\n            return ()\n          return $ QValue 1\n        numAllowedDigits :: Int\n        numAllowedDigits = fromIntegral $ resolution (Proxy :: Proxy QValueResolution)\n\n-- | Helper function used in 'acceptEncodingBody' to evaluate Encoding as ByteString\ncontentCoding :: Parser Encoding\ncontentCoding = Encoding <$> token\n\n-- | Helper function used in 'contentCoding' that skips lightweight spaces and consumes input while 'isTokenChar' returns True\ntoken :: Parser ByteString\ntoken = skipMany lws >> AttoBS.takeWhile1 isTokenChar\n\n-- | Helper function used in 'acceptEncodingBody', discards evaluation and returns  a 'Parser ()' to continue parsing\nliteral :: ByteString -> Parser ()\nliteral s = void $ skipMany lws >> string s\n\n-- | Helper function used in 'token' to validate if ByteStringChar is printable but not a control or seperator char\nisTokenChar :: Word8 -> Bool\nisTokenChar c = isChar c && not (isCtl c || isSeparator c)\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control or printable char\nisChar :: Word8 -> Bool\nisChar c = c <= 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control char\nisCtl :: Word8 -> Bool\nisCtl c = c <= 31 || c == 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a seperator char\nisSeparator :: Word8 -> Bool\nisSeparator c = BS.elem c $ spVal `BS.cons` htVal `BS.cons` \"()<>@,;:\\\\\\\"/[]?={}\"\n\n-- | A version of 'liftM2' that is strict in the result of its first\n-- action.\nliftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\nliftM2' f a b = do\n  !x <- a\n  y <- b\n  return (f x y)\n{-# INLINE liftM2' #-}\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\nstarRule :: Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nstarRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n  mandatoryVals <- replicateM numMandatory element\n  optionalVals <- case maxNum of\n    Nothing -> many' element\n    Just n -> do\n      let countUpTo 0 _ = return []\n          countUpTo m a = liftM2' (:) a (countUpTo (pred m) a) <|> return []\n      countUpTo (n - numMandatory) element\n  return $ mandatoryVals ++ optionalVals\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\n-- The spec is a bit ambiguous on whether extra commas and whitespace are permitted before and after the elements; this implementation permits them\nhashRule :: forall a. Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nhashRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n      sep :: Parser ()\n      sep = do\n        skipMany1 $ do\n          skipMany lws\n          char ','\n        return ()\n      processMandatory :: Bool -> Int -> Parser [a]\n      processMandatory isInitial 0 = processOptional isInitial $ fmap (subtract numMandatory) maxNum\n      processMandatory isInitial n = do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processMandatory False $ pred n\n      processOptional :: Bool -> Maybe Int -> Parser [a]\n      processOptional _ (Just 0) = return []\n      processOptional isInitial n = (<|> return []) $ do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processOptional False $ fmap pred n\n  result <- processMandatory True numMandatory\n  _ <- optional sep\n  skipMany lws\n  return result\n\n-- | Linear whitespace\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlws :: Parser ()\nlws = do\n  option () $ cr >> lf\n  _ <- starRule (Just 1) Nothing $ sp <|> ht\n  return ()\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\ncr :: Parser ()\ncr = void $ word8 13\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlf :: Parser ()\nlf = void $ word8 10\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nsp :: Parser ()\nsp = void $ word8 spVal\n\nspVal :: Word8\nspVal = 32\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nht :: Parser ()\nht = void $ word8 htVal\n\nhtVal :: Word8\nhtVal = 9\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Asset.Accept"
              ],
              "decl": [
                "liftM2'"
              ],
              "severity": "Warning",
              "hint": "Use <$>",
              "file": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
              "startLine": 186,
              "startColumn": 17,
              "endLine": 189,
              "endColumn": 17,
              "from": "do !x <- a\n   y <- b\n   return (f x y)",
              "to": "do !x <- a\n   f x <$> b",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 188, startCol = 3, endLine = 188, endCol = 9}, subts = [(\"x\",SrcSpan {startLine = 188, startCol = 8, endLine = 188, endCol = 9}),(\"f0\",SrcSpan {startLine = 189, startCol = 11, endLine = 189, endCol = 14})], orig = \"f0 <$> x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 189, startCol = 3, endLine = 189, endCol = 17}}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 11,
            "average": 2.5,
            "sum": 20
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 0,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 13,
          "lines_of_code": 154,
          "homplexity_lines_of_code": 175,
          "code_quality_score": 42.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 11,
              "average": 2.5,
              "sum": 20
            },
            "homplexity_loc": 175,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 1 1: module Obelisk.Asset.Serve.Snap has 108 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 48 1: type signature for serveAssets has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 48 1: type signature for serveAssets has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 49 1: function serveAssets has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 49 1: function serveAssets has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 49 1: function serveAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 57 1: type signature for serveAssetsInPlace has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 57 1: type signature for serveAssetsInPlace has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 58 1: function serveAssetsInPlace has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 58 1: function serveAssetsInPlace has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 58 1: function serveAssetsInPlace has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 61 1: type signature for serveAsset has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 61 1: type signature for serveAsset has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 62 1: function serveAsset has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 62 1: function serveAsset has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 62 1: function serveAsset has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 65 1: type signature for serveAssetInPlace has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 65 1: type signature for serveAssetInPlace has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 66 1: function serveAssetInPlace has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 66 1: function serveAssetInPlace has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 66 1: function serveAssetInPlace has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 73 1: type signature for serveAssets' has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 73 1: type signature for serveAssets' has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 74 1: function serveAssets' has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 74 1: function serveAssets' has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 74 1: function serveAssets' has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 79 1: type signature for serveAsset' has 5 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 79 1: type signature for serveAsset' has type constructor nesting of 1 \nCritical:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 80 1: function serveAsset' has 52 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 80 1: function serveAsset' has branching depth of 4 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 80 1: function serveAsset' has cyclomatic complexity of 11 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 138 1: type signature for getAssetPath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 138 1: type signature for getAssetPath has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 142 1: function getAssetPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 142 1: function getAssetPath has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 142 1: function getAssetPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 149 1: type signature for getAssetTarget has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 149 1: type signature for getAssetTarget has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 150 1: function getAssetTarget has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 150 1: function getAssetTarget has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs\" 150 1: function getAssetTarget has cyclomatic complexity of 2 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- | Serve preprocessed assets using Snap.\nmodule Obelisk.Asset.Serve.Snap\n  ( serveAssets\n  , serveAssetsInPlace\n  , serveAsset\n  , serveAssetInPlace\n  , getAssetPath\n  ) where\n\nimport Obelisk.Asset.Accept (Encoding (..), acceptEncodingBody, chooseEncoding, missingAcceptableEncodings)\nimport Obelisk.Snap.Extras\n\nimport Snap\n  (MonadSnap, getHeader, getRequest, getsRequest, modifyResponse, pass, redirect, sendFile, setContentLength, setContentType, setHeader, setResponseCode)\nimport Snap.Util.FileServe (fileType, getSafePath, serveFile)\nimport Snap.Internal.Util.FileServe (checkRangeReq)\n\nimport Control.Applicative ((<|>))\nimport Control.Exception (handleJust, try, throwIO)\nimport Control.Monad (forM, liftM, unless)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail\n#endif\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Attoparsec.ByteString (parseOnly, endOfInput)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.List (isSuffixOf, sort)\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Monoid ((<>))\n#endif\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8, encodeUtf8)\nimport System.Directory (getDirectoryContents)\nimport System.FilePath ((</>), splitFileName, takeDirectory)\nimport System.IO.Error (isDoesNotExistError)\nimport System.PosixCompat.Files (getFileStatus, fileSize)\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, redirects will be sent to the browser\n-- from the logical asset name (e.g. @test.png@) to the unique filename for the\n-- current version of the asset\n-- (e.g. @0rx5yvkkgkig2pcqf4ngi1l7vh89qqajdzc6aiayaibyhvj0d853-test.png@). Hashed\n-- asset names will be sent with permanent caching headers.\nserveAssets :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> m ()\nserveAssets = serveAssets' True\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, redirects will be not sent to the\n-- browser for the logical asset name (e.g. @test.png@) but instead the current\n-- version of the asset with to point the browser at the unique filename for the\n-- current version of the asset.\nserveAssetsInPlace :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> m ()\nserveAssetsInPlace = serveAssets' False\n\n-- | Like 'serveAssets', but only serves a single specified asset\nserveAsset :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> FilePath -> m ()\nserveAsset = serveAsset' True\n\n-- | Like 'serveAssetsInPlace', but only serves a single specified asset\nserveAssetInPlace :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> FilePath -> m ()\nserveAssetInPlace = serveAsset' False\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, the @Bool@ argument @doRedirect@ controls whether redirects will be sent to the browser if a request is made for\n-- an unhashed asset name, e.g. @test.png@. For @True@, a redirect will be sent, yielding more round trips to the server but better caching behavior if the\n-- asset doesn't change often. Conversely for @False@, the asset will be served \"in place\" but made uncacheable.\nserveAssets' :: (MonadSnap m, MonadFail m) => Bool -> FilePath -> FilePath -> m ()\nserveAssets' doRedirect base fallback = do\n  pRaw <- getSafePath\n  serveAsset' doRedirect base fallback $ if \"/\" `isSuffixOf` pRaw || pRaw == \"\" then pRaw <> \"index.html\" else pRaw\n\n-- | Serve a single static asset from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\nserveAsset' :: (MonadFail m, MonadSnap m) => Bool -> FilePath -> FilePath -> FilePath -> m ()\nserveAsset' doRedirect base fallback p = do\n  assetType <- liftIO $ try $ BS.readFile $ base </> p </> \"type\"\n  case assetType of\n    Right \"immutable\" -> do\n      conditionalOnModification <- getsRequest $ getHeader \"If-Modified-Since\"\n      case conditionalOnModification of\n        Nothing -> do\n          encodedFiles <- liftM (filter (`notElem` [\".\", \"..\"])) $ liftIO $ getDirectoryContents $ base </> p </> \"encodings\"\n          availableEncodings <- liftM (map snd . sort) $ forM encodedFiles $ \\f -> do\n            stat <- liftIO $ getFileStatus $ base </> p </> \"encodings\" </> f\n            return (fileSize stat, Encoding $ encodeUtf8 $ T.pack f)\n          acceptEncodingRaw <- getsRequest $ getHeader \"Accept-Encoding\"\n          ae <- case acceptEncodingRaw of\n            Nothing -> return missingAcceptableEncodings\n            Just aer -> case parseOnly (acceptEncodingBody <* endOfInput) aer of\n              Right ae -> return ae\n              Left err -> error err\n          Just (Encoding e) <- return $ chooseEncoding availableEncodings ae\n          modifyResponse $ setHeader \"Content-Encoding\" e . setHeader \"Vary\" \"Accept-Encoding\"\n          if doRedirect then cachePermanently else doNotCache --TODO: Use Etags when not redirecting\n          let finalFilename = base </> p </> \"encodings\" </> T.unpack (decodeUtf8 e)\n          stat <- liftIO $ getFileStatus finalFilename\n          modifyResponse $ setHeader \"Last-Modified\" \"Thu, 1 Jan 1970 00:00:00 GMT\"\n            . setHeader \"Accept-Ranges\" \"bytes\"\n            . setContentType (fileType modernMimeTypes p)\n          let size = fromIntegral $ fileSize stat\n          req <- getRequest\n          -- Despite the name, this function actually does all of the work for\n          -- responding to range requests. We only need to handle *none* range\n          -- requests ourselves.\n          wasRange <- checkRangeReq req finalFilename size\n          unless wasRange $ do\n            modifyResponse $ setResponseCode 200 . setContentLength size\n            sendFile finalFilename\n        Just _ -> do\n          cachePermanently >> modifyResponse (setResponseCode 304)\n    Right \"redirect\" -> do\n      mtarget <- liftIO $ getAssetTarget $ base </> p\n      case mtarget of\n        Just target -> if doRedirect\n                       then do\n                         doNotCache\n                         redirect target\n                       else do\n                         serveAsset' doRedirect base fallback $ takeDirectory p </> T.unpack (decodeUtf8 target)\n        Nothing -> do\n          serveFile $ fallback </> p\n    Right unknown -> error $ T.unpack (\"serveAssets': Unknown asset \" <> decodeUtf8 unknown)\n    Left err | isDoesNotExistError err -> (doNotCache >> serveFileIfExists (fallback </> p)) <|> do\n                 let (dirname, filename) = splitFileName p\n                     unhashedFilename = drop 1 $ dropWhile (/= '-') filename\n                 if null unhashedFilename then pass else do\n                   doNotCache\n                   serveFileIfExists $ fallback </> dirname </> unhashedFilename\n             | otherwise -> liftIO $ throwIO err\n\n-- | If the given file exists in a hashed location, return that location.  The\n-- resulting FilePath will be relative to @base@, just like @assetPath@ is.\ngetAssetPath\n  :: FilePath -- ^ @base@: Path to asset directory\n  -> FilePath -- ^ @assetPath@: Path to non-hashed asset within the asset directory\n  -> IO (Maybe FilePath) -- ^ Path to hashed asset within the asset directory, if it exists\ngetAssetPath base p = do\n  target <- getAssetTarget $ base </> p\n  return $ fmap ((takeDirectory p </>) . T.unpack . decodeUtf8) target\n\n-- | Given a file path into an asset directory prepared by @assets.nix@, read\n-- the target path from the metadata if it exists. Returns @Nothing@ when the\n-- asset path doesn't exist.\ngetAssetTarget :: FilePath -> IO (Maybe ByteString)\ngetAssetTarget p =\n  handleJust\n    (\\ e  -> if isDoesNotExistError e then Just () else Nothing)\n    (\\ () -> return Nothing)\n    (liftM Just $ BS.readFile $ p </> \"target\")\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Asset.Serve.Snap"
              ],
              "decl": [
                "serveAsset'"
              ],
              "severity": "Warning",
              "hint": "Use fmap",
              "file": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
              "startLine": 87,
              "startColumn": 27,
              "endLine": 87,
              "endColumn": 32,
              "from": "liftM",
              "to": "fmap",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 87, startCol = 27, endLine = 87, endCol = 32}, subts = [], orig = \"fmap\"}]"
            },
            {
              "module": [
                "Obelisk.Asset.Serve.Snap"
              ],
              "decl": [
                "serveAsset'"
              ],
              "severity": "Warning",
              "hint": "Use fmap",
              "file": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
              "startLine": 88,
              "startColumn": 33,
              "endLine": 88,
              "endColumn": 38,
              "from": "liftM",
              "to": "fmap",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 88, startCol = 33, endLine = 88, endCol = 38}, subts = [], orig = \"fmap\"}]"
            },
            {
              "module": [
                "Obelisk.Asset.Serve.Snap"
              ],
              "decl": [
                "getAssetTarget"
              ],
              "severity": "Warning",
              "hint": "Use fmap",
              "file": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
              "startLine": 154,
              "startColumn": 6,
              "endLine": 154,
              "endColumn": 11,
              "from": "liftM",
              "to": "fmap",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 154, startCol = 6, endLine = 154, endCol = 11}, subts = [], orig = \"fmap\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 16,
          "homplexity_lines_of_code": 20,
          "code_quality_score": 96.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 20,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 1 1: <unnamed module> has 13 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 7 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 7 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has branching depth of 0 \n"
          },
          "original_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Promoted\nimport Obelisk.Asset.Symlink\nimport System.Environment\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeStaticProject paths haskellTarget $ StaticConfig\n    { _staticConfig_packageName = T.pack packageName\n    , _staticConfig_moduleName = T.pack moduleName\n    }\n  copyAndSymlink paths root fileTarget\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src-bin/generate.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src-bin/generate.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 43,
          "homplexity_lines_of_code": 69,
          "code_quality_score": 91.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 69,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 1 1: <unnamed module> has 38 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 8 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 8 1: type signature for main has 1 arguments \nWarning:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has 31 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has branching depth of 0 \n"
          },
          "original_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Cabal\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Symlink\nimport System.Environment\nimport System.FilePath\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeCabalProject haskellTarget $ SimplePkg\n    { _simplePkg_name = T.pack packageName\n    , _simplePkg_moduleName = T.pack moduleName\n    , _simplePkg_dependencies = map T.pack\n      [ \"base\"\n      , \"obelisk-asset-manifest\"\n      , \"template-haskell\"\n      ]\n    , _simplePkg_moduleContents = T.pack $ unlines\n      [ \"{-# Language CPP #-}\"\n      , \"{-|\"\n      , \"  Description:\"\n      , \"    Automatically generated module that provides the 'static' TH function\"\n      , \"    to generate paths to static assets.\"\n      , \"-}\"\n      , \"module \" <> moduleName <> \" ( static, staticFilePath ) where\"\n      , \"\"\n      , \"import Obelisk.Asset.TH\"\n      , \"import Language.Haskell.TH\"\n      , \"\"\n      , \"static, staticFilePath :: FilePath -> Q Exp\"\n      , \"#ifdef OBELISK_ASSET_PASSTHRU\"\n      , \"static = staticAssetRaw\"\n      , \"staticFilePath =  staticAssetFilePathRaw \\\"static.out\\\"\"\n      , \"#else\"\n      , \"static = staticAssetHashed \" <> show root\n      , \"staticFilePath = staticAssetFilePath \" <> show root\n      , \"#endif\"\n      ]\n    }\n  copyAndSymlink paths root fileTarget\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src-bin/static-th.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src-bin/static-th.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.5,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 42,
          "homplexity_lines_of_code": 55,
          "code_quality_score": 88.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.5,
              "sum": 3
            },
            "homplexity_loc": 55,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 1 1: module Obelisk.Asset.Cabal has 35 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 12 18: data SimplePkg has record fields count of 4 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 19 1: type signature for cabalFile has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 19 1: type signature for cabalFile has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has 11 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 33 1: type signature for writeCabalProject has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 33 1: type signature for writeCabalProject has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has branching depth of 1 \n"
          },
          "original_code": "{-# Language OverloadedStrings #-}\nmodule Obelisk.Asset.Cabal where\n\nimport qualified Data.List as L\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory\nimport System.FilePath\n\n-- | A generated single-module package\ndata SimplePkg = SimplePkg\n  { _simplePkg_name :: Text\n  , _simplePkg_moduleName :: Text\n  , _simplePkg_moduleContents :: Text\n  , _simplePkg_dependencies :: [Text]\n  }\n\ncabalFile :: SimplePkg -> Text\ncabalFile (SimplePkg packageName moduleName _ deps) = T.unlines\n  [ \"name: \" <> packageName\n  , \"version: 0\"\n  , \"cabal-version: >= 1.2\"\n  , \"build-type: Simple\"\n  , \"\"\n  , \"library\"\n  , \"  hs-source-dirs: src\"\n  , \"  build-depends:\"\n  , \"    \" <> T.intercalate \", \" deps\n  , \"  exposed-modules: \" <> moduleName\n  ]\n\nwriteCabalProject :: FilePath -> SimplePkg -> IO ()\nwriteCabalProject target pkg = do\n  createDirectoryIfMissing True target\n  T.writeFile (target </> T.unpack (_simplePkg_name pkg) <.> \"cabal\") $ cabalFile pkg\n  let moduleName = _simplePkg_moduleName pkg\n      (modName', moduleDirPath) = case L.uncons (reverse $ T.splitOn \".\" moduleName) of\n        Nothing -> error $ \"writeStaticProject: invalid module name \" <> T.unpack moduleName\n        Just (name, parents) -> (name, target </> \"src\" </> T.unpack (T.intercalate \"/\" $ reverse parents))\n  createDirectoryIfMissing True moduleDirPath\n  T.writeFile (moduleDirPath </> T.unpack modName' <.> \"hs\") $ _simplePkg_moduleContents pkg\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 22,
          "homplexity_lines_of_code": 21,
          "code_quality_score": 95.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 21,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 1 1: module Obelisk.Asset.Symlink has 17 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 14 1: type signature for copyAndSymlink has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 14 1: type signature for copyAndSymlink has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has branching depth of 0 \n"
          },
          "original_code": "module Obelisk.Asset.Symlink\n  ( copyAndSymlink\n  ) where\n\nimport Control.Monad\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport System.Directory\nimport System.FilePath.Posix\nimport System.PosixCompat.Files\n\n-- | Copy the given hashed files from one location to hashed paths in another\n-- location, and symlink the unhashed paths to the hashed ones\ncopyAndSymlink\n  :: Map FilePath FilePath\n  -> FilePath\n  -> FilePath\n  -> IO ()\ncopyAndSymlink paths source destination = forM_ (Map.toList paths) $ \\(original, hashed) -> do\n  createDirectoryIfMissing True $ destination </> takeDirectory hashed\n  copyFile (source </> original) (destination </> hashed)\n  createSymbolicLink (takeFileName hashed) $ destination </> original\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.6666666666666667,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 11,
          "lines_of_code": 70,
          "homplexity_lines_of_code": 88,
          "code_quality_score": 81.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.6666666666666667,
              "sum": 5
            },
            "homplexity_loc": 88,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 1 1: module Obelisk.Asset.Gather has 58 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 26 1: type signature for gatherHashedPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 26 1: type signature for gatherHashedPaths has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has 11 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 43 1: type signature for toHashedPath has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 43 1: type signature for toHashedPath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 56 1: type signature for toNixBase32 has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 56 1: type signature for toNixBase32 has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has 12 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has cyclomatic complexity of 2 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n-- | Functions for collecting up files to be processed by the asset pipeline\nmodule Obelisk.Asset.Gather\n  ( gatherHashedPaths\n  , toHashedPath\n  ) where\n\nimport Control.DeepSeq (force)\nimport Control.Monad (forM)\nimport Data.Bits (shift, (.|.), (.&.))\nimport qualified Data.ByteString.Builder as LBS (toLazyByteString, word8)\nimport qualified Data.ByteString.Lazy as LBS (readFile, toStrict, ByteString, length, index)\nimport Data.Char (ord)\nimport Data.Digest.Pure.SHA (bytestringDigest, sha256)\nimport Data.Map (Map)\nimport qualified Data.Map as Map (singleton)\nimport qualified Data.Text as T (unpack)\nimport Data.Text.Encoding (decodeUtf8)\nimport qualified Data.Vector.Unboxed as UV ((!), fromList)\nimport Data.Word (Word8)\nimport System.FilePath.Posix ((</>), splitFileName, normalise)\nimport System.Directory (listDirectory, doesFileExist)\n\n-- | Given a path, recursively explore it, creating hashed paths for all files found\ngatherHashedPaths\n  :: FilePath -- ^ The root of the directory to process\n  -> IO (Map FilePath FilePath) -- ^ A mapping of original paths to hashed paths (all relative to the root)\ngatherHashedPaths root = go \"\"\n  where\n    go :: FilePath -> IO (Map FilePath FilePath)\n    go subdir = do\n      subs <- listDirectory $ root </> subdir\n      fmap mconcat $ forM subs $ \\sub -> do\n        let relativePath = subdir </> sub\n        isFile <- doesFileExist $ root </> relativePath\n        if isFile\n          then do !hashedRelativePath <- force <$> toHashedPath root relativePath\n                  return $ Map.singleton relativePath hashedRelativePath\n          else go relativePath\n\n-- | Given a root path and path relative to it, construct a hashed version of the relative path\ntoHashedPath\n  :: FilePath -- ^ Root path\n  -> FilePath -- ^ Relative path within root\n  -> IO FilePath\ntoHashedPath root relativePath = do\n  let path = root </> relativePath\n  contents <- LBS.readFile path\n  let hashPrefix = T.unpack $ decodeUtf8 $ LBS.toStrict $ toNixBase32 $ bytestringDigest $ sha256 contents\n      (dir, filename) = splitFileName relativePath\n      !hashedRelativePath = force $ normalise $ dir </> (hashPrefix <> \"-\" <> filename)\n  return hashedRelativePath\n\n-- | Convert a ByteString to base 32 in the way that Nix does\ntoNixBase32 :: LBS.ByteString -> LBS.ByteString\ntoNixBase32 x = LBS.toLazyByteString $ mconcat $ map (LBS.word8 . (symbols UV.!) . fromIntegral) vals\n  where vals = byteStringToQuintets x\n        symbols = UV.fromList $ map (fromIntegral . ord) $ filter (`notElem` (\"eotu\" :: String)) $ ['0'..'9'] <> ['a'..'z']\n        -- See https://github.com/NixOS/nix/blob/6f1743b1a5116ca57a60b481ee4083c891b7a334/src/libutil/hash.cc#L109\n        byteStringToQuintets :: LBS.ByteString -> [Word8]\n        byteStringToQuintets hash = map f [len-1, len-2 .. 0]\n          where hashSize = fromIntegral $ LBS.length hash\n                len = (hashSize * 8 - 1) `div` 5 + 1\n                f n = let b = n * 5\n                          (i, j) = b `divMod` 8\n                          j' = fromIntegral j\n                          --TODO: This is probably pretty slow; replace with something that doesn't use LBS.index\n                          c = ((hash `LBS.index` i) `shift` (-j')) .|. (if i >= hashSize - 1 then 0 else (hash `LBS.index` (i + 1)) `shift` (8 - j'))\n                      in c .&. 0x1f\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 0,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 5,
          "lines_of_code": 89,
          "homplexity_lines_of_code": 68,
          "code_quality_score": 75.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 9
            },
            "homplexity_loc": 68,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 5 1: module Obelisk.Asset.TH has 48 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has branching depth of 0 \n"
          },
          "original_code": "{-|\nDescription:\n  Template Haskell for generating asset paths.\n-}\nmodule Obelisk.Asset.TH\n  ( assetPath\n  , staticAssetRaw\n  , staticAssetHashed\n  , staticAssetFilePath\n  , staticAssetFilePathRaw\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Control.Monad\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport System.Directory\nimport System.FilePath.Posix\n\n-- | Produces the hashed path of a file\nhashedAssetFilePath :: FilePath -> FilePath -> Q FilePath\nhashedAssetFilePath root relativePath = do\n  qAddDependentFile $ root </> relativePath\n  runIO (toHashedPath root relativePath)\n\n-- | Produces a string literal with the hashed path of the file\nassetPath :: FilePath -> FilePath -> Q Exp\nassetPath root relativePath =\n  LitE . StringL <$> hashedAssetFilePath root relativePath\n\nstaticPrefix :: FilePath\nstaticPrefix = \"/static\"\n\n-- | Location of the symbolic link to static assets and resources.\nstaticOutPath :: FilePath\nstaticOutPath = \"static.out\"\n\n-- | Embed a filepath via template haskell. Resources embedded this way\n-- are requested from the \"/static\" route.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetRaw :: FilePath -> Q Exp\nstaticAssetRaw = staticAssetWorker staticPrefix staticOutPath\n\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp\n\n-- | Embed a filepath via template haskell. Differently to 'staticAssetRaw'\n-- this points to a local filepath instead of an URL during deployment.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetFilePathRaw\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetFilePathRaw root = staticAssetWorker root staticOutPath\n\nstaticAssetFilePath :: FilePath -> FilePath -> Q Exp\nstaticAssetFilePath root relativePath = do\n  let fullPath = root </> relativePath\n  qAddDependentFile fullPath\n  pure $ LitE $ StringL fullPath\n\n-- | @'staticAssetWorker' root staticOut fp@.\n--\n-- Produces @root </> fp@, but checks before that @fp@ has been copied\n-- to 'staticOutPath' and produces a compilation error otherwise.\n-- This helps finding typos in filepaths, etc... at compile-time instead of\n-- run-time.\nstaticAssetWorker\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Directory to which the filepath must have been copied.\n  -- If @fp@ does not exist within this directory, this function will fail.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetWorker root staticOut fp = do\n  exists <- runIO $ doesFileExist $ staticOut </> fp\n  when (not exists) $\n    fail $ \"The file \" <> fp <> \" was not found in \" <> staticOut\n  returnQ $ LitE $ StringL $ root </> fp\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Asset.TH"
              ],
              "decl": [
                "staticAssetWorker"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
              "startLine": 87,
              "startColumn": 3,
              "endLine": 87,
              "endColumn": 20,
              "from": "when (not exists)",
              "to": "unless exists",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 87, startCol = 3, endLine = 87, endCol = 20}, subts = [(\"x\",SrcSpan {startLine = 87, startCol = 13, endLine = 87, endCol = 19})], orig = \"unless x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
          "cyclomatic_complexity": {
            "min": 2,
            "max": 5,
            "average": 3,
            "sum": 18
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 12,
          "lines_of_code": 102,
          "homplexity_lines_of_code": 105,
          "code_quality_score": 53.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 5,
              "average": 3,
              "sum": 18
            },
            "homplexity_loc": 105,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"writeStaticProject\": 4,\n        \"staticModuleFile\": 2,\n        \"declareStatic\": 5,\n        \"staticClassWithInstances\": 3,\n        \"staticClass\": 2,\n        \"staticInstance\": 2,\n        \"min\": 2,\n        \"max\": 5,\n        \"average\": 3,\n        \"sum\": 18\n    },\n    \"homplexity_loc\": 105\n}\n"
          },
          "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\nmodule Obelisk.Asset.Promoted\n  ( writeStaticProject\n  , declareStatic\n  , StaticConfig (..)\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Data.Foldable\nimport Language.Haskell.TH (pprint)\nimport Language.Haskell.TH.Syntax hiding (lift)\nimport GHC.TypeLits\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq\nimport Control.Monad.Trans.Writer\nimport System.FilePath\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Obelisk.Asset.Cabal (writeCabalProject, SimplePkg(..))\n\ndata StaticConfig = StaticConfig\n  { _staticConfig_packageName :: Text --TODO: Better type\n  , _staticConfig_moduleName :: Text --TODO: Better type\n  }\n\nwriteStaticProject :: Map FilePath FilePath -> FilePath -> StaticConfig -> IO ()\nwriteStaticProject paths target cfg = do\n  let modName = _staticConfig_moduleName cfg\n  modContents <- staticModuleFile modName paths\n  writeCabalProject target $ SimplePkg\n    { _simplePkg_name = _staticConfig_packageName cfg\n    , _simplePkg_moduleName = _staticConfig_moduleName cfg\n    , _simplePkg_moduleContents = modContents\n    , _simplePkg_dependencies = [\"base\", \"ghc-prim\", \"text\"]\n    }\n\nstaticModuleFile :: Text -> Map FilePath FilePath -> IO Text\nstaticModuleFile moduleName paths = do\n  decs <- runQ $ fmap toList $ execWriterT $ staticClassWithInstances paths\n  return $ T.unlines\n    [ \"{-# LANGUAGE AllowAmbiguousTypes #-}\"\n    , \"{-# LANGUAGE DataKinds #-}\"\n    , \"{-# LANGUAGE FlexibleInstances #-}\"\n    , \"{-# LANGUAGE KindSignatures #-}\"\n    , \"{-# LANGUAGE OverloadedStrings #-}\"\n    , \"{-# LANGUAGE ScopedTypeVariables #-}\"\n    , \"{-# LANGUAGE TypeApplications #-}\"\n    , \"module \" <> moduleName <> \" {-# DEPRECATED \\\"Generate this module with the 'obelisk-asset-th-generate' executable instead.\\\" #-} where\"\n    , \"\"\n    , \"import qualified GHC.Types\"\n    , \"import Data.Text (Text)\"\n    , \"import qualified Data.Text.Internal\"\n    , \"import Data.Monoid ((<>))\"\n    , \"\"\n    , \"static :: forall a. StaticFile a => Text\"\n    , \"static = \\\"static/\\\" <> hashedPath @a\" --TODO: Use obelisk-route to generate this in a more consistent way\n    , \"\"\n    , T.pack $ pprint decs\n    ]\n\ndata StaticContext = StaticContext\n  { _staticContext_className :: Name\n  , _staticContext_methodName :: Name\n  }\n\ndeclareStatic :: FilePath -> Q [Dec]\ndeclareStatic root = do\n  paths <- runIO $ gatherHashedPaths root\n  -- TODO: If https://ghc.haskell.org/trac/ghc/ticket/14623 is implemented, use\n  -- qAddDependentFile to watch the directories as well as the files\n  forM_ (Map.keys paths) $ \\original -> do\n    qAddDependentFile $ root </> original\n  fmap toList $ execWriterT $ staticClassWithInstances paths\n\nstaticClassWithInstances :: Map FilePath FilePath -> WriterT (Seq Dec) Q ()\nstaticClassWithInstances paths = do\n  ctx <- staticClass\n  forM_ (Map.toList paths) $ \\(original, hashed) -> do\n    staticInstance ctx original hashed\n\nstaticClass :: WriterT (Seq Dec) Q StaticContext\nstaticClass = do\n  let n x = Name (OccName x) NameS\n      className = n \"StaticFile\"\n      methodName = n \"hashedPath\"\n      cls = ClassD [] className [KindedTV (n \"s\") (ConT ''Symbol)] [] [SigD methodName (ConT ''Text)]\n  tell $ Seq.singleton cls\n  return $ StaticContext\n    { _staticContext_className = className\n    , _staticContext_methodName = methodName\n    }\n\nstaticInstance :: StaticContext -> FilePath -> FilePath -> WriterT (Seq Dec) Q ()\nstaticInstance ctx relativePath hashedPath = do\n  let headType = ConT (_staticContext_className ctx) `AppT` LitT (StrTyLit relativePath)\n      methodDec = ValD (VarP $ _staticContext_methodName ctx) (NormalB (LitE (StringL hashedPath))) []\n  tell $ Seq.singleton $ InstanceD Nothing [] headType [methodDec]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 30,
          "homplexity_lines_of_code": 21,
          "code_quality_score": 93.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 21,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 1 1: module Obelisk.ExecutableConfig.Inject has 17 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Inject where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad (mapM_)\nimport Data.Semigroup ((<>))\n#endif\n#endif\nimport Control.Monad.IO.Class (MonadIO)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex.Dom.Core hiding (value)\n\n-- | Produces a @<script>@ tag with an @id@ attribute containing the key and\n-- whose value is the provided configuration, encoded in base64.\ninjectPure :: DomBuilder t m => Text -> ByteString -> m ()\ninjectPure key value =\n  let attrs = (\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key <> \"data-hydration-skip\" =: \"\")\n  in elAttr \"script\" attrs $ text (T.decodeUtf8 (B64.encode value))\n\n-- | Produces injectable @<script>@ tags containing the configuration keys\n-- (filepaths) and values.\ninjectExecutableConfigs :: (MonadIO m, DomBuilder t m) => Map Text ByteString -> m ()\ninjectExecutableConfigs = mapM_ (uncurry injectPure) . Map.toList\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
          "cyclomatic_complexity": {
            "min": 2,
            "max": 3,
            "average": 2.5,
            "sum": 5
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 14,
          "lines_of_code": 51,
          "homplexity_lines_of_code": 59,
          "code_quality_score": 84.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 3,
              "average": 2.5,
              "sum": 5
            },
            "homplexity_loc": 59,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 40 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 22 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 22 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has 15 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 45 1: type signature for nodeListNodes has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 45 1: type signature for nodeListNodes has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Data.Traversable (for)\nimport GHCJS.DOM\nimport GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.DOMStringMap (get)\nimport GHCJS.DOM.Element (getInnerHTML)\nimport GHCJS.DOM.HTMLElement (HTMLElement(HTMLElement), getDataset)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport GHCJS.DOM.Types (MonadJSM, Node(Node), castTo)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = do\n  Just doc <- currentDocument\n  Just hd <- getHead doc\n  nodes <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  fmap Map.fromList $ for nodes $ \\node -> do\n    e <- castTo HTMLElement node >>= \\case\n      Nothing -> error \"Found node with data attribute obelisk-executable-config-inject-key that is not an HTMLElement.\"\n      Just htmlE -> return htmlE\n    dataset <- getDataset e\n    (,)\n      -- the key is camelCased: https://html.spec.whatwg.org/multipage/dom.html#dom-dataset\n      <$> get dataset (\"obeliskExecutableConfigInjectKey\" :: Text)\n      <*> (fmap decodeOrFail (getInnerHTML e))\n  where\n    decodeOrFail x = case B64.decode (T.encodeUtf8 x) of\n      Left e -> error (\"Obelisk.ExecutableConfig.Lookup.getConfigs: error when decoding base64: \" ++ e)\n      Right x' -> x'\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in obelisk-frontend should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.ExecutableConfig.Lookup"
              ],
              "decl": [
                "getConfigs"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
              "startLine": 35,
              "startColumn": 11,
              "endLine": 35,
              "endColumn": 47,
              "from": "(,) <$> get dataset (\"obeliskExecutableConfigInjectKey\" :: Text)\n  <*> (fmap decodeOrFail (getInnerHTML e))",
              "to": "(,) <$> get dataset (\"obeliskExecutableConfigInjectKey\" :: Text)\n  <*> fmap decodeOrFail (getInnerHTML e)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 35, startCol = 11, endLine = 35, endCol = 47}, subts = [(\"x\",SrcSpan {startLine = 35, startCol = 12, endLine = 35, endCol = 46})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
          "cyclomatic_complexity": {
            "min": 2,
            "max": 2,
            "average": 2.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 17,
          "homplexity_lines_of_code": 17,
          "code_quality_score": 94.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 2,
              "average": 2.0,
              "sum": 2
            },
            "homplexity_loc": 17,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 14 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE LambdaCase #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle.WKWebView\nimport System.FilePath.Posix\n\nimport Obelisk.Configs.Internal.Directory\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> error \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 11,
          "homplexity_lines_of_code": 9,
          "code_quality_score": 97.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 9,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 8 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 10 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 10 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\n\nimport Obelisk.Configs.Internal.Directory (getConfigsFromDirectory)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = getConfigsFromDirectory \"config\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
          "cyclomatic_complexity": {
            "min": 2,
            "max": 4,
            "average": 2.6666666666666665,
            "sum": 8
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 7,
          "lines_of_code": 60,
          "homplexity_lines_of_code": 93,
          "code_quality_score": 74.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 2,
              "max": 4,
              "average": 2.6666666666666665,
              "sum": 8
            },
            "homplexity_loc": 93,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 55 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 18 1: type signature for getFromMgr has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 18 1: type signature for getFromMgr has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has 12 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 32 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 32 1: type signature for getConfigs has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 55 1: type signature for lines0 has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 55 1: type signature for lines0 has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has cyclomatic complexity of 2 \n"
          },
          "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Control.Exception (bracket)\nimport Control.Monad (forM)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Foreign.C.String (withCString)\nimport Foreign.Ptr (nullPtr)\n\nimport Obelisk.ExecutableConfig.Internal.AssetManager\n\ngetFromMgr :: AAssetManager -> BS.ByteString -> IO (Maybe ByteString)\ngetFromMgr mgr name = do\n  let open = do\n        a <- BS.useAsCString name $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset a == nullPtr\n          then Nothing\n          else Just a\n      close = mapM_ asset_close\n  bracket open close $ mapM $ \\asset -> do\n    b <- asset_getBuffer asset\n    l <- asset_getLength asset\n    BS.packCStringLen (b, fromIntegral l)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = fmap (Map.mapKeys T.decodeUtf8) $ bracket getAssets freeAssetManager $ \\mgrObj -> do\n  mgr <- assetManagerFromJava mgrObj\n  let openDir = do\n        d <- withCString \"config.files\" $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset d == nullPtr\n          then Nothing\n          else Just d\n      closeDir = mapM_ asset_close\n  configPaths <- bracket openDir closeDir $ \\case\n    Just asset -> do\n      b <- asset_getBuffer asset\n      l <- asset_getLength asset\n      lines0 <$> BS.packCStringLen (b, fromIntegral l)\n    Nothing -> error \"could not open configuration manifest 'config.files'\"\n  result <- fmap Map.fromList $ forM configPaths $ \\fp ->\n    getFromMgr mgr (\"config/\" <> fp) >>= \\case\n      Just v -> return (fp, v)\n      Nothing -> error $ \"Config present in config.files but not in assets: \" <> show fp\n  putStrLn $ \"getConfigs: found \" <> show result\n  pure result\n\nlines0 :: BS.ByteString -> [BS.ByteString]\nlines0 ps\n  | BS.null ps = []\n  | otherwise = case BS.elemIndex 0 ps of\n      Nothing -> [ps]\n      Just n  -> BS.take n ps : lines0 (BS.drop (n+1) ps)\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 0,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 19,
          "lines_of_code": 146,
          "homplexity_lines_of_code": 128,
          "code_quality_score": 81.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 128,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 1 1: module Obelisk.Configs has 125 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 58 3: type class HasConfigs has method + value count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 58 3: type class HasConfigs has associated type count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 69 1: type signature for getTextConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 69 1: type signature for getTextConfig has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 70 1: function getTextConfig has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 70 1: function getTextConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 70 1: function getTextConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 84 24: data ConfigsT has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 136 1: type signature for runConfigsT has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 136 1: type signature for runConfigsT has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 140 1: function runConfigsT has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 140 1: function runConfigsT has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 140 1: function runConfigsT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 142 1: type signature for mapConfigsT has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 142 1: type signature for mapConfigsT has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 146 1: function mapConfigsT has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 146 1: function mapConfigsT has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 146 1: function mapConfigsT has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Configs\n  ( HasConfigs(..)\n  , ConfigsT\n  , runConfigsT\n  , mapConfigsT\n  , getTextConfig\n  ) where\n\nimport Control.Applicative (Alternative)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Base (MonadBase)\nimport Control.Monad.Catch (MonadThrow)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail (MonadFail)\n#endif\nimport Control.Monad.Fix (MonadFix)\nimport Control.Monad.IO.Class (MonadIO)\nimport Control.Monad.Morph (MFunctor)\nimport Control.Monad.Primitive (PrimMonad, PrimState, primitive)\nimport Control.Monad.Ref (MonadRef)\nimport Control.Monad.Trans (MonadTrans, lift)\nimport Control.Monad.Trans.Control (MonadBaseControl)\nimport Control.Monad.Trans.Reader (ReaderT (..), ask, mapReaderT)\nimport Control.Monad.Trans.State (StateT)\nimport qualified Control.Monad.Trans.State.Strict as Strict\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex\nimport Reflex.Host.Class (MonadReflexCreateTrigger)\nimport Reflex.Dom.Core\n  ( DomBuilder\n  , DomRenderHook\n  , HasDocument\n  , Prerender (Client)\n  , StaticDomBuilderT\n  , prerender\n  )\n#ifndef ghcjs_HOST_OS\nimport Language.Javascript.JSaddle (MonadJSM)\n#endif\n\nclass Monad m => HasConfigs m where\n  getConfigs :: m (Map Text ByteString)\n  default getConfigs :: (HasConfigs m', m ~ t m', MonadTrans t) => m (Map Text ByteString)\n  getConfigs = lift getConfigs\n  getConfig :: Text -> m (Maybe ByteString)\n  getConfig k = do\n    configs <- getConfigs\n    return $ Map.lookup k configs\n\ninstance Monad m => HasConfigs (ConfigsT m) where\n  getConfigs = ConfigsT ask\n\ngetTextConfig :: HasConfigs m => Text -> m (Maybe Text)\ngetTextConfig k = fmap T.decodeUtf8 <$> getConfig k\n\ninstance HasConfigs m => HasConfigs (BehaviorWriterT t w m)\ninstance HasConfigs m => HasConfigs (DynamicWriterT t w m)\ninstance HasConfigs m => HasConfigs (EventWriterT t w m)\ninstance HasConfigs m => HasConfigs (PostBuildT t m)\ninstance HasConfigs m => HasConfigs (QueryT t q m)\ninstance HasConfigs m => HasConfigs (ReaderT r m)\ninstance HasConfigs m => HasConfigs (RequesterT t request response m)\ninstance HasConfigs m => HasConfigs (StateT w m)\ninstance HasConfigs m => HasConfigs (Strict.StateT w m)\ninstance HasConfigs m => HasConfigs (StaticDomBuilderT t m)\ninstance HasConfigs m => HasConfigs (TriggerEventT t m)\n\nnewtype ConfigsT m a = ConfigsT { unConfigsT :: ReaderT (Map Text ByteString) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadPlus\n    , Alternative\n    , MonadFail\n    , MonadFix\n    , MonadThrow\n    , MonadIO\n    , MonadBase m'\n    , MonadBaseControl m'\n    , MonadRef\n    , MonadTrans\n    , MFunctor\n    , DomBuilder t\n    , MonadHold t\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , NotReady t\n    , PostBuild t\n    , TriggerEvent t\n    , HasDocument\n    , DomRenderHook t\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    )\n\ninstance PerformEvent t m => PerformEvent t (ConfigsT m) where\n  type Performable (ConfigsT m) = ConfigsT (Performable m)\n  performEvent e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent $ runConfigsT configs <$> e\n  performEvent_ e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent_ $ runConfigsT configs <$> e\n\ninstance Adjustable t m => Adjustable t (ConfigsT m) where\n  runWithReplace a e = ConfigsT $ runWithReplace (unConfigsT a) (unConfigsT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = ConfigsT $ traverseDMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = ConfigsT $ traverseIntMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = ConfigsT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unConfigsT $ f k v) m e\n\ninstance Prerender t m => Prerender t (ConfigsT m) where\n  type Client (ConfigsT m) = ConfigsT (Client m)\n  prerender server client = ConfigsT $ ReaderT $ \\configs ->\n    prerender (runConfigsT configs server) (runConfigsT configs client)\n\ninstance PrimMonad m => PrimMonad (ConfigsT m) where\n  type PrimState (ConfigsT m) = PrimState m\n  primitive = lift . primitive\n\nrunConfigsT\n  :: Map Text ByteString\n  -> ConfigsT m a\n  -> m a\nrunConfigsT cs child = runReaderT (unConfigsT child) cs\n\nmapConfigsT\n  :: (forall x. m x -> n x)\n  -> ConfigsT m a\n  -> ConfigsT n a\nmapConfigsT f (ConfigsT x) = ConfigsT $ mapReaderT f x\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Configs"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "startLine": 9,
              "startColumn": 1,
              "endLine": 9,
              "endColumn": 35,
              "from": "{-# LANGUAGE OverloadedStrings #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 9, startCol = 1, endLine = 9, endCol = 35}, newComment = \"\"}]"
            },
            {
              "module": [
                "Obelisk.Configs"
              ],
              "decl": [
                "HasConfigs"
              ],
              "severity": "Warning",
              "hint": "Use <$>",
              "file": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "startLine": 62,
              "startColumn": 17,
              "endLine": 64,
              "endColumn": 34,
              "from": "do configs <- getConfigs\n   return $ Map.lookup k configs",
              "to": "do Map.lookup k <$> getConfigs",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 63, startCol = 5, endLine = 63, endCol = 26}, subts = [(\"x\",SrcSpan {startLine = 63, startCol = 16, endLine = 63, endCol = 26}),(\"f0\",SrcSpan {startLine = 64, startCol = 14, endLine = 64, endCol = 26})], orig = \"f0 <$> x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 64, startCol = 5, endLine = 64, endCol = 34}}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
          "cyclomatic_complexity": {
            "min": 3,
            "max": 3,
            "average": 3.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 24,
          "homplexity_lines_of_code": 31,
          "code_quality_score": 90.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 3,
              "max": 3,
              "average": 3.0,
              "sum": 3
            },
            "homplexity_loc": 31,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 1 1: module Obelisk.Configs.Internal.Directory has 22 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 15 1: type signature for getConfigsFromDirectory has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 15 1: type signature for getConfigsFromDirectory has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has branching depth of 2 \n"
          },
          "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Configs.Internal.Directory where\n\nimport Control.Monad\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport System.Directory\nimport System.FilePath.Posix\n\ngetConfigsFromDirectory :: FilePath -> IO (Map Text ByteString)\ngetConfigsFromDirectory base = doesDirectoryExist base >>= \\case\n  True -> do\n    ps <- listDirectory base\n    fmap mconcat $ forM ps $ \\p -> do\n      subdirConfigs <- getConfigsFromDirectory $ base </> p\n      pure $ Map.mapKeys (T.pack . (p </>) . T.unpack) subdirConfigs\n  False -> doesFileExist base >>= \\case\n    True -> Map.singleton \"\" <$> BS.readFile base\n    False -> pure mempty\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 4,
          "homplexity_lines_of_code": 4,
          "code_quality_score": 97.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 4,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 1 1: <unnamed module> has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 3 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 3 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has branching depth of 0 \n"
          },
          "original_code": "import qualified Obelisk.SelfTest\n\nmain :: IO ()\nmain = Obelisk.SelfTest.main\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/selftest/src-bin/obelisk-selftest.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/selftest/src-bin/obelisk-selftest.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 19,
            "average": 8,
            "sum": 76
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 2,
            "ignore": 0,
            "total": 4
          },
          "syntax_errors": 22,
          "lines_of_code": 841,
          "homplexity_lines_of_code": 1190,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 19,
              "average": 8,
              "sum": 76
            },
            "homplexity_loc": 1190,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 19,\n        \"average\": 8.444,\n        \"sum\": 76\n    },\n    \"homplexity_loc\": 1190,\n    \"homplexity_output\": \"\"\n}\n"
          },
          "original_code": "{-# LANGUAGE DoAndIfThenElse #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.SelfTest where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Exception (bracket, throw, try)\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Aeson.Types as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as LBS\nimport Data.Foldable (for_)\nimport Data.Function (fix)\nimport Data.List (isInfixOf)\nimport qualified Data.Map as Map\nimport Data.Semigroup ((<>))\nimport qualified Data.Set as Set\nimport Data.String\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.IO as T\nimport qualified Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Socket as Socket\nimport Shelly\nimport System.Directory (getCurrentDirectory, withCurrentDirectory, getDirectoryContents)\nimport System.Environment\nimport System.Exit (ExitCode (..))\nimport System.FilePath (addTrailingPathSeparator)\nimport qualified System.Info\nimport System.IO (Handle, hClose, hIsEOF, hGetContents)\nimport System.IO.Temp\nimport System.Process (readProcessWithExitCode)\nimport System.Which (staticWhich)\nimport Test.Hspec\nimport Test.HUnit.Base\n\nimport Obelisk.ExecutableConfig.Lookup (getConfigs)\nimport Obelisk.Run (getConfigRoute)\n\ndata ObRunState\n  = ObRunState_Init\n  | ObRunState_Startup\n  | ObRunState_BackendStarted\n  deriving (Eq, Show)\n\ncpPath :: FilePath\ncpPath = $(staticWhich \"cp\")\n\ncabalPath :: FilePath\ncabalPath = $(staticWhich \"cabal\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nchownPath :: FilePath\nchownPath = $(staticWhich \"chown\")\n\nchmodPath :: FilePath\nchmodPath = $(staticWhich \"chmod\")\n\nwhoamiPath :: FilePath\nwhoamiPath = $(staticWhich \"whoami\")\n\nnixInstantiatePath :: FilePath\nnixInstantiatePath = $(staticWhich \"nix-instantiate\")\n\nnixBuildPath :: FilePath\nnixBuildPath = $(staticWhich \"nix-build\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nsedPath :: FilePath\nsedPath = $(staticWhich \"sed\")\n\ngitUserConfig :: [Text]\ngitUserConfig = [\"-c\", \"user.name=Obelisk Selftest\", \"-c\", \"user.email=noreply@example.com\"]\n\ncommit :: Text -> Sh ()\ncommit msg = void $ run gitPath $ gitUserConfig <> [ \"commit\"\n  , \"--no-gpg-sign\"\n  , \"--allow-empty\"\n  , \"-m\"\n  , msg\n  ]\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\n-- | Like `shelly` but used when running `ob` commands\nshellyOb :: MonadIO m => (Sh a -> Sh a) -> Sh a -> m a\nshellyOb f obTest = shelly $ f obTest\n\n-- Set \"ob\" in a single place so it can be replaced with a\n-- link to obelisk in the nix store in the future,\n-- and avoid PATH hacking before calling this script.\nob :: FilePath\nob = \"ob\"\n\naugmentWithVerbosity :: (String -> [Text] -> a) -> String -> Bool -> [Text] -> a\naugmentWithVerbosity runner executable isVerbose args = runner executable $ (if isVerbose then (\"-v\" :) else id) args\n\nisolatedGitShell :: Bool -> FilePath -> (([Text] -> Sh Text) -> Sh a) -> IO a\nisolatedGitShell isVerbose dir f = shelly $ bool silently verbosely isVerbose $ do\n  setenv \"HOME\" \"/dev/null\"\n  setenv \"GIT_CONFIG_NOSYSTEM\" \"1\"\n  _ <- git [\"init\"]\n  _ <- git [\"config\", \"user.name\", \"SelfTest\"]\n  _ <- git [\"config\", \"user.email\", \"self@test\"]\n  f git\n  where\n    git args = run gitPath $ [\"-C\", toTextIgnore dir] <> args\n\n-- | Copies a git repo to a new location and \"resets\" the git history to include\n-- exactly one commit with all files added. It then restricts writing and reading\n-- for group and user to make the repo ideal for being a valid git remote for thunks.\n--\n-- Using this allows dirty repos to be used as git remotes during the test since 'git clone'ing\n-- a dirty repo will not include the uncommitted changes.\ncopyForGitRemote :: Bool -> FilePath -> FilePath -> IO ()\ncopyForGitRemote isVerbose origDir copyDir = isolatedGitShell isVerbose copyDir $ \\git -> do\n  run_ rsyncPath\n    [ \"-r\", \"--no-perms\", \"--no-owner\", \"--no-group\", \"--exclude\", \".git\"\n    , toTextIgnore (addTrailingPathSeparator origDir), toTextIgnore copyDir\n    ]\n  _ <- git [\"add\", \"--all\"]\n  _ <- git [\"commit\", \"-m\", \"Copy repo\"]\n  run_ chmodPath [\"-R\", \"u-w,g-rw,o-rw\", toTextIgnore copyDir] -- Freeze this state\n\nmain :: IO ()\nmain = do\n  -- Note: you can pass hspec arguments as well, eg: `-m <pattern>`\n  isVerbose <- elem \"-v\" <$> getArgs\n  unless isVerbose $\n    putStrLn \"Tests may take longer to run if there are unbuilt derivations: use -v for verbose output\"\n\n  obeliskImplDirtyReadOnly <- getCurrentDirectory\n  httpManager <- HTTP.newManager HTTP.defaultManagerSettings\n\n  withSystemTempDirectory \"obelisk-repo-git-remote\" $ \\copyDir -> do\n    copyForGitRemote isVerbose obeliskImplDirtyReadOnly copyDir\n    main' isVerbose httpManager copyDir\n\nmain' :: Bool -> HTTP.Manager -> FilePath -> IO ()\nmain' isVerbose httpManager obeliskRepoReadOnly = withInitCache $ \\initCache -> hspec $ parallel $ do\n  let\n    inTmpObInit' dirname f = inTmp' dirname $ \\dir -> do\n      run_ cpPath [\"-rT\", fromString initCache, toTextIgnore dir]\n      f dir\n    inTmpObInit = inTmpObInit' defaultTmpDirName\n\n    -- To be used in tests that change the obelisk impl directory\n    inTmpObInitWithImplCopy f = inTmpObInit $ \\dir ->\n      withObeliskImplClean $ \\(fromString -> implClean) -> do\n        run_ rmPath [thunk]\n        run_ lnPath [\"-s\", implClean, thunk]\n        f dir\n\n  describe \"ob init\" $ parallel $ do\n    it \"works with default impl\"       $ inTmp $ \\_ -> runOb [\"init\"]\n    it \"works with master branch impl\" $ inTmp $ \\_ -> runOb [\"init\", \"--branch\", \"master\"]\n    it \"works with symlink\"            $ inTmp $ \\_ -> runOb [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n    it \"doesn't silently overwrite existing files\" $ inTmp $ \\_ -> do\n      let p force = errExit False $ do\n            run_ ob $ \"--no-handoff\" : \"-v\" : \"init\" : [\"--force\"|force]\n            (== 0) <$> lastExitCode\n\n      True <- p False\n      False <- p False\n      True <- p True\n      pure ()\n\n    it \"doesn't create anything when given an invalid impl\" $ inTmp $ \\tmp -> do\n      void $ errExit False $ runOb [\"init\", \"--symlink\", \"/dev/null\"]\n      ls tmp >>= liftIO . assertEqual \"\" []\n\n    it \"produces a valid route config\" $ inTmpObInit $ \\tmp -> liftIO $\n      withCurrentDirectory (T.unpack $ toTextIgnore tmp) $ do\n        configs <- getConfigs\n        return (either (const Nothing) Just $ getConfigRoute configs) `shouldNotReturn` Nothing\n\n    it \"can unpack and repack .obelisk/impl after init with master branch impl\" $ inTmp $ \\_ -> do\n      runOb_ [\"init\", \"--branch\", \"master\"]\n      runOb_ [\"thunk\", \"unpack\", \".obelisk/impl\"]\n      runOb_ [\"thunk\", \"pack\", \".obelisk/impl\"]\n\n  -- These tests fail with \"Could not find module 'Obelisk.Generated.Static'\"\n  -- when not run by 'nix-build --attr selftest'\n  describe \"ob run\" $ {- NOT parallel $ -} do\n    it \"works in root directory\" $ inTmpObInit $ \\_ -> testObRunInDir' Nothing httpManager\n    it \"works in sub directory\" $ inTmpObInit $ \\_ -> testObRunInDir' (Just \"frontend\") httpManager\n    it \"can read external TLS certificates in root directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir Nothing\n    it \"can read external TLS certificates in sub directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir (Just \"frontend\")\n    it \"complains when static files are missing in root directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' Nothing\n    it \"complains when static files are missing in sub directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' (Just \"frontend\")\n    it \"complains when static filepaths are missing in root directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' Nothing\n    it \"complains when static filepaths are missing in sub directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' (Just \"frontend\")\n    it \"fails when given an invalid Cabal file\" $ inTmpObInit $ testObRunWithInvalidCabalFile ob\n\n    it \"respects the port given on the command line\" $ inTmpObInit $ \\testDir -> do\n      [port] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandles ob [\"run\", \"-p\", T.pack (show port)] [] $ \\_stdin stdout stderr -> do\n        uri <- handleObRunStdout httpManager stdout stderr\n        -- Make sure obelisk logs the right thing\n        unless (T.pack (show port ++ \"/\") `T.isSuffixOf` T.strip uri) $\n          error $ \"Expected the URI to end in \" ++ show port ++ \" but it ended in \" ++ T.unpack uri\n        -- But also verify that we can actually reach the server in the\n        -- given path, rather than just listening for the log URL\n        let req = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n        req >>= \\case\n          Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n          e -> errorExit $ \"Request to ob run failed: \" <> T.pack (show e)\n        exit 0\n\n  describe \"ob repl\" $ do\n    it \"accepts stdin commands\" $ inTmpObInit $ \\_ -> do\n      setStdin \"print 3\\n:q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        [ \"*Obelisk.Run Obelisk.Run Frontend Backend> 3\"\n        , \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\"\n        ] `isInfixOf` T.lines (T.strip output)\n    it \"works with custom Prelude\" $ inTmpObInit $ \\_ -> do\n      writefile \"common/src/Prelude.hs\"\n        \"{-# LANGUAGE PackageImports #-} module Prelude (module X) where import \\\"base\\\" Prelude as X\"\n      setStdin \":q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\" `T.isInfixOf` output\n\n  describe \"obelisk project\" $ parallel $ do\n    it \"can build obelisk command\"  $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"command\" , toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk skeleton\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"skeleton\", toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk shell\"    $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"shell\",    toTextIgnore obeliskRepoReadOnly]\n    it \"can build everything\"       $ inTmpObInit $ \\_ -> nixBuild [toTextIgnore obeliskRepoReadOnly]\n\n  describe \"blank initialized project\" $ parallel $ do\n\n    it \"can build ghc.backend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghc.backend\"]\n    it \"can build ghcjs.frontend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghcjs.frontend\"]\n\n    if System.Info.os == \"darwin\"\n      then it \"can build ios\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ios.frontend\"]\n      else it \"can build android after accepting license\" $ inTmpObInit $ \\dir -> do\n        let defaultNixPath = dir </> (\"default.nix\" :: FilePath)\n        writefile defaultNixPath\n          =<< T.replace\n            \"# config.android_sdk.accept_license = false;\"\n            \"config.android_sdk.accept_license = true;\"\n          <$> readfile defaultNixPath\n        nixBuild [\"-A\", \"android.frontend\"]\n\n    forM_ [\"ghc\", \"ghcjs\"] $ \\compiler -> do\n      let\n        shellName = \"shells.\" <> compiler\n        inShell cmd' = run_ \"nix-shell\" [\"default.nix\", \"-A\", fromString shellName, \"--run\", cmd']\n      it (\"can enter \"    <> shellName) $ inTmpObInit $ \\_ -> inShell \"exit\"\n      -- NOTE: We override the temporary directory name because cabal has a bug preventing new-build from working\n      -- in a path that has unicode characters.\n      it (\"can build in \" <> shellName) $ inTmpObInit' \"test\" $ \\_ -> inShell $\n          T.pack cabalPath <> \" --version; \" <> T.pack cabalPath <> \" new-build --\" <> T.pack compiler <> \" all\"\n\n    it \"has idempotent thunk update\" $ inTmpObInitWithImplCopy $ \\_ -> do\n      _  <- pack\n      u  <- update\n      uu <- update\n      assertRevEQ u uu\n\n    it \"can run 'ob doc'\" $ inTmpObInit $ \\_ -> runOb_ [\"doc\", \"reflex\"]\n\n  describe \"ob thunk pack/unpack\" $ parallel $ do\n    it \"has thunk pack and unpack inverses\" $ inTmpObInitWithImplCopy $ \\_ -> do\n\n      _    <- pack\n      e    <- commitAll\n      eu   <- unpack\n      eup  <- pack\n      eupu <- unpack\n      _    <- pack\n\n      assertRevEQ e  eup\n      assertRevEQ eu eupu\n      assertRevNE e  eu\n\n    it \"unpacks the correct branch\" $ withTmp $ \\dir -> do\n      let branch = \"master\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch]\n      runOb_ [\"thunk\", \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"unpack\", toTextIgnore dir]\n      branch' <- run gitPath [\"-C\", toTextIgnore $ dir </> unpackedDirName, \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n      liftIO $ assertEqual \"\" branch (T.strip branch')\n\n    it \"can pack and unpack plain git repos\" $\n      shelly_ $ withSystemTempDirectory \"git-repo\" $ \\dir -> do\n        let repo = toTextIgnore $ dir </> (\"repo\" :: FilePath)\n        run_ gitPath [\"clone\", \"https://github.com/haskell/process.git\", repo]\n        origHash <- chdir (fromText repo) revParseHead\n\n        runOb_ [\"thunk\", \"pack\", repo]\n        packedFiles <- Set.fromList <$> ls (fromText repo)\n        liftIO $ assertEqual \"\" packedFiles $ Set.fromList $ (repo </>) <$>\n          [\"default.nix\", \"thunk.nix\", \"github.json\" :: FilePath]\n\n        runOb_ [\"thunk\", \"unpack\", repo]\n        chdir (fromText repo </> unpackedDirName) $ do\n          unpackHash <- revParseHead\n          assertRevEQ origHash unpackHash\n\n        testThunkPack' $ fromText repo\n\n    it \"aborts thunk pack when there are uncommitted files\" $ inTmpObInitWithImplCopy $ \\dir -> do\n      testThunkPack' (dir </> thunk)\n\n    it \"works on legacy git thunks\" $ testLegacyGitThunks isVerbose\n\n  describe \"ob thunk update --branch\" $ parallel $ do\n    it \"can change a thunk to the latest version of a desired branch\" $ withTmp $ \\dir -> do\n      let branch1 = \"master\"\n          branch2 = \"develop\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch1]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", branch2]\n\n    it \"doesn't create anything when given an invalid branch\" $ withTmp $ \\dir -> do\n      let checkDir dir' = liftIO $ getDirectoryContents $ T.unpack $ toTextIgnore dir'\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", \"master\"]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      startingContents <- checkDir dir\n      void $ errExit False $ runOb [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", \"dumble-palooza\"]\n      checkDir dir >>= liftIO . assertEqual \"\" startingContents\n\n  describe \"ob shell\" $ parallel $ do\n    it \"works with --\" $ inTmpObInit $ \\_ -> do\n      output <- runOb [\"shell\", \"--\", \"ghc-pkg\", \"list\"]\n      liftIO $ assertBool \"Unexpected output from ob shell\" $ (\"Cabal-\" `T.isInfixOf` output) && (\"ghc-\" `T.isInfixOf` output)\n\n  describe \"ob hoogle\" $ {- NOT parallel -} do\n    it \"starts a hoogle server on the given port\" $ inTmpObInit $ \\_ -> do\n      [p0] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandle \"ob\" [\"hoogle\", \"--port\", T.pack (show p0)] $ \\stdout -> flip fix Nothing $ \\loop -> \\case\n        Nothing -> do -- Still waiting for initial signal that the server has started\n          ln <- liftIO $ T.hGetLine stdout\n          let search = \"Server starting on port \" <> T.pack (show p0)\n          case search `T.isInfixOf` ln of\n            False -> loop Nothing -- keep waiting\n            True -> loop $ Just 10\n        Just (n :: Int) -> do -- Server has started and we have n attempts left\n          let req uri = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest uri >>= flip HTTP.httpLbs httpManager\n          req (\"http://127.0.0.1:\" <> show p0) >>= \\case\n            Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n            e -> if n <= 0\n              then errorExit $ \"Request to hoogle server failed: \" <> T.pack (show e)\n              else liftIO (threadDelay (1*10^(6 :: Int))) *> loop (Just $ n - 1)\n  where\n    verbosity = bool silently verbosely isVerbose\n    nixBuild args = run nixBuildPath (\"--no-out-link\" : args)\n\n    runOb_ = augmentWithVerbosity run_ ob isVerbose\n    runOb = augmentWithVerbosity run ob isVerbose\n    testObRunInDir' = augmentWithVerbosity testObRunInDir ob isVerbose [\"run\"]\n    testObRunCert' = augmentWithVerbosity testObRunCert ob isVerbose [\"run\", \"-c\", \".\"]\n    testObRunInDirWithMissingStaticFile' = augmentWithVerbosity testObRunInDirWithMissingStaticFile ob isVerbose [\"run\"]\n    testObRunInDirWithMissingStaticFilePath' = augmentWithVerbosity testObRunInDirWithMissingStaticFilePath ob isVerbose [\"run\"]\n    testThunkPack' = augmentWithVerbosity testThunkPack ob isVerbose []\n\n    withObeliskImplClean f =\n      withSystemTempDirectory \"obelisk-impl-clean\" $ \\obeliskImpl -> do\n        void . shellyOb verbosity $ do\n          dirtyFiles <- T.strip <$> run gitPath [\"-C\", toTextIgnore obeliskRepoReadOnly, \"diff\", \"--stat\"]\n          () <- when (dirtyFiles /= \"\") $ error \"SelfTest does not work correctly with dirty obelisk repos as remote\"\n          run_ gitPath [\"clone\", \"file://\" <> toTextIgnore obeliskRepoReadOnly, toTextIgnore obeliskImpl]\n        f obeliskImpl\n\n    withInitCache f =\n      withSystemTempDirectory \"init Cache \u03bb\" $ \\initCache -> do\n        -- Setup the ob init cache\n        void . shellyOb verbosity $ chdir initCache $ do\n          runOb_ [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n          run_ gitPath [\"init\"]\n\n        f initCache\n\n    shelly_ = void . shellyOb verbosity\n\n    defaultTmpDirName = \"test \u03bb\"\n\n    inTmp' :: FilePath -> (FilePath -> Sh a) -> IO ()\n    inTmp' dirname f = withTmp' dirname (chdir <*> f)\n    inTmp = inTmp' defaultTmpDirName\n\n    withTmp' dirname f = shelly_ . withSystemTempDirectory dirname $ f . fromString\n    withTmp = withTmp' defaultTmpDirName\n\n    assertRevEQ a b = liftIO . assertEqual \"\" \"\"        =<< diff a b\n    assertRevNE a b = liftIO . assertBool  \"\" . (/= \"\") =<< diff a b\n\n    revParseHead = T.strip <$> run gitPath [\"rev-parse\", \"HEAD\"]\n\n    commitAll = do\n      run_ gitPath [\"add\", \".\"]\n      commit \"checkpoint\"\n      revParseHead\n\n    thunk  = \".obelisk/impl\"\n    update = runOb [\"thunk\", \"update\", thunk] *> commitAll\n    pack   = runOb [\"thunk\", \"pack\",   thunk] *> commitAll\n    unpack = runOb [\"thunk\", \"unpack\", thunk] *> commitAll\n\n    diff a b = run gitPath [\"diff\", a, b]\n\n\nmaskExitSuccess :: Sh () -> Sh ()\nmaskExitSuccess = handle_sh (\\case ExitSuccess -> pure (); e -> throw e)\n\n-- | Run `ob run` in the given directory (maximum of one level deep)\ntestObRunInDir :: String -> [Text] -> Maybe FilePath -> HTTP.Manager -> Sh ()\ntestObRunInDir executable extraArgs mdir httpManager = maskExitSuccess $ do\n  [p0, p1] <- liftIO $ getFreePorts 2\n  let uri p = \"http://localhost:\" <> T.pack (show p) <> \"/\" -- trailing slash required for comparison\n  writefile \"config/common/route\" $ uri p0\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    firstUri <- handleObRunStdout httpManager stdout stderr\n    let newUri = uri p1\n    when (firstUri == newUri) $ errorExit $\n      \"Startup URI (\" <> firstUri <> \") is the same as test URI (\" <> newUri <> \")\"\n    maybe id (\\_ -> chdir \"..\") mdir $ alterRouteTo newUri stdout\n    runningUri <- handleObRunStdout httpManager stdout stderr\n    if runningUri /= newUri\n      then errorExit $ \"Reloading failed: expected \" <> newUri <> \" but got \" <> runningUri\n      else exit 0\n\ntestObRunCert :: String -> [Text] -> FilePath -> Maybe FilePath -> Sh ()\ntestObRunCert executable extraArgs testDir mdir = maskExitSuccess $ do\n  -- Generate a TLS key, and then a self-signed certificate using that key\n  mapM_ (\\cmd -> run_ \"nix-shell\" [\"-p\", \"openssl\", \"--command\", cmd])\n    [ \"openssl genrsa -out key.pem 2048\"\n    , \"openssl req -new -key key.pem -out certificate.csr -subj \\\"/C=US/ST=New York/L=New York/O=Development/OU=IT Department/CN=obsidian.com\\\"\"\n    , \"openssl x509 -req -in certificate.csr -signkey key.pem -out cert.pem\"\n    ]\n\n  -- One more command is required, for generating the chain.pem file.\n  -- For testing purposes, we'll keep it the same as the cert.pem file.\n  run_ \"cp\" [\"cert.pem\", \"chain.pem\"]\n\n  -- Also need to change the route inside config/common/route to https\n  -- in order to trigger the certificates option (the -c option is not honored for http)\n  writefile \"config/common/route\" \"https://localhost:8000\"\n\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_ stdout _ -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      isEOF <- liftIO $ hIsEOF h\n      if isEOF\n        then errorExit \"Obelisk exited somehow\"\n        else do\n          line <- liftIO $ hGetLineSkipBlanks h\n          check line h\n\n    -- Here we check that the certificates are read properly by Obelisk\n    -- In case the server is started without reading the certificates, show an error.\n    check line h\n      | \"Using certificate information from:\" `T.isPrefixOf` line = do\n        -- Should be followed by a `Frontend running on <url>` line\n        next <- liftIO $ hGetLineSkipBlanks h\n        if \"Frontend running on\" `T.isPrefixOf` next\n          then exit 0\n          else errorExit $ \"Ran into error: \" <> next\n      | \"Frontend running on\" `T.isPrefixOf` line = errorExit \"Obelisk did not read the certificates provided via -c option\"\n      | otherwise = parseObOutput h\n\n-- | Mess up the Cabal file in the given directory, then make sure that\n-- @ob run@ fails.\ntestObRunWithInvalidCabalFile\n  :: FilePath  -- ^ Obelisk path\n  -> FilePath  -- ^ Directory path (will be made invalid)\n  -> Sh ()\ntestObRunWithInvalidCabalFile executable fp = do\n  let commonCabal :: String\n      commonCabal = \"common/common.cabal\"\n  liftIO $ writeFile (fp </> commonCabal) \"This is not a valid Cabal file.\"\n  errExit False $ do\n    runHandles executable [\"run\"] [] $ \\_ _ _ -> pure ()\n    lastExitCode >>= \\case\n      0 -> pure ()\n      _ -> errorExit \"ob run succeeded even with an invalid Cabal file\"\n\n-- | Check whether embedding a non-existent filepath into an obelisk\n-- project is detected correctly and generates a compile-time error.\n--\n-- @'testObRunInDirWithMissingStaticFileWorker' exe args mdir act checkErrorMessage@.\n--\n-- @checkErrorMessage line1 line2@ is invoked on a compile-time error message of the following form:\n--     frontend/src/Frontend.hs:40:32: error:\n--        \u2022 Static file obelisk.jpg was not found in static.out\n--        \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n--       |\n--    40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n--       |\n--\n-- the arguments to @line1@ and @line2@ contain:\n--\n-- @    \u2022 Static file obelisk.jpg was not found in static.out@\n--\n-- and\n--\n-- @    \u2022 In the untyped splice: $(static \"obelisk.jpg\")@\n--\n-- respectively.\ntestObRunInDirWithMissingStaticFileWorker\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\n  -- ^ Run this action before running @ob run@.\n  -- Gives you the opportunity to modify the project to trigger events.\n  -- In particular, make sure static files do not exist, s.t. a compilation\n  -- error is thrown.\n  -> (Text -> Text -> Sh ())\n  -- ^ Assertion function for error messages.\n  -- Since this function is used for asserting error message contents,\n  -- this function specifies what contents two consecutive non-empty lines\n  -- are supposed to have.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkErrorMessage = maskExitSuccess $ do\n  act\n  -- Now run `ob run` and read the error\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      line <- liftIO $ hGetLineSkipBlanks h\n      -- This means that everything was successful, this should not be the case\n      if line == \"Running test...\"\n        then errorExit \"Could not find any error related to static files\"\n        else checkForErrors line h\n\n    -- As can be seen in the example below, we can parse a lot of data.\n    -- For simplicity, we parse the two lines after the `error:` line.\n    -- We also ensure that the file name is same, as the file that we changed ie `obelisk.jpg`\n    checkForErrors line h\n      -- Found an error, check if it is due to static.out\n      | \"error:\" `T.isSuffixOf` line = do\n        line1 <- liftIO $ hGetLineSkipBlanks h\n        line2 <- liftIO $ hGetLineSkipBlanks h\n        checkErrorMessage line1 line2\n      | otherwise = parseObOutput h\n\n-- | Run an obelisk test-case, where @static@ is embedding an non-existent\n-- filepath.\ntestObRunInDirWithMissingStaticFile\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFile executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(static \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\n-- | Run an obelisk test-case, where @staticFilePath@ is embedding an\n-- non-existent filepath.\ntestObRunInDirWithMissingStaticFilePath\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFilePath executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = do\n      run_ sedPath [\"-e\", \"s/\\\\$(static /\\\\$(staticFilePath /\", \"-i\", \"frontend/src/Frontend.hs\"]\n      run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(staticFilePath \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(staticFilePath \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(staticFilePath \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\ntestThunkPack :: String -> [Text] -> FilePath -> Sh ()\ntestThunkPack executable args path' = withTempFile repoDir \"test-file\" $ \\file handle -> do\n  let\n    pack' = readProcessWithExitCode executable ([\"thunk\", \"pack\", path'] ++ map T.unpack args) \"\"\n    ensureThunkPackFails q = liftIO $ pack' >>= \\case\n      (code, out, err)\n        | code == ExitSuccess -> fail $ \"ob thunk pack succeeded when it should have failed with error '\" <> show q <> \"'\"\n        | q `T.isInfixOf` T.pack (out <> err) -> pure ()\n        | otherwise -> fail $ \"ob thunk pack failed for an unexpected reason, expecting '\" <> show q <> \"', received: \" <> show out <> \"\\nstderr: \" <> err\n    git = chdir repoDir . run_ gitPath\n  -- Untracked files\n  ensureThunkPackFails \"Untracked files\"\n  git [\"add\", T.pack file]\n  -- Uncommitted files (staged)\n  ensureThunkPackFails \"unsaved\"\n  chdir repoDir $ commit \"test commit\"\n  -- Non-pushed commits in any branch\n  ensureThunkPackFails \"not yet pushed\"\n  -- Uncommitted files (unstaged)\n  liftIO $ T.hPutStrLn handle \"test file\" >> hClose handle\n  ensureThunkPackFails \"modified\"\n  -- Existing stashes\n  git $ gitUserConfig <> [ \"stash\" ]\n  ensureThunkPackFails \"has stashes\"\n  where\n    repoDir = path' </> unpackedDirName\n\n-- | Blocks until a non-empty line is available\nhGetLineSkipBlanks :: MonadIO m => Handle -> m Text\nhGetLineSkipBlanks h = liftIO $ fix $ \\loop -> T.hGetLine h >>= \\case\n  \"\" -> loop\n  t -> pure t\n\n-- | Alters the route file and waits for `ob run` to reload\nalterRouteTo :: Text -> Handle -> Sh ()\nalterRouteTo uri stdout = do\n  writefile \"config/common/route\" uri\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Reloading...\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"  config/common/route\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Interrupted.\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n\n-- | Handle stdout of `ob run`: check that the frontend and backend servers are started correctly\nhandleObRunStdout :: HTTP.Manager -> Handle -> Handle -> Sh Text\nhandleObRunStdout httpManager stdout stderr = flip fix (ObRunState_Init, []) $ \\loop (state, msgs) -> do\n  isEOF <- liftIO $ hIsEOF stdout\n  if isEOF\n  then handleObRunError msgs\n  else liftIO (T.hGetLine stdout) >>= \\t -> case state of\n    ObRunState_Init\n      | \"Running test...\" `T.isPrefixOf` t -> loop (ObRunState_BackendStarted, msgs)\n    ObRunState_Startup\n      | t == \"backend stopped; make a change to your code to reload\" -> loop (ObRunState_Startup, msgs)\n      -- | Just port <- \"Backend running on port \" `T.stripPrefix` t -> loop $ ObRunState_BackendStarted port\n      | not (T.null t) -> errorExit $ \"Startup: \" <> t -- If theres any other output here, startup failed\n    ObRunState_BackendStarted\n      | Just uri <- \"Frontend running on \" `T.stripPrefix` t -> do\n        obRunCheck httpManager stdout uri\n        pure uri\n      | not (T.null t) -> errorExit $ \"Started: \" <> t -- If theres any other output here, startup failed\n    _ | \"Failed\" `T.isPrefixOf` t -> handleObRunError (t : msgs)\n      | otherwise -> loop (state, t : msgs)\n  where\n    handleObRunError msgs = do\n      stderrContent <- liftIO $ hGetContents stderr\n      errorExit $ \"ob run failed: \" <> T.unlines (reverse msgs) <> \" stderr: \" <> T.pack stderrContent\n\n-- | Make requests to frontend/backend servers to check they are working properly\nobRunCheck :: HTTP.Manager -> Handle -> Text -> Sh ()\nobRunCheck httpManager _stdout frontendUri = do\n  let req uri = liftIO $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n  req frontendUri >>= \\r -> when (HTTP.responseStatus r /= HTTP.ok200) $ errorExit $\n    \"Request to frontend server failed: \" <> T.pack (show r)\n\ngetFreePorts :: Int -> IO [Socket.PortNumber]\ngetFreePorts 0 = pure []\ngetFreePorts n = Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close $ \\s -> (:) <$> Socket.socketPort s <*> getFreePorts (n - 1)\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      pure sock\n\ntestLegacyGitThunks :: Bool -> IO ()\ntestLegacyGitThunks isVerbose = withSystemTempDirectory \"test-git-repo\" $ \\gitDir -> do\n  isolatedGitShell isVerbose gitDir $ \\git -> do\n    writefile (gitDir </> (\"default.nix\" :: FilePath)) \"{}: \\\"hello\\\"\"\n    _ <- git [\"add\", \"--all\"]\n    _ <- git [\"commit\", \"-m\", \"Initial commit\"]\n    rev <- T.strip <$> git [\"rev-parse\", \"HEAD\"]\n    sha256 :: Text\n      <-  either error pure\n      =<< (Aeson.parseEither (Aeson..: \"sha256\") <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n      <$> run nixPrefetchGitPath [toTextIgnore gitDir]\n\n    for_ (legacyGitThunks (GitThunkParams gitDir rev sha256)) $ \\mkFiles ->\n      withSystemTempDirectory \"test-thunks\" $ \\thunkDir -> do\n        liftIO $ mkFiles thunkDir\n        run_ \"ob\" [\"thunk\", \"unpack\", toTextIgnore thunkDir]\n        run_ \"ob\" [\"thunk\", \"pack\", toTextIgnore thunkDir]\n\ndata GitThunkParams = GitThunkParams\n  { _gitThunkParams_repo :: !FilePath\n  , _gitThunkParams_rev :: !Text\n  , _gitThunkParams_sha256 :: !Text\n  } deriving Show\n\nlegacyGitThunks :: GitThunkParams -> [FilePath -> IO ()]\nlegacyGitThunks (GitThunkParams repo' rev sha256) =\n  [ mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  assert !fetchSubmodules; (import <nixpkgs> {}).fetchgit { inherit url rev sha256; };\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  if builtins.hasAttr \\\"fetchGit\\\" builtins\"\n        , \"    then builtins.fetchGit ({ inherit url rev; } // (if branch == null then {} else { ref = branch; }))\"\n        , \"    else abort \\\"Plain Git repositories are only supported on nix 2.0 or higher.\\\";\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, ref ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, branch ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"    ${if branch == null then null else \\\"ref\\\"} = branch;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  ]\n  where\n    repo = T.pack repo'\n    mkLegacyIO :: Aeson.ToJSON v => Text -> Map.Map Text v -> FilePath -> IO ()\n    mkLegacyIO defaultNix gitJson dir = do\n      T.writeFile (dir </> (\"default.nix\" :: FilePath)) defaultNix\n      LBS.writeFile (dir </> (\"git.json\" :: FilePath)) (Aeson.encode gitJson)\n\nunpackedDirName :: FilePath\nunpackedDirName = \".\"\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.SelfTest"
              ],
              "decl": [
                "ObRunState"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "startLine": 50,
              "startColumn": 1,
              "endLine": 54,
              "endColumn": 22,
              "from": "data ObRunState\n  = ObRunState_Init | ObRunState_Startup | ObRunState_BackendStarted\n  deriving (Eq, Show)",
              "to": "data ObRunState\n  = ObRunStateInit | ObRunStateStartup | ObRunStateBackendStarted\n  deriving (Eq, Show)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.SelfTest"
              ],
              "decl": [
                "main'"
              ],
              "severity": "Warning",
              "hint": "Redundant <$>",
              "file": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "startLine": 270,
              "startColumn": 9,
              "endLine": 274,
              "endColumn": 38,
              "from": "writefile defaultNixPath\n  =<<\n    T.replace\n      \"# config.android_sdk.accept_license = false;\"\n      \"config.android_sdk.accept_license = true;\"\n      <$> readfile defaultNixPath",
              "to": "writefile defaultNixPath\n  . T.replace\n      \"# config.android_sdk.accept_license = false;\"\n      \"config.android_sdk.accept_license = true;\"\n  =<< readfile defaultNixPath",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 270, startCol = 9, endLine = 274, endCol = 38}, subts = [(\"f\",SrcSpan {startLine = 271, startCol = 15, endLine = 273, endCol = 56}),(\"g\",SrcSpan {startLine = 270, startCol = 9, endLine = 270, endCol = 33}),(\"x\",SrcSpan {startLine = 274, startCol = 15, endLine = 274, endCol = 38})], orig = \"g . f =<< x\"}]"
            },
            {
              "module": [
                "Obelisk.SelfTest"
              ],
              "decl": [
                "main'"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "startLine": 368,
              "startColumn": 11,
              "endLine": 370,
              "endColumn": 35,
              "from": "case search `T.isInfixOf` ln of\n  False -> loop Nothing\n  True -> loop $ Just 10",
              "to": "(if search `T.isInfixOf` ln then loop $ Just 10 else loop Nothing)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 368, startCol = 11, endLine = 370, endCol = 35}, subts = [(\"a\",SrcSpan {startLine = 368, startCol = 16, endLine = 368, endCol = 39}),(\"f\",SrcSpan {startLine = 369, startCol = 22, endLine = 369, endCol = 34}),(\"t\",SrcSpan {startLine = 370, startCol = 21, endLine = 370, endCol = 35})], orig = \"(if a then t else f)\"}]"
            },
            {
              "module": [
                "Obelisk.SelfTest"
              ],
              "decl": [
                "testLegacyGitThunks"
              ],
              "severity": "Warning",
              "hint": "Redundant <$>",
              "file": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "startLine": 733,
              "startColumn": 11,
              "endLine": 735,
              "endColumn": 55,
              "from": "either error pure\n  =<<\n    (Aeson.parseEither (Aeson..: \"sha256\")\n       <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n      <$> run nixPrefetchGitPath [toTextIgnore gitDir]",
              "to": "either error pure\n  . (Aeson.parseEither (Aeson..: \"sha256\")\n       <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n  =<< run nixPrefetchGitPath [toTextIgnore gitDir]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 733, startCol = 11, endLine = 735, endCol = 55}, subts = [(\"f\",SrcSpan {startLine = 734, startCol = 11, endLine = 734, endCol = 94}),(\"g\",SrcSpan {startLine = 733, startCol = 11, endLine = 733, endCol = 28}),(\"x\",SrcSpan {startLine = 735, startCol = 11, endLine = 735, endCol = 55})], orig = \"g . f =<< x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/selftest/src/Obelisk/SelfTest.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/selftest/src/Obelisk/SelfTest.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/selftest/src/Obelisk/SelfTest.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 1.3181818181818181,
            "sum": 29
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 17,
          "lines_of_code": 304,
          "homplexity_lines_of_code": 322,
          "code_quality_score": 9.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 1.3181818181818181,
              "sum": 29
            },
            "homplexity_loc": 322,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): module Obelisk.Backend has 241 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data BackendConfig has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data StaticAssets has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data GhcjsApp has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 74 43: data Backend has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 94 23: data GhcjsWidgets has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 172 1: type signature for renderAllJsPath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 172 1: type signature for renderAllJsPath has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 176 1: type signature for serveObeliskApp has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 176 1: type signature for serveObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has cyclomatic complexity of 5 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has 10 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 196 1: type signature for serveStaticAssets has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 196 1: type signature for serveStaticAssets has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 206 3: data GhcjsAppRoute has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 209 1: type signature for staticRenderContentType has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 209 1: type signature for staticRenderContentType has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 213 1: type signature for serveGhcjsApp has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 213 1: type signature for serveGhcjsApp has 6 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 229 1: type signature for defaultBackendConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 229 1: type signature for defaultBackendConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 233 1: type signature for runBackend has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 233 1: type signature for runBackend has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 237 1: type signature for runBackendWith has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 237 1: type signature for runBackendWith has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 242 1: function runBackendWith has 14 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 242 1: function runBackendWith has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 242 1: function runBackendWith has branching depth of 3 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 258 1: type signature for renderGhcjsFrontend has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 258 1: type signature for renderGhcjsFrontend has 6 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 266 1: function renderGhcjsFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 266 1: function renderGhcjsFrontend has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 266 1: function renderGhcjsFrontend has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 272 1: type signature for preloadGhcjs has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 272 1: type signature for preloadGhcjs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 273 1: function preloadGhcjs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 273 1: function preloadGhcjs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 273 1: function preloadGhcjs has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 277 1: type signature for deferredGhcjsScript has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 277 1: type signature for deferredGhcjsScript has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 278 1: function deferredGhcjsScript has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 278 1: function deferredGhcjsScript has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 278 1: function deferredGhcjsScript has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 283 1: type signature for delayedGhcjsScript has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 283 1: type signature for delayedGhcjsScript has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 287 1: function delayedGhcjsScript has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 287 1: function delayedGhcjsScript has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 287 1: function delayedGhcjsScript has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 301 1: type signature for getPublicConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 301 1: type signature for getPublicConfigs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 302 1: function getPublicConfigs has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 302 1: function getPublicConfigs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs\" 302 1: function getPublicConfigs has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Obelisk.Backend\n  ( Backend (..)\n  , BackendConfig (..)\n  , defaultBackendConfig\n  , StaticAssets (..)\n  , defaultStaticAssets\n  -- * Running a backend\n  , runBackend\n  , runBackendWith\n  -- * Configuration of backend\n  , GhcjsWidgets(..)\n  , defaultGhcjsWidgets\n  -- * all.js script loading functions\n  , deferredGhcjsScript\n  , delayedGhcjsScript\n  -- * all.js preload functions\n  , preloadGhcjs\n  , renderAllJsPath\n  -- * Re-exports\n  , Default (def)\n  , getPageName\n  , getRouteWith\n  , runSnapWithCommandLineArgs\n  , runSnapWithConfig\n  , serveDefaultObeliskApp\n  , prettifyOutput\n  , staticRenderContentType\n  , getPublicConfigs\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Fail (MonadFail)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad\nimport Control.Monad.Except\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as BSC8\nimport Data.Default (Default (..))\nimport Data.Dependent.Sum\nimport Data.Functor.Identity\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport GHC.Generics (Generic)\nimport Obelisk.Asset.Serve.Snap (serveAsset)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport Obelisk.Frontend\nimport Obelisk.Route\nimport Obelisk.Snap.Extras (doNotCache, serveFileIfExistsAs)\nimport Reflex.Dom.Core\nimport Snap (MonadSnap, Snap, commandLineConfig, defaultConfig, getsRequest, httpServe, modifyResponse\n            , rqPathInfo, rqQueryString, setContentType, writeBS, writeText\n            , rqCookies, Cookie(..) , setHeader)\nimport Snap.Internal.Http.Server.Config (Config (accessLog, errorLog), ConfigLog (ConfigIoLog))\nimport System.IO (BufferMode (..), hSetBuffering, stderr, stdout)\n\ndata Backend backendRoute frontendRoute = Backend\n  { _backend_routeEncoder :: Encoder (Either Text) Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  , _backend_run :: ((R backendRoute -> Snap ()) -> IO ()) -> IO ()\n  } deriving (Generic)\n\ndata BackendConfig frontendRoute = BackendConfig\n  { _backendConfig_runSnap :: !(Snap () -> IO ()) -- ^ Function to run the snap server\n  , _backendConfig_staticAssets :: !StaticAssets -- ^ Static assets\n  , _backendConfig_ghcjsWidgets :: !(GhcjsWidgets (Text -> FrontendWidgetT (R frontendRoute) ()))\n    -- ^ Given the URL of all.js, return the widgets which are responsible for\n    -- loading the script.\n  } deriving (Generic)\n\n-- | The static assets provided must contain a compiled GHCJS app that corresponds exactly to the Frontend provided\ndata GhcjsApp route = GhcjsApp\n  { _ghcjsApp_compiled :: !StaticAssets\n  , _ghcjsApp_value :: !(Frontend route)\n  } deriving (Generic)\n\n-- | Widgets used to load all.js on the frontend\ndata GhcjsWidgets a = GhcjsWidgets\n  { _ghcjsWidgets_preload :: a\n  -- ^ A preload widget, placed in the document head\n  , _ghcjsWidgets_script :: a\n  -- ^ A script widget, placed in the document body\n  } deriving (Functor, Generic)\n\n\n-- | Given the URL of all.js, return the widgets which are responsible for\n-- loading the script. Defaults to 'preloadGhcjs' and 'deferredGhcjsScript'.\ndefaultGhcjsWidgets :: GhcjsWidgets (Text -> FrontendWidgetT r ())\ndefaultGhcjsWidgets = GhcjsWidgets\n  { _ghcjsWidgets_preload = preloadGhcjs\n  , _ghcjsWidgets_script = deferredGhcjsScript\n  }\n\n-- | Serve a frontend, which must be the same frontend that Obelisk has built and placed in the default location\n--TODO: The frontend should be provided together with the asset paths so that this isn't so easily breakable; that will probably make this function obsolete\nserveDefaultObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> Frontend (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveDefaultObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontend =\n  serveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp\n  where frontendApp = GhcjsApp\n          { _ghcjsApp_compiled = defaultFrontendGhcjsAssets\n          , _ghcjsApp_value = frontend\n          }\n\nprettifyOutput :: IO ()\nprettifyOutput = do\n  -- Make output more legible by decreasing the likelihood of output from\n  -- multiple threads being interleaved\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\ndefaultStaticAssets :: StaticAssets\ndefaultStaticAssets = StaticAssets\n  { _staticAssets_processed = \"static.assets\"\n  , _staticAssets_unprocessed = \"static\"\n  }\n\ndefaultFrontendGhcjsAssets :: StaticAssets\ndefaultFrontendGhcjsAssets = StaticAssets\n  { _staticAssets_processed = \"frontend.jsexe.assets\"\n  , _staticAssets_unprocessed = \"frontend.jsexe\"\n  }\n\nrunSnapWithConfig :: MonadIO m => Config Snap a -> Snap () -> m ()\nrunSnapWithConfig conf a = do\n  let httpConf = conf\n        { accessLog = Just $ ConfigIoLog BSC8.putStrLn\n        , errorLog = Just $ ConfigIoLog BSC8.putStrLn\n        }\n  -- Start the web server\n  liftIO $ httpServe httpConf a\n\n-- Get the web server configuration from the command line\nrunSnapWithCommandLineArgs :: MonadIO m => Snap () -> m ()\nrunSnapWithCommandLineArgs s = liftIO (commandLineConfig defaultConfig) >>= \\c ->\n  runSnapWithConfig c s\n\ngetPageName :: (MonadSnap m) => m PageName\ngetPageName = do\n  p <- getsRequest rqPathInfo\n  q <- getsRequest rqQueryString\n  return $ byteStringsToPageName p q\n\ngetRouteWith :: (MonadSnap m) => Encoder Identity parse route PageName -> m (parse route)\ngetRouteWith e = do\n  pageName <- getPageName\n  return $ tryDecode e pageName\n\nrenderAllJsPath :: Encoder Identity Identity (R (FullRoute a b)) PageName -> Text\nrenderAllJsPath validFullEncoder =\n  renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_Ghcjs) :/ [\"all.js\"]\n\nserveObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> GhcjsApp (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp config = \\case\n  ObeliskRoute_App appRouteComponent :=> Identity appRouteRest -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_App appRouteComponent :/ appRouteRest\n  ObeliskRoute_Resource resComponent :=> Identity resRest -> case resComponent :=> Identity resRest of\n    ResourceRoute_Static :=> Identity pathSegments -> serveStaticAsset pathSegments\n    ResourceRoute_Ghcjs :=> Identity pathSegments -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_Resource :/ pathSegments\n    ResourceRoute_JSaddleWarp :=> Identity _ -> do\n      let msg = \"Error: Obelisk.Backend received jsaddle request\"\n      liftIO $ putStrLn $ T.unpack msg\n      writeText msg\n    ResourceRoute_Version :=> Identity () -> doNotCache >> serveFileIfExistsAs \"text/plain\" \"version\"\n\nserveStaticAssets :: (MonadSnap m, MonadFail m) => StaticAssets -> [Text] -> m ()\nserveStaticAssets assets pathSegments = serveAsset (_staticAssets_processed assets) (_staticAssets_unprocessed assets) $ T.unpack $ T.intercalate \"/\" pathSegments\n\ndata StaticAssets = StaticAssets\n  { _staticAssets_processed :: !FilePath\n  , _staticAssets_unprocessed :: !FilePath\n  }\n  deriving (Show, Read, Eq, Ord)\n\ndata GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRoute_App :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]\n\nstaticRenderContentType :: ByteString\nstaticRenderContentType = \"text/html; charset=utf-8\"\n\n--TODO: Don't assume we're being served at \"/\"\nserveGhcjsApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRouteComponent -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRouteComponent) ())\n  -> GhcjsApp (R appRouteComponent)\n  -> Map Text ByteString\n  -> R (GhcjsAppRoute appRouteComponent)\n  -> m ()\nserveGhcjsApp urlEnc ghcjsWidgets app config = \\case\n  GhcjsAppRoute_App appRouteComponent :=> Identity appRouteRest -> do\n    modifyResponse $ setContentType staticRenderContentType\n    modifyResponse $ setHeader \"Cache-Control\" \"no-store private\"\n    writeBS <=< renderGhcjsFrontend urlEnc ghcjsWidgets (appRouteComponent :/ appRouteRest) config $ _ghcjsApp_value app\n  GhcjsAppRoute_Resource :=> Identity pathSegments -> serveStaticAssets (_ghcjsApp_compiled app) pathSegments\n\n-- | Default obelisk backend configuration.\ndefaultBackendConfig :: BackendConfig frontendRoute\ndefaultBackendConfig = BackendConfig runSnapWithCommandLineArgs defaultStaticAssets defaultGhcjsWidgets\n\n-- | Run an obelisk backend with the default configuration.\nrunBackend :: Backend backendRoute frontendRoute -> Frontend (R frontendRoute) -> IO ()\nrunBackend = runBackendWith defaultBackendConfig\n\n-- | Run an obelisk backend with the given configuration.\nrunBackendWith\n  :: BackendConfig frontendRoute\n  -> Backend backendRoute frontendRoute\n  -> Frontend (R frontendRoute)\n  -> IO ()\nrunBackendWith (BackendConfig runSnap staticAssets ghcjsWidgets) backend frontend = case checkEncoder $ _backend_routeEncoder backend of\n  Left e -> fail $ \"backend error:\\n\" <> T.unpack e\n  Right validFullEncoder -> do\n    publicConfigs <- getPublicConfigs\n    _backend_run backend $ \\serveRoute ->\n      runSnap $\n        getRouteWith validFullEncoder >>= \\case\n          Identity r -> case r of\n            FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n            FullRoute_Frontend obeliskRoute :/ a ->\n              serveDefaultObeliskApp routeToUrl (($ allJsUrl) <$> ghcjsWidgets) (serveStaticAssets staticAssets) frontend publicConfigs $\n                obeliskRoute :/ a\n              where\n                routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n                allJsUrl = renderAllJsPath validFullEncoder\n\nrenderGhcjsFrontend\n  :: (MonadSnap m, HasCookies m)\n  => (route -> Text)\n  -> GhcjsWidgets (FrontendWidgetT route ())\n  -> route\n  -> Map Text ByteString\n  -> Frontend route\n  -> m ByteString\nrenderGhcjsFrontend urlEnc ghcjsWidgets route configs f = do\n  cookies <- askCookies\n  renderFrontendHtml configs cookies urlEnc route f (_ghcjsWidgets_preload ghcjsWidgets) (_ghcjsWidgets_script ghcjsWidgets)\n\n-- | Preload all.js in a link tag.\n-- This is the default preload method.\npreloadGhcjs :: Text -> FrontendWidgetT r ()\npreloadGhcjs allJsUrl = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: allJsUrl) blank\n\n-- | Load the script from the given URL in a deferred script tag.\n-- This is the default method.\ndeferredGhcjsScript :: Text -> FrontendWidgetT r ()\ndeferredGhcjsScript allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\" <> \"src\" =: allJsUrl <> \"defer\" =: \"defer\") blank\n\n-- | An all.js script which is loaded after waiting for some time to pass. This\n-- is useful to ensure any CSS animations on the page can play smoothly before\n-- blocking the UI thread by running all.js.\ndelayedGhcjsScript\n  :: Int -- ^ The number of milliseconds to delay loading by\n  -> Text -- ^ URL to GHCJS app JavaScript\n  -> FrontendWidgetT r ()\ndelayedGhcjsScript n allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\") $ text $ T.unlines\n  [ \"setTimeout(function() {\"\n  , \"  var all_js_script = document.createElement('script');\"\n  , \"  all_js_script.type = 'text/javascript';\"\n  , \"  all_js_script.src = '\" <> allJsUrl <> \"';\"\n  , \"  document.body.appendChild(all_js_script);\"\n  , \"}, \" <> T.pack (show n) <> \");\"\n  ]\n\ninstance HasCookies Snap where\n  askCookies = map (\\c -> (cookieName c, cookieValue c)) <$> getsRequest rqCookies\n\n-- | Get configs from the canonical \"public\" locations (i.e., locations that obelisk expects to make available\n-- to frontend applications, and hence visible to end users).\ngetPublicConfigs :: IO (Map Text ByteString)\ngetPublicConfigs = Map.filterWithKey (\\k _ -> isMemberOf k [\"common\", \"frontend\"]) <$> Lookup.getConfigs\n  where\n    isMemberOf k = any (`T.isPrefixOf` k)\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Backend"
              ],
              "decl": [
                "getRouteWith"
              ],
              "severity": "Warning",
              "hint": "Use <$>",
              "file": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs",
              "startLine": 168,
              "startColumn": 18,
              "endLine": 170,
              "endColumn": 32,
              "from": "do pageName <- getPageName\n   return $ tryDecode e pageName",
              "to": "do tryDecode e <$> getPageName",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 169, startCol = 3, endLine = 169, endCol = 26}, subts = [(\"x\",SrcSpan {startLine = 169, startCol = 15, endLine = 169, endCol = 26}),(\"f0\",SrcSpan {startLine = 170, startCol = 12, endLine = 170, endCol = 23})], orig = \"f0 <$> x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 170, startCol = 3, endLine = 170, endCol = 32}}]"
            },
            {
              "module": [
                "Obelisk.Backend"
              ],
              "decl": [
                "GhcjsAppRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs",
              "startLine": 205,
              "startColumn": 1,
              "endLine": 207,
              "endColumn": 67,
              "from": "data GhcjsAppRoute :: (* -> *) -> * -> *\n  where\n    GhcjsAppRoute_App :: appRouteComponent a ->\n                         GhcjsAppRoute appRouteComponent a\n    GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]",
              "to": "data GhcjsAppRoute :: (* -> *) -> * -> *\n  where\n    GhcjsAppRouteApp :: appRouteComponent a ->\n                        GhcjsAppRoute appRouteComponent a\n    GhcjsAppRouteResource :: GhcjsAppRoute appRouteComponent [Text]",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/backend/src/Obelisk/Backend.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.6666666666666667,
            "sum": 10
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 63,
          "homplexity_lines_of_code": 67,
          "code_quality_score": 73.3,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.6666666666666667,
              "sum": 10
            },
            "homplexity_loc": 67,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 1 1: module Obelisk.Snap.Extras has 46 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 22 1: type signature for modernMimeTypes has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 22 1: type signature for modernMimeTypes has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 27 1: type signature for cachePermanently has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 27 1: type signature for cachePermanently has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 33 1: type signature for doNotCache has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 33 1: type signature for doNotCache has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 39 1: type signature for serveFileIfExists has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 39 1: type signature for serveFileIfExists has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 47 1: type signature for serveFileIfExistsAs has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 47 1: type signature for serveFileIfExistsAs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 53 1: type signature for ensureSecure has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 53 1: type signature for ensureSecure has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has 6 lines of code \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Snap.Extras\n  ( cachePermanently\n  , doNotCache\n  , ensureSecure\n  , serveFileIfExists\n  , serveFileIfExistsAs\n  , modernMimeTypes\n  ) where\n\nimport Control.Monad.IO.Class\nimport Data.ByteString (ByteString)\nimport Data.String\nimport Snap.Core\nimport Snap.Util.FileServe\nimport System.Directory\n\nimport qualified Data.HashMap.Strict as Map\n\n\n-- | Default mime types with some modern extras\nmodernMimeTypes :: MimeMap\nmodernMimeTypes =\n  defaultMimeTypes <> Map.fromList [ (\".wasm\", \"application/wasm\") ]\n\n-- | Set response header for \"permanent\" caching\ncachePermanently :: MonadSnap m => m ()\ncachePermanently = do\n  modifyResponse $ setHeader \"Cache-Control\" \"public, max-age=315360000, immutable\"\n  modifyResponse $ setHeader \"Expires\" \"Tue, 01 Feb 2050 00:00:00 GMT\" --TODO: This should be set to \"approximately one year from the time the response is sent\"\n\n-- | Set response header to not cache\ndoNotCache :: MonadSnap m => m ()\ndoNotCache = do\n  modifyResponse $ setHeader \"Cache-Control\" \"no-cache, no-store, must-revalidate\"\n  modifyResponse $ setHeader \"Expires\" \"0\"\n\n-- | Serves the specified file if it exists; otherwise, 'pass'es\nserveFileIfExists :: MonadSnap m => FilePath -> m ()\nserveFileIfExists f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n  where\n    mimeType = fileType modernMimeTypes f\n\n-- | Like 'serveFileIfExists', but with a given MIME type\nserveFileIfExistsAs :: MonadSnap m => ByteString -> FilePath -> m ()\nserveFileIfExistsAs mimeType f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n\n-- | Only run the given handler when the connection is \"secure\" (i.e. made with HTTPS)\nensureSecure\n  :: MonadSnap m\n  => Int -- ^ The port where this server answers HTTPS requests\n  -> m () -- ^ A handler to be run only when the connection is secure\n  -> m ()\nensureSecure port h = do\n  s <- getsRequest rqIsSecure\n  if s then h else do\n    uri <- getsRequest rqURI\n    host <- getsRequest rqHostName --TODO: It might be better to use the canonical base of the server\n    redirect $ \"https://\" <> host <> (if port == 443 then \"\" else \":\" <> fromString (show port)) <> uri\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 2,
          "homplexity_lines_of_code": 3,
          "code_quality_score": 97.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 3,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs\" 2 1: function main has branching depth of 0 \n"
          },
          "original_code": "import Distribution.Simple\nmain = defaultMain\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/tabulation/Setup.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/tabulation/Setup.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/tabulation/Setup.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 152,
          "homplexity_lines_of_code": 28,
          "code_quality_score": 93.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 28,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 1 1: module Data.Tabulation has 26 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has method + value count of 5 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has associated type count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 142 3: data FieldHKD has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Tabulation where\n\nimport Control.Lens\n\n-- | This is a class for record types whose fields can be enumerated by an associated GADT. It's closely related to the concept of a representable functor, except without the functor part, and the fields are not all the same type.\nclass HasFields a where\n  type Field a :: * -> *\n\n  fieldLens :: Field a x -> Lens' a x\n  tabulateFieldsA :: Applicative f => (forall x. Field a x -> f x) -> f a\n\n  tabulateFields :: (forall x. Field a x -> x) -> a\n  tabulateFields f = runIdentity (tabulateFieldsA (Identity . f))\n  traverseWithField :: Applicative m => (forall x. Field a x -> x -> m x) -> a -> m a\n  traverseWithField t r = tabulateFieldsA (\\f -> t f (indexField r f))\n  indexField :: a -> Field a x -> x\n  indexField a f = a ^. fieldLens f\n  {-# MINIMAL fieldLens, tabulateFieldsA #-}\n\n-- | A wrapper to allow mixing/reusing a non-HKD associated GADT with the higher kinded data record.\n\n{- |\n==== __Usage example__\nWe can do\n\n@\ndata XY = XY\n  { _x :: ()\n  , _y :: 'Bool'\n  }\n\ndata XYField a where\n  XYField_X :: XYField ()\n  XYField_Y :: XYField 'Bool'\n\ninstance HasFields XY where\n  type Field XY = XYField\n  fieldLens = \\\\case\n    XYField_X -> \\\\f (XY x y) -> flip XY y '<$>' f x\n    XYField_Y -> lens _y $ \\\\xy y -> xy { _y = y }\n  tabulateFieldsA g = pure XY\n    '<*>' g XYField_X\n    '<*>' g XYField_Y\n@\n\nso one would expect being able to\n\n@\ndata XYHKD f = XYHKD\n  { _x' :: f ()\n  , _y' :: f Bool\n  }\n\ndata XYHKDField a where\n  XYHKDField_X :: XYHKDField (f ())\n  XYHKDField_Y :: XYHKDField (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField\n  fieldLens = \\\\case\n    XYHKDField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    XYHKDField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g XYHKDField_X\n    '<*>' g XYHKDField_Y\n@\n\nWhile `tabulateFieldsA` compiles, `fieldLens` doesn't, with the same sort of error in both its cases.\n\n@\n   \u2022 Could not deduce: f2 ~ f\n      from the context: x ~ f2 ()\n        bound by a pattern with constructor:\n                   XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n                 in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f2\u2019 is a rigid type variable bound by\n        a pattern with constructor:\n          XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n        in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f\u2019 is a rigid type variable bound by\n        the instance declaration\n        at ../lib/tabulation/src/Data/Tabulation.hs:65:10-28\n      Expected type: x\n        Actual type: f ()\n@\n\nThe `XYHKDField` constructors must work for all `f`, but the one from `XYHKD` is a specific one (it's quantified outside), so this direction doesn't work, but the one in `tabulateFieldsA` does.\n\nWe can fix this by threading the `f` from the record to the associated GADT.\n\n@\ndata XYHKDField f a where\n  XYHKDField_X :: XYHKDField f (f ())\n  XYHKDField_Y :: XYHKDField f (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField f\n@\n\nbut that's cumbersome and takes some work to figure out once you first try to use `Field` with HKD.\n\nTo solve these problems, one can use `FieldHKD` instead.\n\n@\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = FieldHKD XYField f\n  fieldLens = \\\\case\n    FieldHKD XYField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    FieldHKD XYField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g (FieldHKD XYField_X)\n    '<*>' g (FieldHKD XYField_Y)\n@\n\nThis also lets us capture the notion that the fields of the HKD version are related to the base version by a `f` layer by transforming one into the other.\n\n@\nliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = 'tabulateFields' $ \\(FieldHKD field) -> f ('indexField' r field)\n\nunliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = 'tabulateFields' $ \\field -> f ('indexField' r (FieldHKD field))\n\nxyPure :: 'Applicative' f => XY -> XYHKD f\nxyPure = 'liftKind' 'pure'\n\nxyRunIdentity :: XYHKD 'Identity' -> XY\nxyRunIdentity = 'unliftKind' 'runIdentity'\n@\n-}\ndata FieldHKD field f x where\n  FieldHKD :: field x -> FieldHKD field f (f x)\n\nliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = tabulateFields $ \\(FieldHKD field) -> f (indexField r field)\n\nunliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = tabulateFields $ \\field -> f (indexField r (FieldHKD field))\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/tabulation/src/Data/Tabulation.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 4,
          "homplexity_lines_of_code": 4,
          "code_quality_score": 97.6,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 4,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 1 1: <unnamed module> has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 3 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 3 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 4 1: function main has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 4 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs\" 4 1: function main has branching depth of 0 \n"
          },
          "original_code": "import qualified Obelisk.Command\n\nmain :: IO ()\nmain = Obelisk.Command.main\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src-bin/ob.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src-bin/ob.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 3
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 2,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 13,
          "lines_of_code": 142,
          "homplexity_lines_of_code": 109,
          "code_quality_score": 83.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 3
            },
            "homplexity_loc": 109,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 1 1: module Obelisk.App has 100 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 44 5: data ObeliskProcessError has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 55 5: data ObeliskError has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 74 19: data Obelisk has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 78 24: data ObeliskT has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 92 3: type class HasObelisk has associated type count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 92 3: type class HasObelisk has method + value count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 109 1: type signature for runObelisk has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 109 1: type signature for runObelisk has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 118 1: type signature for wrapNixThunkError has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 118 1: type signature for wrapNixThunkError has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 141 1: type signature for getObeliskUserStateDir has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 141 1: type signature for getObeliskUserStateDir has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.App where\n\nimport Control.Lens\nimport Control.Monad.Catch (MonadCatch, MonadMask, MonadThrow)\nimport Control.Monad.Fail (MonadFail)\nimport Control.Monad.Reader (MonadIO, ReaderT (..), ask, runReaderT)\nimport Control.Monad.Writer (WriterT)\nimport Control.Monad.State (StateT)\nimport Control.Monad.Except (ExceptT, MonadError)\nimport Control.Monad.Trans.Class (MonadTrans, lift)\nimport Data.Text (Text)\nimport System.Directory (XdgDirectory (XdgData), getXdgDirectory)\nimport Control.Monad.Log (MonadLog)\nimport Cli.Extras.Types\nimport \"nix-thunk\" Nix.Thunk (NixThunkError)\n\nimport Cli.Extras\n  ( CliConfig\n  , CliLog\n  , CliThrow\n  , CliT (..)\n  , ProcessFailure\n  , AsProcessFailure (..)\n  , AsUnstructuredError (..)\n  , HasCliConfig\n  , Output\n  , runCli\n  )\n\n-- | An error thrown by one of the child processes invoked during\n-- execution of Obelisk.\ndata ObeliskProcessError\n  = ObeliskProcessError\n    { _obeliskProcessError_failure :: ProcessFailure\n      -- ^ The 'ProcessFailure' indicating both how the process was\n      -- created and its eventual exit code.\n    , _obeliskProcessError_mComment :: Maybe Text\n      -- ^ Optionally, a comment can be attached to the 'ProcessFailure'\n      -- to give the user more details.\n    }\n\n-- | An error thrown by the Obelisk app.\ndata ObeliskError\n  = ObeliskError_ProcessError ObeliskProcessError\n    -- ^ Indicates an error in one of our child processes.\n  | ObeliskError_NixThunkError NixThunkError\n    -- ^ Propagated errors from @nix-thunk@\n  | ObeliskError_Unstructured Text\n    -- ^ An ad-hoc error.\n\nmakePrisms ''ObeliskError\n\ninstance AsUnstructuredError ObeliskError where\n  asUnstructuredError = _ObeliskError_Unstructured\n\n-- Only project when the other field is null, otherwise we are not law abiding.\ninstance AsProcessFailure ObeliskError where\n  asProcessFailure = _ObeliskError_ProcessError . prism (flip ObeliskProcessError Nothing) f\n    where f = \\case\n            ObeliskProcessError pf Nothing -> Right pf\n            pann@(ObeliskProcessError _ (Just _)) -> Left pann\n\nnewtype Obelisk = Obelisk\n  { _obelisk_cliConfig :: CliConfig ObeliskError\n  }\n\nnewtype ObeliskT m a = ObeliskT\n  { unObeliskT :: ReaderT Obelisk (CliT ObeliskError m) a\n  }\n  deriving\n    ( Functor, Applicative, Monad, MonadIO, MonadThrow, MonadCatch, MonadMask, MonadFail\n    , MonadLog Output -- CliLog\n    , MonadError ObeliskError -- CliThrow ObeliskError\n    , HasCliConfig ObeliskError\n    )\n\ninstance MonadTrans ObeliskT where\n  lift = ObeliskT . lift . lift\n\nclass Monad m => HasObelisk m where\n  getObelisk :: m Obelisk\n\ninstance Monad m => HasObelisk (ObeliskT m) where\n  getObelisk = ObeliskT ask\n\ninstance HasObelisk m => HasObelisk (ReaderT r m) where\n  getObelisk = lift getObelisk\n\ninstance (Monoid w, HasObelisk m) => HasObelisk (WriterT w m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (StateT r m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (ExceptT e m) where\n  getObelisk = lift getObelisk\n\nrunObelisk :: MonadIO m => Obelisk -> ObeliskT m a -> m a\nrunObelisk c =\n    runCli (_obelisk_cliConfig c)\n  . flip runReaderT c\n  . unObeliskT\n\n-- | Wrap an action which may throw 'NixThunkError' (e.g.\n-- 'nixBuildAttrWithCache') in a 'MonadError' which supports throwing\n-- 'ObeliskError'.\nwrapNixThunkError\n  :: (MonadError ObeliskError m, HasCliConfig ObeliskError m, MonadIO m)\n  => CliT NixThunkError m a\n  -> m a\nwrapNixThunkError k = do\n  cfg <- getCliConfig\n  let cfg' = cfg { _cliConfig_errorLogExitCode = _cliConfig_errorLogExitCode cfg . ObeliskError_NixThunkError }\n  runCli cfg' k\n\ntype MonadInfallibleObelisk m =\n  ( CliLog m\n  , HasCliConfig ObeliskError m\n  , HasObelisk m\n  , MonadIO m\n  , MonadMask m\n  )\n\ntype MonadObelisk m =\n  ( MonadInfallibleObelisk m\n  , CliThrow ObeliskError m\n  , MonadFail m\n  )\n\ngetObeliskUserStateDir :: IO FilePath\ngetObeliskUserStateDir = getXdgDirectory XdgData \"obelisk\"\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.App"
              ],
              "decl": [
                "ObeliskError"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs",
              "startLine": 54,
              "startColumn": 1,
              "endLine": 59,
              "endColumn": 35,
              "from": "data ObeliskError\n  = ObeliskError_ProcessError ObeliskProcessError |\n    ObeliskError_NixThunkError NixThunkError |\n    ObeliskError_Unstructured Text",
              "to": "data ObeliskError\n  = ObeliskErrorProcessError ObeliskProcessError |\n    ObeliskErrorNixThunkError NixThunkError |\n    ObeliskErrorUnstructured Text",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.App"
              ],
              "decl": [],
              "severity": "Suggestion",
              "hint": "Use section",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs",
              "startLine": 69,
              "startColumn": 57,
              "endLine": 69,
              "endColumn": 91,
              "from": "(flip ObeliskProcessError Nothing)",
              "to": "(`ObeliskProcessError` Nothing)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 69, startCol = 57, endLine = 69, endCol = 91}, subts = [(\"x\",SrcSpan {startLine = 69, startCol = 83, endLine = 69, endCol = 90})], orig = \"(`ObeliskProcessError` x)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/App.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/App.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 18,
            "average": 1.8823529411764706,
            "sum": 64
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 6,
            "ignore": 0,
            "total": 8
          },
          "syntax_errors": 16,
          "lines_of_code": 505,
          "homplexity_lines_of_code": 609,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 18,
              "average": 1.8823529411764706,
              "sum": 64
            },
            "homplexity_loc": 609,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 1 1: module Obelisk.Command has 364 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 41 13: data Args has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 51 22: data ArgsConfig has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 56 1: function args has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 56 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 56 1: function args has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has cyclomatic complexity of 1 \nCritical:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 89 6: data ObCommand has record fields count of 18 must never reach 9\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 105 6: data ObInternal has record fields count of 5 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has 2 arguments \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has 20 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has 8 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 185 22: data RemoteBuilder has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 189 5: data DeployCommand has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 196 1: type signature for thunkDirectoryParser has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 196 1: type signature for thunkDirectoryParser has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 203 1: type signature for profileCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 203 1: type signature for profileCommand has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has 14 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 221 1: type signature for thunkConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 221 1: type signature for thunkConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 229 1: type signature for thunkUpdateConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 229 1: type signature for thunkUpdateConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 234 1: type signature for thunkPackConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 234 1: type signature for thunkPackConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 239 20: data ThunkOption has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 245 5: data ThunkCommand has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 250 1: type signature for thunkOption has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 250 1: type signature for thunkOption has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has 10 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 266 5: data ShellOpts has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 273 1: type signature for shellFlags has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 273 1: type signature for shellFlags has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 279 1: type signature for userGhciConfigOpt has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 279 1: type signature for userGhciConfigOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 287 1: type signature for interpretOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 287 1: type signature for interpretOpts has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has 8 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 307 1: type signature for certDirOpts has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 307 1: type signature for certDirOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 312 1: type signature for shellOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 312 1: type signature for shellOpts has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 321 1: type signature for portOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 321 1: type signature for portOpt has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 324 1: type signature for parserPrefs has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 324 1: type signature for parserPrefs has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 330 1: type signature for mkObeliskConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 330 1: type signature for mkObeliskConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has 19 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 366 1: type signature for runCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 366 1: type signature for runCommand has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 369 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 369 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 370 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 370 1: function main has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 370 1: function main has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 374 1: type signature for hSetTranslit has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 374 1: type signature for hSetTranslit has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 383 1: type signature for main' has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 383 1: type signature for main' has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has branching depth of 1 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has 32 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has cyclomatic complexity of 6 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 430 1: type signature for ob has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 430 1: type signature for ob has 2 arguments \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 431 1: function ob has 33 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 431 1: function ob has branching depth of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 431 1: function ob has cyclomatic complexity of 18 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 468 1: type signature for withInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 468 1: type signature for withInterpretPaths has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 469 1: function withInterpretPaths has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 469 1: function withInterpretPaths has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 469 1: function withInterpretPaths has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 475 1: type signature for haddockCommand has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 475 1: type signature for haddockCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 476 1: function haddockCommand has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 476 1: function haddockCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 476 1: function haddockCommand has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 485 1: type signature for getArgsConfig has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 485 1: type signature for getArgsConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 486 1: function getArgsConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 486 1: function getArgsConfig has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 486 1: function getArgsConfig has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 498 1: type signature for resolveInterpretPaths has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 498 1: type signature for resolveInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 499 1: function resolveInterpretPaths has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 499 1: function resolveInterpretPaths has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs\" 499 1: function resolveInterpretPaths has 5 lines of code \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command where\n\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Bool (bool)\nimport Data.Foldable (for_)\nimport Data.List (isInfixOf, isPrefixOf, notElem)\nimport Data.List.NonEmpty (NonEmpty, nonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport qualified Data.Map as Map\nimport qualified Data.Text as T\nimport Data.Traversable (for)\nimport Options.Applicative\nimport Options.Applicative.Help.Pretty (text, (<$$>))\nimport System.Directory\nimport System.Environment\nimport System.FilePath\nimport System.Exit\nimport qualified System.Info\nimport System.IO (hIsTerminalDevice, Handle, stdout, stderr, hGetEncoding, hSetEncoding, mkTextEncoding)\nimport GHC.IO.Encoding.Types (textEncodingName)\nimport System.Process (rawSystem)\nimport Network.Socket (PortNumber)\n\nimport Obelisk.App\nimport Obelisk.Command.Deploy\nimport Obelisk.Command.Project\nimport Obelisk.Command.Run\nimport qualified Obelisk.Command.VmBuilder as VmBuilder\nimport qualified Obelisk.Command.Preprocessor as Preprocessor\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n\ndata Args = Args\n  { _args_noHandOffPassed :: Bool\n  -- ^ This flag is actually handled outside of the optparse-applicative parser, but we detect whether\n  -- it has gotten through in order to notify the user that it should only be passed once and as the very\n  -- first argument\n  , _args_verbose :: Bool\n  , _args_command :: ObCommand\n  }\n  deriving Show\n\nnewtype ArgsConfig = ArgsConfig\n  { _argsConfig_enableVmBuilderByDefault :: Bool\n  }\n\nargs :: ArgsConfig -> Parser Args\nargs cfg = Args <$> noHandoff <*> verbose <*> obCommand cfg\n\nnoHandoff :: Parser Bool\nnoHandoff = flag False True $ mconcat\n  [ long \"no-handoff\"\n  , help \"Do not hand off execution to project-specific implementation of this command\"\n  , hidden\n  ]\n\nverbose :: Parser Bool\nverbose = flag False True $ mconcat\n  [ long \"verbose\"\n  , short 'v'\n  , help \"Be more verbose\"\n  ]\n\nargsInfo :: ArgsConfig -> ParserInfo Args\nargsInfo cfg = info (args cfg <**> helper) $ mconcat\n  [ fullDesc\n  , progDesc \"Manage Obelisk projects\"\n  ]\n\ninitSource :: Parser InitSource\ninitSource = foldl1 (<|>)\n  [ pure InitSource_Default\n  , InitSource_Branch <$> strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Initialize the project using the given BRANCH of Obelisk's official repository\")\n  , InitSource_Symlink <$> strOption (long \"symlink\" <> action \"directory\" <> metavar \"PATH\" <> help \"(Use with caution) Initialize the project using the copy of Obelisk found at the given PATH\")\n  ]\n\ninitForce :: Parser Bool\ninitForce = switch (long \"force\" <> help \"Allow ob init to overwrite files\")\n\ndata ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] -- user @.ghci@ config\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String] -- shell and list of packages\n   | ObCommand_Hoogle String Int -- shell and port\n   | ObCommand_Internal ObInternal\n   deriving Show\n\ndata ObInternal\n   -- the preprocessor argument syntax is also handled outside\n   -- optparse-applicative, but it shouldn't ever conflict with another syntax\n   = ObInternal_ApplyPackages String String String [String]\n   | ObInternal_ExportGhciConfig\n      [(FilePath, Interpret)]\n   deriving Show\n\nobCommand :: ArgsConfig -> Parser ObCommand\nobCommand cfg = hsubparser\n  (mconcat\n    [ command \"init\" $ info (ObCommand_Init <$> initSource <*> initForce) $ progDesc \"Initialize an Obelisk project\"\n    , command \"deploy\" $ info (ObCommand_Deploy <$> deployCommand cfg) $ progDesc \"Prepare a deployment for an Obelisk project\"\n    , command \"run\" $ info\n      (   ObCommand_Run\n      <$> interpretOpts\n      <*> certDirOpts\n      <*> (Just <$> option auto (long \"port\" <> short 'p' <> help \"Port number for server; overrides common/config/route\" <> metavar \"INT\") <|> pure Nothing))\n      $ progDesc \"Run current project in development mode\"\n    , command \"profile\" $ info (uncurry ObCommand_Profile <$> profileCommand) $ progDesc \"Run current project with profiling enabled\"\n    , command \"thunk\" $ info (ObCommand_Thunk <$> thunkOption) $ progDesc \"Manipulate thunk directories\"\n    , command \"repl\" $ info (ObCommand_Repl <$> optional userGhciConfigOpt  <*> interpretOpts) $ progDesc \"Open an interactive interpreter\"\n    , command \"watch\" $ info (ObCommand_Watch <$> interpretOpts) $ progDesc \"Watch current project for errors and warnings\"\n    , command \"shell\" $ info (ObCommand_Shell <$> shellOpts) $ progDesc \"Enter a shell with project dependencies or run a command in such a shell. E.g. ob shell -- ghc-pkg list\"\n    , command \"doc\" $ info (ObCommand_Doc <$> shellFlags <*> packageNames) $\n        progDesc \"List paths to haddock documentation for specified packages\"\n        <> footerDoc (Just $\n              text \"Hint: To open the documentation you can pipe the output of this command like\"\n              <$$> text \"ob doc reflex reflex-dom-core | xargs -n1 xdg-open\")\n    , command \"hoogle\" $ info (ObCommand_Hoogle <$> shellFlags <*> portOpt 8080) $ progDesc \"Run a hoogle server locally for your project's dependency tree\"\n    , command \"internal\" $ info (ObCommand_Internal <$> internalCommand) $ progDesc \"Internal Obelisk commands with unstable APIs\"\n    ])\n\ninternalCommand :: Parser ObInternal\ninternalCommand = hsubparser $ mconcat\n  [ command \"export-ghci-configuration\" $ info (ObInternal_ExportGhciConfig <$> interpretOpts)\n      $ progDesc \"Export the GHCi configuration used by ob run, etc.; useful for IDE integration\"\n  ]\n\npackageNames :: Parser [String]\npackageNames = some (strArgument (metavar \"PACKAGE-NAME...\"))\n\ndeployCommand :: ArgsConfig -> Parser DeployCommand\ndeployCommand cfg = hsubparser $ mconcat\n  [ command \"init\" $ info (DeployCommand_Init <$> deployInitOpts) $ progDesc \"Initialize a deployment configuration directory\"\n  , command \"push\" $ info (DeployCommand_Push <$> remoteBuilderParser) mempty\n  , command \"test\" $ info (DeployCommand_Test <$> platformP) $ progDesc \"Test your obelisk project from a mobile platform.\"\n  , command \"update\" $ info (pure DeployCommand_Update) $ progDesc \"Update the deployment's src thunk to latest\"\n  ]\n  where\n    platformP = hsubparser $ mconcat\n      [ command \"android\" $ info (pure (Android, [])) mempty\n      , command \"ios\" $ info ((,) <$> pure IOS <*> fmap pure (strArgument (metavar \"TEAMID\" <> help \"Your Team ID - found in the Apple developer portal\"))) mempty\n      ]\n\n    remoteBuilderParser :: Parser (Maybe RemoteBuilder)\n    remoteBuilderParser =\n      flag (if enabledByDefault then enabled else Nothing) enabled (mconcat\n        [ long $ \"enable-\" <> flagBase\n        , help $ \"Enable \" <> flagDesc <> (if enabledByDefault then \" (default)\" else \"\")\n        ])\n      <|> flag enabled Nothing (mconcat\n        [ long $ \"disable-\" <> flagBase\n        , help $ \"Disable a \" <> flagDesc <> (if not enabledByDefault then \" (default)\" else \"\")\n        ])\n      where\n        enabledByDefault = _argsConfig_enableVmBuilderByDefault cfg\n        enabled = Just RemoteBuilder_ObeliskVM\n        flagBase = \"vm-builder\"\n        flagDesc = \"managed Linux virtual machine as a Nix remote builder (requires Docker)\"\n\n\ndeployInitOpts :: Parser DeployInitOpts\ndeployInitOpts = DeployInitOpts\n  <$> strArgument (action \"directory\" <> metavar \"DEPLOYDIR\" <> help \"Path to a directory where the deployment repository will be initialized\")\n  <*> strOption (long \"ssh-key\" <> action \"file\" <> metavar \"SSHKEY\" <> help \"Path to an SSH key that will be *copied* to the deployment repository\")\n  <*> some (strOption (long \"hostname\" <> metavar \"HOSTNAME\" <> help \"hostname of the deployment target\"))\n  <*> strOption (long \"route\" <> metavar \"PUBLICROUTE\" <> help \"Publicly accessible URL of your app\")\n  <*> strOption (long \"admin-email\" <> metavar \"ADMINEMAIL\" <> help \"Email address where administrative alerts will be sent\")\n  <*> flag True False (long \"disable-https\" <> help \"Disable automatic https configuration for the backend\")\n  <*> flag False True (long \"check-known-hosts\" <> help \"Add keys for the system's known_hosts matching the hostname to the configuration's known_hosts\")\n\ntype TeamID = String\ndata RemoteBuilder = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)\n\ndata DeployCommand\n  = DeployCommand_Init DeployInitOpts\n  | DeployCommand_Push (Maybe RemoteBuilder)\n  | DeployCommand_Test (PlatformDeployment, [String])\n  | DeployCommand_Update\n  deriving Show\n\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]\n\nprofileCommand :: Parser (String, [String])\nprofileCommand = (,)\n  <$> strOption\n    (  long \"output\"\n    <> short 'o'\n    <> help \"Base output to use for profiling output. Suffixes are added to this based on the profiling type. Defaults to a timestamped path in the profile/ directory in the project's root.\"\n    <> metavar \"PATH\"\n    <> value \"profile/%Y-%m-%dT%H:%M:%S\"\n    <> showDefault\n    )\n  <*> (words <$> strOption\n    (  long \"rts-flags\"\n    <> help \"RTS Flags to pass to the executable.\"\n    <> value \"-p -hc\"\n    <> metavar \"FLAGS\"\n    <> showDefault\n    ))\n\nthunkConfig :: Parser ThunkConfig\nthunkConfig = ThunkConfig\n  <$>\n    (   flag' (Just True) (long \"private\" <> help \"Mark thunks as pointing to a private repository\")\n    <|> flag' (Just False) (long \"public\" <> help \"Mark thunks as pointing to a public repository\")\n    <|> pure Nothing\n    )\n\nthunkUpdateConfig :: Parser ThunkUpdateConfig\nthunkUpdateConfig = ThunkUpdateConfig\n  <$> optional (strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Use the given branch when looking for the latest revision\"))\n  <*> thunkConfig\n\nthunkPackConfig :: Parser ThunkPackConfig\nthunkPackConfig = ThunkPackConfig\n  <$> switch (long \"force\" <> short 'f' <> help \"Force packing thunks even if there are branches not pushed upstream, uncommitted changes, stashes. This will cause changes that have not been pushed upstream to be lost; use with care.\")\n  <*> thunkConfig\n\ndata ThunkOption = ThunkOption\n  { _thunkOption_thunks :: NonEmpty FilePath\n  , _thunkOption_command :: ThunkCommand\n  } deriving Show\n\ndata ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig\n  | ThunkCommand_Unpack\n  | ThunkCommand_Pack ThunkPackConfig\n  deriving Show\n\nthunkOption :: Parser ThunkOption\nthunkOption = hsubparser $ mconcat\n  [ command \"update\" $ info (thunkOptionWith $ ThunkCommand_Update <$> thunkUpdateConfig) $ progDesc \"Update packed thunk to latest revision available on the tracked branch\"\n  , command \"unpack\" $ info (thunkOptionWith $ pure ThunkCommand_Unpack) $ progDesc \"Unpack thunk into git checkout of revision it points to\"\n  , command \"pack\" $ info (thunkOptionWith $ ThunkCommand_Pack <$> thunkPackConfig) $ progDesc \"Pack git checkout or unpacked thunk into thunk that points at the current branch's upstream\"\n  ]\n  where\n    thunkOptionWith f = ThunkOption\n      <$> ((NonEmpty.:|)\n            <$> thunkDirArg (metavar \"THUNKDIRS...\" <> help \"Paths to directories containing thunk data\")\n            <*> many (thunkDirArg mempty)\n          )\n      <*> f\n    thunkDirArg opts = fmap (dropTrailingPathSeparator . normalise) $ strArgument $ action \"directory\" <> opts\n\ndata ShellOpts\n  = ShellOpts\n    { _shellOpts_shell :: String\n    , _shellOpts_interpretPaths :: [(FilePath, Interpret)]\n    , _shellOpts_command :: Maybe String\n    }\n  deriving Show\n\nshellFlags :: Parser String\nshellFlags =\n  flag' \"ghc\" (long \"ghc\" <> help \"Enter a shell environment having ghc (default)\")\n  <|> flag \"ghc\" \"ghcjs\" (long \"ghcjs\" <> help \"Enter a shell having ghcjs rather than ghc\")\n  <|> strOption (short 'A' <> long \"argument\" <> metavar \"NIXARG\" <> help \"Use the environment specified by the given nix argument of `shells'\")\n\nuserGhciConfigOpt :: Parser FilePath\nuserGhciConfigOpt = strOption $ mconcat\n  [ long \"config\"\n  , short 'c'\n  , metavar \"CONFIG\"\n  , help \"User .ghci config file (use at your own risk)\"\n  ]\n\ninterpretOpts :: Parser [(FilePath, Interpret)]\ninterpretOpts = many\n    (   (, Interpret_Interpret) <$>\n          strOption (common <> long \"interpret\" <> help\n            \"Don't pre-build packages found in DIR when constructing the package database. The default behavior is \\\n            \\'--interpret <project-root>', which will load everything which is unpacked into GHCi. \\\n            \\ Use --interpret and --no-interpret multiple times to add or remove multiple trees \\\n            \\ from the environment. Settings for right-most directories will \\\n            \\ override settings for any identical directories given earlier.\"\n          )\n    <|> (, Interpret_NoInterpret) <$>\n          strOption (common <> long \"no-interpret\" <> help\n            \"Make packages found in DIR available in the package database (but only when they are used dependencies). \\\n            \\ This will build the packages in DIR before loading GHCi. \\\n            \\See help for --interpret for how the two options are related.\"\n          )\n    )\n  where\n    common = action \"directory\" <> metavar \"DIR\"\n\ncertDirOpts :: Parser (Maybe FilePath)\ncertDirOpts = optional (strOption (short 'c' <> long \"cert\" <> metavar \"DIRECTORY\" <> help helpText))\n  where\n    helpText = \"Specify a directory in which to find \\'cert.pem\\', \\'chain.pem\\' and \\'privkey.pem\\' for use with TLS.\"\n\nshellOpts :: Parser ShellOpts\nshellOpts = ShellOpts\n  <$> shellFlags\n  <*> interpretOpts\n  -- This funny construction is used to support optparse-applicative's @--@ parsing.\n  -- All arguments after @--@ are left unparsed and instead provided to the last positional parser\n  -- which must therefore be 'many' in order to consume the rest of the input.\n  <*> ((\\xs -> if null xs then Nothing else Just $ unwords xs) <$> many (strArgument (metavar \"COMMAND\")))\n\nportOpt :: Int -> Parser Int\nportOpt dfault = option auto (long \"port\" <> short 'p' <> help \"Port number for server\" <> showDefault <> value dfault <> metavar \"INT\")\n\nparserPrefs :: ParserPrefs\nparserPrefs = defaultPrefs\n  { prefShowHelpOnEmpty = True\n  }\n\n-- | Create an Obelisk config for the current process.\nmkObeliskConfig :: IO Obelisk\nmkObeliskConfig = do\n  cliArgs <- getArgs\n  -- This function should not use argument parser (full argument parsing happens post handoff)\n  -- TODO: See if we can use the argument parser with a subset of the parsers to get logging level out.\n  let logLevel = toLogLevel $ any (`elem` [\"-v\", \"--verbose\"]) cliArgs\n  notInteractive <- not <$> isInteractiveTerm\n  cliConf <- newCliConfig logLevel notInteractive notInteractive $ \\case\n    ObeliskError_ProcessError ObeliskProcessError{_obeliskProcessError_failure = ProcessFailure p code, _obeliskProcessError_mComment = ann } ->\n      ( \"Process exited with code \" <> T.pack (show code) <> \"; \" <> reconstructCommand p\n        <> maybe \"\" (\"\\n\" <>) ann\n      , ExitFailure 2\n      )\n    ObeliskError_NixThunkError e -> (prettyNixThunkError e, ExitFailure 2)\n    ObeliskError_Unstructured msg -> (msg, ExitFailure 2)\n\n  return $ Obelisk cliConf\n  where\n    toLogLevel = bool Notice Debug\n    isInteractiveTerm = do\n      isTerm <- hIsTerminalDevice stdout\n      -- Running in bash/fish/zsh completion\n      inShellCompletion <- liftIO $ isInfixOf \"completion\" . unwords <$> getArgs\n\n      -- Respect the user\u2019s TERM environment variable. Dumb terminals\n      -- like Eshell cannot handle lots of control sequences that the\n      -- spinner uses.\n      termEnv <- lookupEnv \"TERM\"\n      let isDumb = termEnv == Just \"dumb\"\n\n      return $ isTerm && not inShellCompletion && not isDumb\n\n-- | For use from development obelisk repls\n--\n-- Example:\n-- > runCommand $ someFuncInMonadObelisk ...\nrunCommand :: ObeliskT IO a -> IO a\nrunCommand f = flip runObelisk f =<< mkObeliskConfig\n\nmain :: IO ()\nmain = runCommand . main' =<< getArgsConfig\n\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()\n\nmain' :: MonadObelisk m => ArgsConfig -> m ()\nmain' argsCfg = do\n  obPath <- liftIO getExecutablePath\n  myArgs <- liftIO getArgs\n  logLevel <- getLogLevel\n\n  -- NB: We set the standard output and standard error streams to\n  -- TransliterateCodingFailure so that, on encodings which do not\n  -- support our fancy characters, we print a replacement character\n  -- instead of exploding.\n  liftIO $ hSetTranslit stdout\n  liftIO $ hSetTranslit stderr\n\n  putLog Debug $ T.pack $ unwords\n    [ \"Starting Obelisk <\" <> obPath <> \">\"\n    , \"args=\" <> show myArgs\n    , \"logging-level=\" <> show logLevel\n    ]\n\n  --TODO: We'd like to actually use the parser to determine whether to hand off,\n  --but in the case where this implementation of 'ob' doesn't support all\n  --arguments being passed along, this could fail.  For now, we don't bother\n  --with optparse-applicative until we've done the handoff.\n  let go as = do\n        args' <- liftIO $ handleParseResult (execParserPure parserPrefs (argsInfo argsCfg) as)\n        case _args_noHandOffPassed args' of\n          False -> return ()\n          True -> putLog Warning \"--no-handoff should only be passed once and as the first argument; ignoring\"\n        ob $ _args_command args'\n      handoffAndGo as = findProjectObeliskCommand \".\" >>= \\case\n        Nothing -> go as -- If not in a project, just run ourselves\n        Just impl -> do\n          -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n          putLog Debug $ \"Handing off to \" <> T.pack impl\n          _ <- liftIO $ rawSystem impl (\"--no-handoff\" : myArgs)\n          return ()\n  case myArgs of\n    \"--no-handoff\" : as -> go as -- If we've been told not to hand off, don't hand off\n    origPath:inPath:outPath:preprocessorName:packagePaths\n      | preprocessorName == preprocessorIdentifier && any (\\c -> c == '.' || c == pathSeparator) origPath ->\n        ob $ ObCommand_Internal $ ObInternal_ApplyPackages origPath inPath outPath packagePaths\n    a:as -- Otherwise bash completion would always hand-off even if the user isn't trying to\n      | \"--bash-completion\" `isPrefixOf` a\n      && \"--no-handoff\" `elem` as -> go (a:as)\n      | otherwise -> handoffAndGo (a:as)\n    as -> handoffAndGo as\n\nob :: MonadObelisk m => ObCommand -> m ()\nob = \\case\n  ObCommand_Init source force -> initProject source force\n  ObCommand_Deploy dc -> case dc of\n    DeployCommand_Init deployOpts -> withProjectRoot \".\" $ \\root -> deployInit deployOpts root\n    DeployCommand_Push remoteBuilder -> do\n      deployPath <- liftIO $ canonicalizePath \".\"\n      deployBuilders <- case remoteBuilder of\n        Nothing -> pure []\n        Just RemoteBuilder_ObeliskVM -> (:[]) <$> VmBuilder.getNixBuildersArg\n      deployPush deployPath deployBuilders\n    DeployCommand_Update -> deployUpdate \".\"\n    DeployCommand_Test (platform, extraArgs) -> deployMobile platform extraArgs\n  ObCommand_Run interpretPathsList certDir servePort -> withInterpretPaths interpretPathsList (run certDir servePort)\n  ObCommand_Profile basePath rtsFlags -> profile basePath rtsFlags\n  ObCommand_Thunk to -> wrapNixThunkError $ case _thunkOption_command to of\n    ThunkCommand_Update config -> for_ thunks (updateThunkToLatest config)\n    ThunkCommand_Unpack -> for_ thunks unpackThunk\n    ThunkCommand_Pack config -> for_ thunks (packThunk config)\n    where\n      thunks = _thunkOption_thunks to\n  ObCommand_Repl mUserGhciConfig interpretPathsList -> withInterpretPaths interpretPathsList $ runRepl mUserGhciConfig\n  ObCommand_Watch interpretPathsList -> withInterpretPaths interpretPathsList runWatch\n  ObCommand_Shell (ShellOpts shellAttr interpretPathsList cmd) -> withInterpretPaths interpretPathsList $ \\root interpretPaths -> do\n    putLog Notice \"Hint: use '--no-interpret path/to/dependency' to force building an unpacked dependency and include it in this shell.\"\n    nixShellForInterpretPaths False shellAttr root interpretPaths cmd -- N.B. We do NOT bash escape here; we want to run the command as-is\n  ObCommand_Doc shellAttr pkgs -> withInterpretPaths [] $ \\root interpretPaths ->\n    nixShellForInterpretPaths True shellAttr root interpretPaths $ Just $ haddockCommand pkgs\n  ObCommand_Hoogle shell' port -> withProjectRoot \".\" $ \\root -> do\n    nixShellWithHoogle root True shell' $ Just $ \"hoogle server -p\" <> show port <> \" --local\"\n  ObCommand_Internal icmd -> case icmd of\n    ObInternal_ApplyPackages origPath inPath outPath packagePaths -> do\n      liftIO $ Preprocessor.applyPackages origPath inPath outPath packagePaths\n    ObInternal_ExportGhciConfig interpretPathsList ->\n      liftIO . putStrLn . unlines =<< withInterpretPaths interpretPathsList exportGhciConfig\n\n-- | A helper for the common case that the command you want to run needs the project root and a resolved\n-- set of interpret paths.\nwithInterpretPaths :: MonadObelisk m => [(FilePath, Interpret)] -> (FilePath -> PathTree Interpret -> m a) -> m a\nwithInterpretPaths interpretPathsList f = withProjectRoot \".\" $ \\root -> do\n  interpretPaths' <- resolveInterpretPaths $ (root, Interpret_Interpret) : interpretPathsList\n  case interpretPaths' of\n    Nothing -> failWith \"No paths provided for finding packages\"\n    Just interpretPaths -> f root interpretPaths\n\nhaddockCommand :: [String] -> String\nhaddockCommand pkgs = unwords\n  [ \"for p in\"\n  , unwords [getHaddockPath p ++ \"/index.html\" | p <- pkgs]\n  , \"; do echo $p; done\"\n  ]\n  where getHaddockPath p = \"$(ghc-pkg field \" ++ p ++ \" haddock-html --simple-output)\"\n\n--TODO: Clean up all the magic strings throughout this codebase\n\ngetArgsConfig :: IO ArgsConfig\ngetArgsConfig = pure $ ArgsConfig { _argsConfig_enableVmBuilderByDefault = System.Info.os == \"darwin\" }\n\n-- | Resolves an ordered list of paths for use with @--interpret@/@--no-interpret@ by coalescing\n--   paths into a non-ambiguous set of paths. Ambiguity is resolved by choosing right-most paths\n--   over any preceeding identical paths.\n--\n--   For example: @a/b=ON a/b/c=OFF@ and @a/b/c=OFF a/b=ON@ are the same.\n--   @a/b=ON a/b=OFF@ is reduced to @a/b=OFF@. We prefer right-biased choice to increase\n--   scriptability.\n--\n--   N.B. All the paths in the result will be canonicalized. It's impossible to determine path\n--   overlap otherwise.\nresolveInterpretPaths :: MonadIO m => [(FilePath, a)] -> m (Maybe (PathTree a))\nresolveInterpretPaths ps = do\n  trees <- liftIO $ for ps $ \\(p, a) -> pathToTree a <$> canonicalizePath p\n  pure $ foldr1 mergeTrees <$> nonEmpty trees\n  where\n    -- | Merge two 'PathTree's preferring leaves on the right in as much as they overlap with paths on the left.\n    mergeTrees :: PathTree a -> PathTree a -> PathTree a\n    mergeTrees (PathTree_Node ax x) (PathTree_Node ay y) = PathTree_Node (ay <|> ax) $ Map.unionWith mergeTrees x y\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "ObCommand"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 88,
              "startColumn": 1,
              "endLine": 100,
              "endColumn": 17,
              "from": "data ObCommand\n  = ObCommand_Init InitSource Bool |\n    ObCommand_Deploy DeployCommand |\n    ObCommand_Run [(FilePath,\n                    Interpret)] (Maybe FilePath) (Maybe PortNumber) |\n    ObCommand_Profile String [String] |\n    ObCommand_Thunk ThunkOption |\n    ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] |\n    ObCommand_Watch [(FilePath, Interpret)] |\n    ObCommand_Shell ShellOpts |\n    ObCommand_Doc String [String] |\n    ObCommand_Hoogle String Int |\n    ObCommand_Internal ObInternal\n  deriving Show",
              "to": "data ObCommand\n  = ObCommandInit InitSource Bool |\n    ObCommandDeploy DeployCommand |\n    ObCommandRun [(FilePath,\n                   Interpret)] (Maybe FilePath) (Maybe PortNumber) |\n    ObCommandProfile String [String] |\n    ObCommandThunk ThunkOption |\n    ObCommandRepl (Maybe FilePath) [(FilePath, Interpret)] |\n    ObCommandWatch [(FilePath, Interpret)] |\n    ObCommandShell ShellOpts |\n    ObCommandDoc String [String] |\n    ObCommandHoogle String Int |\n    ObCommandInternal ObInternal\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "ObInternal"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 102,
              "startColumn": 1,
              "endLine": 108,
              "endColumn": 17,
              "from": "data ObInternal\n  = ObInternal_ApplyPackages String String String [String] |\n    ObInternal_ExportGhciConfig [(FilePath, Interpret)]\n  deriving Show",
              "to": "data ObInternal\n  = ObInternalApplyPackages String String String [String] |\n    ObInternalExportGhciConfig [(FilePath, Interpret)]\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "obCommand"
              ],
              "severity": "Warning",
              "hint": "Use optional",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 119,
              "startColumn": 12,
              "endLine": 119,
              "endColumn": 157,
              "from": "Just\n  <$>\n    option\n      auto\n      (long \"port\"\n         <>\n           short 'p'\n             <>\n               help \"Port number for server; overrides common/config/route\"\n                 <> metavar \"INT\")\n  <|> pure Nothing",
              "to": "optional\n  (option\n     auto\n     (long \"port\"\n        <>\n          short 'p'\n            <>\n              help \"Port number for server; overrides common/config/route\"\n                <> metavar \"INT\"))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 119, startCol = 12, endLine = 119, endCol = 157}, subts = [(\"a\",SrcSpan {startLine = 119, startCol = 21, endLine = 119, endCol = 140})], orig = \"optional (a)\"}]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "deployCommand"
              ],
              "severity": "Warning",
              "hint": "Redundant <$>",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 154,
              "startColumn": 31,
              "endLine": 154,
              "endColumn": 47,
              "from": "(,) <$> pure IOS",
              "to": "pure ((,) IOS)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 154, startCol = 31, endLine = 154, endCol = 47}, subts = [(\"f\",SrcSpan {startLine = 154, startCol = 31, endLine = 154, endCol = 34}),(\"x\",SrcSpan {startLine = 154, startCol = 44, endLine = 154, endCol = 47})], orig = \"pure (f x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "RemoteBuilder"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 185,
              "startColumn": 1,
              "endLine": 186,
              "endColumn": 22,
              "from": "data RemoteBuilder\n  = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)",
              "to": "data RemoteBuilder\n  = RemoteBuilderObeliskVM\n  deriving (Eq, Show)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "DeployCommand"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 188,
              "startColumn": 1,
              "endLine": 193,
              "endColumn": 16,
              "from": "data DeployCommand\n  = DeployCommand_Init DeployInitOpts |\n    DeployCommand_Push (Maybe RemoteBuilder) |\n    DeployCommand_Test (PlatformDeployment, [String]) |\n    DeployCommand_Update\n  deriving Show",
              "to": "data DeployCommand\n  = DeployCommandInit DeployInitOpts |\n    DeployCommandPush (Maybe RemoteBuilder) |\n    DeployCommandTest (PlatformDeployment, [String]) |\n    DeployCommandUpdate\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "ThunkCommand"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 244,
              "startColumn": 1,
              "endLine": 248,
              "endColumn": 16,
              "from": "data ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig |\n    ThunkCommand_Unpack |\n    ThunkCommand_Pack ThunkPackConfig\n  deriving Show",
              "to": "data ThunkCommand\n  = ThunkCommandUpdate ThunkUpdateConfig |\n    ThunkCommandUnpack |\n    ThunkCommandPack ThunkPackConfig\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command"
              ],
              "decl": [
                "main'"
              ],
              "severity": "Suggestion",
              "hint": "Use if",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "startLine": 408,
              "startColumn": 9,
              "endLine": 410,
              "endColumn": 111,
              "from": "case _args_noHandOffPassed args' of\n  False -> return ()\n  True\n    -> putLog\n         Warning\n         \"--no-handoff should only be passed once and as the first argument; ignoring\"",
              "to": "(if _args_noHandOffPassed args' then\n     putLog\n       Warning\n       \"--no-handoff should only be passed once and as the first argument; ignoring\"\n else\n     return ())",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 408, startCol = 9, endLine = 410, endCol = 111}, subts = [(\"a\",SrcSpan {startLine = 408, startCol = 14, endLine = 408, endCol = 41}),(\"f\",SrcSpan {startLine = 409, startCol = 20, endLine = 409, endCol = 29}),(\"t\",SrcSpan {startLine = 410, startCol = 19, endLine = 410, endCol = 111})], orig = \"(if a then t else f)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 1.3333333333333333,
            "sum": 52
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 11,
          "lines_of_code": 274,
          "homplexity_lines_of_code": 314,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 1.3333333333333333,
              "sum": 52
            },
            "homplexity_loc": 314,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 1 1: module Obelisk.Command.Utils has 200 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has 13 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has 2 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has 13 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 233 5: data GitRef has record fields count of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 257 19: data GitHash has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Obelisk.Command.Utils where\n\nimport Control.Applicative hiding (many)\nimport Control.Monad.Except\nimport Data.Bool (bool)\nimport Data.Bifunctor\nimport Data.Char\nimport Data.Either\nimport Data.List (isInfixOf)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Maybe (maybeToList)\nimport Data.Semigroup ((<>))\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Void (Void)\nimport System.Exit (ExitCode)\nimport System.Which (staticWhich)\nimport qualified Text.Megaparsec.Char.Lexer as ML\nimport Text.Megaparsec as MP\nimport Text.Megaparsec.Char as MP\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\ncp :: FilePath\ncp = $(staticWhich \"cp\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nghcidExePath :: FilePath\nghcidExePath = $(staticWhich \"ghcid\")\n\nfindExePath :: FilePath\nfindExePath = $(staticWhich \"find\")\n\nnixExePath :: FilePath\nnixExePath = $(staticWhich \"nix\")\n\nnixBuildExePath :: FilePath\nnixBuildExePath = $(staticWhich \"nix-build\")\n\njreKeyToolPath :: FilePath\njreKeyToolPath = $(staticWhich \"keytool\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nnixPrefetchUrlPath :: FilePath\nnixPrefetchUrlPath = $(staticWhich \"nix-prefetch-url\")\n\nnixShellPath :: FilePath\nnixShellPath = $(staticWhich \"nix-shell\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nsshPath :: FilePath\nsshPath = $(staticWhich \"ssh\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nwhichPath :: FilePath\nwhichPath = $(staticWhich \"which\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nsshKeygenPath :: FilePath\nsshKeygenPath = $(staticWhich \"ssh-keygen\")\n\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\n-- TODO: Investigate the tradeoffs associated with this choice\ndockerPath :: FilePath\ndockerPath = \"docker\"\n\n-- | Nix syntax requires relative paths to be prefixed by @./@ or\n-- @../@. This will make a 'FilePath' that can be embedded in a Nix\n-- expression.\ntoNixPath :: FilePath -> FilePath\ntoNixPath root | \"/\" `isInfixOf` root = root\n               | otherwise = \"./\" <> root\n\n\n-- Check whether the working directory is clean\ncheckGitCleanStatus :: MonadObelisk m => FilePath -> Bool -> m Bool\ncheckGitCleanStatus repo withIgnored = do\n  let\n    runGit = readProcessAndLogStderr Debug . gitProc repo\n    gitStatus = runGit $ [\"status\", \"--porcelain\"] <> bool [] [\"--ignored\"] withIgnored\n    gitDiff = runGit [\"diff\"]\n  T.null <$> liftA2 (<>) gitStatus gitDiff\n\n-- | Ensure that git repo is clean\nensureCleanGitRepo :: MonadObelisk m => FilePath -> Bool -> Text -> m ()\nensureCleanGitRepo path withIgnored s =\n  withSpinnerNoTrail (\"Ensuring clean git repo at \" <> T.pack path) $ do\n    checkGitCleanStatus path withIgnored >>= \\case\n      False -> do\n        statusDebug <- readGitProcess path $ [\"status\"] <> bool [] [\"--ignored\"] withIgnored\n        putLog Warning \"Working copy is unsaved; git status:\"\n        putLog Notice statusDebug\n        failWith s\n      True -> pure ()\n\ninitGit :: MonadObelisk m => FilePath -> m ()\ninitGit repo = do\n  let git = callProcessAndLogOutput (Debug, Debug) . gitProc repo\n  git [\"init\"]\n  git [\"add\", \".\"]\n  git [\"commit\", \"-m\", \"Initial commit.\"]\n\ngitProcNoRepo :: [String] -> ProcessSpec\ngitProcNoRepo args = setEnvOverride (M.singleton \"GIT_TERMINAL_PROMPT\" \"0\" <>) $ proc gitPath args\n\ngitProc :: FilePath -> [String] -> ProcessSpec\ngitProc repo = gitProcNoRepo . runGitInDir\n  where\n    runGitInDir args' = case filter (not . null) args' of\n      args@(\"clone\":_) -> args <> [repo]\n      args -> [\"-C\", repo] <> args\n\nisolateGitProc :: ProcessSpec -> ProcessSpec\nisolateGitProc = setEnvOverride (overrides <>)\n  where\n    overrides = M.fromList\n      [ (\"HOME\", \"/dev/null\")\n      , (\"GIT_CONFIG_NOSYSTEM\", \"1\")\n      , (\"GIT_TERMINAL_PROMPT\", \"0\") -- git 2.3+\n      , (\"GIT_ASKPASS\", \"echo\") -- pre git 2.3 to just use empty password\n      , (\"GIT_SSH_COMMAND\", \"ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o GSSAPIAuthentication=no\")\n      ]\n\n-- | Recursively copy a directory using `cp -a` -- TODO: Should use -rT instead of -a\ncopyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-a\", \".\", dest] -- TODO: This will break if dest is relative since we change cwd\n\nreadGitProcess :: MonadObelisk m => FilePath -> [String] -> m Text\nreadGitProcess repo = readProcessAndLogOutput (Debug, Notice) . gitProc repo\n\nreadGitProcessNoRepo :: MonadObelisk m => [String] -> m Text\nreadGitProcessNoRepo = readProcessAndLogOutput (Debug, Notice) . gitProcNoRepo\n\nprocessToShellString :: FilePath -> [String] -> String\nprocessToShellString cmd args = unwords $ map quoteAndEscape (cmd : args)\n  where quoteAndEscape x = T.unpack $ \"'\" <> T.replace \"'\" \"'\\''\" (T.pack x) <> \"'\"\n\n-- | A simpler wrapper for CliApp's readProcessAndLogStderr with sensible defaults.\nreadProc :: MonadObelisk m => ProcessSpec -> m Text\nreadProc = readProcessAndLogOutput (Debug, Error)\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\ngitLookupDefaultBranch :: GitLsRemoteMaps -> Either Text Text\ngitLookupDefaultBranch (refs, _) = do\n  ref <- case M.lookup GitRef_Head refs of\n    Just ref -> pure ref\n    Nothing -> throwError\n      \"No symref entry for HEAD. \\\n      \\ Is your git version at least 1.8.5? \\\n      \\ Otherwise `git ls-remote --symref` will not work.\"\n  case ref of\n    GitRef_Branch b -> pure b\n    _ -> throwError $\n      \"Default ref \" <> showGitRef ref <> \" is not a branch!\"\n\ngitLookupCommitForRef :: GitLsRemoteMaps -> GitRef -> Either Text CommitId\ngitLookupCommitForRef (_, commits) ref = case M.lookup ref commits of\n  Just a -> pure a\n  Nothing -> throwError $ \"Did not find commit for \" <> showGitRef ref\n\ngitLsRemote\n  :: MonadObelisk m\n  => String\n  -> Maybe GitRef\n  -> Maybe String\n  -> m (ExitCode, GitLsRemoteMaps)\ngitLsRemote repository mRef mBranch = do\n  (exitCode, out, _err) <- case mBranch of\n    Nothing -> readCreateProcessWithExitCode $ gitProcNoRepo $\n        [\"ls-remote\", \"--exit-code\", \"--symref\", repository]\n        ++ maybeToList (T.unpack . showGitRef <$> mRef)\n    Just branchName -> readCreateProcessWithExitCode $ gitProcNoRepo\n        [\"ls-remote\", \"--exit-code\", repository, branchName]\n  let t = T.pack out\n  maps <- case MP.runParser parseLsRemote \"\" t of\n    Left err -> failWith $ T.pack $ MP.errorBundlePretty err\n    Right table -> pure $ bimap M.fromList M.fromList $ partitionEithers table\n  putLog Debug $ \"git ls-remote maps: \" <> T.pack (show maps)\n  pure (exitCode, maps)\n\nlexeme :: Parsec Void Text a -> Parsec Void Text a\nlexeme = ML.lexeme $ void $ MP.takeWhileP (Just \"within-line white space\") $\n  flip elem [' ', '\\t']\n\n-- $ git ls-remote --symref git@github.com:obsidiansystems/obelisk.git HEAD\n-- ref: refs/heads/master\tHEAD\n-- d0a8d25dc93f0acd096bc4ff2f550da9e2d0c8f5\trefs/heads/master\nparseLsRemote :: Parsec Void Text [Either (GitRef, GitRef) (GitRef, CommitId)]\nparseLsRemote =\n  many ((fmap Left (try parseRef) <|> fmap Right parseCommit) <* try MP.eol) <* MP.eof\n  where\n    parseRef :: Parsec Void Text (GitRef, GitRef)\n    parseRef = MP.label \"ref and symbolic ref\" $ do\n      _ <- lexeme \"ref:\"\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      symbolicRef <- lexeme $ MP.takeWhileP (Just \"symbolic ref\") $ not . isSpace\n      return (toGitRef symbolicRef, toGitRef ref)\n    parseCommit :: Parsec Void Text (GitRef, CommitId)\n    parseCommit = MP.label \"commit and ref\" $ do\n      commitId <- lexeme $ MP.takeWhileP (Just \"commit id\") $ not . isSpace\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      return (toGitRef ref, commitId)\n\ndata GitRef\n  = GitRef_Head\n  | GitRef_Branch Text\n  | GitRef_Tag Text\n  | GitRef_Other Text\n  deriving (Show, Eq, Ord)\n\nshowGitRef :: GitRef -> Text\nshowGitRef = \\case\n  GitRef_Head -> \"HEAD\"\n  GitRef_Branch x -> \"refs/heads/\" <> x\n  GitRef_Tag x -> \"refs/tags/\" <> x\n  GitRef_Other x -> x\n\ntoGitRef :: Text -> GitRef\ntoGitRef = \\case\n  \"HEAD\" -> GitRef_Head\n  r -> if\n    | Just s <- \"refs/heads/\" `T.stripPrefix` r -> GitRef_Branch s\n    | Just s <- \"refs/tags/\" `T.stripPrefix` r -> GitRef_Tag s\n    | otherwise -> GitRef_Other r\n\n\n-- | A Git hash. Can represent a specific commit, or a file within a\n-- commit.\nnewtype GitHash = GitHash { _gitHash_text :: T.Text }\n\n-- | Ask @git@ for the hash of a specific tree (file, directory) within\n-- the given repository. The hash of the given path is always computed\n-- with respect to the @HEAD@ revision.\ngetGitHash\n  :: MonadObelisk m\n  => FilePath -- ^ The repository to call @git@ in\n  -> FilePath -- ^ The tree to hash\n  -> m GitHash\ngetGitHash repo pathWithinRepo = do\n  let git = readProcessAndLogOutput (Debug, Debug) . gitProc repo\n  GitHash <$> git [\"rev-parse\", \"HEAD:\" <> pathWithinRepo]\n\n\ntype CommitId = Text\n\ntype GitLsRemoteMaps = (Map GitRef GitRef, Map GitRef CommitId)\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Utils"
              ],
              "decl": [
                "GitRef"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs",
              "startLine": 232,
              "startColumn": 1,
              "endLine": 237,
              "endColumn": 27,
              "from": "data GitRef\n  = GitRef_Head |\n    GitRef_Branch Text |\n    GitRef_Tag Text |\n    GitRef_Other Text\n  deriving (Show, Eq, Ord)",
              "to": "data GitRef\n  = GitRefHead |\n    GitRefBranch Text |\n    GitRefTag Text |\n    GitRefOther Text\n  deriving (Show, Eq, Ord)",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Utils.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 14,
            "average": 3,
            "sum": 93
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 4,
            "suggestion": 3,
            "ignore": 0,
            "total": 7
          },
          "syntax_errors": 32,
          "lines_of_code": 530,
          "homplexity_lines_of_code": 704,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 14,
              "average": 3,
              "sum": 93
            },
            "homplexity_loc": 704,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"initProject\": 14,\n        \"obeliskSourceWithBranch\": 1,\n        \"toObeliskDir\": 1,\n        \"toImplDir\": 1,\n        \"callHandoffOb\": 3,\n        \"findProjectObeliskCommand\": 9,\n        \"getUmask\": 3,\n        \"findProjectRoot\": 4,\n        \"withProjectRoot\": 2,\n        \"walkToProjectRoot\": 9,\n        \"walkToImplDir\": 3,\n        \"isWellOwnedAndWellPermissioned\": 3,\n        \"isOwnedBy\": 1,\n        \"filePermissionIsSafe\": 3,\n        \"nixShellRunConfig\": 5,\n        \"bashEscape\": 1,\n        \"shEscape\": 1,\n        \"nixShellRunProc\": 1,\n        \"mkObNixShellProc\": 5,\n        \"nixShellWithoutPkgs\": 2,\n        \"nixShellWithHoogle\": 4,\n        \"describeImpureAssetSource\": 1,\n        \"findProjectAssets\": 6,\n        \"getHaskellManifestProjectPath\": 2,\n        \"watchStaticFilesDerivation\": 8,\n        \"handleBuildFailure\": 2,\n        \"buildStaticCatchErrors\": 1,\n        \"buildStaticFilesDerivationAndSymlink\": 1,\n        \"min\": 1,\n        \"max\": 14,\n        \"average\": 3.207,\n        \"sum\": 93\n    },\n    \"homplexity_loc\": 704\n}\n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\n\nmodule Obelisk.Command.Project\n  ( InitSource (..)\n  , findProjectObeliskCommand\n  , findProjectRoot\n  , findProjectAssets\n  , initProject\n  , nixShellRunConfig\n  , nixShellRunProc\n  , nixShellWithHoogle\n  , nixShellWithoutPkgs\n  , mkObNixShellProc\n  , obeliskDirName\n  , toImplDir\n  , toObeliskDir\n  , withProjectRoot\n  , bashEscape\n  , shEscape\n  , getHaskellManifestProjectPath\n  , AssetSource(..)\n  , describeImpureAssetSource\n  , watchStaticFilesDerivation\n  ) where\n\nimport Control.Concurrent.MVar (MVar, newMVar, withMVarMasked)\nimport Control.Lens ((.~), (?~), (<&>))\nimport Control.Monad\nimport Control.Monad.Except\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Log\nimport Control.Monad.State\nimport qualified Data.Aeson as Json\nimport qualified Data.ByteString.UTF8 as BSU\nimport Data.Bits\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default (def)\nimport qualified Data.Foldable as F (toList)\nimport Data.Function ((&), on)\nimport Data.Map (Map)\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8, encodeUtf8)\nimport Data.Traversable (for)\nimport \"nix-thunk\" Nix.Thunk\nimport Reflex\nimport Reflex.FSNotify\nimport Reflex.Host.Headless\nimport System.Directory\nimport System.Environment (lookupEnv)\nimport System.Exit (ExitCode(..))\nimport System.FilePath\nimport System.FSNotify (defaultConfig, eventPath, WatchConfig(..), WatchMode(..))\nimport qualified System.Info as Sys\nimport System.IO.Temp\nimport System.IO.Unsafe (unsafePerformIO)\nimport System.PosixCompat.Files\nimport System.PosixCompat.Types\nimport System.PosixCompat.User\nimport qualified System.Process as Proc\nimport Text.ShellEscape (sh, bash, bytes)\n\nimport GitHub.Data.GitData (Branch)\nimport GitHub.Data.Name (Name)\n\nimport Obelisk.App (MonadObelisk, runObelisk, getObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Cli.Extras\nimport Obelisk.Command.Utils (nixBuildExePath, nixExePath, toNixPath, cp, nixShellPath, lnPath)\n\n--TODO: Make this module resilient to random exceptions\n\n--TODO: Don't hardcode this\n-- | Source for the Obelisk project\nobeliskSource :: ThunkSource\nobeliskSource = obeliskSourceWithBranch \"master\"\n\n-- | Source for obelisk developer targeting a specific obelisk branch\nobeliskSourceWithBranch :: Name Branch -> ThunkSource\nobeliskSourceWithBranch branch = ThunkSource_GitHub $ GitHubSource\n  { _gitHubSource_owner = \"obsidiansystems\"\n  , _gitHubSource_repo = \"obelisk\"\n  , _gitHubSource_branch = Just branch\n  , _gitHubSource_private = False\n  }\n\ndata InitSource\n  = InitSource_Default\n  | InitSource_Branch (Name Branch)\n  | InitSource_Symlink FilePath\n  deriving Show\n\nobeliskDirName :: FilePath\nobeliskDirName = \".obelisk\"\n\n-- | Path to obelisk directory in given path\ntoObeliskDir :: FilePath -> FilePath\ntoObeliskDir p = p </> obeliskDirName\n\n-- | Path to impl file in given path\ntoImplDir :: FilePath -> FilePath\ntoImplDir p = toObeliskDir p </> \"impl\"\n\n-- | Create a new project rooted in the current directory\ninitProject :: forall m. MonadObelisk m => InitSource -> Bool -> m ()\ninitProject source force = withSystemTempDirectory \"ob-init\" $ \\tmpDir -> do\n  let implDir = toImplDir tmpDir\n      obDir   = toObeliskDir tmpDir\n  liftIO (listDirectory \".\") >>= \\case\n    [] -> pure ()\n    _ | force -> putLog Warning \"Initializing in non-empty directory\"\n      | otherwise -> failWith \"ob init requires an empty directory. Use the flag --force to init anyway, potentially overwriting files.\"\n  skeleton <- withSpinner \"Setting up obelisk\" $ do\n    liftIO $ createDirectory obDir\n    -- Clone the git source and repack it with the init source obelisk\n    -- The purpose of this is to ensure we use the correct thunk spec.\n    let cloneAndRepack :: ThunkSource -> m ()\n        cloneAndRepack src = do\n          putLog Debug $ \"Cloning obelisk into \" <> T.pack implDir <> \" and repacking using itself\"\n          commit <- wrapNixThunkError $ getLatestRev src\n          wrapNixThunkError $ gitCloneForThunkUnpack (thunkSourceToGitSource src) (_thunkRev_commit commit) implDir\n          callHandoffOb implDir [\"thunk\", \"pack\", implDir]\n    case source of\n      InitSource_Default -> cloneAndRepack obeliskSource\n      InitSource_Branch branch -> cloneAndRepack $ obeliskSourceWithBranch branch\n      InitSource_Symlink path -> do\n        let symlinkPath = if isAbsolute path\n              then path\n              else \"..\" </> path\n        liftIO $ createSymbolicLink symlinkPath implDir\n    _ <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"command\"\n    skel <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"skeleton\" --TODO: I don't think there's actually any reason to cache this\n\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--preserve=links\"\n        , obDir\n        , toObeliskDir \".\"\n        ]\n    pure skel\n\n  withSpinner \"Copying project skeleton\" $ do\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--no-preserve=mode\"\n        , \"-T\"\n        , skeleton </> \".\"\n        , \".\"\n        ]\n  liftIO $ do\n    let configDir = \"config\"\n    createDirectoryIfMissing False configDir\n    mapM_ (createDirectoryIfMissing False . (configDir </>)) [\"backend\", \"common\", \"frontend\"]\n  putLog Notice $ T.intercalate \"\\n\"\n    [ \"An obelisk project has been successfully initialized. Next steps:\"\n    , \"  'ob run': Start a development server\"\n    , \"  'ob watch': Watch for changes without starting a server\"\n    , \"  'ob repl': Load your project into GHCi\"\n    ]\n\ncallHandoffOb\n  :: MonadObelisk m\n  => FilePath -- ^ Directory of the obelisk we want to handoff to\n  -> [String] -- ^ Arguments to pass to ob\n  -> m ()\ncallHandoffOb dir args = do\n  obeliskCommandPkg <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ Target\n      { _target_path = Just dir\n      , _target_attr = Just \"command\"\n      , _target_expr = Nothing\n      }\n  let impl = obeliskCommandPkg </> \"bin\" </> \"ob\"\n  -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n  putLog Debug $ \"Running '\" <> T.pack (unwords args) <> \"' with \" <> T.pack impl\n  callProcessAndLogOutput (Debug, Warning) (proc impl (\"--no-handoff\" : args))\n\n--TODO: Allow the user to ignore our security concerns\n-- | Find the Obelisk implementation for the project at the given path\nfindProjectObeliskCommand :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectObeliskCommand target = do\n  myUid <- liftIO getRealUserID\n  processUmask <- liftIO getUmask\n  targetStat <- liftIO $ getFileStatus target\n  (result, insecurePaths) <- flip runStateT [] $ walkToProjectRoot target targetStat processUmask myUid >>= \\case\n    Nothing -> pure Nothing\n    Just projectRoot -> liftIO (doesDirectoryExist $ toImplDir projectRoot) >>= \\case\n      False -> do\n        putLog Warning $ \"Found obelisk directory in \" <> T.pack projectRoot <> \" but the implementation (impl) file is missing\"\n        pure Nothing\n      True -> do\n        walkToImplDir projectRoot myUid processUmask -- For security check\n        return $ Just projectRoot\n  case (result, insecurePaths) of\n    (Just projDir, []) -> do\n      obeliskCommandPkg <- wrapNixThunkError $ nixBuildAttrWithCache (toImplDir projDir) \"command\"\n      return $ Just $ obeliskCommandPkg </> \"bin\" </> \"ob\"\n    (Nothing, _) -> return Nothing\n    (Just projDir, _) -> do\n      putLog Error $ T.unlines\n        [ \"Error: Found a project at \" <> T.pack (normalise projDir) <> \", but had to traverse one or more insecure directories to get there:\"\n        , T.unlines $ fmap (T.pack . normalise) insecurePaths\n        , \"Please ensure that all of these directories are owned by you, not world-writable, and no more group-writable than permitted by your umask.\"\n        ]\n      return Nothing\n\n-- | Get the umask for the Obelisk process.\n--\n-- Because of\n-- http://man7.org/linux/man-pages/man2/umask.2.html#NOTES we have to set the\n-- umask to read it. We are using 'withMVarMasked' to guarantee that setting and\n-- reading isn't interrupted by any exception or interleaved with another thread.\ngetUmask :: IO FileMode\ngetUmask = withMVarMasked globalUmaskLock $ \\() -> do\n  initialMask <- setFileCreationMask safeUmask\n  void (setFileCreationMask initialMask)\n  pure initialMask\n  where\n    safeUmask :: FileMode\n    safeUmask = CMode 0o22\n\n{-# NOINLINE globalUmaskLock #-}\nglobalUmaskLock :: MVar ()\nglobalUmaskLock = unsafePerformIO (newMVar ())\n\n-- | Get the FilePath to the containing project directory, if there is one\nfindProjectRoot :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectRoot target = do\n  myUid <- liftIO getRealUserID\n  targetStat <- liftIO $ getFileStatus target\n  umask <- liftIO getUmask\n  (result, _) <- liftIO $ runStateT (walkToProjectRoot target targetStat umask myUid) []\n  return $ makeRelative \".\" <$> result\n\nwithProjectRoot :: MonadObelisk m => FilePath -> (FilePath -> m a) -> m a\nwithProjectRoot target f = findProjectRoot target >>= \\case\n  Nothing -> failWith \"Must be used inside of an Obelisk project\"\n  Just root -> f root\n\n-- | Walk from the current directory to the containing project's root directory,\n-- if there is one, accumulating potentially insecure directories that were\n-- traversed in the process.  Return the project root directory, if found.\nwalkToProjectRoot\n  :: (MonadState [FilePath] m, MonadIO m)\n  => FilePath -> FileStatus -> FileMode -> UserID -> m (Maybe FilePath)\nwalkToProjectRoot this thisStat desiredUmask myUid = liftIO (doesDirectoryExist this) >>= \\case\n  -- It's not a directory, so it can't be a project\n  False -> do\n    let dir = takeDirectory this\n    dirStat <- liftIO $ getFileStatus dir\n    walkToProjectRoot dir dirStat desiredUmask myUid\n  True -> do\n    when (not $ isWellOwnedAndWellPermissioned thisStat myUid desiredUmask) $ modify (this:)\n    liftIO (doesDirectoryExist $ toObeliskDir this) >>= \\case\n      True -> return $ Just this\n      False -> do\n        let next = this </> \"..\" -- Use \"..\" instead of chopping off path segments, so that if the current directory is moved during the traversal, the traversal stays consistent\n        nextStat <- liftIO $ getFileStatus next\n        let fileIdentity fs = (deviceID fs, fileID fs)\n            isSameFileAs = (==) `on` fileIdentity\n        if thisStat `isSameFileAs` nextStat\n          then return Nothing -- Found a cycle; probably hit root directory\n          else walkToProjectRoot next nextStat desiredUmask myUid\n\n-- | Walk from the given project root directory to its Obelisk implementation\n-- directory, accumulating potentially insecure directories that were traversed\n-- in the process.\nwalkToImplDir :: (MonadState [FilePath] m, MonadIO m) => FilePath -> UserID -> FileMode -> m ()\nwalkToImplDir projectRoot myUid umask = do\n  let obDir = toObeliskDir projectRoot\n  obDirStat <- liftIO $ getFileStatus obDir\n  when (not $ isWellOwnedAndWellPermissioned obDirStat myUid umask) $ modify (obDir:)\n  let implThunk = obDir </> \"impl\"\n  implThunkStat <- liftIO $ getFileStatus implThunk\n  when (not $ isWellOwnedAndWellPermissioned implThunkStat myUid umask) $ modify (implThunk:)\n\n-- | Check to see if directory is writable by a user whose User ID matches the\n-- second argument provided, and if the fact that other people can write to that\n-- directory is in accordance with the umask of the system, passed as the third\n-- argument.\nisWellOwnedAndWellPermissioned :: FileStatus -> UserID -> FileMode -> Bool\nisWellOwnedAndWellPermissioned s uid umask = isOwnedBy s uid && filePermissionIsSafe s umask\n\nisOwnedBy :: FileStatus -> UserID -> Bool\nisOwnedBy s uid = fileOwner s == uid\n\n-- | Check to see if a directory respect the umask, but check explicitly that\n-- it's not world writable in any case.\nfilePermissionIsSafe :: FileStatus -> FileMode -> Bool\nfilePermissionIsSafe s umask = not fileWorldWritable && fileGroupWritable <= umaskGroupWritable\n  where\n    fileWorldWritable = fileMode s .&. 0o002 == 0o002\n    fileGroupWritable = fileMode s .&. 0o020 == 0o020\n    umaskGroupWritable = umask .&. 0o020 == 0\n\nnixShellRunConfig :: MonadObelisk m => FilePath -> Bool -> Maybe String -> m NixShellConfig\nnixShellRunConfig root isPure command = do\n  nixpkgsPath <- fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath [\"eval\", \"--impure\", \"--expr\", \"(import .obelisk/impl {}).nixpkgs.path\"]\n  nixRemote <- liftIO $ lookupEnv \"NIX_REMOTE\"\n  pure $ def\n    & nixShellConfig_pure .~ isPure\n    & nixShellConfig_common . nixCmdConfig_target .~ (def & target_path .~ Nothing)\n    & nixShellConfig_run .~ (command <&> \\cs -> unwords $ concat\n      [ [\"export\", BSU.toString . bytes . bash $ \"NIX_PATH=nixpkgs=\" <> encodeUtf8 nixpkgsPath, \";\"]\n      , maybe [] (\\v -> [\"export\", BSU.toString . bytes . bash $ \"NIX_REMOTE=\" <> encodeUtf8 (T.pack v), \";\"]) nixRemote\n      , [cs]\n      ])\n\n-- | Escape using ANSI C-style quotes @$''@\n-- This does not work with all shells! Ideally, we would control exactly which shell is used,\n-- down to its sourced configuration, throughout the obelisk environment. At this time, this\n-- is not feasible.\nbashEscape :: String -> String\nbashEscape = BSU.toString . bytes . bash . BSU.fromString\n\n-- | Escape using Bourne style shell escaping\n-- This is not as robust, but is necessary if we are passing to a shell we don't control.\n-- The most prominent issue is that 'System.Process' executes shell commands by invoking\n-- @\\/bin\\/sh@ instead of something configurable. While we can avoid this by specifying a shell manually,\n-- we cannot guarantee that our dependencies do the same. In particular, ghcid invokes its\n-- subcommands that way.\nshEscape :: String -> String\nshEscape = BSU.toString . bytes . sh . BSU.fromString\n\nnixShellRunProc :: NixShellConfig -> ProcessSpec\nnixShellRunProc cfg = setDelegateCtlc True $ proc nixShellPath $ runNixShellConfig cfg\n\nmkObNixShellProc\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ProcessSpec\nmkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  packageNamesAndAbsPaths <- liftIO $ for packageNamesAndPaths makeAbsolute\n  defShellConfig <- nixShellRunConfig root isPure command\n  let setCwd_ = if chdirToRoot then setCwd (Just root) else id\n  pure $ setCwd_ $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{root, pkgs, shell}: ((import root {}).passthru.__unstable__.self.extend (_: _: {\\\n          \\shellPackages = builtins.fromJSON pkgs;\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~\n        [ rawArg \"root\" $ toNixPath $ if chdirToRoot then \".\" else root\n        , strArg \"pkgs\" (T.unpack $ decodeUtf8 $ BSL.toStrict $ Json.encode packageNamesAndAbsPaths)\n        , strArg \"shell\" shellAttr\n        ]\n\nnixShellWithoutPkgs\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ()\nnixShellWithoutPkgs root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  runProcess_ =<< mkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command\n\nnixShellWithHoogle :: MonadObelisk m => FilePath -> Bool -> String -> Maybe String -> m ()\nnixShellWithHoogle root isPure shell' command = do\n  defShellConfig <- nixShellRunConfig root isPure command\n  runProcess_ $ setCwd (Just root) $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{shell}: ((import ./. {}).passthru.__unstable__.self.extend (_: super: {\\\n          \\userSettings = super.userSettings // { withHoogle = true; };\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~ [ strArg \"shell\" shell' ]\n\n-- | Describes the provenance of static assets (i.e., are they the result of a derivation\n-- that was built, or just a folder full of files.\ndata AssetSource = AssetSource_Derivation\n                 | AssetSource_Files\n  deriving (Eq)\n\n-- | Some log messages to make it easier to tell where static files are coming from\ndescribeImpureAssetSource :: AssetSource -> Text -> Text\ndescribeImpureAssetSource src path = case src of\n  AssetSource_Files -> \"Assets impurely loaded from: \" <> path\n  AssetSource_Derivation -> \"Assets derivation built and impurely loaded from: \" <> path\n\n-- | Determine where the static files of a project are and whether they're plain files or a derivation.\n-- If they are a derivation, that derivation will be built.\nfindProjectAssets :: MonadObelisk m => FilePath -> m (AssetSource, Text)\nfindProjectAssets root = do\n  isDerivation <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath\n      [ \"eval\"\n      , \"--impure\"\n      , \"--expr\"\n      , \"(let a = import ./. {}; in toString (a.reflex.nixpkgs.lib.isDerivation a.passthru.staticFilesImpure))\"\n      , \"--raw\"\n      -- `--raw` is not available with old nix-instantiate. It drops quotation\n      -- marks and trailing newline, so is very convenient for shelling out.\n      ]\n  -- Check whether the impure static files are a derivation (and so must be built)\n  if isDerivation == \"1\"\n    then do\n      _ <- buildStaticFilesDerivationAndSymlink\n        (readProcessAndLogStderr Debug)\n        root\n      pure (AssetSource_Derivation, T.pack $ root </> \"static.out\")\n    else fmap (AssetSource_Files,) $ do\n      path <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc nixExePath [\"eval\", \"-f\", \".\", \"passthru.staticFilesImpure\", \"--raw\"]\n      _ <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc lnPath [\"-sfT\", T.unpack path, \"./static.out\"]\n      pure path\n\n-- | Get the nix store path to the generated static asset manifest module (e.g., \"obelisk-generated-static\")\ngetHaskellManifestProjectPath :: MonadObelisk m => FilePath -> m Text\ngetHaskellManifestProjectPath root = fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n  proc nixBuildExePath\n    [ \"--no-out-link\"\n    , \"-E\"\n    , \"(let a = import ./. {}; in a.passthru.processedStatic.haskellManifest)\"\n    ]\n\n-- | Watch the common, backend, frontend, and static directories for file\n-- changes and check whether those file changes cause changes in the static\n-- files nix derivation. If so, rebuild it.\nwatchStaticFilesDerivation\n  :: (MonadIO m, MonadObelisk m)\n  => FilePath\n  -> m ()\nwatchStaticFilesDerivation root = do\n  ob <- getObelisk\n  liftIO $ runHeadlessApp $ do\n    pb <- getPostBuild\n    -- TODO: Instead of filtering like this, we should figure out what the\n    -- derivation actually relies on, or at least use the gitignore\n    let filterEvents x =\n          let fn = takeFileName x\n              dirs = Set.fromList $ splitDirectories x\n              ignoredFilenames = Set.fromList\n                [ \"4913\" -- Vim temporary file\n                ]\n              ignoredExtensions = Set.fromList\n                [ \".hi\"\n                , \".o\"\n                , \".swo\"\n                , \".swp\"\n                ]\n          in not $\n              fn `Set.member` ignoredFilenames ||\n              takeExtension fn `Set.member` ignoredExtensions\n        cfg = defaultConfig\n          -- On macOS, use the polling backend due to\n          -- https://github.com/luite/hfsevents/issues/13\n            { confWatchMode =\n                if Sys.os == \"darwin\"\n                  then WatchModePoll 250000\n                  else WatchModeOS\n            }\n        watch' pkg = fmap (:[]) <$> watchDirectoryTree cfg (root </> pkg <$ pb) (filterEvents . eventPath)\n    rebuild <- batchOccurrences 0.25 =<< mergeWith (<>) <$> mapM watch'\n      [ \"frontend\"\n      , \"backend\"\n      , \"common\"\n      , \"static\"\n      ]\n    performEvent_\n      $ liftIO\n      . runObelisk ob\n      . putLog Debug\n      . (\"Regenerating static.out due to file changes: \"<>)\n      . T.intercalate \", \"\n      . Set.toList\n      . Set.fromList\n      . fmap (T.pack . eventPath)\n      . concat\n      . F.toList\n      <$> rebuild\n    void $ flip throttleBatchWithLag rebuild $ \\e ->\n      performEvent $ ffor e $ \\_ -> liftIO $ runObelisk ob $ do\n        putLog Notice \"Static assets being built...\"\n        buildStaticCatchErrors >>= \\case\n          Nothing -> pure ()\n          Just n -> do\n            putLog Notice $ \"Static assets built and symlinked to static.out\"\n            putLog Debug $ \"Generated static asset nix path: \" <> n\n    pure never\n  where\n    handleBuildFailure\n      :: MonadObelisk m\n      => (ExitCode, String, String)\n      -> m (Maybe Text)\n    handleBuildFailure (ex, out, err) = case ex of\n      ExitSuccess ->\n        let out' = T.strip $ T.pack out\n        in pure $ if T.null out' then Nothing else Just out'\n      _ -> do\n        putLog Error $\n          (\"Static assets build failed: \" <>) $\n            T.unlines $ reverse $ take 20 $ reverse $ T.lines $ T.pack err\n        pure Nothing\n    buildStaticCatchErrors :: MonadObelisk m => m (Maybe Text)\n    buildStaticCatchErrors = handleBuildFailure =<<\n      buildStaticFilesDerivationAndSymlink\n        readCreateProcessWithExitCode\n        root\n\nbuildStaticFilesDerivationAndSymlink\n  :: MonadObelisk m\n  => (ProcessSpec -> m a)\n  -> FilePath\n  -> m a\nbuildStaticFilesDerivationAndSymlink f root = f $\n  setCwd (Just root) $ ProcessSpec\n    { _processSpec_createProcess = Proc.proc\n        nixBuildExePath\n        [ \"-o\", \"static.out\"\n        , \"-E\", \"(import ./. {}).passthru.staticFilesImpure\"\n        ]\n    , _processSpec_overrideEnv = Nothing\n    }\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "InitSource"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 93,
              "startColumn": 1,
              "endLine": 97,
              "endColumn": 16,
              "from": "data InitSource\n  = InitSource_Default |\n    InitSource_Branch (Name Branch) |\n    InitSource_Symlink FilePath\n  deriving Show",
              "to": "data InitSource\n  = InitSourceDefault |\n    InitSourceBranch (Name Branch) |\n    InitSourceSymlink FilePath\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "walkToProjectRoot"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 262,
              "startColumn": 5,
              "endLine": 262,
              "endColumn": 76,
              "from": "when\n  (not $ isWellOwnedAndWellPermissioned thisStat myUid desiredUmask)",
              "to": "unless (isWellOwnedAndWellPermissioned thisStat myUid desiredUmask)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 262, startCol = 5, endLine = 262, endCol = 76}, subts = [(\"x\",SrcSpan {startLine = 262, startCol = 17, endLine = 262, endCol = 75})], orig = \"unless (x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "walkToImplDir"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 281,
              "startColumn": 3,
              "endLine": 281,
              "endColumn": 68,
              "from": "when (not $ isWellOwnedAndWellPermissioned obDirStat myUid umask)",
              "to": "unless (isWellOwnedAndWellPermissioned obDirStat myUid umask)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 281, startCol = 3, endLine = 281, endCol = 68}, subts = [(\"x\",SrcSpan {startLine = 281, startCol = 15, endLine = 281, endCol = 67})], orig = \"unless (x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "walkToImplDir"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 284,
              "startColumn": 3,
              "endLine": 284,
              "endColumn": 72,
              "from": "when\n  (not $ isWellOwnedAndWellPermissioned implThunkStat myUid umask)",
              "to": "unless (isWellOwnedAndWellPermissioned implThunkStat myUid umask)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 284, startCol = 3, endLine = 284, endCol = 72}, subts = [(\"x\",SrcSpan {startLine = 284, startCol = 15, endLine = 284, endCol = 71})], orig = \"unless (x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "AssetSource"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 386,
              "startColumn": 1,
              "endLine": 388,
              "endColumn": 16,
              "from": "data AssetSource\n  = AssetSource_Derivation | AssetSource_Files\n  deriving (Eq)",
              "to": "data AssetSource\n  = AssetSourceDerivation | AssetSourceFiles\n  deriving (Eq)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "watchStaticFilesDerivation"
              ],
              "severity": "Warning",
              "hint": "Redundant <$>",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 470,
              "startColumn": 16,
              "endLine": 475,
              "endColumn": 8,
              "from": "batchOccurrences 0.25\n  =<<\n    mergeWith (<>)\n      <$> mapM watch' [\"frontend\", \"backend\", \"common\", \"static\"]",
              "to": "batchOccurrences 0.25 . mergeWith (<>)\n  =<< mapM watch' [\"frontend\", \"backend\", \"common\", \"static\"]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 470, startCol = 16, endLine = 475, endCol = 8}, subts = [(\"f\",SrcSpan {startLine = 470, startCol = 42, endLine = 470, endCol = 56}),(\"g\",SrcSpan {startLine = 470, startCol = 16, endLine = 470, endCol = 37}),(\"x\",SrcSpan {startLine = 470, startCol = 61, endLine = 475, endCol = 8})], orig = \"g . f =<< x\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Project"
              ],
              "decl": [
                "watchStaticFilesDerivation"
              ],
              "severity": "Suggestion",
              "hint": "Redundant $",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "startLine": 494,
              "startColumn": 27,
              "endLine": 494,
              "endColumn": 28,
              "from": "putLog Notice $ \"Static assets built and symlinked to static.out\"",
              "to": "putLog Notice \"Static assets built and symlinked to static.out\"",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 494, startCol = 13, endLine = 494, endCol = 78}, subts = [(\"a\",SrcSpan {startLine = 494, startCol = 13, endLine = 494, endCol = 26}),(\"b\",SrcSpan {startLine = 494, startCol = 29, endLine = 494, endCol = 78})], orig = \"a b\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Project.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Project.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Project.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.0714285714285714,
            "sum": 15
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 10,
          "lines_of_code": 202,
          "homplexity_lines_of_code": 236,
          "code_quality_score": 46.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.0714285714285714,
              "sum": 15
            },
            "homplexity_loc": 236,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 1 1: module Obelisk.Command.VmBuilder has 136 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 27 1: type signature for getNixBuildersArg has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 27 1: type signature for getNixBuildersArg has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 36 1: type signature for checkForNixDarwin has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 36 1: type signature for checkForNixDarwin has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has 17 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 58 1: type signature for nixBuildersArgString has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 58 1: type signature for nixBuildersArgString has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 62 1: type signature for containerName has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 62 1: type signature for containerName has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 66 1: type signature for containerExists has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 66 1: type signature for containerExists has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has 10 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 81 1: type signature for containerSshPort has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 81 1: type signature for containerSshPort has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 85 1: type signature for startContainer has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 85 1: type signature for startContainer has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 91 1: type signature for setupNixDocker has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 91 1: type signature for setupNixDocker has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has 20 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 120 1: type signature for setupInstructions has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 120 1: type signature for setupInstructions has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has 16 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 140 1: type signature for sshConfigHost has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 140 1: type signature for sshConfigHost has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 150 1: type signature for getDockerBuilderStateDir has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 150 1: type signature for getDockerBuilderStateDir has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 154 1: type signature for testLinuxBuild has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 154 1: type signature for testLinuxBuild has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has 11 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 170 1: type signature for dockerfile has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 170 1: type signature for dockerfile has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 201 1: type signature for sshKeyFileName has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 201 1: type signature for sshKeyFileName has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has 1 lines of code \n"
          },
          "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\nmodule Obelisk.Command.VmBuilder where\n\nimport Control.Applicative (liftA2)\nimport Control.Monad (when, unless)\nimport Control.Monad.Catch (handle)\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Monoid ((<>))\nimport Data.String (IsString)\nimport Data.String.Here.Uninterpolated (hereLit)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory (createDirectoryIfMissing)\nimport System.Exit (ExitCode(..))\nimport System.FilePath ((<.>), (</>))\nimport qualified System.Info\n\nimport Obelisk.App (MonadObelisk, getObeliskUserStateDir)\nimport Obelisk.Command.Utils (rmPath, whichPath, sshKeygenPath, nixBuildExePath, dockerPath)\nimport Cli.Extras\n\n-- | Generate the `--builders` argument string to enable the VM builder after ensuring it is available.\ngetNixBuildersArg :: MonadObelisk m => m String\ngetNixBuildersArg = do\n  stateDir <- liftIO getDockerBuilderStateDir\n  let sshIdFile = stateDir </> sshKeyFileName\n  checkForNixDarwin sshIdFile\n  exists <- containerExists stateDir\n  if exists then startContainer else setupNixDocker stateDir\n  pure $ nixBuildersArgString stateDir\n\ncheckForNixDarwin :: MonadObelisk m => String -> m ()\ncheckForNixDarwin sshIdFile = do\n  (exitCode, _, _) <- readCreateProcessWithExitCode $ proc whichPath [\"darwin-rebuild\"]\n  unless (exitCode == ExitSuccess) $ failWith $ T.intercalate \"\\n\"\n    [ \"Deployments from macOS require nix-darwin to be installed.\"\n    , \"Follow the installation instructions here: https://github.com/LnL7/nix-darwin\"\n    , \"You'll also need to add the following to your 'configuration.nix' and run 'darwin-rebuild switch':\"\n    , \"\"\n    , T.intercalate \"\\n\" $ map (\"  \" <>)\n      [ \"nix.distributedBuilds = true;\"\n      , \"nix.buildMachines = [{\"\n      , \" hostName = \" <> T.pack (show (containerName :: String)) <> \";\"\n      , \" sshUser = \\\"root\\\";\"\n      , \" sshKey = \" <> T.pack (show sshIdFile) <> \";\"\n      , \" sshPort = \" <> T.pack (show containerSshPort) <> \";\"\n      , \" systems = [ \\\"x86_64-linux\\\" ];\"\n      , \" maxJobs = 2;\"\n      , \"}];\"\n      ]\n    ]\n\n-- | String to pass to nix's `--builders` arguments to enable the VM builder.\nnixBuildersArgString :: FilePath -> String\nnixBuildersArgString stateDir = unwords [containerName, \"x86_64-linux\", stateDir </> sshKeyFileName, \"1\", \"1\", \"kvm\"]\n\n-- | Name of Docker container used for the VM builder.\ncontainerName :: IsString str => str\ncontainerName = \"obelisk-docker-nix-builder\"\n\n-- | Check to see if the Docker container exists. This will exit with a helpful message if Docker is not installed.\ncontainerExists :: MonadObelisk m => FilePath -> m Bool\ncontainerExists stateDir = handle (\\(_ :: IOError) -> failWith needDockerMsg) $ do\n  containerNames <- fmap (map T.strip . T.lines) $\n    readProcessAndLogStderr Error $\n      proc dockerPath [\"container\", \"list\", \"--all\", \"--format\", \"{{.Names}}\"]\n  let exists = containerName `elem` containerNames\n  when exists $ testLinuxBuild stateDir\n  pure exists\n  where\n    needDockerMsg = T.intercalate \"\\n\"\n      [ \"This feature requires that you have Docker installed and the `docker` command available on your PATH.\"\n      , \"Please go https://docs.docker.com/ to install Docker and try this command again.\"\n      ]\n\n-- | SSH port on localhost that connects to the container.\ncontainerSshPort :: Int\ncontainerSshPort = 2222\n\n-- | Start the Docker container; assumes it already exists.\nstartContainer :: MonadObelisk m => m ()\nstartContainer = withSpinner \"Starting VM builder\" $\n  callProcessAndLogOutput (Debug, Debug) $\n    proc dockerPath [\"start\", containerName]\n\n-- | Creates the Docker container; assumes it does not exist.\nsetupNixDocker :: MonadObelisk m => FilePath -> m ()\nsetupNixDocker stateDir = withSpinner (\"Creating Docker container named \" <> containerName) $ do\n  liftIO $ do\n    createDirectoryIfMissing True stateDir\n    T.writeFile (stateDir </> \"Dockerfile\") dockerfile\n\n  -- Create new SSH keys for this container\n  callProcessAndLogOutput (Debug, Error) $\n    proc rmPath [\"-f\", stateDir </> sshKeyFileName, stateDir </> sshKeyFileName <.> \"pub\"]\n  callProcessAndLogOutput (Debug, Error) $\n    proc sshKeygenPath [\"-t\", \"ed25519\", \"-f\", stateDir </> sshKeyFileName, \"-P\", \"\"]\n\n  -- Build the docker container (which uses the SSH keys in the 'ssh' folder)\n  containerId <- fmap T.strip $ readProcessAndLogStderr Error $\n    proc dockerPath [\"build\", stateDir, \"--quiet\"]\n  callProcessAndLogOutput (Debug, Error) $ proc dockerPath\n    [ \"run\"\n    , \"--restart\", \"always\"\n    , \"--detach\"\n    , \"--publish\", show containerSshPort <> \":22\"\n    , \"--name\", T.unpack containerName, T.unpack containerId\n    ]\n  exists <- containerExists stateDir\n  unless exists $\n    failWith $ \"Expected to see docker container named \" <> containerName <> \" but it does not exist.\"\n\n  testLinuxBuild stateDir\n\n-- | The instructions for setting up SSH access to the container for the Nix daemon.\nsetupInstructions :: FilePath -> Text\nsetupInstructions sshIdFile = T.unlines\n  [ \"Setting Up Docker Nix Builder\"\n  , \"-----------------------------\"\n  , \"\"\n  , \"We've created a Docker container that can build for Linux. However, the Nix\"\n  , \"daemon needs to connect to this container as root. Please run the following\"\n  , \"commands in a root shell (`sudo su -`) to tell SSH how to access the\"\n  , \"container. Then try your obelisk command again.\"\n  , \"\"\n  , \"# sudo su -\"\n  , \"touch ~/.ssh/config\"\n  , \"cat >> ~/.ssh/config <<CONF\"\n  , \"\"\n  , sshConfigHost sshIdFile\n  , \"CONF\"\n  , \"ssh \" <> containerName <> \" nix --version # Answer 'yes' if prompted\"\n  ]\n\n-- | SSH configuration for `.ssh/config` to connect to the Docker container.\nsshConfigHost :: FilePath -> Text\nsshConfigHost sshIdFile = T.unlines\n  [ \"Host \" <> containerName\n  , \"  User root\"\n  , \"  HostName 127.0.0.1\"\n  , \"  Port \" <> T.pack (show containerSshPort)\n  , \"  IdentityFile \" <> T.pack (show sshIdFile) -- TODO: Check to see how weird paths should be encoded here.\n  ]\n\n-- | User directory where state (namely the SSH keys) is kept for the Docker container.\ngetDockerBuilderStateDir :: IO FilePath\ngetDockerBuilderStateDir = liftA2 (</>) getObeliskUserStateDir (pure \"nix-docker-builder\")\n\n-- | Run a test build to see if a Linux build can finish successfully.\ntestLinuxBuild :: MonadObelisk m => FilePath -> m ()\ntestLinuxBuild stateDir\n  | System.Info.os == \"linux\" = failWith \"Using the docker builder is not necessary on linux.\"\n  | otherwise = do\n    (exitCode, _stdout, stderr) <- readCreateProcessWithExitCode $ proc nixBuildExePath\n      [ \"--no-out-link\"\n      , \"-E\", \"(import <nixpkgs> { system = \\\"x86_64-linux\\\"; }).writeText \\\"test\\\" builtins.currentTime\"\n      , \"--builders\", nixBuildersArgString stateDir\n      ]\n    unless (exitCode == ExitSuccess) $ do\n      let sshIdFile = stateDir </> sshKeyFileName\n      putLog Error $ T.pack stderr\n      failWith $ setupInstructions sshIdFile\n\n-- Copied from https://github.com/LnL7/nix-docker/blob/8dcfb3aff1f87cdafeecb0d27964b27c3fb8b1d2/ssh/Dockerfile\n-- Renamed \"insecure_rsa\" to 'sshKeyFileName'\ndockerfile :: Text\ndockerfile = [hereLit|\nFROM lnl7/nix:2018-09-21\n\nRUN nix-env -f '<nixpkgs>' -iA \\\n    gnused \\\n    openssh \\\n && nix-store --gc\n\nRUN mkdir -p /etc/ssh \\\n && echo \"sshd:x:498:65534::/var/empty:/run/current-system/sw/bin/nologin\" >> /etc/passwd \\\n && cp /root/.nix-profile/etc/ssh/sshd_config /etc/ssh \\\n && sed -i '/^PermitRootLogin/d' /etc/ssh/sshd_config \\\n && echo \"PermitRootLogin yes\" >> /etc/ssh/sshd_config \\\n && ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N \"\" -t rsa \\\n && ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N \"\" -t dsa \\\n && echo \"export SSL_CERT_FILE=$SSL_CERT_FILE\" >> /etc/bashrc \\\n && echo \"export PATH=$PATH\" >> /etc/bashrc \\\n && echo \"export NIX_PATH=$NIX_PATH\" >> /etc/bashrc \\\n && echo \"source /etc/bashrc\" >> /etc/profile\n\n|] <> T.unlines\n  [ \"ADD \" <> T.pack sshKeyFileName <> \" /root/.ssh/id_rsa\"\n  , \"ADD \" <> T.pack (sshKeyFileName <.> \"pub\") <> \" /root/.ssh/authorized_keys\"\n  ] <> [hereLit|\n\nEXPOSE 22\nCMD [\"/nix/store/mydwfxzk8bka4iwjml033dir6gkmqwic-openssh-7.7p1/bin/sshd\", \"-D\", \"-e\"]\n\n|]\n\nsshKeyFileName :: FilePath\nsshKeyFileName = \"id_ed25519_obelisk_vm\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 17,
            "average": 5,
            "sum": 89
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 2,
            "ignore": 0,
            "total": 4
          },
          "syntax_errors": 29,
          "lines_of_code": 547,
          "homplexity_lines_of_code": 683,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 17,
              "average": 5,
              "sum": 89
            },
            "homplexity_loc": 683,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"deployInit\": 7,\n        \"deployInit'\": 11,\n        \"setupObeliskImpl\": 1,\n        \"deployPush\": 17,\n        \"deployActivationScript\": 1,\n        \"deployUpdate\": 1,\n        \"renderPlatformDeployment\": 2,\n        \"deployMobile\": 9,\n        \"createKeystore\": 1,\n        \"writeDeployConfig\": 1,\n        \"readDeployConfig\": 1,\n        \"lookupKnownHosts\": 4,\n        \"addKnownHostFromEnv\": 5,\n        \"verifyHostKey\": 1,\n        \"sshArgs\": 1,\n        \"getHostFromRoute\": 3,\n        \"validateCommonRouteAndGetHost\": 8,\n        \"min\": 1,\n        \"max\": 17,\n        \"average\": 5.235294117647059,\n        \"sum\": 89\n    },\n    \"homplexity_loc\": 683\n}"
          },
          "original_code": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE ViewPatterns #-}\n{-|\n   Description:\n   Implementation of the CLI deploy commands. Deployment is done by intializing\n   a staging area for deployment configuration, and then by actually executing\n   the deployment by installing a NixOS configuration at the configured deployment\n   locations.\n-}\nmodule Obelisk.Command.Deploy where\n\nimport Control.Applicative (liftA2)\nimport Control.Lens\nimport Control.Monad\nimport Control.Monad.Catch (Exception (displayException), MonadThrow, bracket, throwM, try)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Aeson (FromJSON, ToJSON, encode, eitherDecode)\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport GHC.Generics\nimport System.Directory\nimport System.Exit (ExitCode(ExitSuccess))\nimport System.FilePath\nimport System.IO\nimport System.Which\nimport System.PosixCompat.Files\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Nix.Pretty (prettyNix)\nimport qualified Nix.Expr.Shorthands as Nix\nimport Prettyprinter (layoutCompact)\nimport Prettyprinter.Render.String (renderString)\n\nimport Obelisk.App (MonadObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils\n\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n-- | Options passed to the `init` verb\ndata DeployInitOpts = DeployInitOpts\n  { _deployInitOpts_outputDir :: FilePath\n  -- ^ Where to set up the deployment staging area\n  , _deployInitOpts_sshKey :: FilePath\n  -- ^ Which SSH Key will be used to interface with the deployment hosts\n  , _deployInitOpts_hostname :: [String]\n  -- ^ The hostnames that locate the deployment hosts\n  , _deployInitOpts_route :: String\n  -- ^ The route they are serving\n  , _deployInitOpts_adminEmail :: String\n  -- ^ The administrator email, for ACME\n  , _deployInitOpts_enableHttps :: Bool\n  -- ^ Whether or not to use HTTPS, which entails using Lets Encrypt by default\n  , _deployInitOpts_checkKnownHosts :: Bool\n  -- ^ Whether or not to use known_hosts file when assessing the identity of the deployment hosts\n  } deriving Show\n\n-- | The `init` verb\ndeployInit\n  :: MonadObelisk m\n  => DeployInitOpts\n  -- ^ Command line arguments\n  -> FilePath\n  -- ^ Project root, which cannot be the same as the deployment dir\n  -> m ()\ndeployInit deployOpts root = do\n  let deployDir = _deployInitOpts_outputDir deployOpts\n  rootEqualsTarget <- liftIO $ liftA2 equalFilePath (canonicalizePath root) (canonicalizePath deployDir)\n  when rootEqualsTarget $\n    failWith [i|Deploy directory ${deployDir} should not be the same as project root.|]\n  thunkPtr <- wrapNixThunkError (readThunk root) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    _ -> wrapNixThunkError (getThunkPtr CheckClean_NotIgnored root Nothing)\n  deployInit' thunkPtr deployOpts\n\n-- | The preamble in 'deployInit' provides deployInit' with a 'ThunkPtr' that it can install in\n-- the staging directory.\ndeployInit'\n  :: MonadObelisk m\n  => ThunkPtr\n  -> DeployInitOpts\n  -> m ()\ndeployInit' thunkPtr (DeployInitOpts deployDir sshKeyPath hostnames route adminEmail enableHttps checkKnownHosts) = do\n  liftIO $ createDirectoryIfMissing True deployDir\n  localKey <- withSpinner (\"Preparing \" <> T.pack deployDir) $ do\n    localKey <- liftIO (doesFileExist sshKeyPath) >>= \\case\n      False -> failWith $ T.pack $ \"ob deploy init: file does not exist: \" <> sshKeyPath\n      True -> pure $ deployDir </> \"ssh_key\"\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp [sshKeyPath, localKey]\n    liftIO $ setFileMode localKey $ ownerReadMode .|. ownerWriteMode\n    return localKey\n  withSpinner \"Validating configuration\" $ do\n    void $ getHostFromRoute enableHttps route -- make sure that hostname is present\n  let obKnownHostsPath = deployDir </> \"backend_known_hosts\"\n  forM_ hostnames $ \\hostname -> do\n    putLog Notice $ \"Verifying host keys (\" <> T.pack hostname <> \")\"\n    -- Note: we can't use a spinner here as this function will prompt the user.\n    when checkKnownHosts $ addKnownHostFromEnv hostname obKnownHostsPath\n    verifyHostKey obKnownHostsPath localKey hostname\n  --IMPORTANT: We cannot copy config directory from the development project to\n  --the deployment directory.  If we do, it's very likely someone will\n  --accidentally create a production deployment that uses development\n  --credentials to connect to some resources.  This could result in, e.g.,\n  --production data backed up to a dev environment.\n  withSpinner \"Creating project configuration directories\" $ liftIO $ do\n    mapM_ (createDirectoryIfMissing True)\n      [ deployDir </> \"config\" </> \"backend\"\n      , deployDir </> \"config\" </> \"common\"\n      , deployDir </> \"config\" </> \"frontend\"\n      ]\n\n  let srcDir = deployDir </> \"src\"\n  withSpinner (\"Creating source thunk (\" <> T.pack (makeRelative deployDir srcDir) <> \")\") $ do\n    wrapNixThunkError . createThunk srcDir $ Right thunkPtr\n    setupObeliskImpl deployDir\n\n  withSpinner \"Writing deployment configuration\" $ do\n    writeDeployConfig deployDir \"backend_hosts\" $ unlines hostnames\n    writeDeployConfig deployDir \"enable_https\" $ show enableHttps\n    writeDeployConfig deployDir \"admin_email\" adminEmail\n    writeDeployConfig deployDir (\"config\" </> \"common\" </> \"route\") route\n    writeDeployConfig deployDir \"module.nix\" $\n      \"(import \" <> toNixPath (makeRelative deployDir srcDir) <> \" {}).obelisk.serverModules.mkBaseEc2\"\n\n  withSpinner (\"Initializing git repository (\" <> T.pack deployDir <> \")\") $\n    initGit deployDir\n\n-- | Installs an obelisk impl in the staging dir that points at the obelisk of the\n-- project thunk.\nsetupObeliskImpl :: MonadIO m => FilePath -> m ()\nsetupObeliskImpl deployDir = liftIO $ do\n  let\n    implDir = toImplDir deployDir\n    goBackUp = foldr (</>) \"\" $ (\"..\" <$) $ splitPath $ makeRelative deployDir implDir\n  createDirectoryIfMissing True implDir\n  writeFile (implDir </> \"default.nix\") $ \"(import \" <> toNixPath (goBackUp </> \"src\") <> \" {}).obelisk\"\n\n-- | Executes the deployment specified in the supplied staging dir\ndeployPush\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Path to the staging directory\n  -> [String]\n  -- ^ nix builders arg string for the nix-build that builds the deployment artefacts\n  -> m ()\ndeployPush deployPath builders = do\n  hosts <- Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"backend_hosts\"\n  adminEmail <- readDeployConfig deployPath \"admin_email\"\n  enableHttps <- read <$> readDeployConfig deployPath \"enable_https\"\n  route <- readDeployConfig deployPath $ \"config\" </> \"common\" </> \"route\"\n  routeHost <- getHostFromRoute enableHttps route\n  redirectHosts <- liftIO (doesFileExist \"redirect_hosts\") >>= \\case\n    True -> Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"redirect_hosts\"\n    False -> pure mempty\n  let srcPath = deployPath </> \"src\"\n  thunkPtr <- wrapNixThunkError (readThunk srcPath) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    Right ThunkData_Checkout -> do\n      checkGitCleanStatus srcPath True >>= \\case\n        True -> wrapNixThunkError $ packThunk (ThunkPackConfig False (ThunkConfig Nothing)) srcPath\n        False -> failWith $ T.pack $ \"ob deploy push: ensure \" <> srcPath <> \" has no pending changes and latest is pushed upstream.\"\n    Left err -> failWith $ \"ob deploy push: couldn't read src thunk: \" <> T.pack (show err)\n  let version = show . _thunkRev_commit $ _thunkPtr_rev thunkPtr\n  let moduleFile = deployPath </> \"module.nix\"\n  moduleFileExists <- liftIO $ doesFileExist moduleFile\n\n  configHash <- getGitHash deployPath \"config\"\n  buildOutputByHost <- ifor (Map.fromSet (const ()) hosts) $ \\host () -> do\n    --TODO: What does it mean if this returns more or less than 1 line of output?\n    [result] <- fmap lines $ nixCmd $ NixCmd_Build $ def\n      & nixCmdConfig_target .~ Target\n        { _target_path = Just srcPath\n        , _target_attr = Just \"server.system\"\n        , _target_expr = Nothing\n        }\n      & nixBuildConfig_outLink .~ OutLink_None\n      & nixCmdConfig_args .~ (\n        [ strArg \"hostName\" $ fmap (\\c -> if c == '.' then '_' else c) host\n        , strArg \"adminEmail\" adminEmail\n        , strArg \"routeHost\" routeHost\n        , rawArg \"redirectHosts\" $ renderString $ layoutCompact $ prettyNix $ Nix.mkList $ Nix.mkStr . T.pack <$> Set.toList redirectHosts\n        , strArg \"version\" version\n        , boolArg \"enableHttps\" enableHttps\n        , strArg \"configHash\" $ T.unpack $ T.strip (_gitHash_text configHash)\n        ] <> [rawArg \"module\" (\"import \" <> toNixPath moduleFile) | moduleFileExists ])\n      & nixCmdConfig_builders .~ builders\n    pure result\n  let knownHostsPath = deployPath </> \"backend_known_hosts\"\n      sshOpts = sshArgs knownHostsPath (deployPath </> \"ssh_key\") False\n  withSpinner \"Uploading closures\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcess'\n      (Map.fromList [(\"NIX_SSHOPTS\", unwords sshOpts)])\n      \"nix-copy-closure\" [\"-v\", \"--to\", \"--use-substitutes\", \"root@\" <> host, \"--gzip\", outputPath]\n  withSpinner \"Uploading config\" $ ifor_ buildOutputByHost $ \\host _ -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc rsyncPath\n        [ \"-e \" <> sshPath <> \" \" <> unwords sshOpts\n        , \"--chown=backend:backend\"\n        , \"-qarvz\"\n        , deployPath </> \"config\"\n        , \"root@\" <> host <> \":/var/lib/backend\"\n        ]\n  --TODO: Create GC root so we're sure our closure won't go away during this time period\n  withSpinner \"Switching to new configuration\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc sshPath $ sshOpts <>\n        [ \"root@\" <> host\n        , unwords\n            [ \"bash -c\"\n            , bashEscape (deployActivationScript outputPath)\n            ]\n        ]\n  isClean <- checkGitCleanStatus deployPath True\n  when (not isClean) $ do\n    withSpinner \"Committing changes to Git\" $ do\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"add\", \".\"]\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"commit\", \"-m\", \"New deployment\"]\n  putLog Notice $ \"Deployed => \" <> T.pack route\n  where\n    callProcess' envMap cmd args = do\n      let p = setEnvOverride (envMap <>) $ setDelegateCtlc True $ proc cmd args\n      callProcessAndLogOutput (Notice, Notice) p\n\n-- | Bash command that will be run on the deployed machine to actually switch the NixOS configuration\n-- This has some more involved logic than merely activating the right profile. It also determines\n-- whether the kernel parameters have changed so that the deployed NixOS instance should be restarted.\ndeployActivationScript\n  :: String\n  -- ^ The out path of the configuration to activate\n  -> String\ndeployActivationScript outPath =\n-- Note that we don't want to $(staticWhich \"nix-env\") here, because this is executing on a remote machine\n-- This logic follows the nixos auto-upgrade module as of writing.\n-- If the workflow is added to switch-to-configuration proper, we can simplify this:\n-- https://github.com/obsidiansystems/obelisk/issues/958\n  [i|set -euxo pipefail\nnix-env -p /nix/var/nix/profiles/system --set \"${bashEscape outPath}\"\n/nix/var/nix/profiles/system/bin/switch-to-configuration boot\nbooted=\"$(readlink /run/booted-system/{initrd,kernel,kernel-modules})\"\nbuilt=\"$(readlink /nix/var/nix/profiles/system/{initrd,kernel,kernel-modules})\"\nif [ \"$booted\" = \"$built\" ]; then\n  /nix/var/nix/profiles/system/bin/switch-to-configuration switch\nelse\n  /run/current-system/sw/bin/shutdown -r +1\nfi\n|]\n\n-- | Update the source thunk in the staging directory to the HEAD of the branch.\ndeployUpdate :: MonadObelisk m => FilePath -> m ()\ndeployUpdate deployPath = wrapNixThunkError $\n  updateThunkToLatest (ThunkUpdateConfig Nothing (ThunkConfig Nothing)) (deployPath </> \"src\")\n\n-- | Platforms that we deploy obelisk artefacts to.\ndata PlatformDeployment = Android | IOS\n  deriving (Show, Eq)\n\n-- | Pretty print PlatformDeployment\nrenderPlatformDeployment :: PlatformDeployment -> String\nrenderPlatformDeployment = \\case\n  Android -> \"android\"\n  IOS -> \"ios\"\n\n-- | Produce the mobile app for an Obelisk project and deploy it onto a personal device.\n-- This does not submit the artefacts to any app stores, or anything like that. It is\n-- primarily useful for testing, or individual use of an Obelisk project.\ndeployMobile\n  :: forall m. MonadObelisk m\n  => PlatformDeployment\n  -- ^ Which mobile artefact to deploy; e.g. Android or iOS\n  -> [String]\n  -- ^ Extra arguments to pass to the executable that actually loads\n  -- the artefact onto the testing device. An example is the Team ID\n  -- associated with an Apple developer account.\n  -> m ()\ndeployMobile platform mobileArgs = withProjectRoot \".\" $ \\root -> do\n  let srcDir = root </> \"src\"\n      configDir = root </> \"config\"\n  exists <- liftIO $ doesDirectoryExist srcDir\n  unless exists $ failWith \"ob test should be run inside of a deploy directory\"\n  (nixBuildTarget, extraArgs) <- case platform of\n    Android -> do\n      let keystorePath = root </> \"android_keystore.jks\"\n          keytoolConfPath = root </> \"android_keytool_config.json\"\n      hasKeystore <- liftIO $ doesFileExist keystorePath\n      when (not hasKeystore) $ do\n        -- TODO log instructions for how to modify the keystore\n        putLog Notice $ \"Creating keystore: \" <> T.pack keystorePath\n        putLog Notice \"Enter a keystore password: \"\n        keyStorePassword <- liftIO $ withEcho False getLine\n        putLog Notice \"Re-enter the keystore password: \"\n        keyStorePassword' <- liftIO $ withEcho False getLine\n        unless (keyStorePassword' == keyStorePassword) $ failWith \"passwords do not match\"\n        let keyToolConf = KeytoolConfig\n              { _keytoolConfig_keystore = keystorePath\n              , _keytoolConfig_alias = \"obelisk\"\n              , _keytoolConfig_storepass = keyStorePassword\n              , _keytoolConfig_keypass = keyStorePassword\n              }\n        createKeystore root keyToolConf\n        liftIO $ BSL.writeFile keytoolConfPath $ encode keyToolConf\n      checkKeytoolConfExist <- liftIO $ doesFileExist keytoolConfPath\n      unless checkKeytoolConfExist $ failWith \"Missing android KeytoolConfig\"\n      keytoolConfContents <- liftIO $ BSL.readFile keytoolConfPath\n      keyArgs <- case eitherDecode keytoolConfContents :: Either String KeytoolConfig of\n        Left err -> failWith $ T.pack err\n        Right conf -> pure\n          [ \"--sign\"\n          , \"--store-file\", _keytoolConfig_keystore conf\n          , \"--store-password\", _keytoolConfig_storepass conf\n          , \"--key-alias\", _keytoolConfig_alias conf\n          , \"--key-password\", _keytoolConfig_keypass conf\n          ]\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"android.frontend.override (drv: {\"\n            , \"isRelease = true;\"\n            , \"staticSrc = (passthru.__androidWithConfig \", configDir, \").frontend.staticSrc;\"\n            , \"assets = (passthru.__androidWithConfig \", configDir, \").frontend.assets;\"\n            , \"})\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, keyArgs)\n    IOS -> do\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"ios.frontend.override (_: { staticSrc = (passthru.__iosWithConfig \", toNixPath configDir, \").frontend.staticSrc; })\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, [])\n  result <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ nixBuildTarget\n  let mobileArtifact = case platform of\n                         IOS -> \"iOS App\"\n                         Android -> \"Android APK\"\n  putLog Notice $ T.pack $ unwords [\"Your recently built\", mobileArtifact, \"can be found at the following path:\", show result]\n  callProcessAndLogOutput (Notice, Error) $ proc (result </> \"bin\" </> \"deploy\") (mobileArgs ++ extraArgs)\n  where\n    withEcho showEcho f = bracket\n      (do\n        prevEcho <- hGetEcho stdin\n        hSetEcho stdin showEcho\n        pure prevEcho\n      )\n      (hSetEcho stdin)\n      (const f)\n\n-- | obelisk uses keytool, a certificate and keypair management tool that comes with Java,\n-- to manage the cryptographic assets needed to deploy to an Android device.\ndata KeytoolConfig = KeytoolConfig\n  { _keytoolConfig_keystore :: FilePath\n  -- ^ Where is the keystore that keytool should create keypairs?\n  , _keytoolConfig_alias :: String\n  -- ^ Name of the entry in the keystore to process\n  , _keytoolConfig_storepass :: String\n  -- ^ Password for the keystore\n  , _keytoolConfig_keypass :: String\n  -- ^ Password for the keypair under consideration\n  } deriving (Show, Generic)\n\ninstance FromJSON KeytoolConfig\ninstance ToJSON KeytoolConfig\n\n-- | Creates a keystore, and a keypair in that keystore.\ncreateKeystore :: MonadObelisk m => FilePath -> KeytoolConfig -> m ()\ncreateKeystore root config =\n  callProcessAndLogOutput (Notice, Notice) $ setCwd (Just root) $ proc jreKeyToolPath\n    [ \"-genkeypair\", \"-noprompt\"\n    , \"-keystore\", _keytoolConfig_keystore config\n    , \"-keyalg\", \"RSA\", \"-keysize\", \"2048\"\n    , \"-validity\", \"1000000\"\n    , \"-storepass\", _keytoolConfig_storepass config\n    , \"-alias\", _keytoolConfig_alias config\n    , \"-keypass\", _keytoolConfig_keypass config\n    ]\n\n-- | Simplified deployment configuration mechanism. At one point we may revisit this.\nwriteDeployConfig :: MonadObelisk m => FilePath -> FilePath -> String -> m ()\nwriteDeployConfig deployDir fname = liftIO . writeFile (deployDir </> fname)\n\n-- | Read the deployment config file from a deployment staging directory.\nreadDeployConfig\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Deployment staging directory\n  -> FilePath\n  -- ^ The path to the config file relative to the staging directory.\n  -> m String\nreadDeployConfig deployDir fname = liftIO $ do\n  fmap (T.unpack . T.strip) $ T.readFile $ deployDir </> fname\n\n-- | Lookup known hosts using ssh-keygen command\nlookupKnownHosts :: MonadObelisk m\n                 => String\n                 -- ^ the host name\n                 -> m [BS.ByteString]\n                 -- ^ obtained hosts\nlookupKnownHosts hostName =\n  fmap filterComments $ readCreateProcessWithExitCode $ proc $(staticWhichNix \"ssh-keygen\") [\"-F\", hostName]\n   where\n     filterComments (exitCode, out, _) =\n       if exitCode /= ExitSuccess || null out\n         then []\n         else\n           -- ssh-keygen prints the following above each result it finds: \"# Host <hostname> found: line <lineno>\"\n           filter (not . C.isPrefixOf \"# Host\") $ C.lines $ C.pack out\n\n-- | insert a host/pair in backend_known_hosts file\naddKnownHostFromEnv :: MonadObelisk m\n                    => String\n                    -- ^ hostname\n                    -> FilePath\n                    -- ^ path to backend_known_hosts file\n                    -> m ()\naddKnownHostFromEnv hostName obKnownHostsPath = do\n  lookupKnownHosts hostName >>= \\res -> case res of\n    [knownKey] -> liftIO $ BS.appendFile obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    [] -> putLog Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog Notice \"Found more than one matching host/key pair in user's known_hosts\"\n\n-- | Verify the identity of a remote host that we would like to deploy to.\nverifyHostKey\n  :: MonadObelisk m\n  => FilePath\n  -- ^ known_hosts file to use for hosts that have already been verified.\n  -> FilePath\n  -- ^ Path to the ssh key used to connect to the host\n  -> String\n  -- ^ Name of the host\n  -> m ()\nverifyHostKey knownHostsPath keyPath hostName =\n  callProcessAndLogOutput (Notice, Warning) $ proc sshPath $\n    sshArgs knownHostsPath keyPath True <>\n      [ \"root@\" <> hostName\n      , \"-o\", \"NumberOfPasswordPrompts=0\"\n      , \"exit\"\n      ]\n\n-- | Create arguments to pass to ssh on the command line\nsshArgs\n  :: FilePath\n  -- ^ Path to known_hosts file\n  -> FilePath\n  -- ^ Path to the ssh key to use\n  -> Bool\n  -- ^ If true, then prompt the user when a host is not in the known_hosts file,\n  -- otherwise use strict host checking.\n  -> [String]\nsshArgs knownHostsPath keyPath askHostKeyCheck =\n  [ \"-o\", \"UserKnownHostsFile=\" <> knownHostsPath\n  , \"-o\", \"StrictHostKeyChecking=\" <> if askHostKeyCheck then \"ask\" else \"yes\"\n  , \"-i\", keyPath\n  ]\n\n-- common/route validation\n-- TODO: move these to executable-config once the typed-config stuff is done.\n\n-- | Ways in which the route configured for a deployment host can be invalid\ndata InvalidRoute\n  = InvalidRoute_NotHttps URI\n  -- ^ We do not deploy non-https routes unless explicitly asked for\n  | InvalidRoute_MissingScheme URI\n  -- ^ We demand a URI scheme\n  | InvalidRoute_MissingHost URI\n  -- ^ We demand a hostname\n  | InvalidRoute_HasPort URI\n  -- ^ We do not deploy to a route with a particular port number\n  | InvalidRoute_HasPath URI\n  -- ^ We do not deploy to a route that is served at a particular path\n  deriving Show\n\ninstance Exception InvalidRoute where\n  displayException = \\case\n    InvalidRoute_MissingScheme uri -> route uri \"must have an URI scheme\"\n    InvalidRoute_NotHttps uri -> route uri \"must be HTTPS\"\n    InvalidRoute_MissingHost uri -> route uri \"must contain a hostname\"\n    InvalidRoute_HasPort uri -> route uri \"cannot specify port\"\n    InvalidRoute_HasPath uri -> route uri \"cannot contain path\"\n    where\n      route uri err = T.unpack $ \"Route (\" <> URI.render uri <> \") \" <> err\n\n-- | Get the hostname from a https route\n--\n-- Fail if the route is invalid (i.e, no host present or scheme is not https)\ngetHostFromRoute\n  :: MonadObelisk m\n  => Bool  -- ^ Ensure https?\n  -> String\n  -> m String\ngetHostFromRoute mustBeHttps route = do\n  result :: Either InvalidRoute String <- try $ do\n    validateCommonRouteAndGetHost mustBeHttps =<< URI.mkURI (T.strip $ T.pack route)\n  either (failWith . T.pack . displayException) pure result\n\n-- | When deploying, we ensure that the route we are deploying for makes sense.\n-- In particular, we extract the hostname that we are deploying to from the\n-- route.\nvalidateCommonRouteAndGetHost\n  :: (MonadThrow m, MonadObelisk m)\n  => Bool\n  -- ^ If true, demand that the route we are deploying is an HTTPS route\n  -> URI\n  -- ^ The route to validate\n  -> m String\nvalidateCommonRouteAndGetHost mustBeHttps uri = do\n  case uri ^? uriScheme of\n    Just (Just (URI.unRText -> s)) -> case (mustBeHttps, s) of\n      (False, _) -> pure ()\n      (True, \"https\") -> pure ()\n      _ -> throwM $ InvalidRoute_NotHttps uri\n    _ -> throwM $ InvalidRoute_MissingScheme uri\n  case uri ^. uriPath of\n    [] -> pure ()\n    _path -> throwM $ InvalidRoute_HasPath uri\n  case uri ^? uriAuthority . _Right . authPort of\n    Just (Just _port) -> throwM $ InvalidRoute_HasPort uri\n    _ -> pure ()\n  case uri ^? uriAuthority . _Right . authHost of\n    Nothing -> throwM $ InvalidRoute_MissingHost uri\n    Just sslHost -> return $ T.unpack $ URI.unRText sslHost\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Deploy"
              ],
              "decl": [
                "deployPush"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "startLine": 233,
              "startColumn": 3,
              "endLine": 233,
              "endColumn": 21,
              "from": "when (not isClean)",
              "to": "unless isClean",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 233, startCol = 3, endLine = 233, endCol = 21}, subts = [(\"x\",SrcSpan {startLine = 233, startCol = 13, endLine = 233, endCol = 20})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Deploy"
              ],
              "decl": [
                "deployMobile"
              ],
              "severity": "Warning",
              "hint": "Use unless",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "startLine": 306,
              "startColumn": 7,
              "endLine": 306,
              "endColumn": 29,
              "from": "when (not hasKeystore)",
              "to": "unless hasKeystore",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 306, startCol = 7, endLine = 306, endCol = 29}, subts = [(\"x\",SrcSpan {startLine = 306, startCol = 17, endLine = 306, endCol = 28})], orig = \"unless x\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Deploy"
              ],
              "decl": [
                "addKnownHostFromEnv"
              ],
              "severity": "Suggestion",
              "hint": "Use lambda-case",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "startLine": 443,
              "startColumn": 33,
              "endLine": 446,
              "endColumn": 90,
              "from": "\\ res\n  -> case res of\n       [knownKey]\n         -> liftIO\n              $ BS.appendFile\n                  obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n       []\n         -> putLog\n              Notice \"Found no matching hosts in user's known_hosts file\"\n       _ -> putLog\n              Notice\n              \"Found more than one matching host/key pair in user's known_hosts\"",
              "to": "\\case\n  [knownKey]\n    -> liftIO\n         $ BS.appendFile\n             obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n  []\n    -> putLog\n         Notice \"Found no matching hosts in user's known_hosts file\"\n  _ -> putLog\n         Notice\n         \"Found more than one matching host/key pair in user's known_hosts\"",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Deploy"
              ],
              "decl": [
                "InvalidRoute"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "startLine": 486,
              "startColumn": 1,
              "endLine": 497,
              "endColumn": 16,
              "from": "data InvalidRoute\n  = InvalidRoute_NotHttps URI |\n    InvalidRoute_MissingScheme URI |\n    InvalidRoute_MissingHost URI |\n    InvalidRoute_HasPort URI |\n    InvalidRoute_HasPath URI\n  deriving Show",
              "to": "data InvalidRoute\n  = InvalidRouteNotHttps URI |\n    InvalidRouteMissingScheme URI |\n    InvalidRouteMissingHost URI |\n    InvalidRouteHasPort URI |\n    InvalidRouteHasPath URI\n  deriving Show",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Deploy.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Deploy.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Deploy.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 7,
            "average": 3,
            "sum": 34
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 3,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 5,
          "lines_of_code": 224,
          "homplexity_lines_of_code": 220,
          "code_quality_score": 10.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 7,
              "average": 3,
              "sum": 34
            },
            "homplexity_loc": 220,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"strArg\": 1,\n        \"rawArg\": 1,\n        \"boolArg\": 1,\n        \"cliFromArgs\": 2,\n        \"runNixCommonConfig\": 6,\n        \"runNixBuildConfig\": 4,\n        \"runNixInstantiateConfig\": 3,\n        \"runNixShellConfig\": 4,\n        \"nixCmdProc\": 1,\n        \"nixCmdProc'\": 4,\n        \"nixCmd\": 7,\n        \"min\": 1,\n        \"max\": 7,\n        \"average\": 3.09,\n        \"sum\": 34\n    },\n    \"homplexity_loc\": 220,\n    \"homplexity_output\": \"\"\n}\n"
          },
          "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Obelisk.Command.Nix\n  ( Arg (..)\n  , NixBuildConfig (..)\n  , nixBuildConfig_common\n  , nixBuildConfig_outLink\n  , NixCmd (..)\n  , nixCmdConfig_args\n  , nixCmdConfig_builders\n  , nixCmdConfig_target\n  , NixCommonConfig (..)\n  , NixInstantiateConfig (..)\n  , nixInstantiateConfig_eval\n  , NixShellConfig (..)\n  , nixShellConfig_common\n  , nixShellConfig_pure\n  , nixShellConfig_run\n  , OutLink (..)\n  , Target (..)\n  , target_attr\n  , target_expr\n  , target_path\n\n  , boolArg\n  , nixCmd\n  , nixCmdProc\n  , nixCmdProc'\n  , rawArg\n  , runNixShellConfig\n  , strArg\n  ) where\n\nimport Control.Monad (guard)\nimport Control.Lens\n\nimport Data.Bool (bool)\nimport Data.Default\nimport Data.List (intercalate)\nimport Data.Maybe\nimport Data.Monoid ((<>))\nimport qualified Data.Text as T\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\n-- | What to build\ndata Target = Target\n  { _target_path :: Maybe FilePath\n  , _target_attr :: Maybe String\n  , _target_expr :: Maybe String\n  }\nmakeClassy ''Target\n\ninstance Default Target where\n  def = Target\n    { _target_path = Just \".\"\n    , _target_attr = Nothing\n    , _target_expr = Nothing\n    }\n\ndata Arg\n  = Arg_Str String String\n  | Arg_Expr String String\n  deriving (Eq, Show)\n\nstrArg :: String -> String -> Arg\nstrArg = Arg_Str\n\nrawArg :: String -> String -> Arg\nrawArg = Arg_Expr\n\nboolArg :: String -> Bool -> Arg\nboolArg k = Arg_Expr k . bool \"false\" \"true\"\n\ncliFromArgs :: [Arg] -> [String]\ncliFromArgs = concatMap $ \\case\n  Arg_Str k v -> [\"--argstr\", k, v]\n  Arg_Expr k v -> [\"--arg\", k, v]\n\ndata NixCommonConfig = NixCommonConfig\n  { _nixCmdConfig_target :: Target\n  , _nixCmdConfig_args :: [Arg]\n  , _nixCmdConfig_builders :: [String]\n  }\nmakeClassy ''NixCommonConfig\n\ninstance Default NixCommonConfig where\n  def = NixCommonConfig def mempty mempty\n\nrunNixCommonConfig :: NixCommonConfig -> [String]\nrunNixCommonConfig cfg = mconcat [maybeToList path, attrArg, exprArg, args, buildersArg]\n  where\n    path = _target_path $ _nixCmdConfig_target cfg\n    attr = _target_attr $ _nixCmdConfig_target cfg\n    expr = _target_expr $ _nixCmdConfig_target cfg\n    attrArg = case attr of\n      Nothing -> []\n      Just a -> [\"-A\", a]\n    exprArg = case expr of\n      Nothing -> []\n      Just a -> [\"-E\", a]\n    args = cliFromArgs $ _nixCmdConfig_args cfg\n    buildersArg = case _nixCmdConfig_builders cfg of\n      [] -> []\n      builders -> [\"--builders\", intercalate \";\" builders]\n\n-- | Where to put nix-build output\ndata OutLink\n  = OutLink_Default\n  | OutLink_None\n  | OutLink_IndirectRoot FilePath\n\ninstance Default OutLink where\n  def = OutLink_Default\n\ndata NixBuildConfig = NixBuildConfig\n  { _nixBuildConfig_common :: NixCommonConfig\n  , _nixBuildConfig_outLink :: OutLink\n  }\nmakeLenses ''NixBuildConfig\n\ninstance HasNixCommonConfig NixBuildConfig where\n  nixCommonConfig = nixBuildConfig_common\n\ninstance Default NixBuildConfig where\n  def = NixBuildConfig def def\n\nrunNixBuildConfig :: NixBuildConfig -> [String]\nrunNixBuildConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , case _nixBuildConfig_outLink cfg of\n      OutLink_Default -> []\n      OutLink_None -> [\"--no-out-link\"]\n      OutLink_IndirectRoot l -> [\"--out-link\", l]\n  ]\n\ndata NixInstantiateConfig = NixInstantiateConfig\n  { _nixInstantiateConfig_common :: NixCommonConfig\n  , _nixInstantiateConfig_eval :: Bool\n  }\nmakeLenses ''NixInstantiateConfig\n\ninstance HasNixCommonConfig NixInstantiateConfig where\n  nixCommonConfig = nixInstantiateConfig_common\n\ninstance Default NixInstantiateConfig where\n  def = NixInstantiateConfig def False\n\nrunNixInstantiateConfig :: NixInstantiateConfig -> [String]\nrunNixInstantiateConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , \"--eval\" <$ guard (_nixInstantiateConfig_eval cfg)\n  ]\n\ndata NixShellConfig = NixShellConfig\n  { _nixShellConfig_common :: NixCommonConfig\n  , _nixShellConfig_pure :: Bool\n  , _nixShellConfig_run :: Maybe String\n  }\n\nmakeLenses ''NixShellConfig\n\ninstance HasNixCommonConfig NixShellConfig where\n  nixCommonConfig = nixShellConfig_common\n\ninstance Default NixShellConfig where\n  def = NixShellConfig def False Nothing\n\ndata NixCmd\n  = NixCmd_Build NixBuildConfig\n  | NixCmd_Instantiate NixInstantiateConfig\n\ninstance Default NixCmd where\n  def = NixCmd_Build def\n\nrunNixShellConfig :: NixShellConfig -> [String]\nrunNixShellConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , [ \"--pure\" | cfg ^. nixShellConfig_pure ]\n  ] ++ mconcat [\n    [\"--run\", run] | run <- maybeToList $ cfg ^. nixShellConfig_run\n  ]\n\nnixCmdProc :: NixCmd -> ProcessSpec\nnixCmdProc = fst . nixCmdProc'\n\nnixCmdProc' :: NixCmd -> (ProcessSpec, T.Text)\nnixCmdProc' cmdCfg = (proc (T.unpack cmd) options, cmd)\n  where\n    (cmd, options) = case cmdCfg of\n      NixCmd_Build cfg' ->\n        ( \"nix-build\"\n        , runNixBuildConfig cfg'\n        )\n      NixCmd_Instantiate cfg' ->\n        ( \"nix-instantiate\"\n        , runNixInstantiateConfig cfg'\n        )\n\nnixCmd :: MonadObelisk m => NixCmd -> m FilePath\nnixCmd cmdCfg = withSpinner' (T.unwords $ \"Running\" : cmd : desc) (Just $ const $ T.unwords $ \"Built\" : desc) $ do\n  output <- readProcessAndLogStderr Debug cmdProc\n  -- Remove final newline that Nix appends\n  Just (outPath, '\\n') <- pure $ T.unsnoc output\n  pure $ T.unpack outPath\n  where\n    (cmdProc, cmd) = nixCmdProc' cmdCfg\n    commonCfg = case cmdCfg of\n      NixCmd_Build cfg' -> cfg' ^. nixCommonConfig\n      NixCmd_Instantiate cfg' -> cfg' ^. nixCommonConfig\n    path = commonCfg ^. nixCmdConfig_target . target_path\n    desc = concat $ catMaybes\n      [ (\\x -> [\"on\", T.pack x]) <$> path\n      , (\\a -> [\"[\" <> T.pack a <> \"]\"]) <$> (commonCfg ^. nixCmdConfig_target . target_attr)\n      ]\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Nix"
              ],
              "decl": [
                "Arg"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
              "startLine": 70,
              "startColumn": 1,
              "endLine": 73,
              "endColumn": 22,
              "from": "data Arg\n  = Arg_Str String String | Arg_Expr String String\n  deriving (Eq, Show)",
              "to": "data Arg\n  = ArgStr String String | ArgExpr String String\n  deriving (Eq, Show)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Nix"
              ],
              "decl": [
                "OutLink"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
              "startLine": 117,
              "startColumn": 1,
              "endLine": 120,
              "endColumn": 34,
              "from": "data OutLink\n  = OutLink_Default | OutLink_None | OutLink_IndirectRoot FilePath",
              "to": "data OutLink\n  = OutLinkDefault | OutLinkNone | OutLinkIndirectRoot FilePath",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Nix"
              ],
              "decl": [
                "NixCmd"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
              "startLine": 178,
              "startColumn": 1,
              "endLine": 180,
              "endColumn": 44,
              "from": "data NixCmd\n  = NixCmd_Build NixBuildConfig |\n    NixCmd_Instantiate NixInstantiateConfig",
              "to": "data NixCmd\n  = NixCmdBuild NixBuildConfig |\n    NixCmdInstantiate NixInstantiateConfig",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Nix.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Nix.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Nix.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 12,
            "average": 2.1,
            "sum": 63
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 9,
            "suggestion": 7,
            "ignore": 0,
            "total": 16
          },
          "syntax_errors": 11,
          "lines_of_code": 645,
          "homplexity_lines_of_code": 802,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 12,
              "average": 2.1,
              "sum": 63
            },
            "homplexity_loc": 802,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 1 1: module Obelisk.Command.Run has 495 lines of code \nCritical:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 106 25: data CabalPackageInfo has record fields count of 10 must never reach 9\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 126 18: data Interpret has record fields count of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 128 1: type signature for textInterpret has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 128 1: type signature for textInterpret has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 129 1: function textInterpret has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 129 1: function textInterpret has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 129 1: function textInterpret has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 134 19: data PathTree has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 140 1: type signature for drawPathTree has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 140 1: type signature for drawPathTree has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 141 1: function drawPathTree has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 141 1: function drawPathTree has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 141 1: function drawPathTree has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 151 1: type signature for preprocessorIdentifier has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 151 1: type signature for preprocessorIdentifier has type constructor nesting of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 152 1: function preprocessorIdentifier has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 152 1: function preprocessorIdentifier has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 152 1: function preprocessorIdentifier has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 154 1: type signature for profile has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 154 1: type signature for profile has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 159 1: function profile has cyclomatic complexity of 1 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 159 1: function profile has 25 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 159 1: function profile has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 187 1: type signature for run has 5 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 187 1: type signature for run has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 198 1: function run has 23 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 198 1: function run has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 198 1: function run has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 223 1: type signature for runRepl has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 223 1: type signature for runRepl has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 224 1: function runRepl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 224 1: function runRepl has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 224 1: function runRepl has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 231 1: type signature for runWatch has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 231 1: type signature for runWatch has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 232 1: function runWatch has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 232 1: function runWatch has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 232 1: function runWatch has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 238 1: type signature for exportGhciConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 238 1: type signature for exportGhciConfig has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 239 1: function exportGhciConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 239 1: function exportGhciConfig has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 239 1: function exportGhciConfig has branching depth of 0 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 243 1: type signature for nixShellForInterpretPaths has 6 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 243 1: type signature for nixShellForInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 244 1: function nixShellForInterpretPaths has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 244 1: function nixShellForInterpretPaths has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 244 1: function nixShellForInterpretPaths has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 249 1: type signature for getParsedLocalPkgs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 249 1: type signature for getParsedLocalPkgs has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 250 1: function getParsedLocalPkgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 250 1: function getParsedLocalPkgs has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 250 1: function getParsedLocalPkgs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 257 1: type signature for getLocalPkgs has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 257 1: type signature for getLocalPkgs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 258 1: function getLocalPkgs has 19 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 258 1: function getLocalPkgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 258 1: function getLocalPkgs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 288 1: type signature for calcIntepretFinds has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 288 1: type signature for calcIntepretFinds has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 289 1: function calcIntepretFinds has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 289 1: function calcIntepretFinds has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 289 1: function calcIntepretFinds has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 298 1: type signature for foldPathTreeFor has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 298 1: type signature for foldPathTreeFor has 5 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 305 1: function foldPathTreeFor has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 305 1: function foldPathTreeFor has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 305 1: function foldPathTreeFor has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 310 30: data GuessPackageFileError has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 314 25: data HPackFilePath has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 315 25: data CabalFilePath has record fields count of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 318 1: type signature for guessCabalPackageFile has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 318 1: type signature for guessCabalPackageFile has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 322 1: function guessCabalPackageFile has cyclomatic complexity of 8 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 322 1: function guessCabalPackageFile has 18 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 322 1: function guessCabalPackageFile has branching depth of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 343 1: type signature for cabalOrHpackFile has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 343 1: type signature for cabalOrHpackFile has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 344 1: function cabalOrHpackFile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 344 1: function cabalOrHpackFile has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 344 1: function cabalOrHpackFile has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 351 1: type signature for parseCabalPackage has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 351 1: type signature for parseCabalPackage has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 355 1: function parseCabalPackage has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 355 1: function parseCabalPackage has cyclomatic complexity of 3 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 355 1: function parseCabalPackage has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 363 1: type signature for parseCabalPackage' has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 363 1: type signature for parseCabalPackage' has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 367 1: function parseCabalPackage' has cyclomatic complexity of 12 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 367 1: function parseCabalPackage' has branching depth of 2 \nCritical:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 367 1: function parseCabalPackage' has 44 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 418 1: type signature for parsePackagesOrFail has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 418 1: type signature for parsePackagesOrFail has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 419 1: function parsePackagesOrFail has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 419 1: function parsePackagesOrFail has cyclomatic complexity of 5 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 419 1: function parsePackagesOrFail has 25 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 450 1: type signature for packageInfoToNamePathMap has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 450 1: type signature for packageInfoToNamePathMap has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 451 1: function packageInfoToNamePathMap has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 451 1: function packageInfoToNamePathMap has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 451 1: function packageInfoToNamePathMap has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 454 1: type signature for withGhciScriptArgs has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 454 1: type signature for withGhciScriptArgs has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 460 1: function withGhciScriptArgs has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 460 1: function withGhciScriptArgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 460 1: function withGhciScriptArgs has 6 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 472 1: type signature for withGhciScript has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 472 1: type signature for withGhciScript has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 478 1: function withGhciScript has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 478 1: function withGhciScript has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 478 1: function withGhciScript has 16 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 500 1: type signature for getGhciSessionSettings has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 500 1: type signature for getGhciSessionSettings has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 505 1: function getGhciSessionSettings has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 505 1: function getGhciSessionSettings has cyclomatic complexity of 2 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 505 1: function getGhciSessionSettings has 28 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 540 1: type signature for loadPackageIndex has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 540 1: type signature for loadPackageIndex has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 541 1: function loadPackageIndex has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 541 1: function loadPackageIndex has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 541 1: function loadPackageIndex has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 552 1: type signature for baseGhciOptions has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 552 1: type signature for baseGhciOptions has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 553 1: function baseGhciOptions has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 553 1: function baseGhciOptions has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 553 1: function baseGhciOptions has 5 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 561 1: type signature for runGhciRepl has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 561 1: type signature for runGhciRepl has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 567 1: function runGhciRepl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 567 1: function runGhciRepl has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 567 1: function runGhciRepl has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 574 1: type signature for runGhcid has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 574 1: type signature for runGhcid has 6 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 582 1: function runGhcid has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 582 1: function runGhcid has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 582 1: function runGhcid has 13 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 603 1: type signature for getFreePort has 1 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 603 1: type signature for getFreePort has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 604 1: function getFreePort has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 604 1: function getFreePort has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 604 1: function getFreePort has 7 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 615 1: type signature for pathToTree has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 615 1: type signature for pathToTree has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 616 1: function pathToTree has 3 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 616 1: function pathToTree has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 616 1: function pathToTree has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 622 1: type signature for zipDefaultWith has type constructor nesting of 1 \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 622 1: type signature for zipDefaultWith has 6 arguments should be less than 5\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 623 1: function zipDefaultWith has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 623 1: function zipDefaultWith has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 623 1: function zipDefaultWith has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 636 1: type signature for relativeTo has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 636 1: type signature for relativeTo has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 637 1: function relativeTo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 637 1: function relativeTo has 9 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs\" 637 1: function relativeTo has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFoldable #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command.Run where\n\nimport Control.Arrow ((&&&))\nimport Control.Exception (Exception, bracket)\nimport Control.Lens (ifor, (.~), (&), view)\nimport Control.Concurrent (forkIO)\nimport Control.Monad (filterM, void)\nimport Control.Monad.Except (runExceptT, throwError)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Reader (MonadIO)\nimport Data.Bifoldable (bifoldr1)\nimport Data.Bifunctor (bimap)\nimport Data.Coerce (coerce)\nimport Data.Default (def)\nimport Data.Foldable (fold, for_, toList)\nimport Data.Functor.Identity (runIdentity)\nimport Data.List (intercalate)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Either\nimport qualified Data.List.NonEmpty as NE\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport qualified Data.Map.Monoidal as MMap\nimport Data.Maybe (catMaybes, fromMaybe, mapMaybe)\nimport Data.Ord (comparing)\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Time.Clock (getCurrentTime)\nimport Data.Time.Format (formatTime, defaultTimeLocale)\nimport Data.Traversable (for)\nimport Debug.Trace (trace)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Compiler (CompilerFlavor(..), perCompilerFlavorToList, PerCompilerFlavor)\n#else\nimport Distribution.Compiler (CompilerFlavor(..), PerCompilerFlavor)\n#endif\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Fields.ParseResult (runParseResult)\n#else\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription, runParseResult)\n#endif\nimport Distribution.Pretty (prettyShow)\nimport Distribution.Simple.Compiler (PackageDB (GlobalPackageDB))\nimport Distribution.Simple.Configure (configCompilerEx, getInstalledPackages)\nimport Distribution.Simple.PackageIndex (InstalledPackageIndex, lookupDependency)\nimport Distribution.Simple.Program.Db (defaultProgramDb)\nimport qualified Distribution.System as Dist\nimport Distribution.Types.BuildInfo (buildable, cppOptions, defaultExtensions, defaultLanguage, hsSourceDirs, options, targetBuildDepends)\nimport Distribution.Types.CondTree (simplifyCondTree)\nimport Distribution.Types.Dependency (Dependency (..), depPkgName)\nimport Distribution.Parsec.Warning (PWarning)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Types.GenericPackageDescription.Lens (ConfVar (Arch, Impl, OS), condLibrary)\n#else\nimport Distribution.Types.GenericPackageDescription (condLibrary)\nimport Distribution.Types.ConfVar (ConfVar (Arch, Impl, OS))\n#endif\nimport Distribution.Types.InstalledPackageInfo (compatPackageKey)\nimport Distribution.Types.Library (libBuildInfo)\nimport Distribution.Types.LibraryName (LibraryName(..))\nimport Distribution.Types.PackageName (mkPackageName)\nimport Distribution.Types.VersionRange (anyVersion)\nimport Distribution.Utils.Generic (toUTF8BS, readUTF8File)\n#if MIN_VERSION_Cabal(3,2,1)\nimport qualified Distribution.Parsec.Warning as Dist\n#else\nimport qualified Distribution.System as Dist\n#endif\nimport Distribution.Types.Dependency (Dependency (..), depPkgName, depVerRange)\nimport qualified Distribution.Verbosity as Verbosity (silent)\nimport qualified Hpack.Config as Hpack\nimport qualified Hpack.Render as Hpack\nimport qualified Hpack.Yaml as Hpack\nimport Language.Haskell.Extension (Extension, Language)\nimport qualified Network.Socket as Socket\nimport System.Directory\nimport System.Environment (getExecutablePath)\nimport System.FilePath\nimport qualified System.Info\nimport System.IO.Temp (withSystemTempDirectory)\n\nimport Obelisk.App (MonadObelisk, ObeliskError(..), getObelisk, runObelisk)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils (findExePath, ghcidExePath)\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\ndata CabalPackageInfo = CabalPackageInfo\n  { _cabalPackageInfo_packageFile :: FilePath\n  , _cabalPackageInfo_packageName :: T.Text\n  , _cabalPackageInfo_packageRoot :: FilePath\n  , _cabalPackageInfo_buildable :: Bool\n  , _cabalPackageInfo_sourceDirs :: NE.NonEmpty FilePath\n    -- ^ List of hs src dirs of the library component\n  , _cabalPackageInfo_defaultExtensions :: [Extension]\n    -- ^ List of globally enable extensions of the library component\n  , _cabalPackageInfo_defaultLanguage :: Maybe Language\n    -- ^ List of globally set languages of the library component\n  , _cabalPackageInfo_compilerOptions :: PerCompilerFlavor [String]\n    -- ^ List of compiler-specific options (e.g., the \"ghc-options\" field of the cabal file)\n  , _cabalPackageInfo_cppOptions :: [String]\n    -- ^ List of CPP (C Preprocessor) options (e.g. the \"cpp-options\" field of the cabal file)\n  , _cabalPackageInfo_buildDepends :: [Dependency]\n    -- ^ List of build dependencies listed in the cabal file\n  }\n\n-- | 'Bool' with a better name for its purpose.\ndata Interpret = Interpret_Interpret | Interpret_NoInterpret deriving (Eq, Ord, Show)\n\ntextInterpret :: Interpret -> Text\ntextInterpret = \\case\n  Interpret_Interpret -> \"Interpret\"\n  Interpret_NoInterpret -> \"NoInterpret\"\n\n-- | Describe a set of 'FilePath's as a tree to facilitate merging them in a convenient way.\ndata PathTree a = PathTree_Node\n  (Maybe a) -- An optional leaf at this point in the tree\n  (Map FilePath (PathTree a)) -- Branches to deeper leaves\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)\n\n-- | 2D ASCII drawing of a 'PathTree'. Adapted from Data.Tree.draw.\ndrawPathTree :: (a -> Text) -> PathTree a -> Text\ndrawPathTree showA (PathTree_Node _ ts0) = T.intercalate \"\\n\" $ goForest (Map.toList ts0)\n  where\n    annotated ma = maybe id (\\a b -> b <> \" [\" <> showA a <> \"]\") ma . T.pack\n    goTree (fp, PathTree_Node ma forest) = annotated ma fp : goForest (Map.toList forest)\n    goForest [] = []\n    goForest [tree] = shift \"\u2514\u2500 \" \"   \" (goTree tree)\n    goForest (tree:forest) = shift \"\u251c\u2500 \" \"\u2502  \" (goTree tree) <> goForest forest\n    shift first other = zipWith (<>) (first : repeat other)\n\n-- | Used to signal to obelisk that it's being invoked as a preprocessor\npreprocessorIdentifier :: String\npreprocessorIdentifier = \"__preprocessor-apply-packages\"\n\nprofile\n  :: MonadObelisk m\n  => String\n  -> [String]\n  -> m ()\nprofile profileBasePattern rtsFlags = withProjectRoot \".\" $ \\root -> do\n  putLog Debug \"Using profiled build of project.\"\n\n  outPath <- withSpinner \"Building profiled executable\" $\n    fmap (T.unpack . T.strip) $ readProcessAndLogStderr Debug $ setCwd (Just root) $ nixCmdProc $\n      NixCmd_Build $ def\n        & nixBuildConfig_outLink .~ OutLink_None\n        & nixCmdConfig_target .~ Target\n          { _target_path = Just \".\"\n          , _target_attr = Just \"__unstable__.profiledObRun\"\n          , _target_expr = Nothing\n          }\n  (assetType, assets) <- findProjectAssets root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  time <- liftIO getCurrentTime\n  let profileBaseName = formatTime defaultTimeLocale profileBasePattern time\n  liftIO $ createDirectoryIfMissing True $ takeDirectory $ root </> profileBaseName\n  putLog Debug $ \"Storing profiled data under base name of \" <> T.pack (root </> profileBaseName)\n  freePort <- getFreePort\n  runProcess_ $ setCwd (Just root) $ setDelegateCtlc True $ proc (outPath </> \"bin\" </> \"ob-run\") $\n    [ show freePort\n    , T.unpack assets\n    , profileBaseName\n    , \"+RTS\"\n    , \"-po\" <> profileBaseName\n    ] <> rtsFlags\n      <> [ \"-RTS\" ]\n\nrun\n  :: MonadObelisk m\n  => Maybe FilePath\n  -- ^ Certificate Directory path (optional)\n  -> Maybe Socket.PortNumber\n  -- ^ override the route's port number?\n  -> FilePath\n  -- ^ root folder\n  -> PathTree Interpret\n  -- ^ interpreted paths\n  -> m ()\nrun certDir portOverride root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  (assetType, assets) <- findProjectAssets root\n  manifestPkg <- parsePackagesOrFail . (:[]) . T.unpack =<< getHaskellManifestProjectPath root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  case assetType of\n    AssetSource_Derivation -> do\n      ob <- getObelisk\n      putLog Debug \"Starting static file derivation watcher...\"\n      void $ liftIO $ forkIO $ runObelisk ob $ watchStaticFilesDerivation root\n    _ -> pure ()\n  ghciArgs <- getGhciSessionSettings (pkgs <> manifestPkg) root\n  freePort <- getFreePort\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs -> do\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs $ Just $ unwords\n      [ \"Obelisk.Run.run (Obelisk.Run.defaultRunApp\"\n      , \"Backend.backend\"\n      , \"Frontend.frontend\"\n      , \"(Obelisk.Run.runServeAsset \" ++ show assets ++ \")\"\n      , \") { Obelisk.Run._runApp_backendPort =\", show freePort\n      ,   \", Obelisk.Run._runApp_forceFrontendPort =\", show portOverride\n      ,   \", Obelisk.Run._runApp_tlsCertDirectory =\", show certDir\n      , \"}\"\n      ]\n\nrunRepl :: MonadObelisk m => Maybe FilePath -> FilePath -> PathTree Interpret -> m ()\nrunRepl mUserGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  userCommands <- maybe (pure []) (fmap lines . liftIO . readFile) mUserGhciConfig\n  withGhciScriptArgs userCommands pkgs $ \\dotGhciArgs ->\n    runGhciRepl root pkgs (ghciArgs <> dotGhciArgs)\n\nrunWatch :: MonadObelisk m => FilePath -> PathTree Interpret -> m ()\nrunWatch root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs ->\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs Nothing\n\nexportGhciConfig :: MonadObelisk m => FilePath -> PathTree Interpret -> m [String]\nexportGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  getGhciSessionSettings pkgs root\n\nnixShellForInterpretPaths :: MonadObelisk m => Bool -> String -> FilePath -> PathTree Interpret -> Maybe String -> m ()\nnixShellForInterpretPaths isPure shell' root interpretPaths cmd = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  nixShellWithoutPkgs root isPure False (packageInfoToNamePathMap pkgs) shell' cmd\n\n-- | Like 'getLocalPkgs' but also parses them and fails if any of them can't be parsed.\ngetParsedLocalPkgs :: MonadObelisk m => FilePath -> PathTree Interpret -> m (NonEmpty CabalPackageInfo)\ngetParsedLocalPkgs root interpretPaths = parsePackagesOrFail =<< getLocalPkgs root interpretPaths\n\n-- | Relative paths to local packages of an obelisk project.\n--\n-- These are a combination of the obelisk predefined local packages,\n-- and any packages that the user has set with the @packages@ argument\n-- to the Nix @project@ function.\ngetLocalPkgs :: forall m. MonadObelisk m => FilePath -> PathTree Interpret -> m (Set FilePath)\ngetLocalPkgs root interpretPaths = do\n  putLog Debug $ [i|Finding packages with root ${root} and interpret paths:|] <> \"\\n\" <> drawPathTree textInterpret interpretPaths\n  obeliskPackagePaths <- runFind [\"-L\", root, \"-name\", \".obelisk\", \"-type\", \"d\"]\n\n  -- We do not want to find packages that are embedded inside other obelisk projects, unless that\n  -- obelisk project is our own.\n  obeliskPackageExclusions <- liftIO $ fmap Set.fromList $ traverse canonicalizePath $\n    filter (/= root) $ map takeDirectory obeliskPackagePaths\n  putLog Debug [i|Excluding obelisk packages: ${T.pack $ unwords $ Set.toList obeliskPackageExclusions}|]\n  let rootsAndExclusions = calcIntepretFinds \"\" interpretPaths\n\n  fmap fold $ for (MMap.toAscList rootsAndExclusions) $ \\(interpretPathRoot, exclusions) ->\n    let allExclusions = obeliskPackageExclusions\n          <> exclusions\n          <> Set.singleton (\"*\" </> attrCacheFileName)\n          <> Set.singleton (\"*\" </> \"lib/asset/manifest\") -- NB: obelisk-asset-manifest is excluded because it generates\n                                                          -- a module that in turn imports it. This will cause ob run to\n                                                          -- fail in its current implementation.\n    in fmap (Set.fromList . map normalise) $ runFind $\n      [\"-L\", interpretPathRoot, \"(\", \"-name\", \"*.cabal\", \"-o\", \"-name\", Hpack.packageConfig, \")\", \"-a\", \"-type\", \"f\"]\n      <> concat [[\"-not\", \"-path\", p </> \"*\"] | p <- toList allExclusions]\n  where\n    runFind args = do\n      (_exitCode, out, err) <- readCreateProcessWithExitCode $ proc findExePath args\n      putLog Debug $ T.strip $ T.pack err\n      pure $ map T.unpack $ T.lines $ T.strip $ T.pack out\n\n-- | Calculates a set of root 'FilePath's along with each one's corresponding set of exclusions.\n--   This is used when constructing a set of @find@ commands to run to produce a set of packages\n--   that matches the user's @--interpret@/@--no-interpret@ settings.\ncalcIntepretFinds :: FilePath -> PathTree Interpret -> MMap.MonoidalMap FilePath (Set FilePath)\ncalcIntepretFinds treeRoot0 tree0 = runIdentity $ go treeRoot0 tree0\n  where\n    go treeRoot tree = foldPathTreeFor (== Interpret_Interpret) treeRoot tree $ \\parent children -> do\n      exclusions <- foldPathTreeFor (== Interpret_NoInterpret) parent children $ \\parent' children' ->\n        pure $ Map.singleton parent' children'\n      deeperFinds <- Map.traverseWithKey go exclusions\n      pure $ MMap.singleton parent (Map.keysSet exclusions) <> fold (MMap.MonoidalMap deeperFinds)\n\n-- | Traverses a 'PathTree' and folds all leaves matching a given predicate.\nfoldPathTreeFor\n  :: forall m a b. (Applicative m, Monoid b)\n  => (a -> Bool)\n  -> FilePath\n  -> PathTree a\n  -> (FilePath -> PathTree a -> m b)\n  -> m b\nfoldPathTreeFor predicate parent children f = case children of\n  PathTree_Node (Just x) children' | predicate x -> f parent (PathTree_Node Nothing children')\n  PathTree_Node _ children' -> fmap fold $ flip Map.traverseWithKey children' $ \\k children'' ->\n    foldPathTreeFor predicate (parent </> k) children'' f\n\ndata GuessPackageFileError = GuessPackageFileError_Ambiguous [FilePath] | GuessPackageFileError_NotFound\n  deriving (Eq, Ord, Show)\ninstance Exception GuessPackageFileError\n\nnewtype HPackFilePath = HPackFilePath { unHPackFilePath :: FilePath } deriving (Eq, Ord, Show)\nnewtype CabalFilePath = CabalFilePath { unCabalFilePath :: FilePath } deriving (Eq, Ord, Show)\n\n-- | Given a directory, try to guess what the appropriate @.cabal@ or @package.yaml@ file is for the package.\nguessCabalPackageFile\n  :: (MonadIO m)\n  => FilePath -- ^ Directory or path to search for cabal package\n  -> m (Either GuessPackageFileError (Either CabalFilePath HPackFilePath))\nguessCabalPackageFile pkg = do\n  liftIO (doesDirectoryExist pkg) >>= \\case\n    False -> case cabalOrHpackFile pkg of\n      (Just hpack@(Right _)) -> pure $ Right hpack\n      (Just cabal@(Left (CabalFilePath cabalFilePath))) -> do\n        -- If the cabal file has a sibling hpack file, we use that instead\n        -- since running hpack often generates a sibling cabal file\n        let possibleHpackSibling = takeDirectory cabalFilePath </> Hpack.packageConfig\n        hasHpackSibling <- liftIO $ doesFileExist possibleHpackSibling\n        pure $ Right $ if hasHpackSibling then Right (HPackFilePath possibleHpackSibling) else cabal\n      Nothing -> pure $ Left GuessPackageFileError_NotFound\n    True -> do\n      candidates <- liftIO $\n            filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n        =<< mapMaybe (cabalOrHpackFile . (pkg </>)) <$> listDirectory pkg\n      pure $ case partitionEithers candidates of\n        ([hpack], _) -> Right $ Left hpack\n        ([], [cabal]) -> Right $ Right cabal\n        ([], []) -> Left GuessPackageFileError_NotFound\n        (hpacks, cabals) -> Left $ GuessPackageFileError_Ambiguous $ coerce hpacks <> coerce cabals\n\ncabalOrHpackFile :: FilePath -> Maybe (Either CabalFilePath HPackFilePath)\ncabalOrHpackFile = \\case\n  x | takeExtension x == \".cabal\" -> Just (Left $ CabalFilePath x)\n    | takeFileName x == Hpack.packageConfig -> Just (Right $ HPackFilePath x)\n    | otherwise -> Nothing\n\n-- | Parses the cabal package in a given directory.\n-- This automatically figures out which .cabal file or package.yaml (hpack) file to use in the given directory.\nparseCabalPackage\n  :: MonadObelisk m\n  => FilePath -- ^ Package directory\n  -> m (Maybe CabalPackageInfo)\nparseCabalPackage dir = parseCabalPackage' dir >>= \\case\n  Left err -> throwError (ObeliskError_Unstructured err)\n  Right (Just (warnings, pkgInfo)) -> do\n    for_ warnings $ putLog Warning . T.pack . show\n    pure $ Just pkgInfo\n  Right Nothing -> pure Nothing\n\n-- | Like 'parseCabalPackage' but returns errors and warnings directly so as to avoid 'MonadObelisk'.\nparseCabalPackage'\n  :: (MonadIO m)\n  => FilePath -- ^ Package directory\n  -> m (Either T.Text (Maybe ([PWarning], CabalPackageInfo)))\nparseCabalPackage' pkg = runExceptT $ do\n  (cabalContents, packageFile, packageName) <- guessCabalPackageFile pkg >>= \\case\n    Left GuessPackageFileError_NotFound -> throwError $ \"No .cabal or package.yaml file found in \" <> T.pack pkg\n    Left (GuessPackageFileError_Ambiguous _) -> throwError $ \"Unable to determine which .cabal file to use in \" <> T.pack pkg\n    Right (Left (CabalFilePath file)) -> (, file, takeBaseName file) <$> liftIO (readUTF8File file)\n    Right (Right (HPackFilePath file)) -> do\n      let\n        decodeOptions = Hpack.DecodeOptions (Hpack.ProgramName \"ob\") file Nothing Hpack.decodeYaml\n      liftIO (Hpack.readPackageConfig decodeOptions) >>= \\case\n        Left err -> throwError $ T.pack $ \"Failed to parse \" <> file <> \": \" <> err\n        Right (Hpack.DecodeResult hpackPackage _ _ _) -> pure (Hpack.renderPackage [] hpackPackage, file, Hpack.packageName hpackPackage)\n\n  let\n    (warnings, result) = runParseResult $ parseGenericPackageDescription $ toUTF8BS cabalContents\n    osConfVar = case System.Info.os of\n      \"linux\" -> Just Dist.Linux\n      \"darwin\" -> Just Dist.OSX\n      _ -> trace \"Unrecgonized System.Info.os\" Nothing\n    archConfVar = Just Dist.X86_64 -- TODO: Actually infer this\n    evalConfVar v = Right $ case v of\n      OS osVar -> Just osVar == osConfVar\n      Arch archVar -> Just archVar == archConfVar\n      Impl GHC _ -> True -- TODO: Actually check version range\n      _ -> False\n#if MIN_VERSION_Cabal(3,2,1)\n  case (view condLibrary) <$> result of\n#else\n  case condLibrary <$> result of\n#endif\n    Right (Just condLib) -> do\n      let (_, lib) = simplifyCondTree evalConfVar condLib\n      pure $ Just $ (warnings,) $ CabalPackageInfo\n        { _cabalPackageInfo_packageName = T.pack packageName\n        , _cabalPackageInfo_packageFile = packageFile\n        , _cabalPackageInfo_packageRoot = takeDirectory packageFile\n        , _cabalPackageInfo_buildable = buildable $ libBuildInfo lib\n        , _cabalPackageInfo_sourceDirs =\n            fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib\n        , _cabalPackageInfo_defaultExtensions =\n            defaultExtensions $ libBuildInfo lib\n        , _cabalPackageInfo_defaultLanguage =\n            defaultLanguage $ libBuildInfo lib\n        , _cabalPackageInfo_compilerOptions =\n            options $ libBuildInfo lib\n        , _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib\n        , _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib\n        }\n    Right Nothing -> pure Nothing\n    Left (_, errors) ->\n      throwError $ T.pack $ \"Failed to parse \" <> packageFile <> \":\\n\" <> unlines (map show $ toList errors)\n\nparsePackagesOrFail :: (MonadObelisk m, Foldable f) => f FilePath -> m (NE.NonEmpty CabalPackageInfo)\nparsePackagesOrFail dirs' = do\n  packageInfos' <- fmap catMaybes $ for dirs $ \\dir -> do\n    flip fmap (parseCabalPackage dir) $ \\case\n      Just packageInfo\n        | _cabalPackageInfo_buildable packageInfo -> Just packageInfo\n      _ -> Nothing\n\n  -- Sort duplicate packages such that we prefer shorter paths, but fall back to alphabetical ordering.\n  let packagesByName = Map.map (NE.sortBy $ comparing $ \\p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n                     $ Map.fromListWith (<>) [(_cabalPackageInfo_packageName p, p NE.:| []) | p <- packageInfos']\n  unambiguous <- ifor packagesByName $ \\packageName ps -> case ps of\n    p NE.:| [] -> pure p -- No ambiguity here\n    p NE.:| _ -> do\n      let chosenText = \"  [Chosen] \"\n          prefix p'\n            | _cabalPackageInfo_packageFile p' == _cabalPackageInfo_packageFile p = chosenText\n            | otherwise = T.map (const ' ') chosenText\n      putLog Warning $ T.unlines $\n        \"Packages named '\" <> packageName <> \"' appear in \" <> T.pack (show $ length ps) <> \" different locations: \"\n        : map (\\p' -> prefix p' <> T.pack (_cabalPackageInfo_packageFile p')) (toList ps)\n      pure p\n\n  packageInfos <- case NE.nonEmpty $ toList unambiguous of\n    Nothing -> failWith $ T.pack $\n      \"No valid, buildable packages found\" <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n    Just xs -> pure xs\n\n  pure packageInfos\n  where\n    dirs = toList dirs'\n\npackageInfoToNamePathMap :: Foldable f => f CabalPackageInfo -> Map Text FilePath\npackageInfoToNamePathMap = Map.fromList . map (_cabalPackageInfo_packageName &&& _cabalPackageInfo_packageRoot) . toList\n\n-- Like 'withGhciScript' but provides the precise ghci arguments to add to a ghci session\nwithGhciScriptArgs\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ User commands to insert into .ghci\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> ([String] -> m ()) -- ^ Action to run with the extra ghci arguments\n  -> m ()\nwithGhciScriptArgs userCommands packageInfos f =\n  withGhciScript (loadPreludeManually ++ userCommands) packageInfos $ \\fp ->\n    f [\"-XNoImplicitPrelude\", \"-ghci-script\", fp]\n  where\n    -- These lines must be first and allow the session to support a custom Prelude when @-XNoImplicitPrelude@\n    -- is passed to the ghci session.\n    loadPreludeManually =\n      [ \":add Prelude\" -- @:add@ is used because it's less noisy when there is no custom Prelude\n      , \":set -XImplicitPrelude\" -- Turn the default setting on\n      ]\n\n-- | Create ghci configuration to load the given packages\nwithGhciScript\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ Commands to prefix to file\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> (FilePath -> m ()) -- ^ Action to run with the path to generated temporary .ghci\n  -> m ()\nwithGhciScript preCommands (toList -> packageInfos) f =\n  withSystemTempDirectory \"ob-ghci\" $ \\fp -> do\n    let dotGhciPath = fp </> \".ghci\"\n    liftIO $ writeFile dotGhciPath dotGhci\n    f dotGhciPath\n  where\n    packageNames = Set.fromList $ map _cabalPackageInfo_packageName packageInfos\n    modulesToLoad = mconcat\n      [ [ \"Obelisk.Run\" | \"obelisk-run\" `Set.member` packageNames ]\n      , [ \"Backend\" | \"backend\" `Set.member` packageNames ]\n      , [ \"Frontend\" | \"frontend\" `Set.member` packageNames ]\n      ]\n    dotGhci = unlines $\n      preCommands <>\n      [ if null modulesToLoad then \"\" else \":load \" <> unwords modulesToLoad\n      , \"import qualified Obelisk.Run\"\n      , \"import qualified Frontend\"\n      , \"import qualified Backend\"\n      ]\n\n-- | Builds a list of options to pass to ghci or set in .ghci file that configures\n-- the preprocessor and source includes.\ngetGhciSessionSettings\n  :: (MonadObelisk m, Foldable f)\n  => f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> FilePath -- ^ All paths will be relative to this path\n  -> m [String]\ngetGhciSessionSettings (toList -> packageInfos) pathBase = do\n  selfExe <- liftIO $ canonicalizePath =<< getExecutablePath\n  installedPackageIndex <- loadPackageIndex packageInfos pathBase\n\n  (pkgFiles, pkgSrcPaths :: [NonEmpty FilePath]) <- fmap unzip $ liftIO $ for packageInfos $ \\pkg -> do\n    canonicalSrcDirs <- traverse canonicalizePath $ (_cabalPackageInfo_packageRoot pkg </>) <$> _cabalPackageInfo_sourceDirs pkg\n    canonicalPkgFile <- canonicalizePath $ _cabalPackageInfo_packageFile pkg\n    pure (canonicalPkgFile, canonicalSrcDirs)\n\n  pure\n    $  baseGhciOptions\n    <> [\"-DOBELISK_ASSET_PASSTHRU\"] -- For passthrough static assets\n    <> [\"-F\", \"-pgmF\", selfExe, \"-optF\", preprocessorIdentifier]\n    <> concatMap (\\p -> [\"-optF\", p]) pkgFiles\n    <> [\"-i\" <> intercalate \":\" (concatMap toList pkgSrcPaths)]\n    <> concatMap (\\packageId -> [\"-package-id\", packageId ])\n                 (packageIds installedPackageIndex)\n  where\n    -- Package names we're building and not needed from the package DB\n    packageNames =\n      map (mkPackageName . T.unpack . _cabalPackageInfo_packageName)\n          packageInfos\n    packageIds installedPackageIndex = Set.toList $ Set.fromList $\n      map (dependencyPackageId installedPackageIndex) $\n          filter ((`notElem` packageNames) . depPkgName) $\n          concatMap _cabalPackageInfo_buildDepends packageInfos <>\n            [Dependency (mkPackageName \"obelisk-run\") anyVersion (Set.singleton LMainLibName)]\n    dependencyPackageId installedPackageIndex dep =\n      case lookupDependency installedPackageIndex (depPkgName dep) (depVerRange dep) of\n        ((_version,installedPackageInfo:_) :_) ->\n          compatPackageKey installedPackageInfo\n        _ -> error $ \"Couldn't resolve dependency for \" <> prettyShow dep\n\n\n-- Load the package index used by the GHC in this path's nix project\nloadPackageIndex :: MonadObelisk m => [CabalPackageInfo] -> FilePath -> m InstalledPackageIndex\nloadPackageIndex packageInfos root = do\n  ghcPath <- getPathInNixEnvironment \"bash -c 'type -p ghc'\"\n  ghcPkgPath <- getPathInNixEnvironment \"bash -c 'type -p ghc-pkg'\"\n  (compiler, _platform, programDb) <- liftIO\n    $ configCompilerEx (Just GHC) (Just ghcPath) (Just ghcPkgPath) defaultProgramDb Verbosity.silent\n  liftIO $ getInstalledPackages Verbosity.silent compiler [GlobalPackageDB] programDb\n  where\n    getPathInNixEnvironment cmd = do\n      path <- readProcessAndLogStderr Debug =<< mkObNixShellProc root False True (packageInfoToNamePathMap packageInfos) \"ghc\" (Just cmd)\n      liftIO $ canonicalizePath $ T.unpack $ T.strip path\n\nbaseGhciOptions :: [String]\nbaseGhciOptions =\n  [ \"-ignore-dot-ghci\"\n  , \"-no-user-package-db\"\n  , \"-hide-all-packages\"\n  , \"-package-env\", \"-\"\n  ]\n\n-- | Run ghci repl\nrunGhciRepl\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> [String] -- ^ GHCi arguments\n  -> m ()\nrunGhciRepl root (toList -> packages) ghciArgs =\n  -- NOTE: We do *not* want to use $(staticWhich \"ghci\") here because we need the\n  -- ghc that is provided by the shell in the user's project.\n  nixShellWithoutPkgs root True True (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ \"ghci\" : ghciArgs\n\n-- | Run ghcid\nrunGhcid\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should we chdir to root when running this process?\n  -> [String] -- ^ GHCi arguments\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> Maybe String -- ^ Optional command to run at every reload\n  -> m ()\nrunGhcid root chdirToRoot ghciArgs (toList -> packages) mcmd =\n  nixShellWithoutPkgs root True chdirToRoot (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ ghcidExePath : opts\n  where\n    opts = concat\n      [ [\"-W\"]\n      , [\"--outputfile=ghcid-output.txt\"]\n      , map (\\x -> \"--reload=\" <> x) reloadFiles\n      , map (\\x -> \"--restart=\" <> x) restartFiles\n      , maybe [] (\\cmd -> [\"--test=\" <> cmd]) mcmd\n      -- N.B. the subcommand to ghcid has to be itself escaped.\n      -- We have to use 'shEscape' instead of 'bashEscape' because\n      -- ghcid invokes System.Process with a shell command, which uses @\\/bin\\/sh@\n      -- instead of the @bash@ we have in scope.\n      -- This is not guaranteed to be bash on non-NixOS systems.\n      , [\"--command=\" <> unwords (fmap shEscape (\"ghci\" : ghciArgs))]\n      ]\n    adjustRoot x = if chdirToRoot then makeRelative root x else x\n    reloadFiles = map adjustRoot [root </> \"config\"]\n    restartFiles = map (adjustRoot . _cabalPackageInfo_packageFile) packages\n\ngetFreePort :: MonadIO m => m Socket.PortNumber\ngetFreePort = liftIO $ Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close Socket.socketPort\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      return sock\n\n\n-- | Convert a 'FilePath' into a 'PathTree'.\npathToTree :: a -> FilePath -> PathTree a\npathToTree a p = go $ splitDirectories p\n  where\n    go [] = PathTree_Node (Just a) mempty\n    go (x : xs) = PathTree_Node Nothing $ Map.singleton x $ go xs\n\n-- | Like 'zipWith' but pads with a padding value instead of stopping on the shortest list.\nzipDefaultWith :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]\nzipDefaultWith _da _db _f []     []     = []\nzipDefaultWith  da  db  f (a:as) []     = f  a db : zipDefaultWith da db f as []\nzipDefaultWith  da  db  f []     (b:bs) = f da  b : zipDefaultWith da db f [] bs\nzipDefaultWith  da  db  f (a:as) (b:bs) = f  a  b : zipDefaultWith da db f as bs\n\n-- | Makes the first absolute path relative to the second absolute path.\n--\n-- Both input paths MUST be absolute.\n--\n-- Unlike 'makeRelative' this does not merely strip prefixes. It will introduce\n-- enough @..@ paths to make the resulting path truly relative in virtually every\n-- case. The only exception is on Windows when the two paths are on different\n-- drives. In this case the resulting path may be absolute.\nrelativeTo :: FilePath -> FilePath -> FilePath\nrelativeTo dir base\n  = bifoldr1 (</>)\n  $ bimap (collapse . (\"..\" <$) . catMaybes) (collapse . catMaybes)\n  $ unzip\n  $ dropWhile (\\(a,b) -> a == b)\n  $ zipDefaultWith Nothing Nothing (,)\n    (map Just $ splitDirectories base)\n    (map Just $ splitDirectories dir)\n  where collapse = foldr (</>) \"\"\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 2,
              "startColumn": 1,
              "endLine": 2,
              "endColumn": 32,
              "from": "{-# LANGUAGE DeriveFoldable #-}",
              "to": "",
              "note": [
                "Extension DeriveFoldable is implied by DeriveTraversable"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 2, startCol = 1, endLine = 2, endCol = 32}, newComment = \"\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 3,
              "startColumn": 1,
              "endLine": 3,
              "endColumn": 31,
              "from": "{-# LANGUAGE DeriveFunctor #-}",
              "to": "",
              "note": [
                "Extension DeriveFunctor is implied by DeriveTraversable"
              ],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 3, startCol = 1, endLine = 3, endCol = 31}, newComment = \"\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Use fewer imports",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 53,
              "startColumn": 1,
              "endLine": 53,
              "endColumn": 79,
              "from": "import Distribution.PackageDescription.Parsec\n    ( parseGenericPackageDescription )\nimport Distribution.PackageDescription.Parsec\n    ( parseGenericPackageDescription, runParseResult )\n",
              "to": "import Distribution.PackageDescription.Parsec\n    ( parseGenericPackageDescription,\n      parseGenericPackageDescription,\n      runParseResult )\n",
              "note": [],
              "refactorings": "[Replace {rtype = Import, pos = SrcSpan {startLine = 53, startCol = 1, endLine = 53, endCol = 79}, subts = [], orig = \"import Distribution.PackageDescription.Parsec\\n    ( parseGenericPackageDescription,\\n      parseGenericPackageDescription,\\n      runParseResult )\"},Delete {rtype = Import, pos = SrcSpan {startLine = 57, startCol = 1, endLine = 57, endCol = 95}}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Use fewer imports",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 64,
              "startColumn": 1,
              "endLine": 64,
              "endColumn": 45,
              "from": "import qualified Distribution.System as Dist\nimport qualified Distribution.System as Dist\n",
              "to": "import qualified Distribution.System as Dist\n",
              "note": [],
              "refactorings": "[Delete {rtype = Import, pos = SrcSpan {startLine = 84, startCol = 1, endLine = 84, endCol = 45}}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Use fewer imports",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 67,
              "startColumn": 1,
              "endLine": 67,
              "endColumn": 67,
              "from": "import Distribution.Types.Dependency ( Dependency(..), depPkgName )\nimport Distribution.Types.Dependency\n    ( Dependency(..), depPkgName, depVerRange )\n",
              "to": "import Distribution.Types.Dependency\n    ( Dependency(..),\n      depPkgName,\n      Dependency(..),\n      depPkgName,\n      depVerRange )\n",
              "note": [],
              "refactorings": "[Replace {rtype = Import, pos = SrcSpan {startLine = 67, startCol = 1, endLine = 67, endCol = 67}, subts = [], orig = \"import Distribution.Types.Dependency\\n    ( Dependency(..),\\n      depPkgName,\\n      Dependency(..),\\n      depPkgName,\\n      depVerRange )\"},Delete {rtype = Import, pos = SrcSpan {startLine = 86, startCol = 1, endLine = 86, endCol = 80}}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "Interpret"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 126,
              "startColumn": 1,
              "endLine": 126,
              "endColumn": 86,
              "from": "data Interpret\n  = Interpret_Interpret | Interpret_NoInterpret\n  deriving (Eq, Ord, Show)",
              "to": "data Interpret\n  = InterpretInterpret | InterpretNoInterpret\n  deriving (Eq, Ord, Show)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "PathTree"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 134,
              "startColumn": 1,
              "endLine": 137,
              "endColumn": 59,
              "from": "data PathTree a\n  = PathTree_Node (Maybe a) (Map FilePath (PathTree a))\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)",
              "to": "data PathTree a\n  = PathTreeNode (Maybe a) (Map FilePath (PathTree a))\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "GuessPackageFileError"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 310,
              "startColumn": 1,
              "endLine": 311,
              "endColumn": 27,
              "from": "data GuessPackageFileError\n  = GuessPackageFileError_Ambiguous [FilePath] |\n    GuessPackageFileError_NotFound\n  deriving (Eq, Ord, Show)",
              "to": "data GuessPackageFileError\n  = GuessPackageFileErrorAmbiguous [FilePath] |\n    GuessPackageFileErrorNotFound\n  deriving (Eq, Ord, Show)",
              "note": [],
              "refactorings": "[]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "guessCabalPackageFile"
              ],
              "severity": "Warning",
              "hint": "Redundant <$>",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 335,
              "startColumn": 13,
              "endLine": 336,
              "endColumn": 74,
              "from": "filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n  =<< mapMaybe (cabalOrHpackFile . (pkg </>)) <$> listDirectory pkg",
              "to": "(filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n   . mapMaybe (cabalOrHpackFile . (pkg </>))\n   =<< listDirectory pkg)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 335, startCol = 13, endLine = 336, endCol = 74}, subts = [(\"f\",SrcSpan {startLine = 336, startCol = 13, endLine = 336, endCol = 52}),(\"g\",SrcSpan {startLine = 335, startCol = 13, endLine = 335, endCol = 77}),(\"x\",SrcSpan {startLine = 336, startCol = 57, endLine = 336, endCol = 74})], orig = \"(g . f =<< x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "parseCabalPackage'"
              ],
              "severity": "Suggestion",
              "hint": "Evaluate",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 398,
              "startColumn": 21,
              "endLine": 413,
              "endColumn": 10,
              "from": "(warnings,)\n  $ CabalPackageInfo\n      {_cabalPackageInfo_packageName = T.pack packageName,\n       _cabalPackageInfo_packageFile = packageFile,\n       _cabalPackageInfo_packageRoot = takeDirectory packageFile,\n       _cabalPackageInfo_buildable = buildable $ libBuildInfo lib,\n       _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\")\n                                        $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib,\n       _cabalPackageInfo_defaultExtensions = defaultExtensions\n                                               $ libBuildInfo lib,\n       _cabalPackageInfo_defaultLanguage = defaultLanguage\n                                             $ libBuildInfo lib,\n       _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib,\n       _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib,\n       _cabalPackageInfo_buildDepends = targetBuildDepends\n                                          $ libBuildInfo lib}",
              "to": "(warnings, \n CabalPackageInfo\n   {_cabalPackageInfo_packageName = T.pack packageName,\n    _cabalPackageInfo_packageFile = packageFile,\n    _cabalPackageInfo_packageRoot = takeDirectory packageFile,\n    _cabalPackageInfo_buildable = buildable $ libBuildInfo lib,\n    _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\")\n                                     $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib,\n    _cabalPackageInfo_defaultExtensions = defaultExtensions\n                                            $ libBuildInfo lib,\n    _cabalPackageInfo_defaultLanguage = defaultLanguage\n                                          $ libBuildInfo lib,\n    _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib,\n    _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib,\n    _cabalPackageInfo_buildDepends = targetBuildDepends\n                                       $ libBuildInfo lib})",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 398, startCol = 21, endLine = 413, endCol = 10}, subts = [(\"a\",SrcSpan {startLine = 398, startCol = 22, endLine = 398, endCol = 30}),(\"b\",SrcSpan {startLine = 398, startCol = 35, endLine = 413, endCol = 10})], orig = \"(a, b)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "parsePackagesOrFail"
              ],
              "severity": "Warning",
              "hint": "Redundant pure",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 419,
              "startColumn": 29,
              "endLine": 446,
              "endColumn": 20,
              "from": "do packageInfos' <- fmap catMaybes\n                      $ for dirs\n                          $ \\ dir\n                              -> do flip fmap (parseCabalPackage dir)\n                                      $ \\case\n                                          Just packageInfo\n                                            | _cabalPackageInfo_buildable packageInfo\n                                            -> Just packageInfo\n                                          _ -> Nothing\n   let packagesByName\n         = Map.map\n             (NE.sortBy\n                $ comparing\n                    $ \\ p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n             $ Map.fromListWith\n                 (<>)\n                 [(_cabalPackageInfo_packageName p, p NE.:| []) |\n                    p <- packageInfos']\n   unambiguous <- ifor packagesByName\n                    $ \\ packageName ps\n                        -> case ps of\n                             p NE.:| [] -> pure p\n                             p NE.:| _\n                               -> do let chosenText = \"  [Chosen] \"\n                                         prefix p'\n                                           | _cabalPackageInfo_packageFile p'\n                                               == _cabalPackageInfo_packageFile p\n                                           = chosenText\n                                           | otherwise = T.map (const ' ') chosenText\n                                     putLog Warning\n                                       $ T.unlines\n                                           $ \"Packages named '\"\n                                               <>\n                                                 packageName\n                                                   <>\n                                                     \"' appear in \"\n                                                       <>\n                                                         T.pack (show $ length ps)\n                                                           <> \" different locations: \"\n                                               : map\n                                                   (\\ p'\n                                                      -> prefix p'\n                                                           <>\n                                                             T.pack\n                                                               (_cabalPackageInfo_packageFile p'))\n                                                   (toList ps)\n                                     pure p\n   packageInfos <- case NE.nonEmpty $ toList unambiguous of\n                     Nothing\n                       -> failWith\n                            $ T.pack\n                                $ \"No valid, buildable packages found\"\n                                    <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n                     Just xs -> pure xs\n   pure packageInfos",
              "to": "do packageInfos' <- fmap catMaybes\n                      $ for dirs\n                          $ \\ dir\n                              -> do flip fmap (parseCabalPackage dir)\n                                      $ \\case\n                                          Just packageInfo\n                                            | _cabalPackageInfo_buildable packageInfo\n                                            -> Just packageInfo\n                                          _ -> Nothing\n   let packagesByName\n         = Map.map\n             (NE.sortBy\n                $ comparing\n                    $ \\ p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n             $ Map.fromListWith\n                 (<>)\n                 [(_cabalPackageInfo_packageName p, p NE.:| []) |\n                    p <- packageInfos']\n   unambiguous <- ifor packagesByName\n                    $ \\ packageName ps\n                        -> case ps of\n                             p NE.:| [] -> pure p\n                             p NE.:| _\n                               -> do let chosenText = \"  [Chosen] \"\n                                         prefix p'\n                                           | _cabalPackageInfo_packageFile p'\n                                               == _cabalPackageInfo_packageFile p\n                                           = chosenText\n                                           | otherwise = T.map (const ' ') chosenText\n                                     putLog Warning\n                                       $ T.unlines\n                                           $ \"Packages named '\"\n                                               <>\n                                                 packageName\n                                                   <>\n                                                     \"' appear in \"\n                                                       <>\n                                                         T.pack (show $ length ps)\n                                                           <> \" different locations: \"\n                                               : map\n                                                   (\\ p'\n                                                      -> prefix p'\n                                                           <>\n                                                             T.pack\n                                                               (_cabalPackageInfo_packageFile p'))\n                                                   (toList ps)\n                                     pure p\n   case NE.nonEmpty $ toList unambiguous of\n     Nothing\n       -> failWith\n            $ T.pack\n                $ \"No valid, buildable packages found\"\n                    <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n     Just xs -> pure xs",
              "note": [],
              "refactorings": "[Replace {rtype = Stmt, pos = SrcSpan {startLine = 441, startCol = 3, endLine = 444, endCol = 23}, subts = [(\"x\",SrcSpan {startLine = 441, startCol = 19, endLine = 444, endCol = 23})], orig = \"x\"},Delete {rtype = Stmt, pos = SrcSpan {startLine = 446, startCol = 3, endLine = 446, endCol = 20}}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "getGhciSessionSettings"
              ],
              "severity": "Warning",
              "hint": "Fuse traverse/<$>",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 510,
              "startColumn": 25,
              "endLine": 510,
              "endColumn": 129,
              "from": "traverse canonicalizePath\n  $ (_cabalPackageInfo_packageRoot pkg </>)\n      <$> _cabalPackageInfo_sourceDirs pkg",
              "to": "traverse\n  (canonicalizePath . (_cabalPackageInfo_packageRoot pkg </>))\n  (_cabalPackageInfo_sourceDirs pkg)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 510, startCol = 25, endLine = 510, endCol = 129}, subts = [(\"f\",SrcSpan {startLine = 510, startCol = 34, endLine = 510, endCol = 50}),(\"g\",SrcSpan {startLine = 510, startCol = 53, endLine = 510, endCol = 92}),(\"x\",SrcSpan {startLine = 510, startCol = 97, endLine = 510, endCol = 129})], orig = \"traverse (f . g) (x)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "runGhcid"
              ],
              "severity": "Suggestion",
              "hint": "Avoid lambda",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 589,
              "startColumn": 13,
              "endLine": 589,
              "endColumn": 37,
              "from": "(\\ x -> \"--reload=\" <> x)",
              "to": "(\"--reload=\" <>)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 589, startCol = 13, endLine = 589, endCol = 37}, subts = [], orig = \"(\\\"--reload=\\\" <>)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "runGhcid"
              ],
              "severity": "Suggestion",
              "hint": "Avoid lambda",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 590,
              "startColumn": 13,
              "endLine": 590,
              "endColumn": 38,
              "from": "(\\ x -> \"--restart=\" <> x)",
              "to": "(\"--restart=\" <>)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 590, startCol = 13, endLine = 590, endCol = 38}, subts = [], orig = \"(\\\"--restart=\\\" <>)\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "runGhcid"
              ],
              "severity": "Warning",
              "hint": "Evaluate",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 600,
              "startColumn": 19,
              "endLine": 600,
              "endColumn": 53,
              "from": "map adjustRoot [root </> \"config\"]",
              "to": "[adjustRoot (root </> \"config\")]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 600, startCol = 19, endLine = 600, endCol = 53}, subts = [(\"a\",SrcSpan {startLine = 600, startCol = 35, endLine = 600, endCol = 52}),(\"f\",SrcSpan {startLine = 600, startCol = 23, endLine = 600, endCol = 33})], orig = \"[f (a)]\"}]"
            },
            {
              "module": [
                "Obelisk.Command.Run"
              ],
              "decl": [
                "relativeTo"
              ],
              "severity": "Suggestion",
              "hint": "Use uncurry",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "startLine": 641,
              "startColumn": 16,
              "endLine": 641,
              "endColumn": 32,
              "from": "\\ (a, b) -> a == b",
              "to": "uncurry (==)",
              "note": [
                "increases laziness"
              ],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 641, startCol = 16, endLine = 641, endCol = 32}, subts = [], orig = \"uncurry (==)\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Run.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Run.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 7,
            "average": 2.5714285714285716,
            "sum": 18
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 1,
            "ignore": 0,
            "total": 1
          },
          "syntax_errors": 10,
          "lines_of_code": 140,
          "homplexity_lines_of_code": 168,
          "code_quality_score": 47.2,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 7,
              "average": 2.5714285714285716,
              "sum": 18
            },
            "homplexity_loc": 168,
            "homplexity_output": "Info:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 1 1: module Obelisk.Command.Preprocessor has 98 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 31 1: type signature for applyPackages has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 31 1: type signature for applyPackages has 5 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has 20 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has cyclomatic complexity of 4 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 58 1: type signature for writeOutput has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 58 1: type signature for writeOutput has 4 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has 10 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 74 5: data GenHeaderError has record fields count of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 80 1: type signature for prettyGenHeaderError has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 80 1: type signature for prettyGenHeaderError has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has 4 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has branching depth of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has cyclomatic complexity of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 93 1: type signature for generateHeader has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 93 1: type signature for generateHeader has 3 arguments \nWarning:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has 33 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has cyclomatic complexity of 7 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has branching depth of 2 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 133 1: type signature for lineNumberPragma has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 133 1: type signature for lineNumberPragma has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 136 1: type signature for pragma has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 136 1: type signature for pragma has 2 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has branching depth of 0 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 139 1: type signature for quoted has type constructor nesting of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 139 1: type signature for quoted has 3 arguments \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has cyclomatic complexity of 1 \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has 1 lines of code \nInfo:/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Obelisk.Command.Preprocessor where\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Builder as BU\nimport Data.Foldable (for_)\nimport Data.List (intersperse, isPrefixOf, sortOn)\nimport Data.Maybe (fromMaybe)\nimport qualified Data.Text.Lazy.Builder as TL\nimport qualified Data.Text.Lazy.Encoding as TL\nimport Distribution.Compiler (CompilerFlavor (..), perCompilerFlavorToList)\nimport Language.Haskell.Extension (Extension (..), Language(..))\nimport System.Directory (canonicalizePath)\nimport System.IO (IOMode (..), hPutStrLn, stderr, withFile)\nimport System.FilePath (hasTrailingPathSeparator, joinPath, splitPath)\nimport Control.Lens ((<&>))\nimport System.Exit\n\nimport Obelisk.Command.Run (CabalPackageInfo (..), parseCabalPackage')\n\n-- | This code is intended to be executed via ghci's -pgmF preprocessor option.\n-- The command line arguments are passed in via ghc, which dictates the first three options and meanings\n-- In order for this code to execute, origPath must contain either a '.' character or a '/' character.\n-- (This is to avoid the possibility of the command line syntax conflicting with another ob command)\n-- We do have control over the remaining arguments, but they must be the same for all files.\n-- Thus, the fourth command line argument must be \"apply-packages\",  which has already been handled.\n-- We assume all the remaining arguments passed in are paths to cabal or hpack package specifications.\n-- Thus we must select among the packagePaths for the file we are going to parse.\napplyPackages :: FilePath -> FilePath -> FilePath -> [FilePath] -> IO ()\napplyPackages origPath inPath outPath packagePaths' = do\n  origPathCanonical <- canonicalizePath origPath\n  packagePaths <- traverse canonicalizePath packagePaths'\n\n  let\n    takeDirs = takeWhile hasTrailingPathSeparator\n    packageDirs = sortOn (negate . length . takeDirs) $ map splitPath packagePaths\n    origDir = splitPath origPathCanonical\n    matches = [ joinPath d | d <- packageDirs, takeDirs d `isPrefixOf` origDir ]\n    giveUp = exitWith (ExitFailure 1)\n\n  -- The first element of matches is going to be the deepest path to a package spec that contains\n  -- our file as a subdirectory.\n  packageInfo' <- case matches of\n    [] -> do\n      hPutStrLn stderr $ \"Error: Unable to find cabal information for \" <> origPath <> \"; Skipping preprocessor.\"\n      giveUp\n    packagePath:_ -> parseCabalPackage' packagePath >>= \\case\n      Left err -> do\n        hPutStrLn stderr $ \"Error: Unable to parse cabal package \" <> packagePath <> \"; Skipping preprocessor on \" <> origPath <> \". Error: \" <> show err\n        giveUp\n      Right (Just (_, packageInfo)) -> pure $ Just packageInfo\n      Right Nothing -> pure Nothing\n\n  writeOutput packageInfo' inPath outPath\n\nwriteOutput :: Maybe CabalPackageInfo -> FilePath -> FilePath -> IO ()\nwriteOutput packageInfo' origPath outPath = withFile outPath WriteMode $ \\hOut -> do\n  for_ packageInfo' $ \\packageInfo ->\n    case generateHeader origPath packageInfo of\n      Left e -> do\n        hPutStrLn stderr (prettyGenHeaderError origPath e)\n        giveUp\n      Right header -> hPutTextBuilder hOut header\n  BL.readFile origPath >>= BL.hPut hOut\n  where\n    hPutTextBuilder h = BU.hPutBuilder h . TL.encodeUtf8Builder . TL.toLazyText\n    giveUp = exitWith (ExitFailure 1)\n\n-- | Represents an error which may happen when turning a\n-- 'CabalPackageInfo' into a set of GHC pragmas.\ndata GenHeaderError\n  = GenHeaderError_UnknownLanguage String\n  -- ^ An invalid @default-language@ field was specified.\n  | GenHeaderError_UnknownExtension String\n  -- ^ An invalid value was present in the @default-extensions@ field.\n\n-- | Turn a 'GenHeaderError' to a string suitable for display to the user.\nprettyGenHeaderError :: String -> GenHeaderError -> String\nprettyGenHeaderError origPath =\n  \\case\n    GenHeaderError_UnknownExtension e -> \"Error: Unknown default-extension \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n    GenHeaderError_UnknownLanguage e -> \"Error: Unknown default-language \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n\n-- | Turn a parsed 'CabalPackageInfo' into a set of GHC pragmas which\n-- reproduce the same settings.\n--\n-- NOTE: We cannot restrict the package set by adding '-package' flags\n-- to OPTIONS_GHC, because GHC rejects them there.  It seems that we\n-- won't be able to properly handle that situation until GHC itself\n-- supports loading multiple packages officially in GHCi\ngenerateHeader :: FilePath -> CabalPackageInfo -> Either GenHeaderError TL.Builder\ngenerateHeader origPath packageInfo =\n    fmap (\\e -> e <> ghcOptions <> lineNumberPragma origPath) hsExtensions\n  where\n    hsExtensions :: Either GenHeaderError TL.Builder\n    hsExtensions = extList <&> \\exts ->\n      if null exts\n        then mempty\n        else pragma $ TL.fromText \"LANGUAGE \" <> mconcat (intersperse (TL.fromText \", \") exts)\n\n    extList :: Either GenHeaderError [TL.Builder]\n    extList = addDefaultLanguage =<< traverse showExt (_cabalPackageInfo_defaultExtensions packageInfo)\n\n    addDefaultLanguage :: [TL.Builder] -> Either GenHeaderError [TL.Builder]\n    addDefaultLanguage exts =\n      case _cabalPackageInfo_defaultLanguage packageInfo of\n        Nothing -> pure exts\n        Just x -> case x of\n          UnknownLanguage ext -> Left (GenHeaderError_UnknownExtension ext)\n          ext -> pure $ TL.fromString (show ext):exts\n\n    showExt :: Extension -> Either GenHeaderError TL.Builder\n    showExt = \\case\n      EnableExtension ext -> pure $ TL.fromString (show ext)\n      DisableExtension ext -> pure $ \"No\" <> TL.fromString (show ext)\n      UnknownExtension ext -> Left (GenHeaderError_UnknownExtension ext)\n\n    ghcOptions =\n      if null optList\n        then mempty\n        else pragma $\n          TL.fromText \"OPTIONS_GHC \" <> mconcat (intersperse (TL.fromText \" \") (map TL.fromString optList))\n    ghcOptList\n      = filter (not . isPrefixOf \"-O\")\n      $ fromMaybe []\n      $ lookup GHC\n      $ perCompilerFlavorToList\n      $ _cabalPackageInfo_compilerOptions packageInfo\n    optList = _cabalPackageInfo_cppOptions packageInfo <> ghcOptList\n\nlineNumberPragma :: FilePath -> TL.Builder\nlineNumberPragma origPath = pragma $ TL.fromText \"LINE 1 \" <> quoted '\"' (TL.fromString origPath)\n\npragma :: TL.Builder -> TL.Builder\npragma x = TL.fromText \"{-# \" <> x <> TL.fromText \" #-}\\n\"\n\nquoted :: Char -> TL.Builder -> TL.Builder\nquoted char x = TL.singleton char <> x <> TL.singleton char\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Command.Preprocessor"
              ],
              "decl": [
                "GenHeaderError"
              ],
              "severity": "Suggestion",
              "hint": "Use camelCase",
              "file": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs",
              "startLine": 73,
              "startColumn": 1,
              "endLine": 76,
              "endColumn": 43,
              "from": "data GenHeaderError\n  = GenHeaderError_UnknownLanguage String |\n    GenHeaderError_UnknownExtension String",
              "to": "data GenHeaderError\n  = GenHeaderErrorUnknownLanguage String |\n    GenHeaderErrorUnknownExtension String",
              "note": [],
              "refactorings": "[]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs"
          }
        },
        {
          "file_name": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 17,
            "average": 6,
            "sum": 63
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 3,
            "ignore": 0,
            "total": 4
          },
          "syntax_errors": 43,
          "lines_of_code": 357,
          "homplexity_lines_of_code": 578,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 17,
              "average": 6,
              "sum": 63
            },
            "homplexity_loc": 578,
            "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"bindPortTCPRetry\": 5,\n        \"defaultRunApp\": 2,\n        \"getConfigRoute\": 6,\n        \"getProcessIdForPort\": 4,\n        \"logPortBindErr\": 3,\n        \"obeliskApp\": 14,\n        \"renderJsaddleFrontend\": 1,\n        \"run\": 10,\n        \"runServeAsset\": 1,\n        \"runWidget\": 17,\n        \"min\": 1,\n        \"max\": 17,\n        \"average\": 6.3,\n        \"sum\": 63\n    },\n    \"homplexity_loc\": 578,\n    \"homplexity_output\": \"\"\n}\n"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n#if defined(IPROUTE_SUPPORTED)\n{-# LANGUAGE TemplateHaskell #-}\n#endif\n\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-} -- Due to instance HasJS x (EventWriterT t w m)\nmodule Obelisk.Run where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Applicative\nimport Control.Exception\nimport Control.Lens ((%~), (^?), _Just, _Right)\nimport qualified Data.Attoparsec.ByteString.Char8 as A\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BSC\nimport qualified Data.ByteString.Lazy.Char8 as BSLC\nimport qualified Data.ByteString.UTF8 as BSUTF8\nimport Data.Functor.Identity\nimport Data.List (uncons)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup ((<>))\n#endif\nimport Data.Streaming.Network (bindPortTCP)\nimport Data.String (fromString)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Time.Clock (getCurrentTime, addUTCTime)\nimport Language.Javascript.JSaddle.Run (syncPoint)\nimport Language.Javascript.JSaddle.WebSockets\nimport Network.HTTP.Client (Manager, defaultManagerSettings, newManager)\nimport qualified Network.HTTP.ReverseProxy as RP\nimport qualified Network.HTTP.Types as H\nimport Network.Socket\nimport Network.Wai (Application)\nimport qualified Network.Wai as W\nimport Network.Wai.Handler.Warp\nimport Network.Wai.Handler.WarpTLS\nimport Network.Wai.Handler.Warp.Internal (settingsHost, settingsPort)\nimport Network.WebSockets (ConnectionOptions)\nimport Network.WebSockets.Connection (defaultConnectionOptions)\nimport qualified Obelisk.Asset.Serve.Snap as Snap\nimport Obelisk.Backend\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport qualified OpenSSL.PEM as PEM\nimport qualified OpenSSL.RSA as RSA\nimport qualified OpenSSL.X509 as X509\nimport qualified OpenSSL.X509.Request as X509Request\nimport Reflex.Dom.Core\nimport Snap.Core (Snap)\nimport System.Environment\nimport System.FilePath ((</>))\nimport System.IO\nimport System.Process\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Web.Cookie\n\n#if defined(IPROUTE_SUPPORTED)\nimport qualified System.Which\n#endif\n\n-- | The arguments to 'run', specifying the configuration and\n-- implementation of an Obelisk application.\ndata RunApp backendRoute frontendRoute\n  = RunApp\n    { _runApp_backendPort      :: Int\n      -- ^ What port should we serve the backend on? This is used for\n      -- internal communication.\n    , _runApp_backendHost      :: ByteString\n      -- ^ The hostname on which the backend is running. By default,\n      -- this is @127.0.0.1@, i.e., the local machine. Routes not\n      -- handled by the frontend will be redirected to this host.\n    , _runApp_forceFrontendPort :: Maybe Int\n      -- ^ If set, overrides the port on which the frontend will be\n      -- served. If unset, the port will be parsed from the configured\n      -- route.\n    , _runApp_tlsCertDirectory :: Maybe FilePath\n      -- ^ Optional directory in which to find \"cert.pem\", \"chain.pem\"\n      -- and \"privkey.pem\" to be used for TLS.\n      -- If this is 'Nothing' and TLS is enabled, we'll generate a\n      -- self-signed cert.\n    , _runApp_staticHandler    :: [Text] -> Snap ()\n      -- ^ How to serve static assets.\n    , _runApp_backend          :: Backend backendRoute frontendRoute\n      -- ^ The backend.\n    , _runApp_frontend         :: Frontend (R frontendRoute)\n      -- ^ The frontend.\n    }\n\n-- | Construct a 'RunApp' with sane defaults. The TLS certificate\n-- directory will be set to 'Nothing', the backend host will be the\n-- local machine (@127.0.0.1@), the backend port will be set to @3001@,\n-- the frontend port will be fetched from the route configuration.\ndefaultRunApp\n  :: Backend backendRoute frontendRoute -- ^ The backend to use\n  -> Frontend (R frontendRoute)         -- ^ The frontend to use\n  -> ([Text] -> Snap ())                -- ^ How to serve static assets\n  -> RunApp backendRoute frontendRoute\ndefaultRunApp be fe static = RunApp\n  { _runApp_backendPort = 3001\n  , _runApp_backendHost = \"127.0.0.1\"\n  , _runApp_forceFrontendPort = Nothing\n  , _runApp_tlsCertDirectory = Nothing\n  , _runApp_staticHandler = static\n  , _runApp_backend = be\n  , _runApp_frontend = fe\n  }\n\n-- | Run an Obelisk application, including the frontend and backend. The\n-- backend routes are served on the port given by '_runApp_backendPort',\n-- but are also accessible through the frontend.\nrun :: RunApp backendRoute frontendRoute -> IO ()\nrun toRun = do\n  prettifyOutput\n\n  let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"backend stopped; make a change to your code to reload - error \" <> show e\n\n  --TODO: Use Obelisk.Backend.runBackend; this will require separating the checking and running phases\n  case checkEncoder $ _backend_routeEncoder (_runApp_backend toRun) of\n    Left e -> hPutStrLn stderr $ \"backend error:\\n\" <> T.unpack e\n    Right validFullEncoder -> do\n      publicConfigs <- getPublicConfigs\n\n      -- We start the backend server listening on the\n      -- '_runApp_backendPort'. The backend and frontend run in\n      -- different servers: The frontend server will pass any routes it\n      -- can't handle to this process.\n      backendTid <- forkIO $ handle handleBackendErr $ withArgs [\"--quiet\", \"--port\", show (_runApp_backendPort toRun)] $\n        _backend_run (_runApp_backend toRun) $ \\serveRoute ->\n          runSnapWithCommandLineArgs $\n            getRouteWith validFullEncoder >>= \\case\n              Identity r -> case r of\n                FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n                FullRoute_Frontend obeliskRoute :/ a ->\n                  serveDefaultObeliskApp appRouteToUrl (($ allJsUrl) <$> defaultGhcjsWidgets)\n                    (_runApp_staticHandler toRun) (_runApp_frontend toRun) publicConfigs $ obeliskRoute :/ a\n                  where\n                    appRouteToUrl (k :/ v) = renderObeliskRoute validFullEncoder (FullRoute_Frontend (ObeliskRoute_App k) :/ v)\n                    allJsUrl = renderAllJsPath validFullEncoder\n\n      runWidget toRun publicConfigs validFullEncoder `finally` killThread backendTid\n\n-- Convenience wrapper to handle path segments for 'Snap.serveAsset'\nrunServeAsset :: FilePath -> [Text] -> Snap ()\nrunServeAsset rootPath t =\n  Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\" $ t\n\ngetConfigRoute :: Map Text ByteString -> Either Text URI\ngetConfigRoute configs = case Map.lookup \"common/route\" configs of\n    Just r ->\n      let stripped = T.strip (T.decodeUtf8 r)\n      in case URI.mkURI stripped of\n          Just route -> Right route\n          Nothing -> Left $ \"Couldn't parse route as URI; value read was: \" <> T.pack (show stripped)\n    Nothing -> Left $ \"Couldn't find config file common/route; it should contain the site's canonical root URI\" <> T.pack (show $ Map.keys configs)\n\n-- | Start the frontend (given in the 'RunApp' record), with the given\n-- configuration and the given 'FullRoute' encoder, which must be valid.\nrunWidget\n  :: RunApp backendRoute frontendRoute\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> IO ()\nrunWidget toRun configs validFullEncoder = do\n  uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n  let -- Before we can do anything, we need to pick a port to serve the\n      -- backend on. If the user has asked to override it, then we use that:\n      -- they know what they're doing. Otherwise, we'll use the port\n      -- specified in the route.\n      port = fromMaybe 80 $ (_runApp_forceFrontendPort toRun)\n                        <|> (fmap fromIntegral $ uri ^? uriAuthority . _Right . authPort . _Just)\n\n      -- This is the server that will handle the backend requests. We\n      -- support shuttling them off to any host:port pair.\n      redirectHost = _runApp_backendHost toRun\n      redirectPort = _runApp_backendPort toRun\n\n      -- TLS toggle logic: 'routeIsTLS' indicates whether the\n      -- configuration would have mandated TLS (at the moment this is\n      -- only because the route is https://...).\n      -- 'portDisabledTLS' indicates whether the user forced us to use a\n      -- port different than that of the route, and thus TLS was\n      -- disabled.\n      routeIsTLS = (Just \"https\" == uri ^? uriScheme . _Just . unRText)\n      portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n\n      beforeMainLoop = do\n        putStrLn $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n        putStrLn $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n        -- TLS toggle logic: If the --port option was given, warn the\n        -- user that TLS is being skipped.\n        when (routeIsTLS && portDisabledTLS) $ do\n          putStrLn \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n          putStrLn \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n\n\n      settings = setBeforeMainLoop beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n\n      -- Providing TLS here will also incidentally provide it to proxied\n      -- requests to the backend.\n      prepareRunner =\n        -- TLS toggle logic: If the port option was NOT given, then use\n        -- TLS iff the route has it.\n        if not portDisabledTLS && routeIsTLS then\n          case _runApp_tlsCertDirectory toRun of\n            Nothing -> do\n              -- Generate a private key and self-signed certificate for TLS\n              privateKey <- RSA.generateRSAKey' 2048 3\n\n              certRequest <- X509Request.newX509Req\n              _ <- X509Request.setPublicKey certRequest privateKey\n              _ <- X509Request.signX509Req certRequest privateKey Nothing\n\n              cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n              _ <- X509.setPublicKey cert privateKey\n              timenow <- getCurrentTime\n              _ <- X509.setNotBefore cert $ addUTCTime (-1) timenow\n              _ <- X509.setNotAfter cert $ addUTCTime (365 * 24 * 60 * 60) timenow\n              _ <- X509.signX509 cert privateKey Nothing\n\n              certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n              privateKeyByteString <- BSUTF8.fromString <$> PEM.writePKCS8PrivateKey privateKey Nothing\n\n              return $ runTLSSocket (tlsSettingsMemory certByteString privateKeyByteString)\n            Just certDir -> do\n              putStrLn $ \"Using certificate information from: \" ++ certDir\n              return $ runTLSSocket (tlsSettingsChain (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"] (certDir </> \"key.pem\"))\n        else return runSettingsSocket\n\n  runner <- prepareRunner\n  bracket\n    (bindPortTCPRetry settings (logPortBindErr port) 1)\n    close\n    (\\skt -> do\n        man <- newManager defaultManagerSettings\n        app <- obeliskApp configs defaultConnectionOptions (_runApp_frontend toRun) validFullEncoder uri $ fallbackProxy redirectHost redirectPort man\n        runner settings skt app)\n\n\n-- | Build a WAI 'Application' to serve the given Obelisk 'Frontend',\n-- using the specified 'Encoder' to parse routes. Any requests whose\n-- route does not result in a 'FullRoute_Frontend' parse will be\n-- redirected to the backend.\nobeliskApp\n  :: forall frontendRoute backendRoute\n  .  Map Text ByteString -- ^ The parsed configuration\n  -> ConnectionOptions   -- ^ Connection options for the JSaddle websocket\n  -> Frontend (R frontendRoute) -- ^ The Obelisk frontend\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n     -- ^ An encoder for parsing frontend routes.\n  -> URI\n    -- ^ The 'URI' on which the 'Frontend' will be served. Used for\n    -- establishing the JSaddle websocket connection.\n  -> Application -- ^ A WAI 'Application' which handles backend requests.\n  -> IO Application\nobeliskApp configs opts frontend validFullEncoder uri backend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate = True\n        , _frontendMode_adjustRoute = False\n        }\n      entryPoint = do\n        runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n        syncPoint\n  jsaddlePath <- URI.mkPathPiece \"jsaddle\"\n  let jsaddleUri = BSLC.fromStrict $ URI.renderBs $ uri & uriPath %~ (<>[jsaddlePath])\n  Right (jsaddleWarpRouteValidEncoder :: Encoder Identity (Either Text) (R JSaddleWarpRoute) PageName) <- return $ checkEncoder jsaddleWarpRouteEncoder\n  jsaddle <- jsaddleWithAppOr opts entryPoint $ \\_ sendResponse -> sendResponse $ W.responseLBS H.status500 [(\"Content-Type\", \"text/plain\")] \"obeliskApp: jsaddle got a bad URL\"\n  return $ \\req sendResponse -> case tryDecode validFullEncoder $ byteStringsToPageName (BS.dropWhile (== (fromIntegral $ fromEnum '/')) $ W.rawPathInfo req) (BS.drop 1 $ W.rawQueryString req) of\n    Identity r -> case r of\n      FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_JSaddleWarp) :/ jsaddleRoute -> case jsaddleRoute of\n        JSaddleWarpRoute_JavaScript :/ () -> sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", \"application/javascript\")] $ jsaddleJs' (Just jsaddleUri) False\n        _ -> flip jsaddle sendResponse $ req\n          { W.pathInfo = fst $ encode jsaddleWarpRouteValidEncoder jsaddleRoute\n          }\n      FullRoute_Frontend (ObeliskRoute_App appRouteComponent) :/ appRouteRest -> do\n        let cookies = maybe [] parseCookies $ lookup (fromString \"Cookie\") (W.requestHeaders req)\n            routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n        html <- renderJsaddleFrontend configs cookies routeToUrl (appRouteComponent :/ appRouteRest) frontend\n        sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", staticRenderContentType)] $ BSLC.fromStrict html\n      _ -> backend req sendResponse\n\nrenderJsaddleFrontend\n  :: Map Text ByteString\n  -> Cookies\n  -> (route -> Text)\n  -> route\n  -> Frontend route\n  -> IO ByteString\nrenderJsaddleFrontend configs cookies urlEnc r f =\n  let jsaddleScript = elAttr \"script\" (\"src\" =: \"/jsaddle/jsaddle.js\") blank\n      jsaddlePreload = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: \"/jsaddle/jsaddle.js\") blank\n  in renderFrontendHtml configs cookies urlEnc r f jsaddlePreload jsaddleScript\n\n-- | like 'bindPortTCP' but reconnects on exception\nbindPortTCPRetry :: Settings\n                 -> (IOError -> IO ()) -- ^ Action to run the first time an exception is caught\n                 -> Int\n                 -> IO Socket\nbindPortTCPRetry settings m n = catch (bindPortTCP (settingsPort settings) (settingsHost settings)) $ \\(e :: IOError) -> do\n  m e\n  threadDelay $ 1000000 * n\n  bindPortTCPRetry settings (\\_ -> pure ()) n\n\nlogPortBindErr :: Int -> IOError -> IO ()\nlogPortBindErr p e = getProcessIdForPort p >>= \\case\n  Nothing -> putStrLn $ \"runWidget: \" <> show e\n  Just pid -> putStrLn $ unwords [ \"Port\", show p, \"is being used by process ID\", show pid <> \".\", \"Please kill that process or change the port in config/common/route.\"]\n\nssPath :: Maybe String\nssPath =\n#if defined(IPROUTE_SUPPORTED)\n  Just $(System.Which.staticWhich \"ss\")\n#else\n  Nothing\n#endif\n\ngetProcessIdForPort :: Int -> IO (Maybe Int)\ngetProcessIdForPort port = case ssPath of\n  Just ss -> do\n    xs <- lines <$> readProcess ss [\"-lptn\", \"sport = \" <> show port] mempty\n    case uncons xs of\n      Just (_, x:_) -> return $ A.maybeResult $ A.parse parseSsPid $ BSC.pack x\n      _ -> return Nothing\n  _ -> return Nothing\n\nparseSsPid :: A.Parser Int\nparseSsPid = do\n  _ <- A.count 5 $ A.takeWhile (not . A.isSpace) *> A.skipSpace\n  _ <- A.skipWhile (/= ':') >> A.string \":((\" >> A.skipWhile (/= ',')\n  A.string \",pid=\" *> A.decimal\n\nfallbackProxy :: ByteString -> Int -> Manager -> Application\nfallbackProxy host port = RP.waiProxyTo handleRequest RP.defaultOnExc\n  where handleRequest _req = return $ RP.WPRProxyDest $ RP.ProxyDest host port\n",
          "suggestions": [
            {
              "module": [
                "Obelisk.Run"
              ],
              "decl": [
                "runServeAsset"
              ],
              "severity": "Warning",
              "hint": "Eta reduce",
              "file": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "startLine": 168,
              "startColumn": 1,
              "endLine": 169,
              "endColumn": 65,
              "from": "runServeAsset rootPath t\n  = Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\" $ t",
              "to": "runServeAsset rootPath\n  = Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\"",
              "note": [],
              "refactorings": "[Replace {rtype = Decl, pos = SrcSpan {startLine = 168, startCol = 1, endLine = 169, endCol = 65}, subts = [(\"body\",SrcSpan {startLine = 169, startCol = 3, endLine = 169, endCol = 61}),(\"a\",SrcSpan {startLine = 168, startCol = 15, endLine = 168, endCol = 23})], orig = \"runServeAsset a = body\"}]"
            },
            {
              "module": [
                "Obelisk.Run"
              ],
              "decl": [
                "runWidget"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "startLine": 193,
              "startColumn": 29,
              "endLine": 193,
              "endColumn": 62,
              "from": "(_runApp_forceFrontendPort toRun)\n  <|>\n    (fmap fromIntegral\n       $ uri ^? uriAuthority . _Right . authPort . _Just)",
              "to": "_runApp_forceFrontendPort toRun\n  <|>\n    (fmap fromIntegral\n       $ uri ^? uriAuthority . _Right . authPort . _Just)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 193, startCol = 29, endLine = 193, endCol = 62}, subts = [(\"x\",SrcSpan {startLine = 193, startCol = 30, endLine = 193, endCol = 61})], orig = \"x\"}]"
            },
            {
              "module": [
                "Obelisk.Run"
              ],
              "decl": [
                "runWidget"
              ],
              "severity": "Suggestion",
              "hint": "Move brackets to avoid $",
              "file": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "startLine": 193,
              "startColumn": 29,
              "endLine": 194,
              "endColumn": 98,
              "from": "(_runApp_forceFrontendPort toRun)\n  <|>\n    (fmap fromIntegral\n       $ uri ^? uriAuthority . _Right . authPort . _Just)",
              "to": "(_runApp_forceFrontendPort toRun)\n  <|>\n    fmap fromIntegral (uri ^? uriAuthority . _Right . authPort . _Just)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 194, startCol = 29, endLine = 194, endCol = 98}, subts = [(\"a\",SrcSpan {startLine = 194, startCol = 30, endLine = 194, endCol = 47}),(\"b\",SrcSpan {startLine = 194, startCol = 50, endLine = 194, endCol = 97})], orig = \"a (b)\"}]"
            },
            {
              "module": [
                "Obelisk.Run"
              ],
              "decl": [
                "runWidget"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "startLine": 207,
              "startColumn": 20,
              "endLine": 207,
              "endColumn": 72,
              "from": "do uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n   let port\n         = fromMaybe 80\n             $ (_runApp_forceFrontendPort toRun)\n                 <|>\n                   (fmap fromIntegral\n                      $ uri ^? uriAuthority . _Right . authPort . _Just)\n       redirectHost = _runApp_backendHost toRun\n       redirectPort = _runApp_backendPort toRun\n       routeIsTLS = (Just \"https\" == uri ^? uriScheme . _Just . unRText)\n       portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n       beforeMainLoop\n         = do putStrLn\n                $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n              putStrLn\n                $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n              when (routeIsTLS && portDisabledTLS)\n                $ do putStrLn\n                       \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n                     putStrLn\n                       \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n       settings\n         = setBeforeMainLoop\n             beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n       prepareRunner\n         = if not portDisabledTLS && routeIsTLS then\n               case _runApp_tlsCertDirectory toRun of\n                 Nothing\n                   -> do privateKey <- RSA.generateRSAKey' 2048 3\n                         certRequest <- X509Request.newX509Req\n                         _ <- X509Request.setPublicKey certRequest privateKey\n                         _ <- X509Request.signX509Req certRequest privateKey Nothing\n                         cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n                         _ <- X509.setPublicKey cert privateKey\n                         timenow <- getCurrentTime\n                         _ <- X509.setNotBefore cert $ addUTCTime (- 1) timenow\n                         _ <- X509.setNotAfter cert\n                                $ addUTCTime (365 * 24 * 60 * 60) timenow\n                         _ <- X509.signX509 cert privateKey Nothing\n                         certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n                         privateKeyByteString <- BSUTF8.fromString\n                                                   <$> PEM.writePKCS8PrivateKey privateKey Nothing\n                         return\n                           $ runTLSSocket\n                               (tlsSettingsMemory certByteString privateKeyByteString)\n                 Just certDir\n                   -> do putStrLn $ \"Using certificate information from: \" ++ certDir\n                         return\n                           $ runTLSSocket\n                               (tlsSettingsChain\n                                  (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"]\n                                  (certDir </> \"key.pem\"))\n           else\n               return runSettingsSocket\n   runner <- prepareRunner\n   bracket\n     (bindPortTCPRetry settings (logPortBindErr port) 1) close\n     (\\ skt\n        -> do man <- newManager defaultManagerSettings\n              app <- obeliskApp\n                       configs defaultConnectionOptions (_runApp_frontend toRun)\n                       validFullEncoder uri\n                       $ fallbackProxy redirectHost redirectPort man\n              runner settings skt app)",
              "to": "do uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n   let port\n         = fromMaybe 80\n             $ (_runApp_forceFrontendPort toRun)\n                 <|>\n                   (fmap fromIntegral\n                      $ uri ^? uriAuthority . _Right . authPort . _Just)\n       redirectHost = _runApp_backendHost toRun\n       redirectPort = _runApp_backendPort toRun\n       routeIsTLS = Just \"https\" == uri ^? uriScheme . _Just . unRText\n       portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n       beforeMainLoop\n         = do putStrLn\n                $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n              putStrLn\n                $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n              when (routeIsTLS && portDisabledTLS)\n                $ do putStrLn\n                       \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n                     putStrLn\n                       \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n       settings\n         = setBeforeMainLoop\n             beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n       prepareRunner\n         = if not portDisabledTLS && routeIsTLS then\n               case _runApp_tlsCertDirectory toRun of\n                 Nothing\n                   -> do privateKey <- RSA.generateRSAKey' 2048 3\n                         certRequest <- X509Request.newX509Req\n                         _ <- X509Request.setPublicKey certRequest privateKey\n                         _ <- X509Request.signX509Req certRequest privateKey Nothing\n                         cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n                         _ <- X509.setPublicKey cert privateKey\n                         timenow <- getCurrentTime\n                         _ <- X509.setNotBefore cert $ addUTCTime (- 1) timenow\n                         _ <- X509.setNotAfter cert\n                                $ addUTCTime (365 * 24 * 60 * 60) timenow\n                         _ <- X509.signX509 cert privateKey Nothing\n                         certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n                         privateKeyByteString <- BSUTF8.fromString\n                                                   <$> PEM.writePKCS8PrivateKey privateKey Nothing\n                         return\n                           $ runTLSSocket\n                               (tlsSettingsMemory certByteString privateKeyByteString)\n                 Just certDir\n                   -> do putStrLn $ \"Using certificate information from: \" ++ certDir\n                         return\n                           $ runTLSSocket\n                               (tlsSettingsChain\n                                  (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"]\n                                  (certDir </> \"key.pem\"))\n           else\n               return runSettingsSocket\n   runner <- prepareRunner\n   bracket\n     (bindPortTCPRetry settings (logPortBindErr port) 1) close\n     (\\ skt\n        -> do man <- newManager defaultManagerSettings\n              app <- obeliskApp\n                       configs defaultConnectionOptions (_runApp_frontend toRun)\n                       validFullEncoder uri\n                       $ fallbackProxy redirectHost redirectPort man\n              runner settings skt app)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 207, startCol = 20, endLine = 207, endCol = 72}, subts = [(\"x\",SrcSpan {startLine = 207, startCol = 21, endLine = 207, endCol = 71})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_102/static_refactored/lib/run/src/Obelisk/Run.hs",
            "llm_only_refactored_file": "/tmp/project_102/llm_only_refactored/lib/run/src/Obelisk/Run.hs",
            "hybrid_refactored_file": "/tmp/project_102/hybrid_refactored/lib/run/src/Obelisk/Run.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 47,
              "max": 134,
              "average": 19.227272727272727,
              "sum": 846
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 2,
              "suggestion": 29,
              "ignore": 0,
              "total": 31
            },
            "syntax_errors": 407,
            "lines_of_code": 7238,
            "homplexity_lines_of_code": 7751,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "723.8MB",
              "runtime": "1.31 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 12,
              "code_quality_score": 96.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 12,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 1 1: <unnamed module> has 9 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 7 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 7 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 8 1: function main has 3 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 8 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src-bin/main.hs\" 8 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Frontend\nimport Common.Route\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport Reflex.Dom\n\nmain :: IO ()\nmain = do\n  let Right validFullEncoder = checkEncoder fullRouteEncoder\n  run $ runFrontend validFullEncoder frontend\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Frontend\nimport Common.Route\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport Reflex.Dom\n\nmain :: IO ()\nmain = do\n  let Right validFullEncoder = checkEncoder fullRouteEncoder\n  run $ runFrontend validFullEncoder frontend\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs",
              "cyclomatic_complexity": {
                "min": 3,
                "max": 3,
                "average": 3.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 11,
              "lines_of_code": 57,
              "homplexity_lines_of_code": 60,
              "code_quality_score": 88.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 3,
                  "max": 3,
                  "average": 3.0,
                  "sum": 3
                },
                "homplexity_loc": 60,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 1 1: module Frontend has 39 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 28 1: type signature for frontend has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 28 1: type signature for frontend has 1 arguments \nWarning:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/frontend/src/Frontend.hs\" 29 1: function frontend has branching depth of 2 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Frontend where\n\nimport Control.Lens ((^.))\nimport Control.Monad\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle (liftJSM, js, js1, jsg)\n\nimport Obelisk.Frontend\nimport Obelisk.Configs\nimport Obelisk.Route\nimport Obelisk.Generated.Static\n\nimport Reflex.Dom.Core\n\nimport Common.Api\nimport Common.Route\n\n\n-- This runs in a monad that can be run on the client or the server.\n-- To run code in a pure client or pure server context, use one of the\n-- `prerender` functions.\nfrontend :: Frontend (R FrontendRoute)\nfrontend = Frontend\n  { _frontend_head = do\n      el \"title\" $ text \"Obelisk Minimal Example\"\n      elAttr \"script\" (\"type\" =: \"application/javascript\" <> \"src\" =: $(static \"lib.js\")) blank\n      elAttr \"link\" (\"href\" =: $(static \"main.css\") <> \"type\" =: \"text/css\" <> \"rel\" =: \"stylesheet\") blank\n  , _frontend_body = do\n      el \"h1\" $ text \"Welcome to Obelisk!\"\n      el \"p\" $ text $ T.pack commonStuff\n\n      -- `prerender` and `prerender_` let you choose a widget to run on the server\n      -- during prerendering and a different widget to run on the client with\n      -- JavaScript. The following will generate a `blank` widget on the server and\n      -- print \"Hello, World!\" on the client.\n      prerender_ blank $ liftJSM $ void\n        $ jsg (\"window\" :: T.Text)\n        ^. js (\"skeleton_lib\" :: T.Text)\n        ^. js1 (\"log\" :: T.Text) (\"Hello, World!\" :: T.Text)\n\n      elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n      el \"div\" $ do\n        let\n          cfg = \"common/example\"\n          path = \"config/\" <> cfg\n        getConfig cfg >>= \\case\n          Nothing -> text $ \"No config file found in \" <> path\n          Just bytes -> case T.decodeUtf8' bytes of\n            Left ue -> text $ \"Couldn't decode \" <> path <> \" : \" <> T.pack (show ue)\n            Right s -> text s\n      return ()\n  }\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/frontend/src/Frontend.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Frontend where\n\nimport Control.Lens ((^.))\nimport Control.Monad\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle (liftJSM, js, js1, jsg)\n\nimport Obelisk.Frontend\nimport Obelisk.Configs\nimport Obelisk.Route\nimport Obelisk.Generated.Static\n\nimport Reflex.Dom.Core\n\nimport Common.Api\nimport Common.Route\n\n\n-- This runs in a monad that can be run on the client or the server.\n-- To run code in a pure client or pure server context, use one of the\n-- `prerender` functions.\nfrontend :: Frontend (R FrontendRoute)\nfrontend = Frontend\n  { _frontend_head = do\n      el \"title\" $ text \"Obelisk Minimal Example\"\n      elAttr \"script\" (\"type\" =: \"application/javascript\" <> \"src\" =: $(static \"lib.js\")) blank\n      elAttr \"link\" (\"href\" =: $(static \"main.css\") <> \"type\" =: \"text/css\" <> \"rel\" =: \"stylesheet\") blank\n  , _frontend_body = do\n      el \"h1\" $ text \"Welcome to Obelisk!\"\n      el \"p\" $ text $ T.pack commonStuff\n\n      -- `prerender` and `prerender_` let you choose a widget to run on the server\n      -- during prerendering and a different widget to run on the client with\n      -- JavaScript. The following will generate a `blank` widget on the server and\n      -- print \"Hello, World!\" on the client.\n      prerender_ blank $ liftJSM $ void\n        $ (jsg (\"window\" :: T.Text) ^. (js (\"skeleton_lib\" :: T.Text) . js1 (\"log\" :: T.Text) (\"Hello, World!\" :: T.Text)))\n\n      elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n      el \"div\" $ do\n        let\n          cfg = \"common/example\"\n          path = \"config/\" <> cfg\n        getConfig cfg >>= \\case\n          Nothing -> text $ \"No config file found in \" <> path\n          Just bytes -> case T.decodeUtf8' bytes of\n            Left ue -> text $ \"Couldn't decode \" <> path <> \" : \" <> T.pack (show ue)\n            Right s -> text s\n      return ()\n  }\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 6,
              "homplexity_lines_of_code": 6,
              "code_quality_score": 97.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 6,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 1 1: <unnamed module> has 5 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 5 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 5 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 6 1: function main has 1 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 6 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src-bin/main.hs\" 6 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Backend\nimport Frontend\nimport Obelisk.Backend\n\nmain :: IO ()\nmain = runBackend backend frontend\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/backend/src-bin/main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Backend\nimport Frontend\nimport Obelisk.Backend\n\nmain :: IO ()\nmain = runBackend backend frontend\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 2,
              "lines_of_code": 10,
              "homplexity_lines_of_code": 10,
              "code_quality_score": 97.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 10,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 1 1: module Backend has 7 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 6 1: type signature for backend has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 6 1: type signature for backend has 1 arguments \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 7 1: function backend has 3 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 7 1: function backend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/backend/src/Backend.hs\" 7 1: function backend has branching depth of 0 \n"
              },
              "original_code": "module Backend where\n\nimport Common.Route\nimport Obelisk.Backend\n\nbackend :: Backend BackendRoute FrontendRoute\nbackend = Backend\n  { _backend_run = \\serve -> serve $ const $ return ()\n  , _backend_routeEncoder = fullRouteEncoder\n  }\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/backend/src/Backend.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Backend where\n\nimport Common.Route\nimport Obelisk.Backend\n\nbackend :: Backend BackendRoute FrontendRoute\nbackend = Backend\n  { _backend_run = \\serve -> serve $ const $ return ()\n  , _backend_routeEncoder = fullRouteEncoder\n  }\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 0,
              "lines_of_code": 4,
              "homplexity_lines_of_code": 4,
              "code_quality_score": 97.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 4,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 1 1: module Common.Api has 3 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 3 1: type signature for commonStuff has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 3 1: type signature for commonStuff has 1 arguments \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has 1 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Api.hs\" 4 1: function commonStuff has branching depth of 0 \n"
              },
              "original_code": "module Common.Api where\n\ncommonStuff :: String\ncommonStuff = \"Here is a string defined in Common.Api\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Api.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Common.Api where\n\ncommonStuff :: String\ncommonStuff = \"Here is a string defined in Common.Api\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 2,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 3,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 37,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 37,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 1 1: module Common.Route has 31 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 28 3: data BackendRoute has record fields count of 0 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 33 3: data FrontendRoute has record fields count of 0 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has 1 arguments \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has 6 lines of code \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/static_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule Common.Route where\n\n{- -- You will probably want these imports for composing Encoders.\nimport Prelude hiding (id, (.))\nimport Control.Category\n-}\n\nimport Data.Text (Text)\nimport Data.Functor.Identity\n\nimport Obelisk.Route\nimport Obelisk.Route.TH\n\ndata BackendRoute :: * -> * where\n  -- | Used to handle unparseable routes.\n  BackendRoute_Missing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.\n\ndata FrontendRoute :: * -> * where\n  FrontendRoute_Main :: FrontendRoute ()\n  -- This type is used to define frontend routes, i.e. ones for which the backend will serve the frontend.\n\nfullRouteEncoder\n  :: Encoder (Either Text) Identity (R (FullRoute BackendRoute FrontendRoute)) PageName\nfullRouteEncoder = mkFullRouteEncoder\n  (FullRoute_Backend BackendRoute_Missing :/ ())\n  (\\case\n      BackendRoute_Missing -> PathSegment \"missing\" $ unitEncoder mempty)\n  (\\case\n      FrontendRoute_Main -> PathEnd $ unitEncoder mempty)\n\nconcat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs:(26,1)-(28,41)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data BackendRoute :: * -> *",
                    "    where BackendRoute_Missing :: BackendRoute ()"
                  ],
                  "perhaps_block": [
                    "  data BackendRoute :: * -> *",
                    "    where BackendRouteMissing :: BackendRoute ()"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule Common.Route where\n\n{- -- You will probably want these imports for composing Encoders.\nimport Prelude hiding (id, (.))\nimport Control.Category\n-}\n\nimport Data.Text (Text)\nimport Data.Functor.Identity\n\nimport Obelisk.Route\nimport Obelisk.Route.TH\n\ndata BackendRoute :: * -> * where\n  -- | Used to handle unparseable routes.\n  BackendRoute_Missing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.\n\ndata FrontendRoute :: * -> * where\n  FrontendRoute_Main :: FrontendRoute ()\n  -- This type is used to define frontend routes, i.e. ones for which the backend will serve the frontend.\n\nfullRouteEncoder\n  :: Encoder (Either Text) Identity (R (FullRoute BackendRoute FrontendRoute)) PageName\nfullRouteEncoder = mkFullRouteEncoder\n  (FullRoute_Backend BackendRoute_Missing :/ ())\n  (\\case\n      BackendRoute_Missing -> PathSegment \"missing\" $ unitEncoder mempty)\n  (\\case\n      FrontendRoute_Main -> PathEnd $ unitEncoder mempty)\n\nconcat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.7142857142857142,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 26,
              "lines_of_code": 260,
              "homplexity_lines_of_code": 292,
              "code_quality_score": 46.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.7142857142857142,
                  "sum": 12
                },
                "homplexity_loc": 292,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): module Obelisk.Frontend has 207 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): data Frontend has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 133 1: type signature for setInitialRoute has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 133 1: type signature for setInitialRoute has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has 8 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 134 1: function setInitialRoute has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 143 21: data FrontendMode has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has 11 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has 5 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has type constructor nesting of 1 \nCritical:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has 41 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 237 1: type signature for renderFrontendHtml has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 237 1: type signature for renderFrontendHtml has 8 arguments should be less than 5\nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 247 1: function renderFrontendHtml has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 247 1: function renderFrontendHtml has 12 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 247 1: function renderFrontendHtml has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Frontend\n  ( ObeliskWidget\n  , Frontend (..)\n  , runFrontend\n  , runFrontendWithConfigsAndCurrentRoute\n  , renderFrontendHtml\n  , removeHTMLConfigs\n  , FrontendMode (..)\n  , FrontendWidgetT\n  , module Obelisk.Frontend.Cookie\n  ) where\n\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Prelude hiding ((.))\n\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Maybe (MaybeT(..), runMaybeT)\nimport Data.ByteString (ByteString)\nimport Data.Foldable (for_)\nimport Data.Map (Map)\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.History as DOM\nimport qualified GHCJS.DOM.Window as DOM\nimport Language.Javascript.JSaddle (MonadJSM, JSM, jsNull)\nimport GHCJS.DOM (currentDocument)\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.Node (Node, removeChild_)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport Obelisk.Frontend.Cookie\nimport Obelisk.Route.Frontend\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Obelisk.Configs\nimport Obelisk.ExecutableConfig.Inject (injectExecutableConfigs)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport System.Info (os)\nimport Web.Cookie\n\nimport Debug.Trace\n\ntype ObeliskWidget t route m =\n  ( DomBuilder t m\n  , MonadFix m\n  , MonadHold t m\n  , MonadSample t (Performable m)\n  , MonadReflexCreateTrigger t m\n  , PostBuild t m\n  , PerformEvent t m\n  , TriggerEvent t m\n  , HasDocument m\n  , MonadRef m\n  , Ref m ~ Ref IO\n  , MonadRef (Performable m)\n  , Ref (Performable m) ~ Ref IO\n  , MonadFix (Performable m)\n  , PrimMonad m\n  , Prerender t m\n  , PrebuildAgnostic t route m\n  , PrebuildAgnostic t route (Client m)\n  , HasConfigs m\n  , HasCookies m\n  , MonadIO (Performable m)\n  )\n\ntype PrebuildAgnostic t route m =\n  ( SetRoute t route m\n  , RouteToUrl route m\n  , MonadFix m\n  , HasConfigs m\n  , HasConfigs (Performable m)\n  )\n\ndata Frontend route = Frontend\n  { _frontend_head :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  , _frontend_body :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  }\n\nbaseTag :: forall route t m. ObeliskWidget t route m => RoutedT t route m ()\nbaseTag =\n  if os == \"ios\"\n    then blank\n    else elAttr \"base\" (\"href\" =: \"/\") blank --TODO: Figure out the base URL from the routes\n\nremoveHTMLConfigs :: JSM ()\nremoveHTMLConfigs = void $ runMaybeT $ do\n  doc <- MaybeT currentDocument\n  hd <- MaybeT $ getHead doc\n  es <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  for_ es $ removeChild_ hd\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in exe-config/ghcjs/lookup should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n\nsetInitialRoute :: Bool -> JSM ()\nsetInitialRoute useHash = do\n  traceM \"setInitialRoute\"\n  window <- DOM.currentWindowUnchecked\n  initialLocation <- DOM.getLocation window\n  initialUri <- getLocationUri initialLocation\n  history <- DOM.getHistory window\n  DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n    show $ setAdaptedUriPath useHash \"/\" initialUri\n\ndata FrontendMode = FrontendMode\n  { _frontendMode_hydrate :: Bool\n    -- ^ There is already a rendering of the DOM in place; hydrate it rather\n    -- than building new DOM\n  , _frontendMode_adjustRoute :: Bool\n    -- ^ The page can't use regular routes, so encode routes into the hash\n    -- instead\n  }\n\n-- | Run the frontend, setting the initial route to \"/\" on platforms where no\n-- route exists ambiently in the context (e.g. anything but web).\n-- Selects FrontendMode based on platform; this doesn't work for jsaddle-warp\nrunFrontend\n  :: forall backendRoute route\n  .  Encoder Identity Identity (R (FullRoute backendRoute route)) PageName\n  -> Frontend (R route)\n  -> JSM ()\nrunFrontend validFullEncoder frontend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate =\n#ifdef ghcjs_HOST_OS\n          True\n#else\n          False\n#endif\n        , _frontendMode_adjustRoute =\n#ifdef ghcjs_HOST_OS\n          False\n#else\n          True\n#endif\n        }\n  configs <- liftIO Lookup.getConfigs\n  when (_frontendMode_hydrate mode) removeHTMLConfigs\n  -- There's no fundamental reason that adjustRoute needs to control setting the\n  -- initial route and *also* the useHash parameter; that's why these are\n  -- separate here.  However, currently, they are always the same.\n  when (_frontendMode_adjustRoute mode) $ do\n    setInitialRoute $ _frontendMode_adjustRoute mode\n  runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n\nrunFrontendWithConfigsAndCurrentRoute\n  :: forall backendRoute frontendRoute\n  .  FrontendMode\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> Frontend (R frontendRoute)\n  -> JSM ()\nrunFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend = do\n  let ve = validFullEncoder . hoistParse errorLeft (reviewEncoder (rPrism $ _FullRoute_Frontend . _ObeliskRoute_App))\n      errorLeft = \\case\n        Left _ -> error \"runFrontend: Unexpected non-app ObeliskRoute reached the frontend. This shouldn't happen.\"\n        Right x -> Identity x\n      w :: ( RawDocument (DomBuilderSpace (HydrationDomBuilderT s DomTimeline m)) ~ DOM.Document\n           , Ref (Performable m) ~ Ref IO\n           , Ref m ~ Ref IO\n           , DomBuilder DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadHold DomTimeline m\n           , MonadRef m\n           , MonadRef (Performable m)\n           , MonadReflexCreateTrigger DomTimeline m\n           , PerformEvent DomTimeline m\n           , PostBuild DomTimeline m\n           , PrimMonad m\n           , MonadSample DomTimeline (Performable m)\n           , DOM.MonadJSM m\n           , MonadFix (Client (HydrationDomBuilderT s DomTimeline m))\n           , MonadFix (Performable m)\n           , MonadFix m\n           , Prerender DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadIO (Performable m)\n           )\n        => (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> FloatingWidget () ()\n      w appendHead appendBody = do\n        rec switchover <- runRouteViewT ve switchover (_frontendMode_adjustRoute mode) $ do\n              (switchover'', fire) <- newTriggerEvent\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendHead . runConfigsT configs))) $ do\n                -- The order here is important - baseTag has to be before headWidget!\n                baseTag\n                _frontend_head frontend\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendBody . runConfigsT configs))) $ do\n                _frontend_body frontend\n                switchover' <- case _frontendMode_hydrate mode of\n                  True -> lift $ lift $ lift $ lift $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n                  False -> getPostBuild\n                performEvent_ $ liftIO (fire ()) <$ switchover'\n              pure switchover''\n        pure ()\n  if _frontendMode_hydrate mode\n    then runHydrationWidgetWithHeadAndBody (pure ()) w\n    else runImmediateWidgetWithHeadAndBody w\n\ntype FrontendWidgetT r = RoutedT DomTimeline r (SetRouteT DomTimeline r (RouteToUrlT r (ConfigsT (CookiesT (HydratableT (PostBuildT DomTimeline (StaticDomBuilderT DomTimeline (PerformEventT DomTimeline DomHost))))))))\n\nrenderFrontendHtml\n  :: MonadIO m\n  => Map Text ByteString\n  -> Cookies\n  -> (r -> Text)\n  -> r\n  -> Frontend r\n  -> FrontendWidgetT r ()\n  -> FrontendWidgetT r ()\n  -> m ByteString\nrenderFrontendHtml configs cookies urlEnc route frontend headExtra bodyExtra = do\n  --TODO: We should probably have a \"NullEventWriterT\" or a frozen reflex timeline\n  html <- fmap snd $ liftIO $ renderStatic $ runHydratableT $ fmap fst $ runCookiesT cookies $ runConfigsT configs $ flip runRouteToUrlT urlEnc $ runSetRouteT $ flip runRoutedT (pure route) $\n    el \"html\" $ do\n      el \"head\" $ do\n        baseTag\n        injectExecutableConfigs configs\n        _frontend_head frontend\n        headExtra\n      el \"body\" $ do\n        _frontend_body frontend\n        bodyExtra\n  return $ \"<!DOCTYPE html>\" <> html\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs:(227,32)-(229,39)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case _frontendMode_hydrate mode of",
                    "    True",
                    "      -> lift",
                    "           $ lift",
                    "               $ lift",
                    "                   $ lift",
                    "                       $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover",
                    "    False -> getPostBuild"
                  ],
                  "perhaps_block": [
                    "  (if _frontendMode_hydrate mode then",
                    "       lift",
                    "         $ lift",
                    "             $ lift",
                    "                 $ lift",
                    "                     $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover",
                    "   else",
                    "       getPostBuild)"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Frontend\n  ( ObeliskWidget\n  , Frontend (..)\n  , runFrontend\n  , runFrontendWithConfigsAndCurrentRoute\n  , renderFrontendHtml\n  , removeHTMLConfigs\n  , FrontendMode (..)\n  , FrontendWidgetT\n  , module Obelisk.Frontend.Cookie\n  ) where\n\n\n\n\n\n\n\n\nimport Prelude hiding ((.))\n\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Maybe (MaybeT(..), runMaybeT)\nimport Data.ByteString (ByteString)\nimport Data.Foldable (for_)\nimport Data.Map (Map)\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.History as DOM\nimport qualified GHCJS.DOM.Window as DOM\nimport Language.Javascript.JSaddle (MonadJSM, JSM, jsNull)\nimport GHCJS.DOM (currentDocument)\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.Node (Node, removeChild_)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport Obelisk.Frontend.Cookie\nimport Obelisk.Route.Frontend\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Obelisk.Configs\nimport Obelisk.ExecutableConfig.Inject (injectExecutableConfigs)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport System.Info (os)\nimport Web.Cookie\n\nimport Debug.Trace\n\ntype ObeliskWidget t route m =\n  ( DomBuilder t m\n  , MonadFix m\n  , MonadHold t m\n  , MonadSample t (Performable m)\n  , MonadReflexCreateTrigger t m\n  , PostBuild t m\n  , PerformEvent t m\n  , TriggerEvent t m\n  , HasDocument m\n  , MonadRef m\n  , Ref m ~ Ref IO\n  , MonadRef (Performable m)\n  , Ref (Performable m) ~ Ref IO\n  , MonadFix (Performable m)\n  , PrimMonad m\n  , Prerender t m\n  , PrebuildAgnostic t route m\n  , PrebuildAgnostic t route (Client m)\n  , HasConfigs m\n  , HasCookies m\n  , MonadIO (Performable m)\n  )\n\ntype PrebuildAgnostic t route m =\n  ( SetRoute t route m\n  , RouteToUrl route m\n  , MonadFix m\n  , HasConfigs m\n  , HasConfigs (Performable m)\n  )\n\ndata Frontend route = Frontend\n  { _frontend_head :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  , _frontend_body :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  }\n\nbaseTag :: forall route t m. ObeliskWidget t route m => RoutedT t route m ()\nbaseTag =\n  if os == \"ios\"\n    then blank\n    else elAttr \"base\" (\"href\" =: \"/\") blank --TODO: Figure out the base URL from the routes\n\nremoveHTMLConfigs :: JSM ()\nremoveHTMLConfigs = void $ runMaybeT $ do\n  doc <- MaybeT currentDocument\n  hd <- MaybeT $ getHead doc\n  es <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  for_ es $ removeChild_ hd\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in exe-config/ghcjs/lookup should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n\nsetInitialRoute :: Bool -> JSM ()\nsetInitialRoute useHash = do\n  traceM \"setInitialRoute\"\n  window <- DOM.currentWindowUnchecked\n  initialLocation <- DOM.getLocation window\n  initialUri <- getLocationUri initialLocation\n  history <- DOM.getHistory window\n  DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n    show $ setAdaptedUriPath useHash \"/\" initialUri\n\ndata FrontendMode = FrontendMode\n  { _frontendMode_hydrate :: Bool\n    -- ^ There is already a rendering of the DOM in place; hydrate it rather\n    -- than building new DOM\n  , _frontendMode_adjustRoute :: Bool\n    -- ^ The page can't use regular routes, so encode routes into the hash\n    -- instead\n  }\n\n-- | Run the frontend, setting the initial route to \"/\" on platforms where no\n-- route exists ambiently in the context (e.g. anything but web).\n-- Selects FrontendMode based on platform; this doesn't work for jsaddle-warp\nrunFrontend\n  :: forall backendRoute route\n  .  Encoder Identity Identity (R (FullRoute backendRoute route)) PageName\n  -> Frontend (R route)\n  -> JSM ()\nrunFrontend validFullEncoder frontend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate =\n\n\n\n          False\n\n        , _frontendMode_adjustRoute =\n\n\n\n          True\n\n        }\n  configs <- liftIO Lookup.getConfigs\n  when (_frontendMode_hydrate mode) removeHTMLConfigs\n  -- There's no fundamental reason that adjustRoute needs to control setting the\n  -- initial route and *also* the useHash parameter; that's why these are\n  -- separate here.  However, currently, they are always the same.\n  when (_frontendMode_adjustRoute mode) $ do\n    setInitialRoute $ _frontendMode_adjustRoute mode\n  runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n\nrunFrontendWithConfigsAndCurrentRoute\n  :: forall backendRoute frontendRoute\n  .  FrontendMode\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> Frontend (R frontendRoute)\n  -> JSM ()\nrunFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend = do\n  let ve = validFullEncoder . hoistParse errorLeft (reviewEncoder (rPrism $ _FullRoute_Frontend . _ObeliskRoute_App))\n      errorLeft = \\case\n        Left _ -> error \"runFrontend: Unexpected non-app ObeliskRoute reached the frontend. This shouldn't happen.\"\n        Right x -> Identity x\n      w :: ( RawDocument (DomBuilderSpace (HydrationDomBuilderT s DomTimeline m)) ~ DOM.Document\n           , Ref (Performable m) ~ Ref IO\n           , Ref m ~ Ref IO\n           , DomBuilder DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadHold DomTimeline m\n           , MonadRef m\n           , MonadRef (Performable m)\n           , MonadReflexCreateTrigger DomTimeline m\n           , PerformEvent DomTimeline m\n           , PostBuild DomTimeline m\n           , PrimMonad m\n           , MonadSample DomTimeline (Performable m)\n           , DOM.MonadJSM m\n           , MonadFix (Client (HydrationDomBuilderT s DomTimeline m))\n           , MonadFix (Performable m)\n           , MonadFix m\n           , Prerender DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadIO (Performable m)\n           )\n        => (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> FloatingWidget () ()\n      w appendHead appendBody = do\n        rec switchover <- runRouteViewT ve switchover (_frontendMode_adjustRoute mode) $ do\n              (switchover'', fire) <- newTriggerEvent\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendHead . runConfigsT configs))) $ do\n                -- The order here is important - baseTag has to be before headWidget!\n                baseTag\n                _frontend_head frontend\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendBody . runConfigsT configs))) $ do\n                _frontend_body frontend\n                switchover' <- (if _frontendMode_hydrate mode then lift $ lift $ lift $ lift $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover else getPostBuild)\n                performEvent_ $ liftIO (fire ()) <$ switchover'\n              pure switchover''\n        pure ()\n  if _frontendMode_hydrate mode\n    then runHydrationWidgetWithHeadAndBody (pure ()) w\n    else runImmediateWidgetWithHeadAndBody w\n\ntype FrontendWidgetT r = RoutedT DomTimeline r (SetRouteT DomTimeline r (RouteToUrlT r (ConfigsT (CookiesT (HydratableT (PostBuildT DomTimeline (StaticDomBuilderT DomTimeline (PerformEventT DomTimeline DomHost))))))))\n\nrenderFrontendHtml\n  :: MonadIO m\n  => Map Text ByteString\n  -> Cookies\n  -> (r -> Text)\n  -> r\n  -> Frontend r\n  -> FrontendWidgetT r ()\n  -> FrontendWidgetT r ()\n  -> m ByteString\nrenderFrontendHtml configs cookies urlEnc route frontend headExtra bodyExtra = do\n  --TODO: We should probably have a \"NullEventWriterT\" or a frozen reflex timeline\n  html <- fmap snd $ liftIO $ renderStatic $ runHydratableT $ fmap fst $ runCookiesT cookies $ runConfigsT configs $ flip runRouteToUrlT urlEnc $ runSetRouteT $ flip runRoutedT (pure route) $\n    el \"html\" $ do\n      el \"head\" $ do\n        baseTag\n        injectExecutableConfigs configs\n        _frontend_head frontend\n        headExtra\n      el \"body\" $ do\n        _frontend_body frontend\n        bodyExtra\n  return $ \"<!DOCTYPE html>\" <> html\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 13,
              "lines_of_code": 103,
              "homplexity_lines_of_code": 90,
              "code_quality_score": 87.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 90,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 1 1: module Obelisk.Frontend.Cookie has 88 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 34 3: type class HasCookies has method + value count of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 34 3: type class HasCookies has associated type count of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 53 24: data CookiesT has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 87 1: type signature for runCookiesT has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 87 1: type signature for runCookiesT has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 91 1: function runCookiesT has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 96 1: type signature for mapCookiesT has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 96 1: type signature for mapCookiesT has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/frontend/src/Obelisk/Frontend/Cookie.hs\" 100 1: function mapCookiesT has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Obelisk.Frontend.Cookie where\n\nimport Control.Monad.Fix\nimport Control.Monad.Primitive\nimport Control.Monad.Ref\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Reader\nimport Data.Text.Encoding (encodeUtf8)\nimport Reflex\nimport Reflex.Host.Class\nimport Reflex.Dom.Core\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getCookie, Document)\nimport GHCJS.DOM.Types (MonadJSM)\nimport Web.Cookie\n\nimport Obelisk.Configs\nimport Obelisk.Route.Frontend\n\nclass Monad m => HasCookies m where\n  askCookies :: m Cookies\n  default askCookies :: (HasCookies m', m ~ t m', MonadTrans t) => m Cookies\n  askCookies = lift askCookies\n\ninstance HasCookies m => HasCookies (BehaviorWriterT t w m)\ninstance HasCookies m => HasCookies (DynamicWriterT t w m)\ninstance HasCookies m => HasCookies (EventWriterT t w m)\ninstance HasCookies m => HasCookies (PostBuildT t m)\ninstance HasCookies m => HasCookies (QueryT t q m)\ninstance HasCookies m => HasCookies (ReaderT r m)\ninstance HasCookies m => HasCookies (RequesterT t request response m)\ninstance HasCookies m => HasCookies (RouteToUrlT t m)\ninstance HasCookies m => HasCookies (SetRouteT t r m)\ninstance HasCookies m => HasCookies (StaticDomBuilderT t m)\ninstance HasCookies m => HasCookies (TriggerEventT t m)\ninstance HasCookies m => HasCookies (RoutedT t r m)\ninstance HasCookies m => HasCookies (ConfigsT m)\ninstance HasConfigs m => HasConfigs (CookiesT m)\n\nnewtype CookiesT m a = CookiesT { unCookiesT :: ReaderT Cookies m a }\n  deriving\n    ( Functor\n    , Applicative\n    , DomBuilder t\n    , Monad\n    , MonadFix\n    , MonadHold t\n    , MonadIO\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    , MonadRef\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , MonadTrans\n    , NotReady t\n    , PerformEvent t\n    , PostBuild t\n    , Prerender t\n    , TriggerEvent t\n    , HasDocument\n    )\n\ninstance Adjustable t m => Adjustable t (CookiesT m) where\n  runWithReplace a e = CookiesT $ runWithReplace (unCookiesT a) (unCookiesT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = CookiesT $ traverseDMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = CookiesT $ traverseIntMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = CookiesT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unCookiesT $ f k v) m e\n\ninstance PrimMonad m => PrimMonad (CookiesT m) where\n  type PrimState (CookiesT m) = PrimState m\n  primitive = lift . primitive\n\nrunCookiesT\n  :: Cookies\n  -> CookiesT m a\n  -> m a\nrunCookiesT cs child = runReaderT (unCookiesT child) cs\n\ninstance Monad m => HasCookies (CookiesT m) where\n  askCookies = CookiesT ask\n\nmapCookiesT\n  :: (forall x. m x -> n x)\n  -> CookiesT m a\n  -> CookiesT n a\nmapCookiesT f (CookiesT x) = CookiesT $ mapReaderT f x\n\ninstance (MonadJSM m, RawDocument (DomBuilderSpace (HydrationDomBuilderT s t m)) ~ Document) => HasCookies (HydrationDomBuilderT s t m) where\n  askCookies = fmap (parseCookies . encodeUtf8) $ getCookie =<< askDocument\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend/Cookie.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Obelisk.Frontend.Cookie where\n\nimport Control.Monad.Fix\nimport Control.Monad.Primitive\nimport Control.Monad.Ref\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Reader\nimport Data.Text.Encoding (encodeUtf8)\nimport Reflex\nimport Reflex.Host.Class\nimport Reflex.Dom.Core\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getCookie, Document)\nimport GHCJS.DOM.Types (MonadJSM)\nimport Web.Cookie\n\nimport Obelisk.Configs\nimport Obelisk.Route.Frontend\n\nclass Monad m => HasCookies m where\n  askCookies :: m Cookies\n  default askCookies :: (HasCookies m', m ~ t m', MonadTrans t) => m Cookies\n  askCookies = lift askCookies\n\ninstance HasCookies m => HasCookies (BehaviorWriterT t w m)\ninstance HasCookies m => HasCookies (DynamicWriterT t w m)\ninstance HasCookies m => HasCookies (EventWriterT t w m)\ninstance HasCookies m => HasCookies (PostBuildT t m)\ninstance HasCookies m => HasCookies (QueryT t q m)\ninstance HasCookies m => HasCookies (ReaderT r m)\ninstance HasCookies m => HasCookies (RequesterT t request response m)\ninstance HasCookies m => HasCookies (RouteToUrlT t m)\ninstance HasCookies m => HasCookies (SetRouteT t r m)\ninstance HasCookies m => HasCookies (StaticDomBuilderT t m)\ninstance HasCookies m => HasCookies (TriggerEventT t m)\ninstance HasCookies m => HasCookies (RoutedT t r m)\ninstance HasCookies m => HasCookies (ConfigsT m)\ninstance HasConfigs m => HasConfigs (CookiesT m)\n\nnewtype CookiesT m a = CookiesT { unCookiesT :: ReaderT Cookies m a }\n  deriving\n    ( Functor\n    , Applicative\n    , DomBuilder t\n    , Monad\n    , MonadFix\n    , MonadHold t\n    , MonadIO\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    , MonadRef\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , MonadTrans\n    , NotReady t\n    , PerformEvent t\n    , PostBuild t\n    , Prerender t\n    , TriggerEvent t\n    , HasDocument\n    )\n\ninstance Adjustable t m => Adjustable t (CookiesT m) where\n  runWithReplace a e = CookiesT $ runWithReplace (unCookiesT a) (unCookiesT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = CookiesT $ traverseDMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = CookiesT $ traverseIntMapWithKeyWithAdjust (\\k v -> unCookiesT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = CookiesT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unCookiesT $ f k v) m e\n\ninstance PrimMonad m => PrimMonad (CookiesT m) where\n  type PrimState (CookiesT m) = PrimState m\n  primitive = lift . primitive\n\nrunCookiesT\n  :: Cookies\n  -> CookiesT m a\n  -> m a\nrunCookiesT cs child = runReaderT (unCookiesT child) cs\n\ninstance Monad m => HasCookies (CookiesT m) where\n  askCookies = CookiesT ask\n\nmapCookiesT\n  :: (forall x. m x -> n x)\n  -> CookiesT m a\n  -> CookiesT n a\nmapCookiesT f (CookiesT x) = CookiesT $ mapReaderT f x\n\ninstance (MonadJSM m, RawDocument (DomBuilderSpace (HydrationDomBuilderT s t m)) ~ Document) => HasCookies (HydrationDomBuilderT s t m) where\n  askCookies = fmap (parseCookies . encodeUtf8) $ getCookie =<< askDocument\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 15,
                "average": 3,
                "sum": 180
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 6,
                "ignore": 0,
                "total": 6
              },
              "syntax_errors": 36,
              "lines_of_code": 1288,
              "homplexity_lines_of_code": 939,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 15,
                  "average": 3,
                  "sum": 180
                },
                "homplexity_loc": 939,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 15,\n        \"average\": 3.27,\n        \"sum\": 180\n    },\n    \"homplexity_loc\": 939,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-|\n\nTypes and functions for defining routes and 'Encoder's.\n\n-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE EmptyDataDecls #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.Route\n  ( -- * Primary Types\n    R\n  , PageName\n  , PathQuery\n  , Encoder\n  , EncoderImpl (..)\n  , EncoderFunc (..)\n\n  -- * Patterns, operators, and utilities\n  , (:.)\n  , (?/)\n  , hoistR\n  , pattern (:.)\n  , pattern (:/)\n  , unsafeEncoder\n  , checkEncoder\n  , unsafeMkEncoder\n  , encode\n  , decode\n  , tryDecode\n  , hoistCheck\n  , hoistParse\n  , mapSome\n  , rPrism\n  , _R\n  , renderObeliskRoute\n  , renderBackendRoute\n  , renderFrontendRoute\n  , byteStringsToPageName\n\n  -- * Collating Routes\n  , SegmentResult (..)\n  , pathComponentEncoder\n\n  , FullRoute (..)\n  , _FullRoute_Frontend\n  , _FullRoute_Backend\n  , mkFullRouteEncoder\n\n  , ObeliskRoute (..)\n  , _ObeliskRoute_App\n  , _ObeliskRoute_Resource\n  , ResourceRoute (..)\n\n  , JSaddleWarpRoute (..)\n  , jsaddleWarpRouteEncoder\n\n  , IndexOnlyRoute (..)\n  , indexOnlyRouteSegment\n  , indexOnlyRouteEncoder\n\n  -- * Provided Encoders\n  , enumEncoder\n  , enum1Encoder\n  , checkEnum1EncoderFunc\n  , unitEncoder\n  , pathOnlyEncoder\n  , addPathSegmentEncoder\n  , pathParamEncoder\n  , pathLiteralEncoder\n  , singletonListEncoder\n  , packTextEncoder\n  , unpackTextEncoder\n  , prefixTextEncoder\n  , unsafeTshowEncoder\n  , unsafeShowEncoder\n  , readShowEncoder\n  , someConstEncoder\n  , singlePathSegmentEncoder\n  , maybeEncoder\n  , maybeToEitherEncoder\n  , justEncoder\n  , nothingEncoder\n  , isoEncoder\n  , viewEncoder\n  , wrappedEncoder\n  , unwrappedEncoder\n  , listToNonEmptyEncoder\n  , prefixNonemptyTextEncoder\n  , joinPairTextEncoder\n  , toListMapEncoder\n  , shadowEncoder\n  , prismEncoder\n  , reviewEncoder\n  , obeliskRouteEncoder\n  , obeliskRouteSegment\n  , pageNameEncoder\n  , handleEncoder\n  , someSumEncoder\n  , Void1\n  , void1Encoder\n  , pathSegmentsTextEncoder\n  , queryParametersTextEncoder\n  , integralEncoder\n  , pathSegmentEncoder\n  , queryOnlyEncoder\n  , Decoder(..)\n  , dmapEncoder\n  , fieldMapEncoder\n  , pathFieldEncoder\n  , jsonEncoder\n  ) where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Applicative\nimport Control.Category (Category (..))\nimport qualified Control.Categorical.Functor as Cat\nimport Control.Categorical.Bifunctor\nimport Control.Category.Associative\nimport Control.Category.Monoidal\nimport Control.Category.Braided\nimport Control.Lens\n  ( Identity (..)\n  , (^.)\n  , (^?)\n  , _Just\n  , _Nothing\n  , Cons(..)\n  , from\n  , imap\n  , iso\n  , Iso'\n  , itraverse\n  , makePrisms\n  , Prism'\n  , prism'\n  , re\n  , review\n  , view\n  , Wrapped (..)\n  )\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Trans (lift)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad.Except\nimport qualified Control.Monad.State.Strict as State\nimport Control.Monad.Writer (execWriter, tell)\nimport Data.Aeson (FromJSON, ToJSON)\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Dependent.Map (DMap)\nimport qualified Data.Dependent.Map as DMap\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Either.Validation (Validation (..))\nimport Data.Foldable\nimport Data.Functor (($>))\nimport Data.Functor.Sum\nimport Data.GADT.Compare\nimport Data.GADT.Compare.TH\nimport Data.GADT.Show\nimport Data.List.NonEmpty (NonEmpty (..))\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport Data.Monoid (Ap(..))\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.Semigroupoid\nimport Data.Some (Some(Some), mapSome)\nimport Data.Tabulation\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Text.Lens (IsText, packed, unpacked)\nimport Data.Type.Equality\nimport Data.Universe\nimport Data.Universe.Some\nimport Network.HTTP.Types.URI\nimport qualified Numeric.Lens\nimport Obelisk.Route.TH\nimport Text.Read (readMaybe)\n\n-- Design goals:\n-- No start-up time on the frontend (not yet met)\n-- Able to ensure that there aren't overlapping routes prior to deployment\n-- Easy to write common types of parsers\n--   Completeness checking\n\n-- Laws:\n-- We statically know that all valid Routes can be turned into valid URIs\n--   - This means we need to know whether there are any overlaps, e.g. with the static file namespace\n\n--TODO:\n-- Backend:\n--  Redirect the user to a canonical route\n--  Pre-render\n-- Frontend:\n--  Intercept links that can be kept within the app\n--  Fragments\n\n--------------------------------------------------------------------------------\n-- Subroutes/paths\n--------------------------------------------------------------------------------\n\n-- | This alias is used to wrap the type of a route GADT so that the type variable of the GADT is existentially quantified.\n--\n-- Given the following route type :\n--\n-- @\n--\n-- data MyRoutes a where\n--   MyRoutes_Main :: MyRoutes ()\n--   MyRoutes_A :: MyRoutes Text\n--   MyRoutes_B :: MyRoutes Int\n-- @\n--\n-- Using 'R' we're able to write type signatures without worrying about the 'a':\n--\n-- @\n-- myRoutesWidget :: RoutedT t (R MyRoutes) m ()\n-- @\n--\ntype R f = DSum f Identity --TODO: Better name\n\n-- | Convenience builder for an 'R' using 'Identity' for the functor.\npattern (:/) :: f a -> a -> R f\npattern a :/ b = a :=> Identity b\n{-# COMPLETE (:/) #-}\ninfixr 5 :/\n\n-- | Like '(:/)' but adds a 'Just' wrapper around the right-hand side.\n(?/) :: f (Maybe a) -> a -> R f\nr ?/ a = r :/ Just a\ninfixr 5 ?/\n\nhoistR :: (forall x. f x -> g x) -> R f -> R g\nhoistR f (x :=> Identity y) = f x :/ y\n\n--------------------------------------------------------------------------------\n-- Dealing with pairs (i.e. non-dependently-typed subroutes/paths)\n--------------------------------------------------------------------------------\n\ninfixr 5 :.\ntype (:.) = (,)\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ >= 810\n{-# COMPLETE (:.) #-}\n#else\n{-# WARNING (:.)\n  [ \"Use of this pattern in GHC < 8.10 will result in spurious non-exhaustive warnings at every use site.\"\n  , \"We cannot provide a COMPLETE pragma to silence these due to a GHC bug: https://gitlab.haskell.org/ghc/ghc/issues/17729.\"\n  , \"The bug hides incompleteness warnings for all two tuples when the COMPLETE pattern is in scope.\"\n  , \"Instead, you should use (,) directly until you can switch to GHC >= 8.10, where the COMPLETE pragma is reinstated.\"\n  ]\n  #-}\n#endif\n#endif\npattern (:.) :: a -> b -> a :. b\npattern a :. b = (a, b)\n\naddPathSegmentEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse (Text, PageName) PageName\naddPathSegmentEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(ph, (pt, q)) -> (ph : pt, q)\n  , _encoderImpl_decode = \\(p, q) -> case p of\n      [] -> throwError \"Expected a path segment\"\n      ph : pt -> pure (ph, (pt, q))\n  }\n\npathParamEncoder\n  :: forall check parse item rest.\n     ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse item Text\n  -> Encoder check parse rest PageName\n  -> Encoder check parse (item :. rest) PageName\npathParamEncoder itemUnchecked restUnchecked = addPathSegmentEncoder . bimap itemUnchecked restUnchecked\n\npathLiteralEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Text\n  -> Encoder check parse a PageName\n  -> Encoder check parse a PageName\npathLiteralEncoder t e = addPathSegmentEncoder . bimap (unitEncoder t) e . coidl\n\n--------------------------------------------------------------------------------\n-- Encoder fundamentals\n--------------------------------------------------------------------------------\n\n-- | This is the type of route encoder/decoders. It is parameterised over two monads: Firstly, the monad\n-- used to check the validity of the encoder (i.e. that it is total), secondly the monad used for parsing\n-- during the decode phase. The following two parameters are respectively the type of decoded data, and the\n-- encoded type.\nnewtype Encoder check parse decoded encoded =\n  Encoder { unEncoder :: check (EncoderImpl parse decoded encoded) }\n\nunsafeEncoder :: check (EncoderImpl parse decoded encoded) -> Encoder check parse decoded encoded\nunsafeEncoder = Encoder\n\n-- | The internal type used to construct primitive 'Encoder' values.\n-- Law:\n-- forall p. _encoderImpl_decode ve . _encoderImpl_encode ve p == pure\n-- Note that the reverse may not be the case: when parsing, a route may be canonicalized, and erroneous routes may be collapsed to a single 404 route.  However, as a consequence of the law, encode . decode must be idempotent.\ndata EncoderImpl parse decoded encoded = EncoderImpl\n  { _encoderImpl_decode :: !(encoded -> parse decoded) -- Can fail; can lose information; must always succeed on outputs of `_encoderImpl_encode` and result in the original value\n  , _encoderImpl_encode :: !(decoded -> encoded) -- Must be injective\n  }\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', and its parser is total\n-- so that its parse monad is also 'Identity', it may be used to actually decode by applying this function.\ndecode :: Encoder Identity Identity decoded encoded -> encoded -> decoded\ndecode e x = runIdentity (tryDecode e x)\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', even if the same is not true of the\n-- parse monad, we may still attempt to decode with it in its parse monad.\ntryDecode :: Encoder Identity parse decoded encoded -> encoded -> parse decoded\ntryDecode (Encoder (Identity impl)) = _encoderImpl_decode impl\n\n-- | Similar to 'decode', once an encoder has been checked so that its check monad is Identity, it\n-- can be used to actually encode by using this. Note that while there's no constraint on the parse monad here,\n-- one should usually be applying decode and encode to the same 'Encoder'\nencode :: Encoder Identity parse decoded encoded -> decoded -> encoded\nencode (Encoder (Identity impl)) = _encoderImpl_encode impl\n\n-- | This is a primitive used to build encoders which can't fail to check. It should not be used unless one is\n-- reasonably certain that the law given for 'EncoderImpl' above holds.\nunsafeMkEncoder :: (Applicative check) => EncoderImpl parse decoded encoded -> Encoder check parse decoded encoded\nunsafeMkEncoder impl = Encoder (pure impl)\n\n-- | Transform the check monad of an 'Encoder' by applying a natural transformation.\nhoistCheck :: (forall t. check t -> check' t) -> Encoder check parse a b -> Encoder check' parse a b\nhoistCheck f (Encoder x) = Encoder (f x)\n\n-- | Transform the parse monad of an 'Encoder' by applying a natural transformation.\nhoistParse :: (Functor check)\n  => (forall t. parse t -> parse' t) -> Encoder check parse a b -> Encoder check parse' a b\nhoistParse f (Encoder x) = Encoder (fmap (\\(EncoderImpl dec enc) -> EncoderImpl (f . dec) enc) x)\n\n-- | Check an 'Encoder', transforming it into one whose check monad is anything we want (usually Identity).\ncheckEncoder :: (Applicative check', Functor check)\n  => Encoder check parse decoded encoded\n  -> check (Encoder check' parse decoded encoded)\ncheckEncoder = fmap unsafeMkEncoder . unEncoder\n\ninstance (Applicative check, Monad parse) => Semigroupoid (Encoder check parse) where\n  Encoder f `o` Encoder g = Encoder $ liftA2 (.) f g\n\ninstance (Applicative check, Monad parse) => Category (Encoder check parse) where\n  id = Encoder $ pure id\n  (.) = o\n\ninstance Monad parse => Category (EncoderImpl parse) where\n  id = EncoderImpl\n    { _encoderImpl_decode = pure\n    , _encoderImpl_encode = id\n    }\n  f . g = EncoderImpl\n    { _encoderImpl_decode = _encoderImpl_decode g <=< _encoderImpl_decode f\n    , _encoderImpl_encode = _encoderImpl_encode f . _encoderImpl_encode g\n    }\n\ninstance Monad parse => PFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  second g = bimap id g\ninstance Monad parse => Bifunctor (,) (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\(a, b) -> liftA2 (,) (_encoderImpl_decode f a) (_encoderImpl_decode g b)\n    }\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) (,) where\n  braid = viewEncoder (iso swap swap)\n\n\ninstance (Applicative check, Monad parse) => PFunctor (,) (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Applicative check, Monad parse) => QFunctor (,) (Encoder check parse) (Encoder check parse) where\n  second g = bimap id g\ninstance (Applicative check, Monad parse) => Bifunctor (,) (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Traversable f, Monad parse) => Cat.Functor f (EncoderImpl parse) (EncoderImpl parse) where\n  fmap ve = EncoderImpl\n    { _encoderImpl_encode = fmap $ _encoderImpl_encode ve\n    , _encoderImpl_decode = traverse $ _encoderImpl_decode ve\n    }\n\ninstance Monad parse => PFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  second g = bimap id g\ninstance Monad parse => Bifunctor Either (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\case\n      Left a -> Left <$> _encoderImpl_decode f a\n      Right b -> Right <$> _encoderImpl_decode g b\n    }\n\ninstance (Monad parse, Applicative check) => QFunctor Either (Encoder check parse) (Encoder check parse) where\n  second g = bimap id g\ninstance (Monad parse, Applicative check) => PFunctor Either (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Monad parse, Applicative check) => Bifunctor Either (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) Either where\n  associate = viewEncoder (iso (associate @(->) @Either) disassociate)\n  disassociate = viewEncoder (iso disassociate associate)\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) Either where\n  braid = viewEncoder (iso swap swap)\n\n\n\ninstance (Traversable f, Monad check, Monad parse) => Cat.Functor f (Encoder check parse) (Encoder check parse) where\n  fmap e = Encoder $ do\n    ve <- unEncoder e\n    pure $ Cat.fmap ve\n\ninstance Monad parse => Associative (EncoderImpl parse) (,) where\n  associate = EncoderImpl\n    { _encoderImpl_encode = associate\n    , _encoderImpl_decode = pure . disassociate\n    }\n  disassociate = EncoderImpl\n    { _encoderImpl_encode = disassociate\n    , _encoderImpl_decode = pure . associate\n    }\n\ninstance Monad parse => Monoidal (EncoderImpl parse) (,) where\n  type Id (EncoderImpl parse) (,) = ()\n  idl = EncoderImpl\n    { _encoderImpl_encode = idl\n    , _encoderImpl_decode = pure . coidl\n    }\n  idr = EncoderImpl\n    { _encoderImpl_encode = idr\n    , _encoderImpl_decode = pure . coidr\n    }\n  coidl = EncoderImpl\n    { _encoderImpl_encode = coidl\n    , _encoderImpl_decode = pure . idl\n    }\n  coidr = EncoderImpl\n    { _encoderImpl_encode = coidr\n    , _encoderImpl_decode = pure . idr\n    }\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) (,) where\n  associate = Encoder $ pure associate\n  disassociate = Encoder $ pure disassociate\n\ninstance (Applicative check, Monad parse) => Monoidal (Encoder check parse) (,) where\n  type Id (Encoder check parse) (,) = ()\n  idl = Encoder $ pure idl\n  idr = Encoder $ pure idr\n  coidl = Encoder $ pure coidl\n  coidr = Encoder $ pure coidr\n\n--------------------------------------------------------------------------------\n-- Specific instances of encoders\n--------------------------------------------------------------------------------\n\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nviewEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nviewEncoder f = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = view f\n  , _encoderImpl_decode = pure . view (from f)\n  }\n\nwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse (Unwrapped a) a\nwrappedEncoder = viewEncoder $ from _Wrapped'\n\nunwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse a (Unwrapped a)\nunwrappedEncoder = viewEncoder $ _Wrapped'\n\nmaybeToEitherEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a) (Either () a)\nmaybeToEitherEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Nothing -> Left ()\n      Just a -> Right a\n  , _encoderImpl_decode = pure . \\case\n      Left _ -> Nothing\n      Right a -> Just a\n  }\n\nmaybeEncoder\n  :: ( MonadError Text check\n     , Show a\n     , Show b\n     , check ~ parse\n     )\n  => Encoder check parse () b\n  -> Encoder check parse a b\n  -> Encoder check parse (Maybe a) b\nmaybeEncoder f g = shadowEncoder f g . maybeToEitherEncoder\n\n-- | Encode a value by simply applying 'Just'\njustEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a (Maybe a)\njustEncoder = reviewEncoder _Just\n\n-- | Encode () to 'Nothing'.\nnothingEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse () (Maybe a)\nnothingEncoder = reviewEncoder _Nothing\n\nsomeConstEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Const a)) a\nsomeConstEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(Some (Const a)) -> a\n  , _encoderImpl_decode = pure . Some . Const\n  }\n\n-- | WARNING: This is only safe if the Show and Read instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeTshowEncoder :: (Show a, Read a, Applicative check, MonadError Text parse) => Encoder check parse a Text\nunsafeTshowEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = tshow\n  , _encoderImpl_decode = \\raw -> case readMaybe $ T.unpack raw of\n      Nothing -> throwError $ \"unsafeTshowEncoderImpl: couldn't decode \" <> tshow raw\n      Just parsed -> pure parsed\n  }\n\nnewtype EncoderFunc check parse p r = EncoderFunc { runEncoderImplFunc :: forall a. p a -> Encoder check parse a r }\n\nnewtype Flip f a b = Flip { unFlip :: f b a }\n\ncheckEnum1EncoderFunc\n  :: forall check check' parse p r.\n     ( Universe (Some p)\n     , GCompare p\n     , Monad check\n     , Applicative check'\n     )\n  => (forall a. p a -> Encoder check parse a r)\n  -> check (EncoderFunc check' parse p r)\ncheckEnum1EncoderFunc f = do\n  (encoderImpls :: DMap p (Flip (EncoderImpl parse) r)) <- DMap.fromList <$>\n    traverse (\\(Some p) -> (p :=>) . Flip <$> unEncoder (f p)) universe\n  pure $ EncoderFunc $ \\p -> unsafeMkEncoder . unFlip $\n    DMap.findWithDefault (error \"checkEnum1EncoderFunc: EncoderImpl not found (should be impossible)\") p encoderImpls\n\n-- | This type is used by pathComponentEncoder to allow the user to indicate how to treat\n-- various cases when encoding a dependent sum of type `(R p)`.\ndata SegmentResult check parse a =\n    PathEnd (Encoder check parse a (Map Text (Maybe Text)))\n    -- ^ Indicate that the path is finished, with an Encoder that translates the\n    -- corresponding value into query parameters\n  | PathSegment Text (Encoder check parse a PageName)\n    -- ^ Indicate that the key should be represented by an additional path segment with\n    -- the given 'Text', and give an Encoder for translating the corresponding value into\n    -- the remainder of the route.\n\n-- | Encode a dependent sum of type `(R p)` into a PageName (i.e. the path and query part of a URL) by using the\n-- supplied function to decide how to encode the constructors of p using the SegmentResult type. It is important\n-- that the number of values of type `(Some p)` be relatively small in order for checking to complete quickly.\npathComponentEncoder\n  :: forall check parse p.\n     ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse )\n  => (forall a. p a -> SegmentResult check parse a)\n  -> Encoder check parse (R p) PageName\npathComponentEncoder f = Encoder $ do\n  let extractEncoder = \\case\n        PathEnd e -> first (unitEncoder []) . coidl . e\n        PathSegment _ e -> e\n      extractPathSegment = \\case\n        PathEnd _ -> Nothing\n        PathSegment t _ -> Just t\n  EncoderFunc f' <- checkEnum1EncoderFunc (extractEncoder . f)\n  unEncoder (pathComponentEncoderImpl (enum1Encoder (extractPathSegment . f)) f')\n\npathComponentEncoderImpl :: forall check parse p. (Monad check, Monad parse)\n  => Encoder check parse (Some p) (Maybe Text)\n  -> (forall a. p a -> Encoder Identity parse a PageName)\n  -> Encoder check parse (R p) PageName\npathComponentEncoderImpl =\n  chainEncoder (lensEncoder (\\(_, b) a -> (a, b)) Prelude.fst consEncoder)\n\n--NOTE: Naming convention in this module is to always talk about things in the *encoding* direction, never in the *decoding* direction\n\nchainEncoder\n  :: forall check parse p r b.\n     ( Monad check\n     , Monad parse\n     )\n  => Encoder check parse (b, r) r\n  -> Encoder check parse (Some p) b\n  -> (forall a. p a -> Encoder Identity parse a r)\n  -> Encoder check parse (R p) r\nchainEncoder cons this rest = Encoder $ do\n  consValid <- unEncoder cons\n  thisValid <- unEncoder this\n  pure $ EncoderImpl\n    { _encoderImpl_decode = \\v -> do\n        (here, following) <- _encoderImpl_decode consValid v\n        _encoderImpl_decode thisValid here >>= \\case\n          Some r ->\n            (r :/) <$> _encoderImpl_decode (runIdentity . unEncoder $ rest r) following\n    , _encoderImpl_encode = \\(r :/ s) ->\n        _encoderImpl_encode consValid\n          ( _encoderImpl_encode thisValid $ Some r\n          , _encoderImpl_encode (runIdentity . unEncoder $ rest r) s)\n    }\n\n--TODO: Do this in terms of a lens instead\nlensEncoder :: (Applicative check, Monad parse)\n  => (b -> [a] -> b) -> (b -> [a]) -> Encoder check parse (c, [a]) [a] -> Encoder check parse (c, b) b\nlensEncoder set get g = Encoder $ do\n  gImpl <- unEncoder g\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(ma, b) -> set b $ _encoderImpl_encode gImpl (ma, get b)\n    , _encoderImpl_decode = \\b -> do\n        (ma, la) <- _encoderImpl_decode gImpl $ get b\n        pure (ma, set b la)\n    }\n\nconsEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a, [a]) [a] --TODO: Really shouldn't *always* have the [a], even in the Nothing case\nconsEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(h, t) -> maybeToList h <> t\n  , _encoderImpl_decode = pure . \\case\n      [] -> (Nothing, [])\n      h:t -> (Just h, t)\n  }\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\nshadowEncoder\n  :: ( Universe a\n     , MonadError Text check\n     , Show a\n     , Show b\n     , Show c\n     , check ~ parse --TODO: Get rid of this\n     )\n  => Encoder check parse a c -- ^ Overlaps; should have a small number of possible routes\n  -> Encoder check parse b c -- ^ Gets overlapped\n  -> Encoder check parse (Either a b) c\nshadowEncoder f g = Encoder $ do\n  vf <- unEncoder f\n  vg <- unEncoder g\n  let gCanParse c = catchError (Just <$> _encoderImpl_decode vg c) (\\_ -> pure Nothing)\n  overlaps <- fmap catMaybes $ forM universe $ \\a -> do\n    let c = _encoderImpl_encode vf a\n    mb <- gCanParse c\n    pure $ fmap (\\b -> (a, b, c)) mb\n  case overlaps of\n    [] -> pure ()\n    _ -> throwError $ \"shadowEncoder: overlap detected: \" <> T.unlines\n      (flip fmap overlaps $ \\(a, b, c) -> \"first encoder encodes \" <> tshow a <> \" as \" <> tshow c <> \", which second encoder decodes as \" <> tshow b)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\case\n        Left a -> _encoderImpl_encode vf a\n        Right b -> _encoderImpl_encode vg b\n    , _encoderImpl_decode = \\c -> (Left <$> _encoderImpl_decode vf c) `catchError` \\_ -> Right <$> _encoderImpl_decode vg c\n    }\n\nenum1Encoder\n  :: ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse\n     , Ord r\n     , Show r\n     )\n  => (forall a. p a -> r) -> Encoder check parse (Some p) r\nenum1Encoder f = enumEncoder $ \\(Some p) -> f p\n\n-- | Encode an enumerable, bounded type.  WARNING: Don't use this on types that\n-- have a large number of values - it will use a lot of memory.\nenumEncoder :: forall parse check p r. (Universe p, Show p, Ord p, Ord r, MonadError Text parse, MonadError Text check, Show r) => (p -> r) -> Encoder check parse p r\nenumEncoder f = Encoder $ do\n  let reversed = Map.fromListWith (<>) [ (f p, Set.singleton p) | p <- universe ]\n      checkSingleton k vs = case Set.toList vs of\n        [] -> error \"enumEncoder: empty reverse mapping; should be impossible\"\n        [e] -> Success e\n        _ -> Failure $ Map.singleton k vs\n      showRedundant :: r -> Set p -> [Text]\n      showRedundant k vs = (\"  \" <> tshow k <> \" can decode to any of:\")\n        : fmap ((\"    \"<>) . tshow) (Set.toList vs)\n  case itraverse checkSingleton reversed :: Validation (Map r (Set p)) (Map r p) of\n    Failure ambiguousEntries -> throwError $ T.unlines $\n      \"enumEncoder: ambiguous encodings detected:\" : concat (Map.elems $ imap showRedundant ambiguousEntries)\n    Success m -> pure $ EncoderImpl\n      { _encoderImpl_decode = \\r -> case Map.lookup r m of\n          Just a -> pure a\n          Nothing -> throwError $ \"enumEncoder: not recognized: \" <> tshow r --TODO: Report this as a better type\n      , _encoderImpl_encode = f\n      }\n\nunitEncoder :: (Applicative check, MonadError Text parse, Show r, Eq r) => r -> Encoder check parse () r\nunitEncoder expected = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\obtained ->\n      if obtained == expected\n      then pure ()\n      else throwError $ \"endEncoderImpl: expected \" <> tshow expected <> \", got \" <> tshow obtained\n  , _encoderImpl_encode = \\_ -> expected\n  }\n\nsinglePathSegmentEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse Text PageName\nsinglePathSegmentEncoder = pathOnlyEncoder . singletonListEncoder\n\npathOnlyEncoderIgnoringQuery :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoderIgnoringQuery = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\(path, _query) -> pure path\n  , _encoderImpl_encode = \\path -> (path, mempty)\n  }\n\npathOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoder = second (unitEncoder mempty) . coidr\n\nqueryOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Map Text (Maybe Text)) PageName\nqueryOnlyEncoder = first (unitEncoder []) . coidl\n\nsingletonListEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a [a]\nsingletonListEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\case\n      [a] -> pure a\n      l -> throwError $ \"singletonListEncoderImpl: expected one item, got \" <> tshow (length l)\n  , _encoderImpl_encode = (:[])\n  }\n\nsplitTextNonEmpty :: Text -> Text -> NonEmpty Text\nsplitTextNonEmpty separator v = case T.splitOn separator v of\n  [] -> error \"splitTextNonEmpty: Data.Text.splitOn should never return an empty list\"\n  h : t -> h :| t\n\n--TODO: To know this is reversible, we must know that the separator isn't included anywhere in the input text\npathSegmentsTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse (NonEmpty Text) Text\npathSegmentsTextEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = T.intercalate \"/\" . fmap (urlEncodeText False) . toList\n  , _encoderImpl_decode = pure . fmap (urlDecodeText False) . splitTextNonEmpty \"/\"\n  }\n\nqueryParametersTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse [(Text, Maybe Text)] Text\nqueryParametersTextEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> \"\"\n      params -> T.intercalate \"&\" (fmap encodeParameter params)\n  , _encoderImpl_decode = pure . \\case\n      \"\" -> []\n      encoded ->\n        let h :| t = splitTextNonEmpty \"&\" encoded\n        in fmap decodeParameter $ h : t\n  }\n  where\n    encodeParameter (k, mv) = urlEncodeText True k <> case mv of\n      Nothing -> \"\"\n      Just v -> \"=\" <> urlEncodeText True v\n    decodeParameter t =\n      let (k, eqV) = T.breakOn \"=\" t\n          mv = T.stripPrefix \"=\" eqV\n      in (urlDecodeText True k, urlDecodeText True <$> mv)\n\nurlEncodeText :: Bool -> Text -> Text\nurlEncodeText q = T.decodeUtf8 . urlEncode q . T.encodeUtf8\n\nurlDecodeText :: Bool -> Text -> Text\nurlDecodeText q = T.decodeUtf8 . urlDecode q . T.encodeUtf8\n\nlistToNonEmptyEncoder :: (Applicative check, Applicative parse, Monoid a, Eq a) => Encoder check parse [a] (NonEmpty a)\nlistToNonEmptyEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> mempty :| []\n      h : t -> h :| t\n  , _encoderImpl_decode = \\(h :| t) -> pure $\n      if h == mempty\n      then []\n      else h : t\n  }\n\nprefixTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = mappend p\n  , _encoderImpl_decode = \\v -> case T.stripPrefix p v of\n      Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p <> \", got \" <> tshow (T.take (T.length p) v)\n      Just stripped -> pure stripped\n  }\n\nprefixNonemptyTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixNonemptyTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      \"\" -> \"\"\n      v -> p <> v\n  , _encoderImpl_decode = \\case\n      \"\" -> pure \"\"\n      v -> case T.stripPrefix p v of\n        Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p\n        Just stripped -> pure stripped\n  }\n\npackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse String text\npackTextEncoder = isoEncoder packed\n\nunpackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse text String\nunpackTextEncoder = isoEncoder unpacked\n\ntoListMapEncoder :: (Applicative check, Applicative parse, Ord k) => Encoder check parse (Map k v) [(k, v)]\ntoListMapEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = Map.toList\n  , _encoderImpl_decode = pure . Map.fromList --TODO: Should we be stricter about repeated keys?\n  }\n\njoinPairTextEncoder :: (MonadError Text check, MonadError Text parse) => Text -> Encoder check parse (Text, Text) Text\njoinPairTextEncoder = Encoder . \\case\n  \"\" -> throwError \"joinPairTextEncoder: empty separator\"\n  separator -> pure $ EncoderImpl\n    { _encoderImpl_encode = \\(k, v) -> k <> separator <> v\n    , _encoderImpl_decode = \\r ->\n        let (kt, vt) = T.breakOn separator r\n        in case vt of\n          -- The separator was not found\n          \"\" -> throwError $ \"joinPairTextEncoder: separator not found; expected \" <> tshow separator\n          _ -> return (kt, T.drop (T.length separator) vt)\n    }\n\n-- This slight generalization of 'rPrism' happens to be enough to write all our\n-- prism combinators so far.\ndSumPrism\n  :: forall f f' g\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (DSum f g) (DSum f' g)\ndSumPrism p = prism'\n  (\\(f' :=> x) -> f' ^. re p :=> x)\n  (\\(f :=> x) -> (:=> x) <$> (f ^? p))\n\n-- already in obelisk\nrPrism\n  :: forall f f'\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (R f) (R f')\nrPrism = dSumPrism\n\ndSumPrism'\n  :: forall f g a\n  .  (forall b. Prism' (f b) (a :~: b))\n  -> Prism' (DSum f g) (g a)\ndSumPrism' p = dSumPrism p . iso (\\(Refl :=> b) -> b) (Refl :=>)\n\ndSumGEqPrism\n  :: GEq f\n  => f a\n  -> Prism' (DSum f g) (g a)\ndSumGEqPrism variant = dSumPrism' $ prism' (\\Refl -> variant) (geq variant)\n\n-- | Given a 'tag :: f a', make a prism for 'R f'. This generalizes the usual\n-- prisms for a sum type (the ones that 'mkPrisms' would make), just as 'R'\n-- generalized a usual sum type.\n--\n-- [This is given the '_R' name of the \"cannonical\" prism not because it is the\n-- most general, but because it seems the most useful for routes, and 'R' itself\n-- trades generality for route-specificity.]\n_R\n  :: GEq f\n  => f a\n  -> Prism' (R f) a\n_R variant = dSumGEqPrism variant . iso runIdentity Identity\n\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'reviewEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @reviewEncoder (f . g) = reviewEncoder g . reviewEncoder f@.\nreviewEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nreviewEncoder p = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = review p\n  , _encoderImpl_decode = \\r -> case r ^? p of\n      Just a -> pure a\n      Nothing -> throwError \"reviewEncoder: value is not present in the prism\"\n  }\n\n-- | A URL path and query string, in which trailing slashes don't matter in the path\n-- and duplicate query parameters are not allowed. A final goal of encoders using this library\n-- will frequently be to produce this.\ntype PageName = ([Text], Map Text (Maybe Text))\n\n-- | A path (separated by slashes), and a query string.\ntype PathQuery = (String, String)\n\n-- | Encode a PageName into a path and query string.\npageNameEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse PageName PathQuery\npageNameEncoder = bimap\n  (unpackTextEncoder . prefixTextEncoder \"/\" . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n  (unpackTextEncoder . prefixNonemptyTextEncoder \"?\" . queryParametersTextEncoder . toListMapEncoder)\n\n-- | Handle an error in parsing, for example, in order to redirect to a 404 page.\nhandleEncoder\n  :: (Functor check)\n  => (e -> a)\n  -> Encoder check (Either e) a b\n  -> Encoder check Identity a b\nhandleEncoder recover e = Encoder $ do\n  i <- unEncoder e\n  return $ i\n    { _encoderImpl_decode = \\a -> pure $ case _encoderImpl_decode i a of\n      Right r -> r\n      Left err -> recover err\n    }\n\n--------------------------------------------------------------------------------\n-- Actual obelisk route info\n--------------------------------------------------------------------------------\n\n-- | The typical full route type comprising all of an Obelisk application's routes.\n-- Parameterised by the top level GADTs that define backend and frontend routes, respectively.\ndata FullRoute :: (* -> *) -> (* -> *) -> * -> * where\n  FullRoute_Backend :: br a -> FullRoute br fr a\n  FullRoute_Frontend :: ObeliskRoute fr a -> FullRoute br fr a\n\ninstance (GShow br, GShow fr) => GShow (FullRoute br fr) where\n  gshowsPrec p = \\case\n    FullRoute_Backend x -> showParen (p > 10) (showString \"FullRoute_Backend \" . gshowsPrec 11 x)\n    FullRoute_Frontend x -> showParen (p > 10) (showString \"FullRoute_Frontend \" . gshowsPrec 11 x)\n\ninstance (GEq br, GEq fr) => GEq (FullRoute br fr) where\n  geq (FullRoute_Backend x) (FullRoute_Backend y) = geq x y\n  geq (FullRoute_Frontend x) (FullRoute_Frontend y) = geq x y\n  geq _ _ = Nothing\n\ninstance (GCompare br, GCompare fr) => GCompare (FullRoute br fr) where\n  gcompare (FullRoute_Backend _) (FullRoute_Frontend _) = GLT\n  gcompare (FullRoute_Frontend _) (FullRoute_Backend _) = GGT\n  gcompare (FullRoute_Backend x) (FullRoute_Backend y) = gcompare x y\n  gcompare (FullRoute_Frontend x) (FullRoute_Frontend y) = gcompare x y\n\ninstance  (UniverseSome br, UniverseSome fr) => UniverseSome (FullRoute br fr) where\n  universeSome = [Some (FullRoute_Backend x) | Some x <- universeSome]\n              ++ [Some (FullRoute_Frontend x) | Some x <- universeSome]\n\n-- | Build the typical top level application route encoder from a route for handling 404's,\n-- and segment encoders for backend and frontend routes.\nmkFullRouteEncoder\n  :: (GCompare br, GCompare fr, GShow br, GShow fr, UniverseSome br, UniverseSome fr)\n  => R (FullRoute br fr) -- ^ 404 handler\n  -> (forall a. br a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single backend route segment\n  -> (forall a. fr a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single frontend route segment\n  -> Encoder (Either Text) Identity (R (FullRoute br fr)) PageName\nmkFullRouteEncoder missing backendSegment frontendSegment = handleEncoder (const missing) $\n  pathComponentEncoder $ \\case\n    FullRoute_Backend backendRoute -> backendSegment backendRoute\n    FullRoute_Frontend obeliskRoute -> obeliskRouteSegment obeliskRoute frontendSegment\n\n-- | A type which can represent Obelisk-specific resource routes, in addition to application specific routes which serve your\n-- frontend.\ndata ObeliskRoute :: (* -> *) -> * -> * where\n  -- We need to have the `f a` as an argument here, because otherwise we have no way to specifically check for overlap between us and the given encoder\n  ObeliskRoute_App :: f a -> ObeliskRoute f a\n  ObeliskRoute_Resource :: ResourceRoute a -> ObeliskRoute f a\n\ninstance UniverseSome f => UniverseSome (ObeliskRoute f) where\n  universeSome = concat\n    [ (\\(Some x) -> Some (ObeliskRoute_App x)) <$> universe\n    , (\\(Some x) -> Some (ObeliskRoute_Resource x)) <$> (universe @(Some ResourceRoute))\n    ]\n\ninstance GEq f => GEq (ObeliskRoute f) where\n  geq (ObeliskRoute_App x) (ObeliskRoute_App y) = geq x y\n  geq (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = geq x y\n  geq _ _ = Nothing\n\ninstance GCompare f => GCompare (ObeliskRoute f) where\n  gcompare (ObeliskRoute_App x) (ObeliskRoute_App y) = gcompare x y\n  gcompare (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = gcompare x y\n  gcompare (ObeliskRoute_App _) (ObeliskRoute_Resource _) = GLT\n  gcompare (ObeliskRoute_Resource _) (ObeliskRoute_App _) = GGT\n\n-- | A type representing the various resource routes served by Obelisk. These can in principle map to any physical routes you want,\n-- but sane defaults are provided by 'resourceRouteSegment'\ndata ResourceRoute :: * -> * where\n  ResourceRoute_Static :: ResourceRoute [Text] -- This [Text] represents the *path in our static files directory*, not necessarily the URL path that the asset gets served at (although that will often be \"/static/this/text/thing\")\n  ResourceRoute_Ghcjs :: ResourceRoute [Text]\n  ResourceRoute_JSaddleWarp :: ResourceRoute (R JSaddleWarpRoute)\n  ResourceRoute_Version :: ResourceRoute ()\n\n-- | If there are no additional backend routes in your app (i.e. ObeliskRoute gives you all the routes you need),\n-- this constructs a suitable 'Encoder' to use for encoding routes to 'PageName's. If you do have additional backend routes,\n-- you'll want to use 'pathComponentEncoder' yourself, applied to a function that will likely use obeliskRouteSegment in order to\n-- handle the ObeliskRoute case (i.e. Obelisk resource routes and app frontend routes).\nobeliskRouteEncoder :: forall check parse appRoute.\n     ( Universe (Some (ObeliskRoute appRoute))\n     , GCompare (ObeliskRoute appRoute)\n     , GShow appRoute\n     , MonadError Text check\n     , check ~ parse --TODO: Get rid of this\n     )\n  => (forall a. appRoute a -> SegmentResult check parse a)\n  -> Encoder check parse (R (ObeliskRoute appRoute)) PageName\nobeliskRouteEncoder appRouteSegment = pathComponentEncoder $ \\r ->\n  obeliskRouteSegment r appRouteSegment\n\n-- | From a function which explains how app-specific frontend routes translate into segments, produce a function which does the\n-- same for ObeliskRoute. This uses the given function for the 'ObeliskRoute_App' case, and 'resourceRouteSegment' for the\n-- 'ObeliskRoute_Resource' case.\nobeliskRouteSegment :: forall check parse appRoute a.\n     (MonadError Text check, MonadError Text parse)\n  => ObeliskRoute appRoute a\n  -> (forall b. appRoute b -> SegmentResult check parse b)\n  -> SegmentResult check parse a\nobeliskRouteSegment r appRouteSegment = case r of\n  ObeliskRoute_App appRoute -> appRouteSegment appRoute\n  ObeliskRoute_Resource resourceRoute -> resourceRouteSegment resourceRoute\n\n-- | A function which gives a sane default for how to encode Obelisk resource routes. It's given in this form, because it will\n-- be combined with other such segment encoders before 'pathComponentEncoder' turns it into a proper 'Encoder'.\nresourceRouteSegment :: (MonadError Text check, MonadError Text parse) => ResourceRoute a -> SegmentResult check parse a\nresourceRouteSegment = \\case\n  ResourceRoute_Static -> PathSegment \"static\" pathOnlyEncoderIgnoringQuery\n  ResourceRoute_Ghcjs -> PathSegment \"ghcjs\" pathOnlyEncoder\n  ResourceRoute_JSaddleWarp -> PathSegment \"jsaddle\" jsaddleWarpRouteEncoder\n  ResourceRoute_Version -> PathSegment \"version\" $ unitEncoder mempty\n\ndata JSaddleWarpRoute :: * -> * where\n  JSaddleWarpRoute_JavaScript :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_WebSocket :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_Sync :: JSaddleWarpRoute [Text]\n\njsaddleWarpRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R JSaddleWarpRoute) PageName\njsaddleWarpRouteEncoder = pathComponentEncoder $ \\case\n  JSaddleWarpRoute_JavaScript -> PathSegment \"jsaddle.js\" $ unitEncoder mempty\n  JSaddleWarpRoute_WebSocket ->  PathEnd $ unitEncoder mempty\n  JSaddleWarpRoute_Sync -> PathSegment \"sync\" pathOnlyEncoder\n\ninstance GShow appRoute => GShow (ObeliskRoute appRoute) where\n  gshowsPrec prec = \\case\n    ObeliskRoute_App appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_App \" . gshowsPrec 11 appRoute\n    ObeliskRoute_Resource appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_Resource \" . gshowsPrec 11 appRoute\n\ndata IndexOnlyRoute :: * -> * where\n  IndexOnlyRoute :: IndexOnlyRoute ()\n\nindexOnlyRouteSegment :: (Applicative check, MonadError Text parse) => IndexOnlyRoute a -> SegmentResult check parse a\nindexOnlyRouteSegment = \\case\n  IndexOnlyRoute -> PathEnd $ unitEncoder mempty\n\nindexOnlyRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R IndexOnlyRoute) PageName\nindexOnlyRouteEncoder = pathComponentEncoder indexOnlyRouteSegment\n\nsomeSumEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Sum a b)) (Either (Some a) (Some b))\nsomeSumEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\(Some t) -> case t of\n      InL l -> Left $ Some l\n      InR r -> Right $ Some r\n  , _encoderImpl_decode = pure . \\case\n      Left (Some l) -> Some (InL l)\n      Right (Some r) -> Some (InR r)\n  }\n\ndata Void1 :: * -> * where {}\n\ninstance UniverseSome Void1 where\n  universeSome = []\n\nvoid1Encoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Some Void1) a\nvoid1Encoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Some f -> case f of {}\n  , _encoderImpl_decode = \\_ -> throwError \"void1Encoder: can't decode anything\"\n  }\n\ninstance GShow Void1 where\n  gshowsPrec _ = \\case {}\n\n-- | Given a backend route and a checked route encoder, render the route (path\n-- and query string). See 'checkEncoder' for how to produce a checked encoder.\nrenderBackendRoute\n  :: forall br a.\n     Encoder Identity Identity (R (FullRoute br a)) PageName\n  -> R br\n  -> Text\nrenderBackendRoute enc = renderObeliskRoute enc . hoistR FullRoute_Backend\n\n-- | Renders a frontend route with the supplied checked encoder\nrenderFrontendRoute\n  :: forall a fr.\n     Encoder Identity Identity (R (FullRoute a fr)) PageName\n  -> R fr\n  -> Text\nrenderFrontendRoute enc = renderObeliskRoute enc . hoistR (FullRoute_Frontend . ObeliskRoute_App)\n\n-- | Renders a route of the form typically found in an Obelisk project\nrenderObeliskRoute\n  :: forall a b.\n     Encoder Identity Identity (R (FullRoute a b)) PageName\n  -> R (FullRoute a b)\n  -> Text\nrenderObeliskRoute e r =\n  let enc :: Encoder Identity (Either Text) (R (FullRoute a b)) PathQuery\n      enc = (pageNameEncoder . hoistParse (pure . runIdentity) e)\n  in (T.pack . uncurry (<>)) $ encode enc r\n\n-- | As per the 'unsafeTshowEncoder' but does not use the 'Text' type.\n--\n-- WARNING: Just like 'unsafeTshowEncoder' this is only safe if the Show and Read\n-- instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nunsafeShowEncoder = singlePathSegmentEncoder . unsafeTshowEncoder\n\n-- | This 'Encoder' does not properly indicate that its use may be unsafe and is being renamed to 'unsafeShowEncoder'\nreadShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nreadShowEncoder = unsafeShowEncoder\n{-# DEPRECATED readShowEncoder \"This function has been renamed to 'unsafeShowEncoder'. 'readShowEncoder' will be removed in a future release\" #-}\n\nintegralEncoder :: (MonadError Text parse, Applicative check, Integral a) => Encoder check parse a Integer\nintegralEncoder = reviewEncoder Numeric.Lens.integral\n\npathSegmentEncoder :: (MonadError Text parse, Applicative check, Cons as as a a) =>\n  Encoder check parse (a, (as, b)) (as, b)\npathSegmentEncoder = first (reviewEncoder _Cons) . disassociate\n\nnewtype Decoder check parse b a = Decoder { toEncoder :: Encoder check parse a b }\n\ndmapEncoder :: forall check parse k k' v.\n   ( Monad check\n   , MonadError Text parse\n   , Universe (Some k')\n   , Ord k\n   , GCompare k'\n   , GShow k'\n   )\n  => Encoder check parse (Some k') k\n  -> (forall v'. k' v' -> Encoder check parse v' v)\n  -> Encoder check parse (DMap k' Identity) (Map k v)\ndmapEncoder keyEncoder' valueEncoderFor = unsafeEncoder $ do\n  keyEncoder :: Encoder Identity parse (Some k') k <- checkEncoder keyEncoder'\n  valueDecoders :: DMap k' (Decoder Identity parse v) <- fmap DMap.fromList . forM universe $ \\(Some (k' :: k' t)) -> do\n    ve :: Encoder Identity parse t v <- checkEncoder (valueEncoderFor k')\n    return $ (k' :: k' t) :=> (Decoder ve :: Decoder Identity parse v t)\n  let keyError k = \"dmapEncoder: key `\" <> k <> \"' was missing from the Universe instance for its type.\"\n  return $ EncoderImpl\n    { _encoderImpl_encode = \\dm -> Map.fromList $ do\n        ((k' :: k' t) :=> Identity v') <- DMap.toList dm\n        return ( encode keyEncoder (Some k')\n               , encode (toEncoder (DMap.findWithDefault (error . keyError $ gshow k') k' valueDecoders)) v'\n               )\n    , _encoderImpl_decode = \\m -> fmap DMap.fromList . forM (Map.toList m) $ \\(k,v) -> do\n          tryDecode keyEncoder k >>= \\case\n            Some (k' :: k' t) -> case DMap.lookup k' valueDecoders of\n              Nothing -> throwError . T.pack . keyError $ gshow k'\n              Just (Decoder e) -> do\n                v' <- tryDecode e v\n                return (k' :=> Identity v')\n    }\n\nfieldMapEncoder :: forall check parse r.\n   ( Applicative check\n   , MonadError Text parse\n   , HasFields r\n   , Universe (Some (Field r))\n   , GShow (Field r)\n   , GCompare (Field r)\n   )\n  => Encoder check parse r (DMap (Field r) Identity)\nfieldMapEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\r -> DMap.fromList [ f :=> Identity (indexField r f) | Some f <- universe ]\n    , _encoderImpl_decode = \\dm -> tabulateFieldsA $ \\f -> do\n      case DMap.lookup f dm of\n        Nothing -> throwError $ \"fieldMapEncoder: Couldn't find key for `\" <> T.pack (gshow f) <> \"' in DMap.\"\n        Just (Identity v) -> return v\n    }\n\npathFieldEncoder :: forall a p check parse . (HasFields a, Monad check, MonadError Text parse, GCompare (Field a)) => (forall x. Field a x -> Encoder check parse x p) -> Encoder check parse (a, [p]) [p]\npathFieldEncoder fieldEncoder = unsafeEncoder $ do\n  fieldEncoderPureMap :: DMap.DMap (Field a) (Decoder Identity parse p) <- getAp $ getConst $ tabulateFieldsA @a $ \\f -> Const (Ap $ fmap (DMap.singleton f . Decoder) $ (checkEncoder @Identity) $ fieldEncoder f)\n  let fieldEncoderPure :: forall x. Field a x -> Encoder Identity parse x p\n      fieldEncoderPure f = toEncoder (DMap.findWithDefault (error \"bad\") f fieldEncoderPureMap)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(x, rest) -> execWriter $ do\n      _ <- traverseWithField (\\f x_i -> tell (pure $ encode (fieldEncoderPure f) x_i) $> x_i) x\n      tell rest\n    , _encoderImpl_decode = State.runStateT $ tabulateFieldsA $ \\f -> State.get >>= \\case\n      [] -> throwError $ T.pack \"not enough path components\"\n      p:ps -> do\n        State.put ps\n        lift $ tryDecode (fieldEncoderPure f) p\n    }\n\n-- | Use ToJSON/FromJSON to encode to Text. The correctness of this encoder is dependent on the encoding being injective and round-tripping correctly.\njsonEncoder :: forall check parse r.\n  ( ToJSON r\n  , FromJSON r\n  , Applicative check\n  , MonadError Text parse\n  )\n  => Encoder check parse r Text\njsonEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\r -> T.decodeUtf8 . BSL.toStrict $ Aeson.encode r\n    , _encoderImpl_decode = \\t -> case Aeson.eitherDecodeStrict $ T.encodeUtf8 t of\n        Left err -> throwError (\"jsonEncoder: \" <> T.pack err)\n        Right x -> return x\n    }\n\n-- Useful for app server integration.\n-- p must not start with slashes\nbyteStringsToPageName :: BS.ByteString -> BS.ByteString -> PageName\nbyteStringsToPageName p q =\n  let pageNameEncoder' :: Encoder Identity Identity PageName (String, String)\n      pageNameEncoder' = bimap\n        (unpackTextEncoder . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n        (unpackTextEncoder . queryParametersTextEncoder . toListMapEncoder)\n  in decode pageNameEncoder' (T.unpack (T.decodeUtf8 p), T.unpack (T.decodeUtf8 q))\n\n--TODO: decodeURIComponent as appropriate\n\n\n{-# DEPRECATED isoEncoder \"Instead of 'isoEncoder f', use 'viewEncoder f'\" #-}\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nisoEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nisoEncoder = viewEncoder\n\n{-# DEPRECATED prismEncoder \"Instead of 'prismEncoder f', use 'reviewEncoder f'\" #-}\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'prismEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @prismEncoder (f . g) = prismEncoder g . prismEncoder f@.\nprismEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nprismEncoder = reviewEncoder\n\n\nconcat <$> mapM deriveRouteComponent\n  [ ''ResourceRoute\n  , ''JSaddleWarpRoute\n  , ''IndexOnlyRoute\n  ]\n\nmakePrisms ''ObeliskRoute\nmakePrisms ''FullRoute\nderiveGEq ''Void1\nderiveGCompare ''Void1\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs:(952,1)-(954,62)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data FullRoute :: (* -> *) -> (* -> *) -> * -> *",
                    "    where",
                    "      FullRoute_Backend :: br a -> FullRoute br fr a",
                    "      FullRoute_Frontend :: ObeliskRoute fr a -> FullRoute br fr a"
                  ],
                  "perhaps_block": [
                    "  data FullRoute :: (* -> *) -> (* -> *) -> * -> *",
                    "    where",
                    "      FullRouteBackend :: br a -> FullRoute br fr a",
                    "      FullRouteFrontend :: ObeliskRoute fr a -> FullRoute br fr a"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs:(997,18)-(1000,5)",
                  "suggestion_title": "Use ++",
                  "found_block": [
                    "  concat",
                    "    [(\\ (Some x) -> Some (ObeliskRoute_App x)) <$> universe,",
                    "     (\\ (Some x) -> Some (ObeliskRoute_Resource x))",
                    "       <$> (universe @(Some ResourceRoute))]"
                  ],
                  "perhaps_block": [
                    "  ((\\ (Some x) -> Some (ObeliskRoute_App x)) <$> universe)",
                    "    ++",
                    "      ((\\ (Some x) -> Some (ObeliskRoute_Resource x))",
                    "         <$> (universe @(Some ResourceRoute)))"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route.hs:(1058,1)-(1061,50)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data JSaddleWarpRoute :: * -> *",
                    "    where",
                    "      JSaddleWarpRoute_JavaScript :: JSaddleWarpRoute ()",
                    "      JSaddleWarpRoute_WebSocket :: JSaddleWarpRoute ()",
                    "      JSaddleWarpRoute_Sync :: JSaddleWarpRoute [Text]"
                  ],
                  "perhaps_block": [
                    "  data JSaddleWarpRoute :: * -> *",
                    "    where",
                    "      JSaddleWarpRouteJavaScript :: JSaddleWarpRoute ()",
                    "      JSaddleWarpRouteWebSocket :: JSaddleWarpRoute ()",
                    "      JSaddleWarpRouteSync :: JSaddleWarpRoute [Text]"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-|\n\nTypes and functions for defining routes and 'Encoder's.\n\n-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE EmptyDataDecls #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.Route\n  ( -- * Primary Types\n    R\n  , PageName\n  , PathQuery\n  , Encoder\n  , EncoderImpl (..)\n  , EncoderFunc (..)\n\n  -- * Patterns, operators, and utilities\n  , (:.)\n  , (?/)\n  , hoistR\n  , pattern (:.)\n  , pattern (:/)\n  , unsafeEncoder\n  , checkEncoder\n  , unsafeMkEncoder\n  , encode\n  , decode\n  , tryDecode\n  , hoistCheck\n  , hoistParse\n  , mapSome\n  , rPrism\n  , _R\n  , renderObeliskRoute\n  , renderBackendRoute\n  , renderFrontendRoute\n  , byteStringsToPageName\n\n  -- * Collating Routes\n  , SegmentResult (..)\n  , pathComponentEncoder\n\n  , FullRoute (..)\n  , _FullRoute_Frontend\n  , _FullRoute_Backend\n  , mkFullRouteEncoder\n\n  , ObeliskRoute (..)\n  , _ObeliskRoute_App\n  , _ObeliskRoute_Resource\n  , ResourceRoute (..)\n\n  , JSaddleWarpRoute (..)\n  , jsaddleWarpRouteEncoder\n\n  , IndexOnlyRoute (..)\n  , indexOnlyRouteSegment\n  , indexOnlyRouteEncoder\n\n  -- * Provided Encoders\n  , enumEncoder\n  , enum1Encoder\n  , checkEnum1EncoderFunc\n  , unitEncoder\n  , pathOnlyEncoder\n  , addPathSegmentEncoder\n  , pathParamEncoder\n  , pathLiteralEncoder\n  , singletonListEncoder\n  , packTextEncoder\n  , unpackTextEncoder\n  , prefixTextEncoder\n  , unsafeTshowEncoder\n  , unsafeShowEncoder\n  , readShowEncoder\n  , someConstEncoder\n  , singlePathSegmentEncoder\n  , maybeEncoder\n  , maybeToEitherEncoder\n  , justEncoder\n  , nothingEncoder\n  , isoEncoder\n  , viewEncoder\n  , wrappedEncoder\n  , unwrappedEncoder\n  , listToNonEmptyEncoder\n  , prefixNonemptyTextEncoder\n  , joinPairTextEncoder\n  , toListMapEncoder\n  , shadowEncoder\n  , prismEncoder\n  , reviewEncoder\n  , obeliskRouteEncoder\n  , obeliskRouteSegment\n  , pageNameEncoder\n  , handleEncoder\n  , someSumEncoder\n  , Void1\n  , void1Encoder\n  , pathSegmentsTextEncoder\n  , queryParametersTextEncoder\n  , integralEncoder\n  , pathSegmentEncoder\n  , queryOnlyEncoder\n  , Decoder(..)\n  , dmapEncoder\n  , fieldMapEncoder\n  , pathFieldEncoder\n  , jsonEncoder\n  ) where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Applicative\nimport Control.Category (Category (..))\nimport qualified Control.Categorical.Functor as Cat\nimport Control.Categorical.Bifunctor\nimport Control.Category.Associative\nimport Control.Category.Monoidal\nimport Control.Category.Braided\nimport Control.Lens\n  ( Identity (..)\n  , (^.)\n  , (^?)\n  , _Just\n  , _Nothing\n  , Cons(..)\n  , from\n  , imap\n  , iso\n  , Iso'\n  , itraverse\n  , makePrisms\n  , Prism'\n  , prism'\n  , re\n  , review\n  , view\n  , Wrapped (..)\n  )\n\n\n\n\n\n\n\n\nimport Control.Monad.Except\nimport qualified Control.Monad.State.Strict as State\nimport Control.Monad.Writer (execWriter, tell)\nimport Data.Aeson (FromJSON, ToJSON)\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Dependent.Map (DMap)\nimport qualified Data.Dependent.Map as DMap\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Either.Validation (Validation (..))\nimport Data.Foldable\nimport Data.Functor (($>))\nimport Data.Functor.Sum\nimport Data.GADT.Compare\nimport Data.GADT.Compare.TH\nimport Data.GADT.Show\nimport Data.List.NonEmpty (NonEmpty (..))\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport Data.Monoid (Ap(..))\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.Semigroupoid\nimport Data.Some (Some(Some), mapSome)\nimport Data.Tabulation\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Text.Lens (IsText, packed, unpacked)\nimport Data.Type.Equality\nimport Data.Universe\nimport Data.Universe.Some\nimport Network.HTTP.Types.URI\nimport qualified Numeric.Lens\nimport Obelisk.Route.TH\nimport Text.Read (readMaybe)\n\n-- Design goals:\n-- No start-up time on the frontend (not yet met)\n-- Able to ensure that there aren't overlapping routes prior to deployment\n-- Easy to write common types of parsers\n--   Completeness checking\n\n-- Laws:\n-- We statically know that all valid Routes can be turned into valid URIs\n--   - This means we need to know whether there are any overlaps, e.g. with the static file namespace\n\n--TODO:\n-- Backend:\n--  Redirect the user to a canonical route\n--  Pre-render\n-- Frontend:\n--  Intercept links that can be kept within the app\n--  Fragments\n\n--------------------------------------------------------------------------------\n-- Subroutes/paths\n--------------------------------------------------------------------------------\n\n-- | This alias is used to wrap the type of a route GADT so that the type variable of the GADT is existentially quantified.\n--\n-- Given the following route type :\n--\n-- @\n--\n-- data MyRoutes a where\n--   MyRoutes_Main :: MyRoutes ()\n--   MyRoutes_A :: MyRoutes Text\n--   MyRoutes_B :: MyRoutes Int\n-- @\n--\n-- Using 'R' we're able to write type signatures without worrying about the 'a':\n--\n-- @\n-- myRoutesWidget :: RoutedT t (R MyRoutes) m ()\n-- @\n--\ntype R f = DSum f Identity --TODO: Better name\n\n-- | Convenience builder for an 'R' using 'Identity' for the functor.\npattern (:/) :: f a -> a -> R f\npattern a :/ b = a :=> Identity b\n{-# COMPLETE (:/) #-}\ninfixr 5 :/\n\n-- | Like '(:/)' but adds a 'Just' wrapper around the right-hand side.\n(?/) :: f (Maybe a) -> a -> R f\nr ?/ a = r :/ Just a\ninfixr 5 ?/\n\nhoistR :: (forall x. f x -> g x) -> R f -> R g\nhoistR f (x :=> Identity y) = f x :/ y\n\n--------------------------------------------------------------------------------\n-- Dealing with pairs (i.e. non-dependently-typed subroutes/paths)\n--------------------------------------------------------------------------------\n\ninfixr 5 :.\ntype (:.) = (,)\n\n\n\n{-# COMPLETE (:.) #-}\n\n\n\n\n\n\n\n\n\n\npattern (:.) :: a -> b -> a :. b\npattern a :. b = (a, b)\n\naddPathSegmentEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse (Text, PageName) PageName\naddPathSegmentEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(ph, (pt, q)) -> (ph : pt, q)\n  , _encoderImpl_decode = \\(p, q) -> case p of\n      [] -> throwError \"Expected a path segment\"\n      ph : pt -> pure (ph, (pt, q))\n  }\n\npathParamEncoder\n  :: forall check parse item rest.\n     ( Applicative check\n     , MonadError Text parse\n     )\n  => Encoder check parse item Text\n  -> Encoder check parse rest PageName\n  -> Encoder check parse (item :. rest) PageName\npathParamEncoder itemUnchecked restUnchecked = addPathSegmentEncoder . bimap itemUnchecked restUnchecked\n\npathLiteralEncoder\n  :: ( Applicative check\n     , MonadError Text parse\n     )\n  => Text\n  -> Encoder check parse a PageName\n  -> Encoder check parse a PageName\npathLiteralEncoder t e = addPathSegmentEncoder . bimap (unitEncoder t) e . coidl\n\n--------------------------------------------------------------------------------\n-- Encoder fundamentals\n--------------------------------------------------------------------------------\n\n-- | This is the type of route encoder/decoders. It is parameterised over two monads: Firstly, the monad\n-- used to check the validity of the encoder (i.e. that it is total), secondly the monad used for parsing\n-- during the decode phase. The following two parameters are respectively the type of decoded data, and the\n-- encoded type.\nnewtype Encoder check parse decoded encoded =\n  Encoder { unEncoder :: check (EncoderImpl parse decoded encoded) }\n\nunsafeEncoder :: check (EncoderImpl parse decoded encoded) -> Encoder check parse decoded encoded\nunsafeEncoder = Encoder\n\n-- | The internal type used to construct primitive 'Encoder' values.\n-- Law:\n-- forall p. _encoderImpl_decode ve . _encoderImpl_encode ve p == pure\n-- Note that the reverse may not be the case: when parsing, a route may be canonicalized, and erroneous routes may be collapsed to a single 404 route.  However, as a consequence of the law, encode . decode must be idempotent.\ndata EncoderImpl parse decoded encoded = EncoderImpl\n  { _encoderImpl_decode :: !(encoded -> parse decoded) -- Can fail; can lose information; must always succeed on outputs of `_encoderImpl_encode` and result in the original value\n  , _encoderImpl_encode :: !(decoded -> encoded) -- Must be injective\n  }\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', and its parser is total\n-- so that its parse monad is also 'Identity', it may be used to actually decode by applying this function.\ndecode :: Encoder Identity Identity decoded encoded -> encoded -> decoded\ndecode e x = runIdentity (tryDecode e x)\n\n-- | Once an 'Encoder' has been checked, so that its check monad has become 'Identity', even if the same is not true of the\n-- parse monad, we may still attempt to decode with it in its parse monad.\ntryDecode :: Encoder Identity parse decoded encoded -> encoded -> parse decoded\ntryDecode (Encoder (Identity impl)) = _encoderImpl_decode impl\n\n-- | Similar to 'decode', once an encoder has been checked so that its check monad is Identity, it\n-- can be used to actually encode by using this. Note that while there's no constraint on the parse monad here,\n-- one should usually be applying decode and encode to the same 'Encoder'\nencode :: Encoder Identity parse decoded encoded -> decoded -> encoded\nencode (Encoder (Identity impl)) = _encoderImpl_encode impl\n\n-- | This is a primitive used to build encoders which can't fail to check. It should not be used unless one is\n-- reasonably certain that the law given for 'EncoderImpl' above holds.\nunsafeMkEncoder :: (Applicative check) => EncoderImpl parse decoded encoded -> Encoder check parse decoded encoded\nunsafeMkEncoder impl = Encoder (pure impl)\n\n-- | Transform the check monad of an 'Encoder' by applying a natural transformation.\nhoistCheck :: (forall t. check t -> check' t) -> Encoder check parse a b -> Encoder check' parse a b\nhoistCheck f (Encoder x) = Encoder (f x)\n\n-- | Transform the parse monad of an 'Encoder' by applying a natural transformation.\nhoistParse :: (Functor check)\n  => (forall t. parse t -> parse' t) -> Encoder check parse a b -> Encoder check parse' a b\nhoistParse f (Encoder x) = Encoder (fmap (\\(EncoderImpl dec enc) -> EncoderImpl (f . dec) enc) x)\n\n-- | Check an 'Encoder', transforming it into one whose check monad is anything we want (usually Identity).\ncheckEncoder :: (Applicative check', Functor check)\n  => Encoder check parse decoded encoded\n  -> check (Encoder check' parse decoded encoded)\ncheckEncoder = fmap unsafeMkEncoder . unEncoder\n\ninstance (Applicative check, Monad parse) => Semigroupoid (Encoder check parse) where\n  Encoder f `o` Encoder g = Encoder $ liftA2 (.) f g\n\ninstance (Applicative check, Monad parse) => Category (Encoder check parse) where\n  id = Encoder $ pure id\n  (.) = o\n\ninstance Monad parse => Category (EncoderImpl parse) where\n  id = EncoderImpl\n    { _encoderImpl_decode = pure\n    , _encoderImpl_encode = id\n    }\n  f . g = EncoderImpl\n    { _encoderImpl_decode = _encoderImpl_decode g <=< _encoderImpl_decode f\n    , _encoderImpl_encode = _encoderImpl_encode f . _encoderImpl_encode g\n    }\n\ninstance Monad parse => PFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor (,) (EncoderImpl parse) (EncoderImpl parse) where\n  second = bimap id\ninstance Monad parse => Bifunctor (,) (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\(a, b) -> liftA2 (,) (_encoderImpl_decode f a) (_encoderImpl_decode g b)\n    }\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) (,) where\n  braid = viewEncoder (iso swap swap)\n\n\ninstance (Applicative check, Monad parse) => PFunctor (,) (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Applicative check, Monad parse) => QFunctor (,) (Encoder check parse) (Encoder check parse) where\n  second = bimap id\ninstance (Applicative check, Monad parse) => Bifunctor (,) (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Traversable f, Monad parse) => Cat.Functor f (EncoderImpl parse) (EncoderImpl parse) where\n  fmap ve = EncoderImpl\n    { _encoderImpl_encode = fmap $ _encoderImpl_encode ve\n    , _encoderImpl_decode = traverse $ _encoderImpl_decode ve\n    }\n\ninstance Monad parse => PFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  first f = bimap f id\ninstance Monad parse => QFunctor Either (EncoderImpl parse) (EncoderImpl parse) where\n  second = bimap id\ninstance Monad parse => Bifunctor Either (EncoderImpl parse) (EncoderImpl parse) (EncoderImpl parse) where\n  bimap f g = EncoderImpl\n    { _encoderImpl_encode = bimap (_encoderImpl_encode f) (_encoderImpl_encode g)\n    , _encoderImpl_decode = \\case\n      Left a -> Left <$> _encoderImpl_decode f a\n      Right b -> Right <$> _encoderImpl_decode g b\n    }\n\ninstance (Monad parse, Applicative check) => QFunctor Either (Encoder check parse) (Encoder check parse) where\n  second = bimap id\ninstance (Monad parse, Applicative check) => PFunctor Either (Encoder check parse) (Encoder check parse) where\n  first f = bimap f id\ninstance (Monad parse, Applicative check) => Bifunctor Either (Encoder check parse) (Encoder check parse) (Encoder check parse) where\n  bimap f g = Encoder $ liftA2 bimap (unEncoder f) (unEncoder g)\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) Either where\n  associate = viewEncoder (iso (associate @(->) @Either) disassociate)\n  disassociate = viewEncoder (iso disassociate associate)\n\ninstance (Monad parse, Applicative check) => Braided (Encoder check parse) Either where\n  braid = viewEncoder (iso swap swap)\n\n\n\ninstance (Traversable f, Monad check, Monad parse) => Cat.Functor f (Encoder check parse) (Encoder check parse) where\n  fmap e = Encoder $ do\n    ve <- unEncoder e\n    pure $ Cat.fmap ve\n\ninstance Monad parse => Associative (EncoderImpl parse) (,) where\n  associate = EncoderImpl\n    { _encoderImpl_encode = associate\n    , _encoderImpl_decode = pure . disassociate\n    }\n  disassociate = EncoderImpl\n    { _encoderImpl_encode = disassociate\n    , _encoderImpl_decode = pure . associate\n    }\n\ninstance Monad parse => Monoidal (EncoderImpl parse) (,) where\n  type Id (EncoderImpl parse) (,) = ()\n  idl = EncoderImpl\n    { _encoderImpl_encode = idl\n    , _encoderImpl_decode = pure . coidl\n    }\n  idr = EncoderImpl\n    { _encoderImpl_encode = idr\n    , _encoderImpl_decode = pure . coidr\n    }\n  coidl = EncoderImpl\n    { _encoderImpl_encode = coidl\n    , _encoderImpl_decode = pure . idl\n    }\n  coidr = EncoderImpl\n    { _encoderImpl_encode = coidr\n    , _encoderImpl_decode = pure . idr\n    }\n\ninstance (Applicative check, Monad parse) => Associative (Encoder check parse) (,) where\n  associate = Encoder $ pure associate\n  disassociate = Encoder $ pure disassociate\n\ninstance (Applicative check, Monad parse) => Monoidal (Encoder check parse) (,) where\n  type Id (Encoder check parse) (,) = ()\n  idl = Encoder $ pure idl\n  idr = Encoder $ pure idr\n  coidl = Encoder $ pure coidl\n  coidr = Encoder $ pure coidr\n\n--------------------------------------------------------------------------------\n-- Specific instances of encoders\n--------------------------------------------------------------------------------\n\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nviewEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nviewEncoder f = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = view f\n  , _encoderImpl_decode = pure . view (from f)\n  }\n\nwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse (Unwrapped a) a\nwrappedEncoder = viewEncoder $ from _Wrapped'\n\nunwrappedEncoder :: (Wrapped a, Applicative check, Applicative parse) => Encoder check parse a (Unwrapped a)\nunwrappedEncoder = viewEncoder _Wrapped'\n\nmaybeToEitherEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a) (Either () a)\nmaybeToEitherEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Nothing -> Left ()\n      Just a -> Right a\n  , _encoderImpl_decode = pure . \\case\n      Left _ -> Nothing\n      Right a -> Just a\n  }\n\nmaybeEncoder\n  :: ( MonadError Text check\n     , Show a\n     , Show b\n     , check ~ parse\n     )\n  => Encoder check parse () b\n  -> Encoder check parse a b\n  -> Encoder check parse (Maybe a) b\nmaybeEncoder f g = shadowEncoder f g . maybeToEitherEncoder\n\n-- | Encode a value by simply applying 'Just'\njustEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a (Maybe a)\njustEncoder = reviewEncoder _Just\n\n-- | Encode () to 'Nothing'.\nnothingEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse () (Maybe a)\nnothingEncoder = reviewEncoder _Nothing\n\nsomeConstEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Const a)) a\nsomeConstEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(Some (Const a)) -> a\n  , _encoderImpl_decode = pure . Some . Const\n  }\n\n-- | WARNING: This is only safe if the Show and Read instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeTshowEncoder :: (Show a, Read a, Applicative check, MonadError Text parse) => Encoder check parse a Text\nunsafeTshowEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = tshow\n  , _encoderImpl_decode = \\raw -> case readMaybe $ T.unpack raw of\n      Nothing -> throwError $ \"unsafeTshowEncoderImpl: couldn't decode \" <> tshow raw\n      Just parsed -> pure parsed\n  }\n\nnewtype EncoderFunc check parse p r = EncoderFunc { runEncoderImplFunc :: forall a. p a -> Encoder check parse a r }\n\nnewtype Flip f a b = Flip { unFlip :: f b a }\n\ncheckEnum1EncoderFunc\n  :: forall check check' parse p r.\n     ( Universe (Some p)\n     , GCompare p\n     , Monad check\n     , Applicative check'\n     )\n  => (forall a. p a -> Encoder check parse a r)\n  -> check (EncoderFunc check' parse p r)\ncheckEnum1EncoderFunc f = do\n  (encoderImpls :: DMap p (Flip (EncoderImpl parse) r)) <- DMap.fromList <$>\n    traverse (\\(Some p) -> (p :=>) . Flip <$> unEncoder (f p)) universe\n  pure $ EncoderFunc $ \\p -> unsafeMkEncoder . unFlip $\n    DMap.findWithDefault (error \"checkEnum1EncoderFunc: EncoderImpl not found (should be impossible)\") p encoderImpls\n\n-- | This type is used by pathComponentEncoder to allow the user to indicate how to treat\n-- various cases when encoding a dependent sum of type `(R p)`.\ndata SegmentResult check parse a =\n    PathEnd (Encoder check parse a (Map Text (Maybe Text)))\n    -- ^ Indicate that the path is finished, with an Encoder that translates the\n    -- corresponding value into query parameters\n  | PathSegment Text (Encoder check parse a PageName)\n    -- ^ Indicate that the key should be represented by an additional path segment with\n    -- the given 'Text', and give an Encoder for translating the corresponding value into\n    -- the remainder of the route.\n\n-- | Encode a dependent sum of type `(R p)` into a PageName (i.e. the path and query part of a URL) by using the\n-- supplied function to decide how to encode the constructors of p using the SegmentResult type. It is important\n-- that the number of values of type `(Some p)` be relatively small in order for checking to complete quickly.\npathComponentEncoder\n  :: forall check parse p.\n     ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse )\n  => (forall a. p a -> SegmentResult check parse a)\n  -> Encoder check parse (R p) PageName\npathComponentEncoder f = Encoder $ do\n  let extractEncoder = \\case\n        PathEnd e -> first (unitEncoder []) . coidl . e\n        PathSegment _ e -> e\n      extractPathSegment = \\case\n        PathEnd _ -> Nothing\n        PathSegment t _ -> Just t\n  EncoderFunc f' <- checkEnum1EncoderFunc (extractEncoder . f)\n  unEncoder (pathComponentEncoderImpl (enum1Encoder (extractPathSegment . f)) f')\n\npathComponentEncoderImpl :: forall check parse p. (Monad check, Monad parse)\n  => Encoder check parse (Some p) (Maybe Text)\n  -> (forall a. p a -> Encoder Identity parse a PageName)\n  -> Encoder check parse (R p) PageName\npathComponentEncoderImpl =\n  chainEncoder (lensEncoder (\\(_, b) a -> (a, b)) Prelude.fst consEncoder)\n\n--NOTE: Naming convention in this module is to always talk about things in the *encoding* direction, never in the *decoding* direction\n\nchainEncoder\n  :: forall check parse p r b.\n     ( Monad check\n     , Monad parse\n     )\n  => Encoder check parse (b, r) r\n  -> Encoder check parse (Some p) b\n  -> (forall a. p a -> Encoder Identity parse a r)\n  -> Encoder check parse (R p) r\nchainEncoder cons this rest = Encoder $ do\n  consValid <- unEncoder cons\n  thisValid <- unEncoder this\n  pure $ EncoderImpl\n    { _encoderImpl_decode = \\v -> do\n        (here, following) <- _encoderImpl_decode consValid v\n        _encoderImpl_decode thisValid here >>= \\case\n          Some r ->\n            (r :/) <$> _encoderImpl_decode (runIdentity . unEncoder $ rest r) following\n    , _encoderImpl_encode = \\(r :/ s) ->\n        _encoderImpl_encode consValid\n          ( _encoderImpl_encode thisValid $ Some r\n          , _encoderImpl_encode (runIdentity . unEncoder $ rest r) s)\n    }\n\n--TODO: Do this in terms of a lens instead\nlensEncoder :: (Applicative check, Monad parse)\n  => (b -> [a] -> b) -> (b -> [a]) -> Encoder check parse (c, [a]) [a] -> Encoder check parse (c, b) b\nlensEncoder set get g = Encoder $ do\n  gImpl <- unEncoder g\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(ma, b) -> set b $ _encoderImpl_encode gImpl (ma, get b)\n    , _encoderImpl_decode = \\b -> do\n        (ma, la) <- _encoderImpl_decode gImpl $ get b\n        pure (ma, set b la)\n    }\n\nconsEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Maybe a, [a]) [a] --TODO: Really shouldn't *always* have the [a], even in the Nothing case\nconsEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = \\(h, t) -> maybeToList h <> t\n  , _encoderImpl_decode = pure . \\case\n      [] -> (Nothing, [])\n      h:t -> (Just h, t)\n  }\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\nshadowEncoder\n  :: ( Universe a\n     , MonadError Text check\n     , Show a\n     , Show b\n     , Show c\n     , check ~ parse --TODO: Get rid of this\n     )\n  => Encoder check parse a c -- ^ Overlaps; should have a small number of possible routes\n  -> Encoder check parse b c -- ^ Gets overlapped\n  -> Encoder check parse (Either a b) c\nshadowEncoder f g = Encoder $ do\n  vf <- unEncoder f\n  vg <- unEncoder g\n  let gCanParse c = catchError (Just <$> _encoderImpl_decode vg c) (\\_ -> pure Nothing)\n  overlaps <- fmap catMaybes $ forM universe $ \\a -> do\n    let c = _encoderImpl_encode vf a\n    mb <- gCanParse c\n    pure $ fmap (\\b -> (a, b, c)) mb\n  case overlaps of\n    [] -> pure ()\n    _ -> throwError $ \"shadowEncoder: overlap detected: \" <> T.unlines\n      (flip fmap overlaps $ \\(a, b, c) -> \"first encoder encodes \" <> tshow a <> \" as \" <> tshow c <> \", which second encoder decodes as \" <> tshow b)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\case\n        Left a -> _encoderImpl_encode vf a\n        Right b -> _encoderImpl_encode vg b\n    , _encoderImpl_decode = \\c -> (Left <$> _encoderImpl_decode vf c) `catchError` \\_ -> Right <$> _encoderImpl_decode vg c\n    }\n\nenum1Encoder\n  :: ( Universe (Some p)\n     , GShow p\n     , GCompare p\n     , MonadError Text check\n     , MonadError Text parse\n     , Ord r\n     , Show r\n     )\n  => (forall a. p a -> r) -> Encoder check parse (Some p) r\nenum1Encoder f = enumEncoder $ \\(Some p) -> f p\n\n-- | Encode an enumerable, bounded type.  WARNING: Don't use this on types that\n-- have a large number of values - it will use a lot of memory.\nenumEncoder :: forall parse check p r. (Universe p, Show p, Ord p, Ord r, MonadError Text parse, MonadError Text check, Show r) => (p -> r) -> Encoder check parse p r\nenumEncoder f = Encoder $ do\n  let reversed = Map.fromListWith (<>) [ (f p, Set.singleton p) | p <- universe ]\n      checkSingleton k vs = case Set.toList vs of\n        [] -> error \"enumEncoder: empty reverse mapping; should be impossible\"\n        [e] -> Success e\n        _ -> Failure $ Map.singleton k vs\n      showRedundant :: r -> Set p -> [Text]\n      showRedundant k vs = (\"  \" <> tshow k <> \" can decode to any of:\")\n        : fmap ((\"    \"<>) . tshow) (Set.toList vs)\n  case itraverse checkSingleton reversed :: Validation (Map r (Set p)) (Map r p) of\n    Failure ambiguousEntries -> throwError $ T.unlines $\n      \"enumEncoder: ambiguous encodings detected:\" : concat (Map.elems $ imap showRedundant ambiguousEntries)\n    Success m -> pure $ EncoderImpl\n      { _encoderImpl_decode = \\r -> case Map.lookup r m of\n          Just a -> pure a\n          Nothing -> throwError $ \"enumEncoder: not recognized: \" <> tshow r --TODO: Report this as a better type\n      , _encoderImpl_encode = f\n      }\n\nunitEncoder :: (Applicative check, MonadError Text parse, Show r, Eq r) => r -> Encoder check parse () r\nunitEncoder expected = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\obtained ->\n      if obtained == expected\n      then pure ()\n      else throwError $ \"endEncoderImpl: expected \" <> tshow expected <> \", got \" <> tshow obtained\n  , _encoderImpl_encode = const expected\n  }\n\nsinglePathSegmentEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse Text PageName\nsinglePathSegmentEncoder = pathOnlyEncoder . singletonListEncoder\n\npathOnlyEncoderIgnoringQuery :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoderIgnoringQuery = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\(path, _query) -> pure path\n  , _encoderImpl_encode = \\path -> (path, mempty)\n  }\n\npathOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse [Text] PageName\npathOnlyEncoder = second (unitEncoder mempty) . coidr\n\nqueryOnlyEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Map Text (Maybe Text)) PageName\nqueryOnlyEncoder = first (unitEncoder []) . coidl\n\nsingletonListEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse a [a]\nsingletonListEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_decode = \\case\n      [a] -> pure a\n      l -> throwError $ \"singletonListEncoderImpl: expected one item, got \" <> tshow (length l)\n  , _encoderImpl_encode = (:[])\n  }\n\nsplitTextNonEmpty :: Text -> Text -> NonEmpty Text\nsplitTextNonEmpty separator v = case T.splitOn separator v of\n  [] -> error \"splitTextNonEmpty: Data.Text.splitOn should never return an empty list\"\n  h : t -> h :| t\n\n--TODO: To know this is reversible, we must know that the separator isn't included anywhere in the input text\npathSegmentsTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse (NonEmpty Text) Text\npathSegmentsTextEncoder = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = T.intercalate \"/\" . fmap (urlEncodeText False) . toList\n  , _encoderImpl_decode = pure . fmap (urlDecodeText False) . splitTextNonEmpty \"/\"\n  }\n\nqueryParametersTextEncoder :: (Applicative check, Applicative parse) => Encoder check parse [(Text, Maybe Text)] Text\nqueryParametersTextEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> \"\"\n      params -> T.intercalate \"&\" (fmap encodeParameter params)\n  , _encoderImpl_decode = pure . \\case\n      \"\" -> []\n      encoded ->\n        let h :| t = splitTextNonEmpty \"&\" encoded\n        in fmap decodeParameter $ h : t\n  }\n  where\n    encodeParameter (k, mv) = urlEncodeText True k <> case mv of\n      Nothing -> \"\"\n      Just v -> \"=\" <> urlEncodeText True v\n    decodeParameter t =\n      let (k, eqV) = T.breakOn \"=\" t\n          mv = T.stripPrefix \"=\" eqV\n      in (urlDecodeText True k, urlDecodeText True <$> mv)\n\nurlEncodeText :: Bool -> Text -> Text\nurlEncodeText q = T.decodeUtf8 . urlEncode q . T.encodeUtf8\n\nurlDecodeText :: Bool -> Text -> Text\nurlDecodeText q = T.decodeUtf8 . urlDecode q . T.encodeUtf8\n\nlistToNonEmptyEncoder :: (Applicative check, Applicative parse, Monoid a, Eq a) => Encoder check parse [a] (NonEmpty a)\nlistToNonEmptyEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      [] -> mempty :| []\n      h : t -> h :| t\n  , _encoderImpl_decode = \\(h :| t) -> pure $\n      if h == mempty\n      then []\n      else h : t\n  }\n\nprefixTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = mappend p\n  , _encoderImpl_decode = \\v -> case T.stripPrefix p v of\n      Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p <> \", got \" <> tshow (T.take (T.length p) v)\n      Just stripped -> pure stripped\n  }\n\nprefixNonemptyTextEncoder :: (Applicative check, MonadError Text parse) => Text -> Encoder check parse Text Text\nprefixNonemptyTextEncoder p = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      \"\" -> \"\"\n      v -> p <> v\n  , _encoderImpl_decode = \\case\n      \"\" -> pure \"\"\n      v -> case T.stripPrefix p v of\n        Nothing -> throwError $ \"prefixTextEncoder: wrong prefix; expected \" <> tshow p\n        Just stripped -> pure stripped\n  }\n\npackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse String text\npackTextEncoder = isoEncoder packed\n\nunpackTextEncoder :: (Applicative check, Applicative parse, IsText text) => Encoder check parse text String\nunpackTextEncoder = isoEncoder unpacked\n\ntoListMapEncoder :: (Applicative check, Applicative parse, Ord k) => Encoder check parse (Map k v) [(k, v)]\ntoListMapEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = Map.toList\n  , _encoderImpl_decode = pure . Map.fromList --TODO: Should we be stricter about repeated keys?\n  }\n\njoinPairTextEncoder :: (MonadError Text check, MonadError Text parse) => Text -> Encoder check parse (Text, Text) Text\njoinPairTextEncoder = Encoder . \\case\n  \"\" -> throwError \"joinPairTextEncoder: empty separator\"\n  separator -> pure $ EncoderImpl\n    { _encoderImpl_encode = \\(k, v) -> k <> separator <> v\n    , _encoderImpl_decode = \\r ->\n        let (kt, vt) = T.breakOn separator r\n        in case vt of\n          -- The separator was not found\n          \"\" -> throwError $ \"joinPairTextEncoder: separator not found; expected \" <> tshow separator\n          _ -> return (kt, T.drop (T.length separator) vt)\n    }\n\n-- This slight generalization of 'rPrism' happens to be enough to write all our\n-- prism combinators so far.\ndSumPrism\n  :: forall f f' g\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (DSum f g) (DSum f' g)\ndSumPrism p = prism'\n  (\\(f' :=> x) -> f' ^. re p :=> x)\n  (\\(f :=> x) -> (:=> x) <$> (f ^? p))\n\n-- already in obelisk\nrPrism\n  :: forall f f'\n  .  (forall a. Prism' (f a) (f' a))\n  -> Prism' (R f) (R f')\nrPrism = dSumPrism\n\ndSumPrism'\n  :: forall f g a\n  .  (forall b. Prism' (f b) (a :~: b))\n  -> Prism' (DSum f g) (g a)\ndSumPrism' p = dSumPrism p . iso (\\(Refl :=> b) -> b) (Refl :=>)\n\ndSumGEqPrism\n  :: GEq f\n  => f a\n  -> Prism' (DSum f g) (g a)\ndSumGEqPrism variant = dSumPrism' $ prism' (\\Refl -> variant) (geq variant)\n\n-- | Given a 'tag :: f a', make a prism for 'R f'. This generalizes the usual\n-- prisms for a sum type (the ones that 'mkPrisms' would make), just as 'R'\n-- generalized a usual sum type.\n--\n-- [This is given the '_R' name of the \"cannonical\" prism not because it is the\n-- most general, but because it seems the most useful for routes, and 'R' itself\n-- trades generality for route-specificity.]\n_R\n  :: GEq f\n  => f a\n  -> Prism' (R f) a\n_R variant = dSumGEqPrism variant . iso runIdentity Identity\n\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'reviewEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @reviewEncoder (f . g) = reviewEncoder g . reviewEncoder f@.\nreviewEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nreviewEncoder p = unsafeMkEncoder $ EncoderImpl\n  { _encoderImpl_encode = review p\n  , _encoderImpl_decode = \\r -> case r ^? p of\n      Just a -> pure a\n      Nothing -> throwError \"reviewEncoder: value is not present in the prism\"\n  }\n\n-- | A URL path and query string, in which trailing slashes don't matter in the path\n-- and duplicate query parameters are not allowed. A final goal of encoders using this library\n-- will frequently be to produce this.\ntype PageName = ([Text], Map Text (Maybe Text))\n\n-- | A path (separated by slashes), and a query string.\ntype PathQuery = (String, String)\n\n-- | Encode a PageName into a path and query string.\npageNameEncoder :: (Applicative check, MonadError Text parse) => Encoder check parse PageName PathQuery\npageNameEncoder = bimap\n  (unpackTextEncoder . prefixTextEncoder \"/\" . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n  (unpackTextEncoder . prefixNonemptyTextEncoder \"?\" . queryParametersTextEncoder . toListMapEncoder)\n\n-- | Handle an error in parsing, for example, in order to redirect to a 404 page.\nhandleEncoder\n  :: (Functor check)\n  => (e -> a)\n  -> Encoder check (Either e) a b\n  -> Encoder check Identity a b\nhandleEncoder recover e = Encoder $ do\n  i <- unEncoder e\n  return $ i\n    { _encoderImpl_decode = \\a -> pure $ case _encoderImpl_decode i a of\n      Right r -> r\n      Left err -> recover err\n    }\n\n--------------------------------------------------------------------------------\n-- Actual obelisk route info\n--------------------------------------------------------------------------------\n\n-- | The typical full route type comprising all of an Obelisk application's routes.\n-- Parameterised by the top level GADTs that define backend and frontend routes, respectively.\ndata FullRoute :: (* -> *) -> (* -> *) -> * -> * where\n  FullRoute_Backend :: br a -> FullRoute br fr a\n  FullRoute_Frontend :: ObeliskRoute fr a -> FullRoute br fr a\n\ninstance (GShow br, GShow fr) => GShow (FullRoute br fr) where\n  gshowsPrec p = \\case\n    FullRoute_Backend x -> showParen (p > 10) (showString \"FullRoute_Backend \" . gshowsPrec 11 x)\n    FullRoute_Frontend x -> showParen (p > 10) (showString \"FullRoute_Frontend \" . gshowsPrec 11 x)\n\ninstance (GEq br, GEq fr) => GEq (FullRoute br fr) where\n  geq (FullRoute_Backend x) (FullRoute_Backend y) = geq x y\n  geq (FullRoute_Frontend x) (FullRoute_Frontend y) = geq x y\n  geq _ _ = Nothing\n\ninstance (GCompare br, GCompare fr) => GCompare (FullRoute br fr) where\n  gcompare (FullRoute_Backend _) (FullRoute_Frontend _) = GLT\n  gcompare (FullRoute_Frontend _) (FullRoute_Backend _) = GGT\n  gcompare (FullRoute_Backend x) (FullRoute_Backend y) = gcompare x y\n  gcompare (FullRoute_Frontend x) (FullRoute_Frontend y) = gcompare x y\n\ninstance  (UniverseSome br, UniverseSome fr) => UniverseSome (FullRoute br fr) where\n  universeSome = [Some (FullRoute_Backend x) | Some x <- universeSome]\n              ++ [Some (FullRoute_Frontend x) | Some x <- universeSome]\n\n-- | Build the typical top level application route encoder from a route for handling 404's,\n-- and segment encoders for backend and frontend routes.\nmkFullRouteEncoder\n  :: (GCompare br, GCompare fr, GShow br, GShow fr, UniverseSome br, UniverseSome fr)\n  => R (FullRoute br fr) -- ^ 404 handler\n  -> (forall a. br a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single backend route segment\n  -> (forall a. fr a -> SegmentResult (Either Text) (Either Text) a) -- ^ How to encode a single frontend route segment\n  -> Encoder (Either Text) Identity (R (FullRoute br fr)) PageName\nmkFullRouteEncoder missing backendSegment frontendSegment = handleEncoder (const missing) $\n  pathComponentEncoder $ \\case\n    FullRoute_Backend backendRoute -> backendSegment backendRoute\n    FullRoute_Frontend obeliskRoute -> obeliskRouteSegment obeliskRoute frontendSegment\n\n-- | A type which can represent Obelisk-specific resource routes, in addition to application specific routes which serve your\n-- frontend.\ndata ObeliskRoute :: (* -> *) -> * -> * where\n  -- We need to have the `f a` as an argument here, because otherwise we have no way to specifically check for overlap between us and the given encoder\n  ObeliskRoute_App :: f a -> ObeliskRoute f a\n  ObeliskRoute_Resource :: ResourceRoute a -> ObeliskRoute f a\n\ninstance UniverseSome f => UniverseSome (ObeliskRoute f) where\n  universeSome = ((\\(Some x) -> Some (ObeliskRoute_App x)) <$> universe) ++ ((\\(Some x) -> Some (ObeliskRoute_Resource x)) <$> (universe @(Some ResourceRoute)))\n\ninstance GEq f => GEq (ObeliskRoute f) where\n  geq (ObeliskRoute_App x) (ObeliskRoute_App y) = geq x y\n  geq (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = geq x y\n  geq _ _ = Nothing\n\ninstance GCompare f => GCompare (ObeliskRoute f) where\n  gcompare (ObeliskRoute_App x) (ObeliskRoute_App y) = gcompare x y\n  gcompare (ObeliskRoute_Resource x) (ObeliskRoute_Resource y) = gcompare x y\n  gcompare (ObeliskRoute_App _) (ObeliskRoute_Resource _) = GLT\n  gcompare (ObeliskRoute_Resource _) (ObeliskRoute_App _) = GGT\n\n-- | A type representing the various resource routes served by Obelisk. These can in principle map to any physical routes you want,\n-- but sane defaults are provided by 'resourceRouteSegment'\ndata ResourceRoute :: * -> * where\n  ResourceRoute_Static :: ResourceRoute [Text] -- This [Text] represents the *path in our static files directory*, not necessarily the URL path that the asset gets served at (although that will often be \"/static/this/text/thing\")\n  ResourceRoute_Ghcjs :: ResourceRoute [Text]\n  ResourceRoute_JSaddleWarp :: ResourceRoute (R JSaddleWarpRoute)\n  ResourceRoute_Version :: ResourceRoute ()\n\n-- | If there are no additional backend routes in your app (i.e. ObeliskRoute gives you all the routes you need),\n-- this constructs a suitable 'Encoder' to use for encoding routes to 'PageName's. If you do have additional backend routes,\n-- you'll want to use 'pathComponentEncoder' yourself, applied to a function that will likely use obeliskRouteSegment in order to\n-- handle the ObeliskRoute case (i.e. Obelisk resource routes and app frontend routes).\nobeliskRouteEncoder :: forall check parse appRoute.\n     ( Universe (Some (ObeliskRoute appRoute))\n     , GCompare (ObeliskRoute appRoute)\n     , GShow appRoute\n     , MonadError Text check\n     , check ~ parse --TODO: Get rid of this\n     )\n  => (forall a. appRoute a -> SegmentResult check parse a)\n  -> Encoder check parse (R (ObeliskRoute appRoute)) PageName\nobeliskRouteEncoder appRouteSegment = pathComponentEncoder $ \\r ->\n  obeliskRouteSegment r appRouteSegment\n\n-- | From a function which explains how app-specific frontend routes translate into segments, produce a function which does the\n-- same for ObeliskRoute. This uses the given function for the 'ObeliskRoute_App' case, and 'resourceRouteSegment' for the\n-- 'ObeliskRoute_Resource' case.\nobeliskRouteSegment :: forall check parse appRoute a.\n     (MonadError Text check, MonadError Text parse)\n  => ObeliskRoute appRoute a\n  -> (forall b. appRoute b -> SegmentResult check parse b)\n  -> SegmentResult check parse a\nobeliskRouteSegment r appRouteSegment = case r of\n  ObeliskRoute_App appRoute -> appRouteSegment appRoute\n  ObeliskRoute_Resource resourceRoute -> resourceRouteSegment resourceRoute\n\n-- | A function which gives a sane default for how to encode Obelisk resource routes. It's given in this form, because it will\n-- be combined with other such segment encoders before 'pathComponentEncoder' turns it into a proper 'Encoder'.\nresourceRouteSegment :: (MonadError Text check, MonadError Text parse) => ResourceRoute a -> SegmentResult check parse a\nresourceRouteSegment = \\case\n  ResourceRoute_Static -> PathSegment \"static\" pathOnlyEncoderIgnoringQuery\n  ResourceRoute_Ghcjs -> PathSegment \"ghcjs\" pathOnlyEncoder\n  ResourceRoute_JSaddleWarp -> PathSegment \"jsaddle\" jsaddleWarpRouteEncoder\n  ResourceRoute_Version -> PathSegment \"version\" $ unitEncoder mempty\n\ndata JSaddleWarpRoute :: * -> * where\n  JSaddleWarpRoute_JavaScript :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_WebSocket :: JSaddleWarpRoute ()\n  JSaddleWarpRoute_Sync :: JSaddleWarpRoute [Text]\n\njsaddleWarpRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R JSaddleWarpRoute) PageName\njsaddleWarpRouteEncoder = pathComponentEncoder $ \\case\n  JSaddleWarpRoute_JavaScript -> PathSegment \"jsaddle.js\" $ unitEncoder mempty\n  JSaddleWarpRoute_WebSocket ->  PathEnd $ unitEncoder mempty\n  JSaddleWarpRoute_Sync -> PathSegment \"sync\" pathOnlyEncoder\n\ninstance GShow appRoute => GShow (ObeliskRoute appRoute) where\n  gshowsPrec prec = \\case\n    ObeliskRoute_App appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_App \" . gshowsPrec 11 appRoute\n    ObeliskRoute_Resource appRoute -> showParen (prec > 10) $\n      showString \"ObeliskRoute_Resource \" . gshowsPrec 11 appRoute\n\ndata IndexOnlyRoute :: * -> * where\n  IndexOnlyRoute :: IndexOnlyRoute ()\n\nindexOnlyRouteSegment :: (Applicative check, MonadError Text parse) => IndexOnlyRoute a -> SegmentResult check parse a\nindexOnlyRouteSegment = \\case\n  IndexOnlyRoute -> PathEnd $ unitEncoder mempty\n\nindexOnlyRouteEncoder :: (MonadError Text check, MonadError Text parse) => Encoder check parse (R IndexOnlyRoute) PageName\nindexOnlyRouteEncoder = pathComponentEncoder indexOnlyRouteSegment\n\nsomeSumEncoder :: (Applicative check, Applicative parse) => Encoder check parse (Some (Sum a b)) (Either (Some a) (Some b))\nsomeSumEncoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\(Some t) -> case t of\n      InL l -> Left $ Some l\n      InR r -> Right $ Some r\n  , _encoderImpl_decode = pure . \\case\n      Left (Some l) -> Some (InL l)\n      Right (Some r) -> Some (InR r)\n  }\n\ndata Void1 :: * -> * where {}\n\ninstance UniverseSome Void1 where\n  universeSome = []\n\nvoid1Encoder :: (Applicative check, MonadError Text parse) => Encoder check parse (Some Void1) a\nvoid1Encoder = Encoder $ pure $ EncoderImpl\n  { _encoderImpl_encode = \\case\n      Some f -> case f of {}\n  , _encoderImpl_decode = \\_ -> throwError \"void1Encoder: can't decode anything\"\n  }\n\ninstance GShow Void1 where\n  gshowsPrec _ = \\case {}\n\n-- | Given a backend route and a checked route encoder, render the route (path\n-- and query string). See 'checkEncoder' for how to produce a checked encoder.\nrenderBackendRoute\n  :: forall br a.\n     Encoder Identity Identity (R (FullRoute br a)) PageName\n  -> R br\n  -> Text\nrenderBackendRoute enc = renderObeliskRoute enc . hoistR FullRoute_Backend\n\n-- | Renders a frontend route with the supplied checked encoder\nrenderFrontendRoute\n  :: forall a fr.\n     Encoder Identity Identity (R (FullRoute a fr)) PageName\n  -> R fr\n  -> Text\nrenderFrontendRoute enc = renderObeliskRoute enc . hoistR (FullRoute_Frontend . ObeliskRoute_App)\n\n-- | Renders a route of the form typically found in an Obelisk project\nrenderObeliskRoute\n  :: forall a b.\n     Encoder Identity Identity (R (FullRoute a b)) PageName\n  -> R (FullRoute a b)\n  -> Text\nrenderObeliskRoute e r =\n  let enc :: Encoder Identity (Either Text) (R (FullRoute a b)) PathQuery\n      enc = (pageNameEncoder . hoistParse (pure . runIdentity) e)\n  in (T.pack . uncurry (<>)) $ encode enc r\n\n-- | As per the 'unsafeTshowEncoder' but does not use the 'Text' type.\n--\n-- WARNING: Just like 'unsafeTshowEncoder' this is only safe if the Show and Read\n-- instances for 'a' are inverses of each other\n--\n-- Instances must be able to satisfy the following property for this 'Encoder' to be safe:\n--\n-- @\n-- forall a. reads (show a) === [(a, \"\")]\n-- @\n--\nunsafeShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nunsafeShowEncoder = singlePathSegmentEncoder . unsafeTshowEncoder\n\n-- | This 'Encoder' does not properly indicate that its use may be unsafe and is being renamed to 'unsafeShowEncoder'\nreadShowEncoder :: (MonadError Text parse, Read a, Show a, Applicative check) => Encoder check parse a PageName\nreadShowEncoder = unsafeShowEncoder\n{-# DEPRECATED readShowEncoder \"This function has been renamed to 'unsafeShowEncoder'. 'readShowEncoder' will be removed in a future release\" #-}\n\nintegralEncoder :: (MonadError Text parse, Applicative check, Integral a) => Encoder check parse a Integer\nintegralEncoder = reviewEncoder Numeric.Lens.integral\n\npathSegmentEncoder :: (MonadError Text parse, Applicative check, Cons as as a a) =>\n  Encoder check parse (a, (as, b)) (as, b)\npathSegmentEncoder = first (reviewEncoder _Cons) . disassociate\n\nnewtype Decoder check parse b a = Decoder { toEncoder :: Encoder check parse a b }\n\ndmapEncoder :: forall check parse k k' v.\n   ( Monad check\n   , MonadError Text parse\n   , Universe (Some k')\n   , Ord k\n   , GCompare k'\n   , GShow k'\n   )\n  => Encoder check parse (Some k') k\n  -> (forall v'. k' v' -> Encoder check parse v' v)\n  -> Encoder check parse (DMap k' Identity) (Map k v)\ndmapEncoder keyEncoder' valueEncoderFor = unsafeEncoder $ do\n  keyEncoder :: Encoder Identity parse (Some k') k <- checkEncoder keyEncoder'\n  valueDecoders :: DMap k' (Decoder Identity parse v) <- fmap DMap.fromList . forM universe $ \\(Some (k' :: k' t)) -> do\n    ve :: Encoder Identity parse t v <- checkEncoder (valueEncoderFor k')\n    return $ (k' :: k' t) :=> (Decoder ve :: Decoder Identity parse v t)\n  let keyError k = \"dmapEncoder: key `\" <> k <> \"' was missing from the Universe instance for its type.\"\n  return $ EncoderImpl\n    { _encoderImpl_encode = \\dm -> Map.fromList $ do\n        ((k' :: k' t) :=> Identity v') <- DMap.toList dm\n        return ( encode keyEncoder (Some k')\n               , encode (toEncoder (DMap.findWithDefault (error . keyError $ gshow k') k' valueDecoders)) v'\n               )\n    , _encoderImpl_decode = \\m -> fmap DMap.fromList . forM (Map.toList m) $ \\(k,v) -> do\n          tryDecode keyEncoder k >>= \\case\n            Some (k' :: k' t) -> case DMap.lookup k' valueDecoders of\n              Nothing -> throwError . T.pack . keyError $ gshow k'\n              Just (Decoder e) -> do\n                v' <- tryDecode e v\n                return (k' :=> Identity v')\n    }\n\nfieldMapEncoder :: forall check parse r.\n   ( Applicative check\n   , MonadError Text parse\n   , HasFields r\n   , Universe (Some (Field r))\n   , GShow (Field r)\n   , GCompare (Field r)\n   )\n  => Encoder check parse r (DMap (Field r) Identity)\nfieldMapEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\r -> DMap.fromList [ f :=> Identity (indexField r f) | Some f <- universe ]\n    , _encoderImpl_decode = \\dm -> tabulateFieldsA $ \\f -> do\n      case DMap.lookup f dm of\n        Nothing -> throwError $ \"fieldMapEncoder: Couldn't find key for `\" <> T.pack (gshow f) <> \"' in DMap.\"\n        Just (Identity v) -> return v\n    }\n\npathFieldEncoder :: forall a p check parse . (HasFields a, Monad check, MonadError Text parse, GCompare (Field a)) => (forall x. Field a x -> Encoder check parse x p) -> Encoder check parse (a, [p]) [p]\npathFieldEncoder fieldEncoder = unsafeEncoder $ do\n  fieldEncoderPureMap :: DMap.DMap (Field a) (Decoder Identity parse p) <- getAp $ getConst $ tabulateFieldsA @a $ \\f -> Const (Ap $ fmap (DMap.singleton f . Decoder) $ (checkEncoder @Identity) $ fieldEncoder f)\n  let fieldEncoderPure :: forall x. Field a x -> Encoder Identity parse x p\n      fieldEncoderPure f = toEncoder (DMap.findWithDefault (error \"bad\") f fieldEncoderPureMap)\n  pure $ EncoderImpl\n    { _encoderImpl_encode = \\(x, rest) -> execWriter $ do\n      _ <- traverseWithField (\\f x_i -> tell (pure $ encode (fieldEncoderPure f) x_i) $> x_i) x\n      tell rest\n    , _encoderImpl_decode = State.runStateT $ tabulateFieldsA $ \\f -> State.get >>= \\case\n      [] -> throwError $ T.pack \"not enough path components\"\n      p:ps -> do\n        State.put ps\n        lift $ tryDecode (fieldEncoderPure f) p\n    }\n\n-- | Use ToJSON/FromJSON to encode to Text. The correctness of this encoder is dependent on the encoding being injective and round-tripping correctly.\njsonEncoder :: forall check parse r.\n  ( ToJSON r\n  , FromJSON r\n  , Applicative check\n  , MonadError Text parse\n  )\n  => Encoder check parse r Text\njsonEncoder = unsafeEncoder $ do\n  pure $ EncoderImpl\n    { _encoderImpl_encode = T.decodeUtf8 . BSL.toStrict . Aeson.encode\n    , _encoderImpl_decode = \\t -> case Aeson.eitherDecodeStrict $ T.encodeUtf8 t of\n        Left err -> throwError (\"jsonEncoder: \" <> T.pack err)\n        Right x -> return x\n    }\n\n-- Useful for app server integration.\n-- p must not start with slashes\nbyteStringsToPageName :: BS.ByteString -> BS.ByteString -> PageName\nbyteStringsToPageName p q =\n  let pageNameEncoder' :: Encoder Identity Identity PageName (String, String)\n      pageNameEncoder' = bimap\n        (unpackTextEncoder . pathSegmentsTextEncoder . listToNonEmptyEncoder)\n        (unpackTextEncoder . queryParametersTextEncoder . toListMapEncoder)\n  in decode pageNameEncoder' (T.unpack (T.decodeUtf8 p), T.unpack (T.decodeUtf8 q))\n\n--TODO: decodeURIComponent as appropriate\n\n\n{-# DEPRECATED isoEncoder \"Instead of 'isoEncoder f', use 'viewEncoder f'\" #-}\n-- | Given a valid 'Iso' from lens, construct an 'Encoder'\nisoEncoder :: (Applicative check, Applicative parse) => Iso' a b -> Encoder check parse a b\nisoEncoder = viewEncoder\n\n{-# DEPRECATED prismEncoder \"Instead of 'prismEncoder f', use 'reviewEncoder f'\" #-}\n-- | An encoder that only works on the items available via the prism. An error will be thrown in the parse monad\n-- if the prism doesn't match.\n--\n-- Note that a 'Prism' from @a@ to @b@ will produce an 'Encoder' from @b@ to @a@\n-- (i.e. 'prismEncoder' is a contravariant functor from the category of prisms to the category of encoders),\n-- just like 'review' produces a function @b -> a@. This is because 'Prism's extract values, in a way that might\n-- fail, in their forward direction and inject values, in a way that cannot fail, in their reverse direction;\n-- whereas 'Encoder's encode, which cannot fail, in their forward direction, and decode, which can fail, in their\n-- reverse direction. In short @prismEncoder (f . g) = prismEncoder g . prismEncoder f@.\nprismEncoder :: (Applicative check, MonadError Text parse) => Prism' b a -> Encoder check parse a b\nprismEncoder = reviewEncoder\n\n\nconcat <$> mapM deriveRouteComponent\n  [ ''ResourceRoute\n  , ''JSaddleWarpRoute\n  , ''IndexOnlyRoute\n  ]\n\nmakePrisms ''ObeliskRoute\nmakePrisms ''FullRoute\nderiveGEq ''Void1\nderiveGCompare ''Void1\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 19,
              "code_quality_score": 96.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 19,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 1 1: module Obelisk.Route.TH has 13 lines of code \nInfo:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 10 1: type signature for deriveRouteComponent has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 10 1: type signature for deriveRouteComponent has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/TH.hs\" 11 1: function deriveRouteComponent has branching depth of 0 \n"
              },
              "original_code": "module Obelisk.Route.TH (deriveRouteComponent) where\n\nimport Data.Constraint.Extras.TH\nimport Data.GADT.Show.TH\nimport Data.GADT.Compare.TH\nimport Data.Universe.Some.TH\nimport Language.Haskell.TH\n\n-- | Derive all the typeclasses needed for a RouteComponent type.  The argument should be the name of a type of kind @k -> *@\nderiveRouteComponent :: Name -> Q [Dec]\nderiveRouteComponent x = concat <$> traverse ($ x)\n  [ deriveGShow\n  , deriveGEq\n  , deriveGCompare\n  , deriveUniverseSome\n  , deriveArgDict\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/TH.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Obelisk.Route.TH (deriveRouteComponent) where\n\nimport Data.Constraint.Extras.TH\nimport Data.GADT.Show.TH\nimport Data.GADT.Compare.TH\nimport Data.Universe.Some.TH\nimport Language.Haskell.TH\n\n-- | Derive all the typeclasses needed for a RouteComponent type.  The argument should be the name of a type of kind @k -> *@\nderiveRouteComponent :: Name -> Q [Dec]\nderiveRouteComponent x = concat <$> traverse ($ x)\n  [ deriveGShow\n  , deriveGEq\n  , deriveGCompare\n  , deriveUniverseSome\n  , deriveArgDict\n  ]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/route/src/Obelisk/Route/Frontend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 10,
                "average": 3,
                "sum": 204
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 24,
              "lines_of_code": 671,
              "homplexity_lines_of_code": 572,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 10,
                  "average": 3,
                  "sum": 204
                },
                "homplexity_loc": 572,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 10,\n        \"average\": 2.92,\n        \"sum\": 204\n    },\n    \"homplexity_loc\": 572,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Obelisk.Route.Frontend\n  ( module Obelisk.Route\n  , pattern (:~)\n  , Routed\n  , RoutedT\n  , runRoutedT\n  , askRoute\n  , withRoutedT\n  , mapRoutedT\n  , subRoute\n  , subRoute_\n  , subPairRoute\n  , subPairRoute_\n  , maybeRoute\n  , maybeRoute_\n  , maybeRouted\n  , eitherRoute\n  , eitherRoute_\n  , eitherRouted\n  , runRouteViewT\n  , SetRouteT(..)\n  , SetRoute(..)\n  , runSetRouteT\n  , mapSetRouteT\n  , RouteToUrl(..)\n  , RouteToUrlT(..)\n  , runRouteToUrlT\n  , mapRouteToUrlT\n  , routeLink\n  , routeLinkAttr\n  , routeLinkDynAttr\n  , dynRouteLink\n  , adaptedUriPath\n  , setAdaptedUriPath\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad ((<=<))\n#endif\n#endif\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category (Category (..), (.))\nimport Control.Category.Cartesian ((&&&))\nimport Control.Lens hiding (Bifunctor, bimap, universe, element)\nimport Control.Monad.Fix\nimport Control.Monad.Morph\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Control\nimport Data.Coerce\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Functor.Compose\nimport Data.Functor.Misc\nimport Data.GADT.Compare\nimport qualified Data.List as L\nimport Data.Map as Map (Map, lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Type.Coercion\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.Window as Window\nimport Language.Javascript.JSaddle (MonadJSM, jsNull, liftJSM) --TODO: Get rid of this - other platforms can also be routed\nimport Network.URI\nimport Reflex.Class\nimport Reflex.Dom.Builder.Class\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Unsafe.Coerce\n\nimport Obelisk.Configs\nimport Obelisk.Route\n\ninfixr 5 :~\npattern (:~) :: Reflex t => f a -> Dynamic t a -> DSum f (Compose (Dynamic t) Identity)\npattern a :~ b <- a :=> (coerceDynamic . getCompose -> b)\n\nclass Routed t r m | m -> t r where\n  askRoute :: m (Dynamic t r)\n  default askRoute :: (Monad m', MonadTrans f, Routed t r m', m ~ f m') => m (Dynamic t r)\n  askRoute = lift askRoute\n\ninstance Monad m => Routed t r (RoutedT t r m) where\n  askRoute = RoutedT ask\n\ninstance (Monad m, Routed t r m) => Routed t r (ReaderT r' m)\n\nnewtype RoutedT t r m a = RoutedT { unRoutedT :: ReaderT (Dynamic t r) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadFix\n    , MonadTrans\n    , MFunctor\n    , NotReady t\n    , MonadHold t\n    , MonadSample t\n    , PostBuild t\n    , TriggerEvent t\n    , MonadIO\n    , MonadReflexCreateTrigger t\n    , HasDocument\n    , DomRenderHook t\n    )\n\ninstance MonadReader r' m => MonadReader r' (RoutedT t r m) where\n  ask = lift ask\n  local = mapRoutedT . local\n\ninstance (Prerender t m, Monad m) => Prerender t (RoutedT t r m) where\n  type Client (RoutedT t r m) = RoutedT t r (Client m)\n  prerender server client = RoutedT $ do\n    r <- ask\n    lift $ prerender (runRoutedT server r) (runRoutedT client r)\n\ninstance Requester t m => Requester t (RoutedT t r m) where\n  type Request (RoutedT t r m) = Request m\n  type Response (RoutedT t r m) = Response m\n  requesting = RoutedT . requesting\n  requesting_ = RoutedT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RoutedT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RoutedT t r m) where\n  type Performable (RoutedT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RoutedT t r m) where\n  type Ref (RoutedT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\nderiving instance EventWriter t w m => EventWriter t w (RoutedT t r m)\n\ninstance MonadTransControl (RoutedT t r) where\n  type StT (RoutedT t r) a = StT (ReaderT (Dynamic t r)) a\n  liftWith = defaultLiftWith RoutedT unRoutedT\n  restoreT = defaultRestoreT RoutedT\n\ninstance PrimMonad m => PrimMonad (RoutedT t r m ) where\n  type PrimState (RoutedT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RoutedT t r m) where\n  type DomBuilderSpace (RoutedT t r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RoutedT t r m) where\n  runWithReplace a0 a' = RoutedT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RoutedT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RoutedT t r m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (QueryT t q m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (QueryT t q m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (EventWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (EventWriterT t w m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (DynamicWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (DynamicWriterT t w m)\n\nrunRoutedT :: RoutedT t r m a -> Dynamic t r -> m a\nrunRoutedT = runReaderT . unRoutedT\n\nmapRoutedT :: (m a -> n b) -> RoutedT t r m a -> RoutedT t r n b\nmapRoutedT f = RoutedT . mapReaderT f . unRoutedT\n\nwithRoutedT :: (Dynamic t r -> Dynamic t r') -> RoutedT t r' m a -> RoutedT t r m a\nwithRoutedT f = RoutedT . withReaderT f . unRoutedT\n\nsubRoute_ :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m ()) -> RoutedT t (R r) m ()\nsubRoute_ f = factorRouted $ strictDynWidget_ $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute_ :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m ()) -> RoutedT t (a, b) m ()\nsubPairRoute_ f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute_ (\\(Const2 a) -> f a)\n\nsubRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m b) -> RoutedT t (R r) m (Dynamic t b)\nsubRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m c) -> RoutedT t (a, b) m (Dynamic t c)\nsubPairRoute f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute (\\(Const2 a) -> f a)\n\nmaybeRoute_ :: (MonadFix m, MonadHold t m, Adjustable t m) => m () -> RoutedT t r m () -> RoutedT t (Maybe r) m ()\nmaybeRoute_ n j = maybeRouted $ strictDynWidget_ $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\nmaybeRoute :: (MonadFix m, MonadHold t m, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m (Dynamic t a)\nmaybeRoute n j = maybeRouted $ strictDynWidget $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\n{-\nmaybeRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m a\nmaybeRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n-}\n\neitherRoute_\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m ()\n  -> RoutedT t r m ()\n  -> RoutedT t (Either l r) m ()\neitherRoute_ l r = eitherRouted $ strictDynWidget_ $ either (runRoutedT l) (runRoutedT r)\n\neitherRoute\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m a\n  -> RoutedT t r m a\n  -> RoutedT t (Either l r) m (Dynamic t a)\neitherRoute l r = eitherRouted $ strictDynWidget $ either (runRoutedT l) (runRoutedT r)\n\ndsumValueCoercion :: Coercion f g -> Coercion (DSum k f) (DSum k g)\ndsumValueCoercion Coercion = Coercion\n\ndynamicIdentityCoercion :: Coercion (Compose (Dynamic t) Identity) (Dynamic t)\ndynamicIdentityCoercion = unsafeCoerce (Coercion :: Coercion (Identity ()) ()) --TODO: Is it possible to prove this?\n\nfactorRouted :: (Reflex t, MonadFix m, MonadHold t m, GEq f) => RoutedT t (DSum f (Dynamic t)) m a -> RoutedT t (DSum f Identity) m a\nfactorRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- factorDyn d\n  runRoutedT r $ coerceWith (dynamicCoercion $ dsumValueCoercion dynamicIdentityCoercion) d'\n\nmaybeRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Maybe (Dynamic t a)) m b -> RoutedT t (Maybe a) m b\nmaybeRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- maybeDyn d\n  runRoutedT r d'\n\neitherRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Either (Dynamic t a) (Dynamic t b)) m c -> RoutedT t (Either a b) m c\neitherRouted r = RoutedT $ ReaderT $ runRoutedT r <=< eitherDyn\n\n-- | WARNING: The input 'Dynamic' must be fully constructed when this is run\nstrictDynWidget :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m b) -> RoutedT t a m (Dynamic t b)\nstrictDynWidget f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (result0, result') <- runWithReplace (f r0) $ f <$> updated r\n  holdDyn result0 result'\n\nstrictDynWidget_ :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m ()) -> RoutedT t a m ()\nstrictDynWidget_ f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (_, _) <- runWithReplace (f r0) $ f <$> updated r\n  pure ()\n\nnewtype SetRouteT t r m a = SetRouteT { unSetRouteT :: EventWriterT t (Endo r) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, MonadIO, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\ninstance (MonadFix m, MonadHold t m, DomBuilder t m) => DomBuilder t (SetRouteT t r m) where\n  type DomBuilderSpace (SetRouteT t r m) = DomBuilderSpace m\n  element t cfg child = SetRouteT $ element t cfg $ unSetRouteT child\n  inputElement = lift . inputElement\n  textAreaElement = lift . textAreaElement\n  selectElement cfg child = SetRouteT $ selectElement cfg $ unSetRouteT child\n\nmapSetRouteT :: (forall x. m x -> n x) -> SetRouteT t r m a -> SetRouteT t r n a\nmapSetRouteT f (SetRouteT x) = SetRouteT (mapEventWriterT f x)\n\nrunSetRouteT :: (Reflex t, Monad m) => SetRouteT t r m a -> m (a, Event t (Endo r))\nrunSetRouteT = runEventWriterT . unSetRouteT\n\nclass Reflex t => SetRoute t r m | m -> t r where\n  setRoute :: Event t r -> m ()\n  modifyRoute :: Event t (r -> r) -> m ()\n  default modifyRoute :: (Monad m', MonadTrans f, SetRoute t r m', m ~ f m') => Event t (r -> r) -> m ()\n  modifyRoute = lift . modifyRoute\n\n  setRoute = modifyRoute . fmap const\n\ninstance (Reflex t, Monad m) => SetRoute t r (SetRouteT t r m) where\n  modifyRoute = SetRouteT . tellEvent . fmap Endo\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RoutedT t r' m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (ReaderT r' m)\n\ninstance (PerformEvent t m, Prerender t m, Monad m, Reflex t) => Prerender t (SetRouteT t r m) where\n  type Client (SetRouteT t r m) = SetRouteT t r (Client m)\n  prerender server client = do\n    d <- lift $ prerender (runSetRouteT server) (runSetRouteT client)\n    let (a, r) = splitDynPure d\n    -- Must be prompt here\n    SetRouteT . tellEvent $ switchPromptlyDyn r\n    pure a\n\ninstance Requester t m => Requester t (SetRouteT t r m) where\n  type Request (SetRouteT t r m) = Request m\n  type Response (SetRouteT t r m) = Response m\n  requesting = SetRouteT . requesting\n  requesting_ = SetRouteT . requesting_\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RequesterT t req rsp m)\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (SetRouteT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (SetRouteT t r m) where\n  type Performable (SetRouteT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (SetRouteT t r m) where\n  type Ref (SetRouteT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance PrimMonad m => PrimMonad (SetRouteT t r m ) where\n  type PrimState (SetRouteT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance HasConfigs m => HasConfigs (SetRouteT t r m)\n\ninstance (MonadHold t m, Adjustable t m) => Adjustable t (SetRouteT t r m) where\n  runWithReplace a0 a' = SetRouteT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (SetRouteT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\nclass RouteToUrl r m | m -> r where\n  askRouteToUrl :: m (r -> Text)\n  default askRouteToUrl :: (Monad m', MonadTrans f, RouteToUrl r m', m ~ f m') => m (r -> Text)\n  askRouteToUrl = lift askRouteToUrl\n\nnewtype RouteToUrlT r m a = RouteToUrlT { unRouteToUrlT :: ReaderT (r -> Text) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadIO, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\nrunRouteToUrlT\n  :: RouteToUrlT r m a\n  -> (r -> Text)\n  -> m a\nrunRouteToUrlT a = runReaderT (unRouteToUrlT a)\n\nmapRouteToUrlT :: (forall x. m x -> n x) -> RouteToUrlT r m a -> RouteToUrlT r n a\nmapRouteToUrlT f (RouteToUrlT m) = RouteToUrlT $ mapReaderT f m\n\ninstance Monad m => RouteToUrl r (RouteToUrlT r m) where\n  askRouteToUrl = RouteToUrlT ask\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (SetRouteT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RoutedT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (ReaderT r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RequesterT t req rsp m)\n\ninstance (Prerender t m, Monad m) => Prerender t (RouteToUrlT r m) where\n  type Client (RouteToUrlT r m) = RouteToUrlT r (Client m)\n  prerender server client = do\n    r <- RouteToUrlT ask\n    lift $ prerender (runRouteToUrlT server r) (runRouteToUrlT client r)\n\ninstance Requester t m => Requester t (RouteToUrlT r m) where\n  type Request (RouteToUrlT r m) = Request m\n  type Response (RouteToUrlT r m) = Response m\n  requesting = RouteToUrlT . requesting\n  requesting_ = RouteToUrlT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RouteToUrlT r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RouteToUrlT r m) where\n  type Performable (RouteToUrlT r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RouteToUrlT r m) where\n  type Ref (RouteToUrlT r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance MonadTransControl (RouteToUrlT r) where\n  type StT (RouteToUrlT r) a = StT (ReaderT (r -> Text)) a\n  liftWith = defaultLiftWith RouteToUrlT unRouteToUrlT\n  restoreT = defaultRestoreT RouteToUrlT\n\ninstance PrimMonad m => PrimMonad (RouteToUrlT r m ) where\n  type PrimState (RouteToUrlT r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RouteToUrlT r m) where\n  type DomBuilderSpace (RouteToUrlT r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RouteToUrlT r m) where\n  runWithReplace a0 a' = RouteToUrlT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RouteToUrlT r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RouteToUrlT t m)\n\nrunRouteViewT\n  :: forall t m r a.\n     ( TriggerEvent t m\n     , PerformEvent t m\n     , MonadHold t m\n     , MonadJSM m\n     , MonadJSM (Performable m)\n     , MonadFix m\n     )\n  => Encoder Identity Identity r PageName\n  --TODO: Get rid of the switchover and useHash arguments\n  -- useHash can probably be baked into the encoder\n  -> Event t () -- ^ Switchover event, nothing is done until this event fires. Used to prevent incorrect DOM expectations at hydration switchover time\n  -> Bool\n  -> RoutedT t r (SetRouteT t r (RouteToUrlT r m)) a\n  -> m a\nrunRouteViewT routeEncoder switchover useHash a = do\n  rec historyState <- manageHistory' switchover $ HistoryCommand_PushState <$> setState\n      let theEncoder = pageNameEncoder . hoistParse (pure . runIdentity) routeEncoder\n          -- NB: The can only fail if the uriPath doesn't begin with a '/' or if the uriQuery\n          -- is nonempty, but begins with a character that isn't '?'. Since we don't expect\n          -- this ever to happen, we'll just handle it by failing completely with 'error'.\n          route :: Dynamic t r\n          route = fmap (errorLeft . tryDecode theEncoder . (adaptedUriPath useHash &&& uriQuery) . _historyItem_uri) historyState\n            where\n              errorLeft (Left e) = error (T.unpack e)\n              errorLeft (Right x) = x\n      (result, changeState) <- runRouteToUrlT (runSetRouteT $ runRoutedT a route) $ (\\(p, q) -> T.pack $ p <> q) . encode theEncoder\n      let f (currentHistoryState, oldRoute) change =\n            let newRoute = appEndo change oldRoute\n                (newPath, newQuery) = encode theEncoder newRoute\n            in HistoryStateUpdate\n               { _historyStateUpdate_state = DOM.SerializedScriptValue jsNull\n                 -- We always provide \"\" as the title.  On Firefox, Chrome, and\n                 -- Edge, this parameter does nothing.  On Safari, \"\" has the\n                 -- same behavior as other browsers (as far as I can tell), but\n                 -- anything else sets the title for the back button list item\n                 -- the *next* time pushState is called, unless the page title\n                 -- is changed in the interim.  Since the Safari functionality\n                 -- is near-pointless and also confusing, I'm not going to even\n                 -- bother exposing it; if there ends up being a real use case,\n                 -- we can change this function later to accommodate.\n                 -- See: https://github.com/whatwg/html/issues/2174\n               , _historyStateUpdate_title = \"\"\n               , _historyStateUpdate_uri = Just $ setAdaptedUriPath useHash newPath $ (_historyItem_uri currentHistoryState)\n                 { uriQuery = newQuery\n                 }\n               }\n          setState = attachWith f ((,) <$> current historyState <*> current route) changeState\n  return result\n\n-- | A link widget that, when clicked, sets the route to the provided route. In non-javascript\n-- contexts, this widget falls back to using @href@s to control navigation\nrouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLink r w = do\n  (e, a) <- routeLinkImpl mempty r w\n  scrollToTop e\n  return a\n\n-- | Like 'routeLink', but takes additional attributes as argument.\n--\nrouteLinkAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Map AttributeName Text -- ^ Additional attributes\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLinkAttr attrs r w = do\n  (e, a) <- routeLinkImpl attrs r w\n  let\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n  when (not targetBlank) $ scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLink'. Does not scroll to the top of the page on clicks.\nrouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Map AttributeName Text\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\nrouteLinkImpl attrs r w = do\n  enc <- askRouteToUrl\n  let\n    -- If targetBlank == True, the link will be opened in another page. In that\n    -- case, we don't prevent the default behaviour, and we don't need to\n    -- setRoute.\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n    cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_initialAttributes .~ (\"href\" =: enc r <> attrs)\n        & (if targetBlank\n           then id\n           else elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault))\n  (e, a) <- element \"a\" cfg w\n  when (not targetBlank) $ setRoute $ r <$ domEvent Click e\n  return (domEvent Click e, a)\n\nscrollToTop :: forall m t. (Prerender t m, Monad m) => Event t () -> m ()\nscrollToTop e = prerender_ blank $ performEvent_ $ ffor e $ \\_ -> liftJSM $ DOM.currentWindow >>= \\case\n  Nothing -> pure ()\n  Just win -> Window.scrollTo win 0 0\n\n-- | Like 'routeLinkDynAttr' but without custom attributes.\ndynRouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\ndynRouteLink r w = do\n  (e, a) <- dynRouteLinkImpl r w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'dynRouteLink'. Does not scroll to the top of the page on clicks.\ndynRouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\ndynRouteLinkImpl dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ (\"href\" =:) . enc <$> dr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- | An @a@-tag link widget that, when clicked, sets the route to current value of the\n-- provided dynamic route. In non-JavaScript contexts the value of the dynamic post\n-- build is used so the link still works like 'routeLink'.\nrouteLinkDynAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     , Prerender t m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m a\nrouteLinkDynAttr dAttr dr w = do\n  (e, a) <- routeLinkDynAttrImpl dAttr dr w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLinkDynAttr'. Does not scroll to the top of the page on clicks.\nrouteLinkDynAttrImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m (Event t (), a)\nrouteLinkDynAttrImpl dAttr dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ zipDynWith (<>) ((\"href\" =:) . enc <$> dr) dAttr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- On ios due to sandboxing when loading the page from a file adapt the\n-- path to be based on the hash.\n\nadaptedUriPath :: Bool -> URI -> String\nadaptedUriPath = \\case\n  True -> hashToPath . uriFragment\n  False -> uriPath\n\nsetAdaptedUriPath :: Bool -> String -> URI -> URI\nsetAdaptedUriPath useHash s u = case useHash of\n  True -> u { uriFragment = pathToHash s }\n  False -> u { uriPath = s }\n\npathToHash :: String -> String\npathToHash = ('#' :) . fromMaybe \"\" . L.stripPrefix \"/\"\n\nhashToPath :: String -> String\nhashToPath = ('/' :) . fromMaybe \"\" . L.stripPrefix \"#\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs:(664,33)-(666,28)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case useHash of",
                    "    True -> u {uriFragment = pathToHash s}",
                    "    False -> u {uriPath = s}"
                  ],
                  "perhaps_block": [
                    "  if useHash then u {uriFragment = pathToHash s} else u {uriPath = s}"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Obelisk.Route.Frontend\n  ( module Obelisk.Route\n  , pattern (:~)\n  , Routed\n  , RoutedT\n  , runRoutedT\n  , askRoute\n  , withRoutedT\n  , mapRoutedT\n  , subRoute\n  , subRoute_\n  , subPairRoute\n  , subPairRoute_\n  , maybeRoute\n  , maybeRoute_\n  , maybeRouted\n  , eitherRoute\n  , eitherRoute_\n  , eitherRouted\n  , runRouteViewT\n  , SetRouteT(..)\n  , SetRoute(..)\n  , runSetRouteT\n  , mapSetRouteT\n  , RouteToUrl(..)\n  , RouteToUrlT(..)\n  , runRouteToUrlT\n  , mapRouteToUrlT\n  , routeLink\n  , routeLinkAttr\n  , routeLinkDynAttr\n  , dynRouteLink\n  , adaptedUriPath\n  , setAdaptedUriPath\n  ) where\n\n\n\n\n\n\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category (Category (..), (.))\nimport Control.Category.Cartesian ((&&&))\nimport Control.Lens hiding (Bifunctor, bimap, universe, element)\nimport Control.Monad.Fix\nimport Control.Monad.Morph\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Control\nimport Data.Coerce\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Functor.Compose\nimport Data.Functor.Misc\nimport Data.GADT.Compare\nimport qualified Data.List as L\nimport Data.Map as Map (Map, lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Type.Coercion\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.Window as Window\nimport Language.Javascript.JSaddle (MonadJSM, jsNull, liftJSM) --TODO: Get rid of this - other platforms can also be routed\nimport Network.URI\nimport Reflex.Class\nimport Reflex.Dom.Builder.Class\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Unsafe.Coerce\n\nimport Obelisk.Configs\nimport Obelisk.Route\n\ninfixr 5 :~\npattern (:~) :: Reflex t => f a -> Dynamic t a -> DSum f (Compose (Dynamic t) Identity)\npattern a :~ b <- a :=> (coerceDynamic . getCompose -> b)\n\nclass Routed t r m | m -> t r where\n  askRoute :: m (Dynamic t r)\n  default askRoute :: (Monad m', MonadTrans f, Routed t r m', m ~ f m') => m (Dynamic t r)\n  askRoute = lift askRoute\n\ninstance Monad m => Routed t r (RoutedT t r m) where\n  askRoute = RoutedT ask\n\ninstance (Monad m, Routed t r m) => Routed t r (ReaderT r' m)\n\nnewtype RoutedT t r m a = RoutedT { unRoutedT :: ReaderT (Dynamic t r) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadFix\n    , MonadTrans\n    , MFunctor\n    , NotReady t\n    , MonadHold t\n    , MonadSample t\n    , PostBuild t\n    , TriggerEvent t\n    , MonadIO\n    , MonadReflexCreateTrigger t\n    , HasDocument\n    , DomRenderHook t\n    )\n\ninstance MonadReader r' m => MonadReader r' (RoutedT t r m) where\n  ask = lift ask\n  local = mapRoutedT . local\n\ninstance (Prerender t m, Monad m) => Prerender t (RoutedT t r m) where\n  type Client (RoutedT t r m) = RoutedT t r (Client m)\n  prerender server client = RoutedT $ do\n    r <- ask\n    lift $ prerender (runRoutedT server r) (runRoutedT client r)\n\ninstance Requester t m => Requester t (RoutedT t r m) where\n  type Request (RoutedT t r m) = Request m\n  type Response (RoutedT t r m) = Response m\n  requesting = RoutedT . requesting\n  requesting_ = RoutedT . requesting_\n\n\nderiving instance MonadJSM m => MonadJSM (RoutedT t r m)\n\n\ninstance PerformEvent t m => PerformEvent t (RoutedT t r m) where\n  type Performable (RoutedT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RoutedT t r m) where\n  type Ref (RoutedT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\nderiving instance EventWriter t w m => EventWriter t w (RoutedT t r m)\n\ninstance MonadTransControl (RoutedT t r) where\n  type StT (RoutedT t r) a = StT (ReaderT (Dynamic t r)) a\n  liftWith = defaultLiftWith RoutedT unRoutedT\n  restoreT = defaultRestoreT RoutedT\n\ninstance PrimMonad m => PrimMonad (RoutedT t r m ) where\n  type PrimState (RoutedT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RoutedT t r m) where\n  type DomBuilderSpace (RoutedT t r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RoutedT t r m) where\n  runWithReplace a0 a' = RoutedT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RoutedT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RoutedT t r m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (QueryT t q m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (QueryT t q m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (EventWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (EventWriterT t w m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (DynamicWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (DynamicWriterT t w m)\n\nrunRoutedT :: RoutedT t r m a -> Dynamic t r -> m a\nrunRoutedT = runReaderT . unRoutedT\n\nmapRoutedT :: (m a -> n b) -> RoutedT t r m a -> RoutedT t r n b\nmapRoutedT f = RoutedT . mapReaderT f . unRoutedT\n\nwithRoutedT :: (Dynamic t r -> Dynamic t r') -> RoutedT t r' m a -> RoutedT t r m a\nwithRoutedT f = RoutedT . withReaderT f . unRoutedT\n\nsubRoute_ :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m ()) -> RoutedT t (R r) m ()\nsubRoute_ f = factorRouted $ strictDynWidget_ $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute_ :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m ()) -> RoutedT t (a, b) m ()\nsubPairRoute_ f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute_ (\\(Const2 a) -> f a)\n\nsubRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m b) -> RoutedT t (R r) m (Dynamic t b)\nsubRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m c) -> RoutedT t (a, b) m (Dynamic t c)\nsubPairRoute f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute (\\(Const2 a) -> f a)\n\nmaybeRoute_ :: (MonadFix m, MonadHold t m, Adjustable t m) => m () -> RoutedT t r m () -> RoutedT t (Maybe r) m ()\nmaybeRoute_ n j = maybeRouted $ strictDynWidget_ $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\nmaybeRoute :: (MonadFix m, MonadHold t m, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m (Dynamic t a)\nmaybeRoute n j = maybeRouted $ strictDynWidget $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\n{-\nmaybeRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m a\nmaybeRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n-}\n\neitherRoute_\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m ()\n  -> RoutedT t r m ()\n  -> RoutedT t (Either l r) m ()\neitherRoute_ l r = eitherRouted $ strictDynWidget_ $ either (runRoutedT l) (runRoutedT r)\n\neitherRoute\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m a\n  -> RoutedT t r m a\n  -> RoutedT t (Either l r) m (Dynamic t a)\neitherRoute l r = eitherRouted $ strictDynWidget $ either (runRoutedT l) (runRoutedT r)\n\ndsumValueCoercion :: Coercion f g -> Coercion (DSum k f) (DSum k g)\ndsumValueCoercion Coercion = Coercion\n\ndynamicIdentityCoercion :: Coercion (Compose (Dynamic t) Identity) (Dynamic t)\ndynamicIdentityCoercion = unsafeCoerce (Coercion :: Coercion (Identity ()) ()) --TODO: Is it possible to prove this?\n\nfactorRouted :: (Reflex t, MonadFix m, MonadHold t m, GEq f) => RoutedT t (DSum f (Dynamic t)) m a -> RoutedT t (DSum f Identity) m a\nfactorRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- factorDyn d\n  runRoutedT r $ coerceWith (dynamicCoercion $ dsumValueCoercion dynamicIdentityCoercion) d'\n\nmaybeRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Maybe (Dynamic t a)) m b -> RoutedT t (Maybe a) m b\nmaybeRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- maybeDyn d\n  runRoutedT r d'\n\neitherRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Either (Dynamic t a) (Dynamic t b)) m c -> RoutedT t (Either a b) m c\neitherRouted r = RoutedT $ ReaderT $ runRoutedT r <=< eitherDyn\n\n-- | WARNING: The input 'Dynamic' must be fully constructed when this is run\nstrictDynWidget :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m b) -> RoutedT t a m (Dynamic t b)\nstrictDynWidget f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (result0, result') <- runWithReplace (f r0) $ f <$> updated r\n  holdDyn result0 result'\n\nstrictDynWidget_ :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m ()) -> RoutedT t a m ()\nstrictDynWidget_ f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (_, _) <- runWithReplace (f r0) $ f <$> updated r\n  pure ()\n\nnewtype SetRouteT t r m a = SetRouteT { unSetRouteT :: EventWriterT t (Endo r) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, MonadIO, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\ninstance (MonadFix m, MonadHold t m, DomBuilder t m) => DomBuilder t (SetRouteT t r m) where\n  type DomBuilderSpace (SetRouteT t r m) = DomBuilderSpace m\n  element t cfg child = SetRouteT $ element t cfg $ unSetRouteT child\n  inputElement = lift . inputElement\n  textAreaElement = lift . textAreaElement\n  selectElement cfg child = SetRouteT $ selectElement cfg $ unSetRouteT child\n\nmapSetRouteT :: (forall x. m x -> n x) -> SetRouteT t r m a -> SetRouteT t r n a\nmapSetRouteT f (SetRouteT x) = SetRouteT (mapEventWriterT f x)\n\nrunSetRouteT :: (Reflex t, Monad m) => SetRouteT t r m a -> m (a, Event t (Endo r))\nrunSetRouteT = runEventWriterT . unSetRouteT\n\nclass Reflex t => SetRoute t r m | m -> t r where\n  setRoute :: Event t r -> m ()\n  modifyRoute :: Event t (r -> r) -> m ()\n  default modifyRoute :: (Monad m', MonadTrans f, SetRoute t r m', m ~ f m') => Event t (r -> r) -> m ()\n  modifyRoute = lift . modifyRoute\n\n  setRoute = modifyRoute . fmap const\n\ninstance (Reflex t, Monad m) => SetRoute t r (SetRouteT t r m) where\n  modifyRoute = SetRouteT . tellEvent . fmap Endo\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RoutedT t r' m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (ReaderT r' m)\n\ninstance (PerformEvent t m, Prerender t m, Monad m, Reflex t) => Prerender t (SetRouteT t r m) where\n  type Client (SetRouteT t r m) = SetRouteT t r (Client m)\n  prerender server client = do\n    d <- lift $ prerender (runSetRouteT server) (runSetRouteT client)\n    let (a, r) = splitDynPure d\n    -- Must be prompt here\n    SetRouteT . tellEvent $ switchPromptlyDyn r\n    pure a\n\ninstance Requester t m => Requester t (SetRouteT t r m) where\n  type Request (SetRouteT t r m) = Request m\n  type Response (SetRouteT t r m) = Response m\n  requesting = SetRouteT . requesting\n  requesting_ = SetRouteT . requesting_\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RequesterT t req rsp m)\n\n\nderiving instance MonadJSM m => MonadJSM (SetRouteT t r m)\n\n\ninstance PerformEvent t m => PerformEvent t (SetRouteT t r m) where\n  type Performable (SetRouteT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (SetRouteT t r m) where\n  type Ref (SetRouteT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance PrimMonad m => PrimMonad (SetRouteT t r m ) where\n  type PrimState (SetRouteT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance HasConfigs m => HasConfigs (SetRouteT t r m)\n\ninstance (MonadHold t m, Adjustable t m) => Adjustable t (SetRouteT t r m) where\n  runWithReplace a0 a' = SetRouteT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (SetRouteT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\nclass RouteToUrl r m | m -> r where\n  askRouteToUrl :: m (r -> Text)\n  default askRouteToUrl :: (Monad m', MonadTrans f, RouteToUrl r m', m ~ f m') => m (r -> Text)\n  askRouteToUrl = lift askRouteToUrl\n\nnewtype RouteToUrlT r m a = RouteToUrlT { unRouteToUrlT :: ReaderT (r -> Text) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadIO, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\nrunRouteToUrlT\n  :: RouteToUrlT r m a\n  -> (r -> Text)\n  -> m a\nrunRouteToUrlT a = runReaderT (unRouteToUrlT a)\n\nmapRouteToUrlT :: (forall x. m x -> n x) -> RouteToUrlT r m a -> RouteToUrlT r n a\nmapRouteToUrlT f (RouteToUrlT m) = RouteToUrlT $ mapReaderT f m\n\ninstance Monad m => RouteToUrl r (RouteToUrlT r m) where\n  askRouteToUrl = RouteToUrlT ask\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (SetRouteT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RoutedT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (ReaderT r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RequesterT t req rsp m)\n\ninstance (Prerender t m, Monad m) => Prerender t (RouteToUrlT r m) where\n  type Client (RouteToUrlT r m) = RouteToUrlT r (Client m)\n  prerender server client = do\n    r <- RouteToUrlT ask\n    lift $ prerender (runRouteToUrlT server r) (runRouteToUrlT client r)\n\ninstance Requester t m => Requester t (RouteToUrlT r m) where\n  type Request (RouteToUrlT r m) = Request m\n  type Response (RouteToUrlT r m) = Response m\n  requesting = RouteToUrlT . requesting\n  requesting_ = RouteToUrlT . requesting_\n\n\nderiving instance MonadJSM m => MonadJSM (RouteToUrlT r m)\n\n\ninstance PerformEvent t m => PerformEvent t (RouteToUrlT r m) where\n  type Performable (RouteToUrlT r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RouteToUrlT r m) where\n  type Ref (RouteToUrlT r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance MonadTransControl (RouteToUrlT r) where\n  type StT (RouteToUrlT r) a = StT (ReaderT (r -> Text)) a\n  liftWith = defaultLiftWith RouteToUrlT unRouteToUrlT\n  restoreT = defaultRestoreT RouteToUrlT\n\ninstance PrimMonad m => PrimMonad (RouteToUrlT r m ) where\n  type PrimState (RouteToUrlT r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RouteToUrlT r m) where\n  type DomBuilderSpace (RouteToUrlT r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RouteToUrlT r m) where\n  runWithReplace a0 a' = RouteToUrlT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RouteToUrlT r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RouteToUrlT t m)\n\nrunRouteViewT\n  :: forall t m r a.\n     ( TriggerEvent t m\n     , PerformEvent t m\n     , MonadHold t m\n     , MonadJSM m\n     , MonadJSM (Performable m)\n     , MonadFix m\n     )\n  => Encoder Identity Identity r PageName\n  --TODO: Get rid of the switchover and useHash arguments\n  -- useHash can probably be baked into the encoder\n  -> Event t () -- ^ Switchover event, nothing is done until this event fires. Used to prevent incorrect DOM expectations at hydration switchover time\n  -> Bool\n  -> RoutedT t r (SetRouteT t r (RouteToUrlT r m)) a\n  -> m a\nrunRouteViewT routeEncoder switchover useHash a = do\n  rec historyState <- manageHistory' switchover $ HistoryCommand_PushState <$> setState\n      let theEncoder = pageNameEncoder . hoistParse (pure . runIdentity) routeEncoder\n          -- NB: The can only fail if the uriPath doesn't begin with a '/' or if the uriQuery\n          -- is nonempty, but begins with a character that isn't '?'. Since we don't expect\n          -- this ever to happen, we'll just handle it by failing completely with 'error'.\n          route :: Dynamic t r\n          route = fmap (errorLeft . tryDecode theEncoder . (adaptedUriPath useHash &&& uriQuery) . _historyItem_uri) historyState\n            where\n              errorLeft (Left e) = error (T.unpack e)\n              errorLeft (Right x) = x\n      (result, changeState) <- runRouteToUrlT (runSetRouteT $ runRoutedT a route) $ (\\(p, q) -> T.pack $ p <> q) . encode theEncoder\n      let f (currentHistoryState, oldRoute) change =\n            let newRoute = appEndo change oldRoute\n                (newPath, newQuery) = encode theEncoder newRoute\n            in HistoryStateUpdate\n               { _historyStateUpdate_state = DOM.SerializedScriptValue jsNull\n                 -- We always provide \"\" as the title.  On Firefox, Chrome, and\n                 -- Edge, this parameter does nothing.  On Safari, \"\" has the\n                 -- same behavior as other browsers (as far as I can tell), but\n                 -- anything else sets the title for the back button list item\n                 -- the *next* time pushState is called, unless the page title\n                 -- is changed in the interim.  Since the Safari functionality\n                 -- is near-pointless and also confusing, I'm not going to even\n                 -- bother exposing it; if there ends up being a real use case,\n                 -- we can change this function later to accommodate.\n                 -- See: https://github.com/whatwg/html/issues/2174\n               , _historyStateUpdate_title = \"\"\n               , _historyStateUpdate_uri = Just $ setAdaptedUriPath useHash newPath $ (_historyItem_uri currentHistoryState)\n                 { uriQuery = newQuery\n                 }\n               }\n          setState = attachWith f ((,) <$> current historyState <*> current route) changeState\n  return result\n\n-- | A link widget that, when clicked, sets the route to the provided route. In non-javascript\n-- contexts, this widget falls back to using @href@s to control navigation\nrouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLink r w = do\n  (e, a) <- routeLinkImpl mempty r w\n  scrollToTop e\n  return a\n\n-- | Like 'routeLink', but takes additional attributes as argument.\n--\nrouteLinkAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Map AttributeName Text -- ^ Additional attributes\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLinkAttr attrs r w = do\n  (e, a) <- routeLinkImpl attrs r w\n  let\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n  unless targetBlank $ scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLink'. Does not scroll to the top of the page on clicks.\nrouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Map AttributeName Text\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\nrouteLinkImpl attrs r w = do\n  enc <- askRouteToUrl\n  let\n    -- If targetBlank == True, the link will be opened in another page. In that\n    -- case, we don't prevent the default behaviour, and we don't need to\n    -- setRoute.\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n    cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_initialAttributes .~ (\"href\" =: enc r <> attrs)\n        & (if targetBlank\n           then id\n           else elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault))\n  (e, a) <- element \"a\" cfg w\n  unless targetBlank $ setRoute $ r <$ domEvent Click e\n  return (domEvent Click e, a)\n\nscrollToTop :: forall m t. (Prerender t m, Monad m) => Event t () -> m ()\nscrollToTop e = prerender_ blank $ performEvent_ $ ffor e $ \\_ -> liftJSM $ DOM.currentWindow >>= \\case\n  Nothing -> pure ()\n  Just win -> Window.scrollTo win 0 0\n\n-- | Like 'routeLinkDynAttr' but without custom attributes.\ndynRouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\ndynRouteLink r w = do\n  (e, a) <- dynRouteLinkImpl r w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'dynRouteLink'. Does not scroll to the top of the page on clicks.\ndynRouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\ndynRouteLinkImpl dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ (\"href\" =:) . enc <$> dr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- | An @a@-tag link widget that, when clicked, sets the route to current value of the\n-- provided dynamic route. In non-JavaScript contexts the value of the dynamic post\n-- build is used so the link still works like 'routeLink'.\nrouteLinkDynAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     , Prerender t m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m a\nrouteLinkDynAttr dAttr dr w = do\n  (e, a) <- routeLinkDynAttrImpl dAttr dr w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLinkDynAttr'. Does not scroll to the top of the page on clicks.\nrouteLinkDynAttrImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m (Event t (), a)\nrouteLinkDynAttrImpl dAttr dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ zipDynWith (<>) ((\"href\" =:) . enc <$> dr) dAttr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- On ios due to sandboxing when loading the page from a file adapt the\n-- path to be based on the hash.\n\nadaptedUriPath :: Bool -> URI -> String\nadaptedUriPath = \\case\n  True -> hashToPath . uriFragment\n  False -> uriPath\n\nsetAdaptedUriPath :: Bool -> String -> URI -> URI\nsetAdaptedUriPath useHash s u = if useHash then u { uriFragment = pathToHash s } else u { uriPath = s }\n\npathToHash :: String -> String\npathToHash = ('#' :) . fromMaybe \"\" . L.stripPrefix \"/\"\n\nhashToPath :: String -> String\nhashToPath = ('/' :) . fromMaybe \"\" . L.stripPrefix \"#\"\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.4545454545454546,
                "sum": 32
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 259,
              "homplexity_lines_of_code": 271,
              "code_quality_score": 8.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.4545454545454546,
                  "sum": 32
                },
                "homplexity_loc": 271,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 1 1: module Obelisk.Asset.Accept has 166 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 55 20: data Encoding has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 63 18: data QValue has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 69 28: data AcceptableEncodings has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 77 1: type signature for missingAcceptableEncodings has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 77 1: type signature for missingAcceptableEncodings has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 78 1: function missingAcceptableEncodings has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 93 1: type signature for chooseEncoding has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 93 1: type signature for chooseEncoding has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 94 1: function chooseEncoding has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 100 1: type signature for encodingQValue has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 100 1: type signature for encodingQValue has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: function encodingQValue has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 106 1: type signature for acceptEncodingBody has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 106 1: type signature for acceptEncodingBody has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 107 1: function acceptEncodingBody has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 135 1: type signature for qvalue has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 135 1: type signature for qvalue has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has 18 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 136 1: function qvalue has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 156 1: type signature for contentCoding has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 156 1: type signature for contentCoding has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 157 1: function contentCoding has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 160 1: type signature for token has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 160 1: type signature for token has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 161 1: function token has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for literal has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for literal has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function literal has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for isTokenChar has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for isTokenChar has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function isTokenChar has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for isChar has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for isChar has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function isChar has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isCtl has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isCtl has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isCtl has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isSeparator has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isSeparator has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isSeparator has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: type signature for liftM2' has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: type signature for liftM2' has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 186 1: function liftM2' has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 192 1: type signature for starRule has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 192 1: type signature for starRule has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 193 1: function starRule has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 193 1: function starRule has 10 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 193 1: function starRule has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 206 1: type signature for hashRule has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 206 1: type signature for hashRule has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 207 1: function hashRule has cyclomatic complexity of 5 \nWarning:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 207 1: function hashRule has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 207 1: function hashRule has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 232 1: type signature for lws has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 232 1: type signature for lws has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 233 1: function lws has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 233 1: function lws has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 233 1: function lws has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 239 1: type signature for cr has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 239 1: type signature for cr has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 240 1: function cr has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 240 1: function cr has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 240 1: function cr has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 243 1: type signature for lf has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 243 1: type signature for lf has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 244 1: function lf has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 244 1: function lf has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 244 1: function lf has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 247 1: type signature for sp has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 247 1: type signature for sp has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: function sp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: function sp has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: function sp has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 250 1: type signature for spVal has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 250 1: type signature for spVal has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 251 1: function spVal has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 251 1: function spVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 251 1: function spVal has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 254 1: type signature for ht has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 254 1: type signature for ht has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: function ht has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: function ht has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: function ht has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 257 1: type signature for htVal has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 257 1: type signature for htVal has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 258 1: function htVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 258 1: function htVal has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 258 1: function htVal has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving  #-}\n\n-- | Module containing parsers and utilities for managing @Accept-Encoding@ headers and the overall process of encoding selection.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nmodule Obelisk.Asset.Accept\n  ( AcceptableEncodings(..)\n  , Encoding(..)\n  , QValue(..)\n  , QValueResolution\n  , acceptEncodingBody\n  , chooseEncoding\n  , missingAcceptableEncodings\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 710\nimport Prelude hiding (takeWhile, sequence)\nimport Data.Traversable (sequence)\n#elif __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#else\nimport Prelude hiding (takeWhile)\n#endif\n#else\nimport Prelude hiding (takeWhile)\n#endif\n\nimport Control.Applicative ((<|>), optional)\nimport Control.Arrow (second)\nimport Control.Monad (replicateM, void)\nimport Data.Attoparsec.ByteString as AttoBS\nimport Data.Attoparsec.ByteString.Char8 as AC8\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Either (partitionEithers)\nimport Data.Fixed (E3, Fixed(..), resolution)\nimport Data.List (sort)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes, fromMaybe, listToMaybe)\nimport Data.Ord (Down(..))\nimport Data.Proxy (Proxy(..))\nimport Data.String (IsString)\nimport Data.Word (Word8)\n\n\n-- | Type of a particular named encoding technique, such as @gzip@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5\nnewtype Encoding = Encoding { unEncoding :: ByteString } deriving (Show, Read, Eq, Ord, IsString)\n\n-- | Maximum precision of a Q value, in particular 3 decimal places of precision as given by the standard.\ntype QValueResolution = E3\n\n-- | Type of an HTTP @qvalue@ or quality value indicating how preferred some encoding is relative to some other one.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nnewtype QValue = QValue { unQValue :: Fixed QValueResolution } deriving (Show, Read, Eq, Ord)\n\n-- | Structure used for picking a mutually acceptable encoding, holding a default 'QValue' along with 'QValue's for a number of 'Encoding's and typically\n-- represented in HTTP as a string like gzip; q=1.0, identity; q=0.5, *; q=0.0@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\ndata AcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue :: QValue\n  -- ^The 'QValue' associated with the default encoding value @*@, indicating any unmentioned encoding.\n  , _acceptableEncodings_byEncoding :: Map Encoding QValue\n  -- ^'QValue's for each 'Encoding'.\n  } deriving (Show, Read, Eq, Ord)\n\n-- | When no Accept-Encoding header is present, prefer identity, then gzip or compress, then anything else available.\nmissingAcceptableEncodings :: AcceptableEncodings\nmissingAcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue = QValue 0.001\n  , _acceptableEncodings_byEncoding = Map.fromList\n      [ (Encoding \"identity\", QValue 1)\n      , (Encoding \"gzip\", QValue 0.5)\n      , (Encoding \"compress\", QValue 0.5)\n      ]\n  }\n\n-- | Takes a list of 'Encoding's and an 'AcceptableEncodings' representing preferences and returns @Just 'Encoding'@ to use of the given list based on those\n-- preferences. An 'Encoding' is preferred if it has a higher 'QValue' or in the case of ties if it comes first in the given list of encodings. An encoding\n-- with a @QValue@ of 0 will never be chosen. If no encoding could be chosen, either because no encodings were given or because 0 @QValue@s suppressed them,\n-- then @Nothing@ is returned.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nchooseEncoding :: [Encoding] -> AcceptableEncodings -> Maybe Encoding\nchooseEncoding es ae = fmap snd $ listToMaybe $ sort $ catMaybes $ zipWith f es [(1::Int)..]\n  where f e n = case encodingQValue e ae of\n          QValue 0 -> Nothing\n          q -> Just ((Down q, n), e) -- Choose by quality first (in descending order), then by the server's preference order\n\n-- | Helper function for 'chooseEncoding' that returns the default AcceptableEncoding if requested encoding is unavailable\nencodingQValue :: Encoding -> AcceptableEncodings -> QValue\nencodingQValue e ae = Map.findWithDefault (_acceptableEncodings_defaultQValue ae) e $ _acceptableEncodings_byEncoding ae\n\n-- | Attoparsec 'Parser' for parsing an 'AcceptableEncodings' from the value of an @Accept-Encoding@ header, as specified by HTTP/1.1 / RFC2616.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nacceptEncodingBody :: Parser AcceptableEncodings\nacceptEncodingBody = do\n  l <- hashRule (Just 1) Nothing $ do -- partially applied hashRule awaiting to be passed Parser a\n    c <- (Nothing <$ literal \"*\") <|> (Just <$> contentCoding) -- Parser Nothing <|> Parser Encoding\n    mq <- optional $ do\n      literal \";\"\n      literal \"q\"\n      literal \"=\"\n      qvalue\n    let q = fromMaybe (QValue 1) mq\n    return (c, q)\n  let (stars, specificEncodings) = partitionEithers $ flip map l $ \\(c, q) -> case c of\n        Nothing -> Left q\n        Just n -> Right (n, q)\n  starQValue <- case stars of\n    [] -> return Nothing\n    [q] -> return $ Just q\n    _ -> fail \"acceptEncodingBody: multiple * values provided\"\n  byEncodingProvided <- sequence $ Map.fromListWithKey (\\k _ _ -> fail $ \"acceptEncodingBody: encoding \" <> show k <> \" repeated multiple times\") $ map (second return) specificEncodings\n  let defaultIdentityQValue = fromMaybe (QValue 1) starQValue -- identity has a default qvalue of 1 unless * is given a different qvalue explicitly\n      defaultQValue = fromMaybe (QValue 0) starQValue\n      byEncoding = Map.filter (/= defaultQValue) -- Canonicalize: qvalues equal to the default are redundant\n                 . Map.alter (Just . fromMaybe defaultIdentityQValue) \"identity\" -- Add implicit \"identity\" encoding, unless it has been explicitly added\n                 $ byEncodingProvided\n  return $ AcceptableEncodings defaultQValue byEncoding\n\n-- | Parser for a 'QValue'.\n--\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nqvalue :: Parser QValue\nqvalue = do\n  skipMany lws\n  q0 <|> q1\n  where q0 = do\n          _ <- char '0'\n          decimals <- option [] $ do\n            _ <- char '.'\n            starRule (Just 0) (Just numAllowedDigits) digit\n          return $ QValue $ MkFixed $ fromIntegral $ (read ('0' : decimals) :: Int) * 10 ^ (numAllowedDigits - length decimals)\n        q1 = do\n          _ <- char '1'\n          option () $ do\n            _ <- char '.'\n            _ <- starRule (Just 0) (Just numAllowedDigits) $ char '0'\n            return ()\n          return $ QValue 1\n        numAllowedDigits :: Int\n        numAllowedDigits = fromIntegral $ resolution (Proxy :: Proxy QValueResolution)\n\n-- | Helper function used in 'acceptEncodingBody' to evaluate Encoding as ByteString\ncontentCoding :: Parser Encoding\ncontentCoding = Encoding <$> token\n\n-- | Helper function used in 'contentCoding' that skips lightweight spaces and consumes input while 'isTokenChar' returns True\ntoken :: Parser ByteString\ntoken = skipMany lws >> AttoBS.takeWhile1 isTokenChar\n\n-- | Helper function used in 'acceptEncodingBody', discards evaluation and returns  a 'Parser ()' to continue parsing\nliteral :: ByteString -> Parser ()\nliteral s = void $ skipMany lws >> string s\n\n-- | Helper function used in 'token' to validate if ByteStringChar is printable but not a control or seperator char\nisTokenChar :: Word8 -> Bool\nisTokenChar c = isChar c && not (isCtl c || isSeparator c)\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control or printable char\nisChar :: Word8 -> Bool\nisChar c = c <= 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control char\nisCtl :: Word8 -> Bool\nisCtl c = c <= 31 || c == 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a seperator char\nisSeparator :: Word8 -> Bool\nisSeparator c = BS.elem c $ spVal `BS.cons` htVal `BS.cons` \"()<>@,;:\\\\\\\"/[]?={}\"\n\n-- | A version of 'liftM2' that is strict in the result of its first\n-- action.\nliftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\nliftM2' f a b = do\n  !x <- a\n  y <- b\n  return (f x y)\n{-# INLINE liftM2' #-}\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\nstarRule :: Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nstarRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n  mandatoryVals <- replicateM numMandatory element\n  optionalVals <- case maxNum of\n    Nothing -> many' element\n    Just n -> do\n      let countUpTo 0 _ = return []\n          countUpTo m a = liftM2' (:) a (countUpTo (pred m) a) <|> return []\n      countUpTo (n - numMandatory) element\n  return $ mandatoryVals ++ optionalVals\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\n-- The spec is a bit ambiguous on whether extra commas and whitespace are permitted before and after the elements; this implementation permits them\nhashRule :: forall a. Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nhashRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n      sep :: Parser ()\n      sep = do\n        skipMany1 $ do\n          skipMany lws\n          char ','\n        return ()\n      processMandatory :: Bool -> Int -> Parser [a]\n      processMandatory isInitial 0 = processOptional isInitial $ fmap (subtract numMandatory) maxNum\n      processMandatory isInitial n = do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processMandatory False $ pred n\n      processOptional :: Bool -> Maybe Int -> Parser [a]\n      processOptional _ (Just 0) = return []\n      processOptional isInitial n = (<|> return []) $ do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processOptional False $ fmap pred n\n  result <- processMandatory True numMandatory\n  _ <- optional sep\n  skipMany lws\n  return result\n\n-- | Linear whitespace\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlws :: Parser ()\nlws = do\n  option () $ cr >> lf\n  _ <- starRule (Just 1) Nothing $ sp <|> ht\n  return ()\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\ncr :: Parser ()\ncr = void $ word8 13\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlf :: Parser ()\nlf = void $ word8 10\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nsp :: Parser ()\nsp = void $ word8 spVal\n\nspVal :: Word8\nspVal = 32\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nht :: Parser ()\nht = void $ word8 htVal\n\nhtVal :: Word8\nhtVal = 9\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving  #-}\n\n-- | Module containing parsers and utilities for managing @Accept-Encoding@ headers and the overall process of encoding selection.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nmodule Obelisk.Asset.Accept\n  ( AcceptableEncodings(..)\n  , Encoding(..)\n  , QValue(..)\n  , QValueResolution\n  , acceptEncodingBody\n  , chooseEncoding\n  , missingAcceptableEncodings\n  ) where\n\n\n\n\n\n\n\n\nimport Prelude hiding (takeWhile)\n\n\n\n\n\nimport Control.Applicative ((<|>), optional)\nimport Control.Arrow (second)\nimport Control.Monad (replicateM, void)\nimport Data.Attoparsec.ByteString as AttoBS\nimport Data.Attoparsec.ByteString.Char8 as AC8\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Either (partitionEithers)\nimport Data.Fixed (E3, Fixed(..), resolution)\nimport Data.List (sort)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes, fromMaybe, listToMaybe)\nimport Data.Ord (Down(..))\nimport Data.Proxy (Proxy(..))\nimport Data.String (IsString)\nimport Data.Word (Word8)\n\n\n-- | Type of a particular named encoding technique, such as @gzip@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5\nnewtype Encoding = Encoding { unEncoding :: ByteString } deriving (Show, Read, Eq, Ord, IsString)\n\n-- | Maximum precision of a Q value, in particular 3 decimal places of precision as given by the standard.\ntype QValueResolution = E3\n\n-- | Type of an HTTP @qvalue@ or quality value indicating how preferred some encoding is relative to some other one.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nnewtype QValue = QValue { unQValue :: Fixed QValueResolution } deriving (Show, Read, Eq, Ord)\n\n-- | Structure used for picking a mutually acceptable encoding, holding a default 'QValue' along with 'QValue's for a number of 'Encoding's and typically\n-- represented in HTTP as a string like gzip; q=1.0, identity; q=0.5, *; q=0.0@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\ndata AcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue :: QValue\n  -- ^The 'QValue' associated with the default encoding value @*@, indicating any unmentioned encoding.\n  , _acceptableEncodings_byEncoding :: Map Encoding QValue\n  -- ^'QValue's for each 'Encoding'.\n  } deriving (Show, Read, Eq, Ord)\n\n-- | When no Accept-Encoding header is present, prefer identity, then gzip or compress, then anything else available.\nmissingAcceptableEncodings :: AcceptableEncodings\nmissingAcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue = QValue 0.001\n  , _acceptableEncodings_byEncoding = Map.fromList\n      [ (Encoding \"identity\", QValue 1)\n      , (Encoding \"gzip\", QValue 0.5)\n      , (Encoding \"compress\", QValue 0.5)\n      ]\n  }\n\n-- | Takes a list of 'Encoding's and an 'AcceptableEncodings' representing preferences and returns @Just 'Encoding'@ to use of the given list based on those\n-- preferences. An 'Encoding' is preferred if it has a higher 'QValue' or in the case of ties if it comes first in the given list of encodings. An encoding\n-- with a @QValue@ of 0 will never be chosen. If no encoding could be chosen, either because no encodings were given or because 0 @QValue@s suppressed them,\n-- then @Nothing@ is returned.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nchooseEncoding :: [Encoding] -> AcceptableEncodings -> Maybe Encoding\nchooseEncoding es ae = fmap snd $ listToMaybe $ sort $ catMaybes $ zipWith f es [(1::Int)..]\n  where f e n = case encodingQValue e ae of\n          QValue 0 -> Nothing\n          q -> Just ((Down q, n), e) -- Choose by quality first (in descending order), then by the server's preference order\n\n-- | Helper function for 'chooseEncoding' that returns the default AcceptableEncoding if requested encoding is unavailable\nencodingQValue :: Encoding -> AcceptableEncodings -> QValue\nencodingQValue e ae = Map.findWithDefault (_acceptableEncodings_defaultQValue ae) e $ _acceptableEncodings_byEncoding ae\n\n-- | Attoparsec 'Parser' for parsing an 'AcceptableEncodings' from the value of an @Accept-Encoding@ header, as specified by HTTP/1.1 / RFC2616.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nacceptEncodingBody :: Parser AcceptableEncodings\nacceptEncodingBody = do\n  l <- hashRule (Just 1) Nothing $ do -- partially applied hashRule awaiting to be passed Parser a\n    c <- (Nothing <$ literal \"*\") <|> (Just <$> contentCoding) -- Parser Nothing <|> Parser Encoding\n    mq <- optional $ do\n      literal \";\"\n      literal \"q\"\n      literal \"=\"\n      qvalue\n    let q = fromMaybe (QValue 1) mq\n    return (c, q)\n  let (stars, specificEncodings) = partitionEithers $ flip map l $ \\(c, q) -> case c of\n        Nothing -> Left q\n        Just n -> Right (n, q)\n  starQValue <- case stars of\n    [] -> return Nothing\n    [q] -> return $ Just q\n    _ -> fail \"acceptEncodingBody: multiple * values provided\"\n  byEncodingProvided <- sequence $ Map.fromListWithKey (\\k _ _ -> fail $ \"acceptEncodingBody: encoding \" <> show k <> \" repeated multiple times\") $ map (second return) specificEncodings\n  let defaultIdentityQValue = fromMaybe (QValue 1) starQValue -- identity has a default qvalue of 1 unless * is given a different qvalue explicitly\n      defaultQValue = fromMaybe (QValue 0) starQValue\n      byEncoding = Map.filter (/= defaultQValue) -- Canonicalize: qvalues equal to the default are redundant\n                 . Map.alter (Just . fromMaybe defaultIdentityQValue) \"identity\" -- Add implicit \"identity\" encoding, unless it has been explicitly added\n                 $ byEncodingProvided\n  return $ AcceptableEncodings defaultQValue byEncoding\n\n-- | Parser for a 'QValue'.\n--\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nqvalue :: Parser QValue\nqvalue = do\n  skipMany lws\n  q0 <|> q1\n  where q0 = do\n          _ <- char '0'\n          decimals <- option [] $ do\n            _ <- char '.'\n            starRule (Just 0) (Just numAllowedDigits) digit\n          return $ QValue $ MkFixed $ fromIntegral $ (read ('0' : decimals) :: Int) * 10 ^ (numAllowedDigits - length decimals)\n        q1 = do\n          _ <- char '1'\n          option () $ do\n            _ <- char '.'\n            _ <- starRule (Just 0) (Just numAllowedDigits) $ char '0'\n            return ()\n          return $ QValue 1\n        numAllowedDigits :: Int\n        numAllowedDigits = fromIntegral $ resolution (Proxy :: Proxy QValueResolution)\n\n-- | Helper function used in 'acceptEncodingBody' to evaluate Encoding as ByteString\ncontentCoding :: Parser Encoding\ncontentCoding = Encoding <$> token\n\n-- | Helper function used in 'contentCoding' that skips lightweight spaces and consumes input while 'isTokenChar' returns True\ntoken :: Parser ByteString\ntoken = skipMany lws >> AttoBS.takeWhile1 isTokenChar\n\n-- | Helper function used in 'acceptEncodingBody', discards evaluation and returns  a 'Parser ()' to continue parsing\nliteral :: ByteString -> Parser ()\nliteral s = void $ skipMany lws >> string s\n\n-- | Helper function used in 'token' to validate if ByteStringChar is printable but not a control or seperator char\nisTokenChar :: Word8 -> Bool\nisTokenChar c = isChar c && not (isCtl c || isSeparator c)\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control or printable char\nisChar :: Word8 -> Bool\nisChar c = c <= 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control char\nisCtl :: Word8 -> Bool\nisCtl c = c <= 31 || c == 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a seperator char\nisSeparator :: Word8 -> Bool\nisSeparator c = BS.elem c $ spVal `BS.cons` htVal `BS.cons` \"()<>@,;:\\\\\\\"/[]?={}\"\n\n-- | A version of 'liftM2' that is strict in the result of its first\n-- action.\nliftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\nliftM2' f a b = do\n  !x <- a\n  f x <$> b\n{-# INLINE liftM2' #-}\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\nstarRule :: Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nstarRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n  mandatoryVals <- replicateM numMandatory element\n  optionalVals <- case maxNum of\n    Nothing -> many' element\n    Just n -> do\n      let countUpTo 0 _ = return []\n          countUpTo m a = liftM2' (:) a (countUpTo (pred m) a) <|> return []\n      countUpTo (n - numMandatory) element\n  return $ mandatoryVals ++ optionalVals\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\n-- The spec is a bit ambiguous on whether extra commas and whitespace are permitted before and after the elements; this implementation permits them\nhashRule :: forall a. Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nhashRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n      sep :: Parser ()\n      sep = do\n        skipMany1 $ do\n          skipMany lws\n          char ','\n        return ()\n      processMandatory :: Bool -> Int -> Parser [a]\n      processMandatory isInitial 0 = processOptional isInitial $ fmap (subtract numMandatory) maxNum\n      processMandatory isInitial n = do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processMandatory False $ pred n\n      processOptional :: Bool -> Maybe Int -> Parser [a]\n      processOptional _ (Just 0) = return []\n      processOptional isInitial n = (<|> return []) $ do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processOptional False $ fmap pred n\n  result <- processMandatory True numMandatory\n  _ <- optional sep\n  skipMany lws\n  return result\n\n-- | Linear whitespace\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlws :: Parser ()\nlws = do\n  option () $ cr >> lf\n  _ <- starRule (Just 1) Nothing $ sp <|> ht\n  return ()\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\ncr :: Parser ()\ncr = void $ word8 13\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlf :: Parser ()\nlf = void $ word8 10\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nsp :: Parser ()\nsp = void $ word8 spVal\n\nspVal :: Word8\nspVal = 32\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nht :: Parser ()\nht = void $ word8 htVal\n\nhtVal :: Word8\nhtVal = 9\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 98.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 1
                },
                "homplexity_loc": 0,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 1,\n        \"average\": 1,\n        \"sum\": 1\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- | Serve preprocessed assets using Snap.\nmodule Obelisk.Asset.Serve.Snap\n  ( serveAssets\n  , serveAssetsInPlace\n  , serveAsset\n  , serveAssetInPlace\n  , getAssetPath\n  ) where\n\nimport Obelisk.Asset.Accept (Encoding (..), acceptEncodingBody, chooseEncoding, missingAcceptableEncodings)\nimport Obelisk.Snap.Extras\n\nimport Snap\n  (MonadSnap, getHeader, getRequest, getsRequest, modifyResponse, pass, redirect, sendFile, setContentLength, setContentType, setHeader, setResponseCode)\nimport Snap.Util.FileServe (fileType, getSafePath, serveFile)\nimport Snap.Internal.Util.FileServe (checkRangeReq)\n\nimport Control.Applicative ((<|>))\nimport Control.Exception (handleJust, try, throwIO)\nimport Control.Monad (forM, liftM, unless)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail\n#endif\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Attoparsec.ByteString (parseOnly, endOfInput)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.List (isSuffixOf, sort)\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Monoid ((<>))\n#endif\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8, encodeUtf8)\nimport System.Directory (getDirectoryContents)\nimport System.FilePath ((</>), splitFileName, takeDirectory)\nimport System.IO.Error (isDoesNotExistError)\nimport System.PosixCompat.Files (getFileStatus, fileSize)\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, redirects will be sent to the browser\n-- from the logical asset name (e.g. @test.png@) to the unique filename for the\n-- current version of the asset\n-- (e.g. @0rx5yvkkgkig2pcqf4ngi1l7vh89qqajdzc6aiayaibyhvj0d853-test.png@). Hashed\n-- asset names will be sent with permanent caching headers.\nserveAssets :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> m ()\nserveAssets = serveAssets' True\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, redirects will be not sent to the\n-- browser for the logical asset name (e.g. @test.png@) but instead the current\n-- version of the asset with to point the browser at the unique filename for the\n-- current version of the asset.\nserveAssetsInPlace :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> m ()\nserveAssetsInPlace = serveAssets' False\n\n-- | Like 'serveAssets', but only serves a single specified asset\nserveAsset :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> FilePath -> m ()\nserveAsset = serveAsset' True\n\n-- | Like 'serveAssetsInPlace', but only serves a single specified asset\nserveAssetInPlace :: (MonadSnap m, MonadFail m) => FilePath -> FilePath -> FilePath -> m ()\nserveAssetInPlace = serveAsset' False\n\n-- | Serve static assets from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\n--\n-- For assets generated from @assets.nix@, the @Bool@ argument @doRedirect@ controls whether redirects will be sent to the browser if a request is made for\n-- an unhashed asset name, e.g. @test.png@. For @True@, a redirect will be sent, yielding more round trips to the server but better caching behavior if the\n-- asset doesn't change often. Conversely for @False@, the asset will be served \"in place\" but made uncacheable.\nserveAssets' :: (MonadSnap m, MonadFail m) => Bool -> FilePath -> FilePath -> m ()\nserveAssets' doRedirect base fallback = do\n  pRaw <- getSafePath\n  serveAsset' doRedirect base fallback $ if \"/\" `isSuffixOf` pRaw || pRaw == \"\" then pRaw <> \"index.html\" else pRaw\n\n-- | Serve a single static asset from an asset directory generated via @assets.nix@ or, failing that, from a regular directory.\nserveAsset' :: (MonadFail m, MonadSnap m) => Bool -> FilePath -> FilePath -> FilePath -> m ()\nserveAsset' doRedirect base fallback p = do\n  assetType <- liftIO $ try $ BS.readFile $ base </> p </> \"type\"\n  case assetType of\n    Right \"immutable\" -> do\n      conditionalOnModification <- getsRequest $ getHeader \"If-Modified-Since\"\n      case conditionalOnModification of\n        Nothing -> do\n          encodedFiles <- liftM (filter (`notElem` [\".\", \"..\"])) $ liftIO $ getDirectoryContents $ base </> p </> \"encodings\"\n          availableEncodings <- liftM (map snd . sort) $ forM encodedFiles $ \\f -> do\n            stat <- liftIO $ getFileStatus $ base </> p </> \"encodings\" </> f\n            return (fileSize stat, Encoding $ encodeUtf8 $ T.pack f)\n          acceptEncodingRaw <- getsRequest $ getHeader \"Accept-Encoding\"\n          ae <- case acceptEncodingRaw of\n            Nothing -> return missingAcceptableEncodings\n            Just aer -> case parseOnly (acceptEncodingBody <* endOfInput) aer of\n              Right ae -> return ae\n              Left err -> error err\n          Just (Encoding e) <- return $ chooseEncoding availableEncodings ae\n          modifyResponse $ setHeader \"Content-Encoding\" e . setHeader \"Vary\" \"Accept-Encoding\"\n          if doRedirect then cachePermanently else doNotCache --TODO: Use Etags when not redirecting\n          let finalFilename = base </> p </> \"encodings\" </> T.unpack (decodeUtf8 e)\n          stat <- liftIO $ getFileStatus finalFilename\n          modifyResponse $ setHeader \"Last-Modified\" \"Thu, 1 Jan 1970 00:00:00 GMT\"\n            . setHeader \"Accept-Ranges\" \"bytes\"\n            . setContentType (fileType modernMimeTypes p)\n          let size = fromIntegral $ fileSize stat\n          req <- getRequest\n          -- Despite the name, this function actually does all of the work for\n          -- responding to range requests. We only need to handle *none* range\n          -- requests ourselves.\n          wasRange <- checkRangeReq req finalFilename size\n          unless wasRange $ do\n            modifyResponse $ setResponseCode 200 . setContentLength size\n            sendFile finalFilename\n        Just _ -> do\n          cachePermanently >> modifyResponse (setResponseCode 304)\n    Right \"redirect\" -> do\n      mtarget <- liftIO $ getAssetTarget $ base </> p\n      case mtarget of\n        Just target -> if doRedirect\n                       then do\n                         doNotCache\n                         redirect target\n                       else do\n                         serveAsset' doRedirect base fallback $ takeDirectory p </> T.unpack (decodeUtf8 target)\n        Nothing -> do\n          serveFile $ fallback </> p\n    Right unknown -> error $ T.unpack (\"serveAssets': Unknown asset \" <> decodeUtf8 unknown)\n    Left err | isDoesNotExistError err -> (doNotCache >> serveFileIfExists (fallback </> p)) <|> do\n                 let (dirname, filename) = splitFileName p\n                     unhashedFilename = drop 1 $ dropWhile (/= '-') filename\n                 if null unhashedFilename then pass else do\n                   doNotCache\n                   serveFileIfExists $ fallback </> dirname </> unhashedFilename\n             | otherwise -> liftIO $ throwIO err\n\n-- | If the given file exists in a hashed location, return that location.  The\n-- resulting FilePath will be relative to @base@, just like @assetPath@ is.\ngetAssetPath\n  :: FilePath -- ^ @base@: Path to asset directory\n  -> FilePath -- ^ @assetPath@: Path to non-hashed asset within the asset directory\n  -> IO (Maybe FilePath) -- ^ Path to hashed asset within the asset directory, if it exists\ngetAssetPath base p = do\n  target <- getAssetTarget $ base </> p\n  return $ fmap ((takeDirectory p </>) . T.unpack . decodeUtf8) target\n\n-- | Given a file path into an asset directory prepared by @assets.nix@, read\n-- the target path from the metadata if it exists. Returns @Nothing@ when the\n-- asset path doesn't exist.\ngetAssetTarget :: FilePath -> IO (Maybe ByteString)\ngetAssetTarget p =\n  handleJust\n    (\\ e  -> if isDoesNotExistError e then Just () else Nothing)\n    (\\ () -> return Nothing)\n    (liftM Just $ BS.readFile $ p </> \"target\")\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Serve/Snap.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": ""
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 16,
              "homplexity_lines_of_code": 20,
              "code_quality_score": 96.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 20,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 1 1: <unnamed module> has 13 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 7 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 7 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/generate.hs\" 8 1: function main has branching depth of 0 \n"
              },
              "original_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Promoted\nimport Obelisk.Asset.Symlink\nimport System.Environment\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeStaticProject paths haskellTarget $ StaticConfig\n    { _staticConfig_packageName = T.pack packageName\n    , _staticConfig_moduleName = T.pack moduleName\n    }\n  copyAndSymlink paths root fileTarget\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/generate.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Promoted\nimport Obelisk.Asset.Symlink\nimport System.Environment\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeStaticProject paths haskellTarget $ StaticConfig\n    { _staticConfig_packageName = T.pack packageName\n    , _staticConfig_moduleName = T.pack moduleName\n    }\n  copyAndSymlink paths root fileTarget\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 43,
              "homplexity_lines_of_code": 69,
              "code_quality_score": 91.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 69,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 1 1: <unnamed module> has 38 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 8 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 8 1: type signature for main has 1 arguments \nWarning:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has 31 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src-bin/static-th.hs\" 9 1: function main has branching depth of 0 \n"
              },
              "original_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Cabal\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Symlink\nimport System.Environment\nimport System.FilePath\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeCabalProject haskellTarget $ SimplePkg\n    { _simplePkg_name = T.pack packageName\n    , _simplePkg_moduleName = T.pack moduleName\n    , _simplePkg_dependencies = map T.pack\n      [ \"base\"\n      , \"obelisk-asset-manifest\"\n      , \"template-haskell\"\n      ]\n    , _simplePkg_moduleContents = T.pack $ unlines\n      [ \"{-# Language CPP #-}\"\n      , \"{-|\"\n      , \"  Description:\"\n      , \"    Automatically generated module that provides the 'static' TH function\"\n      , \"    to generate paths to static assets.\"\n      , \"-}\"\n      , \"module \" <> moduleName <> \" ( static, staticFilePath ) where\"\n      , \"\"\n      , \"import Obelisk.Asset.TH\"\n      , \"import Language.Haskell.TH\"\n      , \"\"\n      , \"static, staticFilePath :: FilePath -> Q Exp\"\n      , \"#ifdef OBELISK_ASSET_PASSTHRU\"\n      , \"static = staticAssetRaw\"\n      , \"staticFilePath =  staticAssetFilePathRaw \\\"static.out\\\"\"\n      , \"#else\"\n      , \"static = staticAssetHashed \" <> show root\n      , \"staticFilePath = staticAssetFilePath \" <> show root\n      , \"#endif\"\n      ]\n    }\n  copyAndSymlink paths root fileTarget\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src-bin/static-th.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import qualified Data.Text as T\nimport Obelisk.Asset.Cabal\nimport Obelisk.Asset.Gather\nimport Obelisk.Asset.Symlink\nimport System.Environment\nimport System.FilePath\n\nmain :: IO ()\nmain = do\n  --TODO: Usage\n  [root, haskellTarget, packageName, moduleName, fileTarget] <- getArgs\n  paths <- gatherHashedPaths root\n  writeCabalProject haskellTarget $ SimplePkg\n    { _simplePkg_name = T.pack packageName\n    , _simplePkg_moduleName = T.pack moduleName\n    , _simplePkg_dependencies = map T.pack\n      [ \"base\"\n      , \"obelisk-asset-manifest\"\n      , \"template-haskell\"\n      ]\n    , _simplePkg_moduleContents = T.pack $ unlines\n      [ \"{-# Language CPP #-}\"\n      , \"{-|\"\n      , \"  Description:\"\n      , \"    Automatically generated module that provides the 'static' TH function\"\n      , \"    to generate paths to static assets.\"\n      , \"-}\"\n      , \"module \" <> moduleName <> \" ( static, staticFilePath ) where\"\n      , \"\"\n      , \"import Obelisk.Asset.TH\"\n      , \"import Language.Haskell.TH\"\n      , \"\"\n      , \"static, staticFilePath :: FilePath -> Q Exp\"\n      , \"#ifdef OBELISK_ASSET_PASSTHRU\"\n      , \"static = staticAssetRaw\"\n      , \"staticFilePath =  staticAssetFilePathRaw \\\"static.out\\\"\"\n      , \"#else\"\n      , \"static = staticAssetHashed \" <> show root\n      , \"staticFilePath = staticAssetFilePath \" <> show root\n      , \"#endif\"\n      ]\n    }\n  copyAndSymlink paths root fileTarget\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.5,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 42,
              "homplexity_lines_of_code": 55,
              "code_quality_score": 88.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.5,
                  "sum": 3
                },
                "homplexity_loc": 55,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 1 1: module Obelisk.Asset.Cabal has 35 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 12 18: data SimplePkg has record fields count of 4 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 19 1: type signature for cabalFile has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 19 1: type signature for cabalFile has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has 11 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 20 1: function cabalFile has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 33 1: type signature for writeCabalProject has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 33 1: type signature for writeCabalProject has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has 9 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs\" 34 1: function writeCabalProject has branching depth of 1 \n"
              },
              "original_code": "{-# Language OverloadedStrings #-}\nmodule Obelisk.Asset.Cabal where\n\nimport qualified Data.List as L\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory\nimport System.FilePath\n\n-- | A generated single-module package\ndata SimplePkg = SimplePkg\n  { _simplePkg_name :: Text\n  , _simplePkg_moduleName :: Text\n  , _simplePkg_moduleContents :: Text\n  , _simplePkg_dependencies :: [Text]\n  }\n\ncabalFile :: SimplePkg -> Text\ncabalFile (SimplePkg packageName moduleName _ deps) = T.unlines\n  [ \"name: \" <> packageName\n  , \"version: 0\"\n  , \"cabal-version: >= 1.2\"\n  , \"build-type: Simple\"\n  , \"\"\n  , \"library\"\n  , \"  hs-source-dirs: src\"\n  , \"  build-depends:\"\n  , \"    \" <> T.intercalate \", \" deps\n  , \"  exposed-modules: \" <> moduleName\n  ]\n\nwriteCabalProject :: FilePath -> SimplePkg -> IO ()\nwriteCabalProject target pkg = do\n  createDirectoryIfMissing True target\n  T.writeFile (target </> T.unpack (_simplePkg_name pkg) <.> \"cabal\") $ cabalFile pkg\n  let moduleName = _simplePkg_moduleName pkg\n      (modName', moduleDirPath) = case L.uncons (reverse $ T.splitOn \".\" moduleName) of\n        Nothing -> error $ \"writeStaticProject: invalid module name \" <> T.unpack moduleName\n        Just (name, parents) -> (name, target </> \"src\" </> T.unpack (T.intercalate \"/\" $ reverse parents))\n  createDirectoryIfMissing True moduleDirPath\n  T.writeFile (moduleDirPath </> T.unpack modName' <.> \"hs\") $ _simplePkg_moduleContents pkg\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Cabal.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# Language OverloadedStrings #-}\nmodule Obelisk.Asset.Cabal where\n\nimport qualified Data.List as L\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory\nimport System.FilePath\n\n-- | A generated single-module package\ndata SimplePkg = SimplePkg\n  { _simplePkg_name :: Text\n  , _simplePkg_moduleName :: Text\n  , _simplePkg_moduleContents :: Text\n  , _simplePkg_dependencies :: [Text]\n  }\n\ncabalFile :: SimplePkg -> Text\ncabalFile (SimplePkg packageName moduleName _ deps) = T.unlines\n  [ \"name: \" <> packageName\n  , \"version: 0\"\n  , \"cabal-version: >= 1.2\"\n  , \"build-type: Simple\"\n  , \"\"\n  , \"library\"\n  , \"  hs-source-dirs: src\"\n  , \"  build-depends:\"\n  , \"    \" <> T.intercalate \", \" deps\n  , \"  exposed-modules: \" <> moduleName\n  ]\n\nwriteCabalProject :: FilePath -> SimplePkg -> IO ()\nwriteCabalProject target pkg = do\n  createDirectoryIfMissing True target\n  T.writeFile (target </> T.unpack (_simplePkg_name pkg) <.> \"cabal\") $ cabalFile pkg\n  let moduleName = _simplePkg_moduleName pkg\n      (modName', moduleDirPath) = case L.uncons (reverse $ T.splitOn \".\" moduleName) of\n        Nothing -> error $ \"writeStaticProject: invalid module name \" <> T.unpack moduleName\n        Just (name, parents) -> (name, target </> \"src\" </> T.unpack (T.intercalate \"/\" $ reverse parents))\n  createDirectoryIfMissing True moduleDirPath\n  T.writeFile (moduleDirPath </> T.unpack modName' <.> \"hs\") $ _simplePkg_moduleContents pkg\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 22,
              "homplexity_lines_of_code": 21,
              "code_quality_score": 95.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 21,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 1 1: module Obelisk.Asset.Symlink has 17 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 14 1: type signature for copyAndSymlink has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 14 1: type signature for copyAndSymlink has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs\" 19 1: function copyAndSymlink has branching depth of 0 \n"
              },
              "original_code": "module Obelisk.Asset.Symlink\n  ( copyAndSymlink\n  ) where\n\nimport Control.Monad\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport System.Directory\nimport System.FilePath.Posix\nimport System.PosixCompat.Files\n\n-- | Copy the given hashed files from one location to hashed paths in another\n-- location, and symlink the unhashed paths to the hashed ones\ncopyAndSymlink\n  :: Map FilePath FilePath\n  -> FilePath\n  -> FilePath\n  -> IO ()\ncopyAndSymlink paths source destination = forM_ (Map.toList paths) $ \\(original, hashed) -> do\n  createDirectoryIfMissing True $ destination </> takeDirectory hashed\n  copyFile (source </> original) (destination </> hashed)\n  createSymbolicLink (takeFileName hashed) $ destination </> original\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Symlink.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Obelisk.Asset.Symlink\n  ( copyAndSymlink\n  ) where\n\nimport Control.Monad\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport System.Directory\nimport System.FilePath.Posix\nimport System.PosixCompat.Files\n\n-- | Copy the given hashed files from one location to hashed paths in another\n-- location, and symlink the unhashed paths to the hashed ones\ncopyAndSymlink\n  :: Map FilePath FilePath\n  -> FilePath\n  -> FilePath\n  -> IO ()\ncopyAndSymlink paths source destination = forM_ (Map.toList paths) $ \\(original, hashed) -> do\n  createDirectoryIfMissing True $ destination </> takeDirectory hashed\n  copyFile (source </> original) (destination </> hashed)\n  createSymbolicLink (takeFileName hashed) $ destination </> original\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.6666666666666667,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 11,
              "lines_of_code": 70,
              "homplexity_lines_of_code": 88,
              "code_quality_score": 81.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.6666666666666667,
                  "sum": 5
                },
                "homplexity_loc": 88,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 1 1: module Obelisk.Asset.Gather has 58 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 26 1: type signature for gatherHashedPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 26 1: type signature for gatherHashedPaths has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has 11 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 29 1: function gatherHashedPaths has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 43 1: type signature for toHashedPath has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 43 1: type signature for toHashedPath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 47 1: function toHashedPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 56 1: type signature for toNixBase32 has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 56 1: type signature for toNixBase32 has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has 12 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Gather.hs\" 57 1: function toNixBase32 has cyclomatic complexity of 2 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n-- | Functions for collecting up files to be processed by the asset pipeline\nmodule Obelisk.Asset.Gather\n  ( gatherHashedPaths\n  , toHashedPath\n  ) where\n\nimport Control.DeepSeq (force)\nimport Control.Monad (forM)\nimport Data.Bits (shift, (.|.), (.&.))\nimport qualified Data.ByteString.Builder as LBS (toLazyByteString, word8)\nimport qualified Data.ByteString.Lazy as LBS (readFile, toStrict, ByteString, length, index)\nimport Data.Char (ord)\nimport Data.Digest.Pure.SHA (bytestringDigest, sha256)\nimport Data.Map (Map)\nimport qualified Data.Map as Map (singleton)\nimport qualified Data.Text as T (unpack)\nimport Data.Text.Encoding (decodeUtf8)\nimport qualified Data.Vector.Unboxed as UV ((!), fromList)\nimport Data.Word (Word8)\nimport System.FilePath.Posix ((</>), splitFileName, normalise)\nimport System.Directory (listDirectory, doesFileExist)\n\n-- | Given a path, recursively explore it, creating hashed paths for all files found\ngatherHashedPaths\n  :: FilePath -- ^ The root of the directory to process\n  -> IO (Map FilePath FilePath) -- ^ A mapping of original paths to hashed paths (all relative to the root)\ngatherHashedPaths root = go \"\"\n  where\n    go :: FilePath -> IO (Map FilePath FilePath)\n    go subdir = do\n      subs <- listDirectory $ root </> subdir\n      fmap mconcat $ forM subs $ \\sub -> do\n        let relativePath = subdir </> sub\n        isFile <- doesFileExist $ root </> relativePath\n        if isFile\n          then do !hashedRelativePath <- force <$> toHashedPath root relativePath\n                  return $ Map.singleton relativePath hashedRelativePath\n          else go relativePath\n\n-- | Given a root path and path relative to it, construct a hashed version of the relative path\ntoHashedPath\n  :: FilePath -- ^ Root path\n  -> FilePath -- ^ Relative path within root\n  -> IO FilePath\ntoHashedPath root relativePath = do\n  let path = root </> relativePath\n  contents <- LBS.readFile path\n  let hashPrefix = T.unpack $ decodeUtf8 $ LBS.toStrict $ toNixBase32 $ bytestringDigest $ sha256 contents\n      (dir, filename) = splitFileName relativePath\n      !hashedRelativePath = force $ normalise $ dir </> (hashPrefix <> \"-\" <> filename)\n  return hashedRelativePath\n\n-- | Convert a ByteString to base 32 in the way that Nix does\ntoNixBase32 :: LBS.ByteString -> LBS.ByteString\ntoNixBase32 x = LBS.toLazyByteString $ mconcat $ map (LBS.word8 . (symbols UV.!) . fromIntegral) vals\n  where vals = byteStringToQuintets x\n        symbols = UV.fromList $ map (fromIntegral . ord) $ filter (`notElem` (\"eotu\" :: String)) $ ['0'..'9'] <> ['a'..'z']\n        -- See https://github.com/NixOS/nix/blob/6f1743b1a5116ca57a60b481ee4083c891b7a334/src/libutil/hash.cc#L109\n        byteStringToQuintets :: LBS.ByteString -> [Word8]\n        byteStringToQuintets hash = map f [len-1, len-2 .. 0]\n          where hashSize = fromIntegral $ LBS.length hash\n                len = (hashSize * 8 - 1) `div` 5 + 1\n                f n = let b = n * 5\n                          (i, j) = b `divMod` 8\n                          j' = fromIntegral j\n                          --TODO: This is probably pretty slow; replace with something that doesn't use LBS.index\n                          c = ((hash `LBS.index` i) `shift` (-j')) .|. (if i >= hashSize - 1 then 0 else (hash `LBS.index` (i + 1)) `shift` (8 - j'))\n                      in c .&. 0x1f\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Gather.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n-- | Functions for collecting up files to be processed by the asset pipeline\nmodule Obelisk.Asset.Gather\n  ( gatherHashedPaths\n  , toHashedPath\n  ) where\n\nimport Control.DeepSeq (force)\nimport Control.Monad (forM)\nimport Data.Bits (shift, (.|.), (.&.))\nimport qualified Data.ByteString.Builder as LBS (toLazyByteString, word8)\nimport qualified Data.ByteString.Lazy as LBS (readFile, toStrict, ByteString, length, index)\nimport Data.Char (ord)\nimport Data.Digest.Pure.SHA (bytestringDigest, sha256)\nimport Data.Map (Map)\nimport qualified Data.Map as Map (singleton)\nimport qualified Data.Text as T (unpack)\nimport Data.Text.Encoding (decodeUtf8)\nimport qualified Data.Vector.Unboxed as UV ((!), fromList)\nimport Data.Word (Word8)\nimport System.FilePath.Posix ((</>), splitFileName, normalise)\nimport System.Directory (listDirectory, doesFileExist)\n\n-- | Given a path, recursively explore it, creating hashed paths for all files found\ngatherHashedPaths\n  :: FilePath -- ^ The root of the directory to process\n  -> IO (Map FilePath FilePath) -- ^ A mapping of original paths to hashed paths (all relative to the root)\ngatherHashedPaths root = go \"\"\n  where\n    go :: FilePath -> IO (Map FilePath FilePath)\n    go subdir = do\n      subs <- listDirectory $ root </> subdir\n      fmap mconcat $ forM subs $ \\sub -> do\n        let relativePath = subdir </> sub\n        isFile <- doesFileExist $ root </> relativePath\n        if isFile\n          then do !hashedRelativePath <- force <$> toHashedPath root relativePath\n                  return $ Map.singleton relativePath hashedRelativePath\n          else go relativePath\n\n-- | Given a root path and path relative to it, construct a hashed version of the relative path\ntoHashedPath\n  :: FilePath -- ^ Root path\n  -> FilePath -- ^ Relative path within root\n  -> IO FilePath\ntoHashedPath root relativePath = do\n  let path = root </> relativePath\n  contents <- LBS.readFile path\n  let hashPrefix = T.unpack $ decodeUtf8 $ LBS.toStrict $ toNixBase32 $ bytestringDigest $ sha256 contents\n      (dir, filename) = splitFileName relativePath\n      !hashedRelativePath = force $ normalise $ dir </> (hashPrefix <> \"-\" <> filename)\n  return hashedRelativePath\n\n-- | Convert a ByteString to base 32 in the way that Nix does\ntoNixBase32 :: LBS.ByteString -> LBS.ByteString\ntoNixBase32 x = LBS.toLazyByteString $ mconcat $ map (LBS.word8 . (symbols UV.!) . fromIntegral) vals\n  where vals = byteStringToQuintets x\n        symbols = UV.fromList $ map (fromIntegral . ord) $ filter (`notElem` (\"eotu\" :: String)) $ ['0'..'9'] <> ['a'..'z']\n        -- See https://github.com/NixOS/nix/blob/6f1743b1a5116ca57a60b481ee4083c891b7a334/src/libutil/hash.cc#L109\n        byteStringToQuintets :: LBS.ByteString -> [Word8]\n        byteStringToQuintets hash = map f [len-1, len-2 .. 0]\n          where hashSize = fromIntegral $ LBS.length hash\n                len = (hashSize * 8 - 1) `div` 5 + 1\n                f n = let b = n * 5\n                          (i, j) = b `divMod` 8\n                          j' = fromIntegral j\n                          --TODO: This is probably pretty slow; replace with something that doesn't use LBS.index\n                          c = ((hash `LBS.index` i) `shift` (-j')) .|. (if i >= hashSize - 1 then 0 else (hash `LBS.index` (i + 1)) `shift` (8 - j'))\n                      in c .&. 0x1f\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 89,
              "homplexity_lines_of_code": 68,
              "code_quality_score": 75.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 9
                },
                "homplexity_loc": 68,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 5 1: module Obelisk.Asset.TH has 48 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has branching depth of 0 \n"
              },
              "original_code": "{-|\nDescription:\n  Template Haskell for generating asset paths.\n-}\nmodule Obelisk.Asset.TH\n  ( assetPath\n  , staticAssetRaw\n  , staticAssetHashed\n  , staticAssetFilePath\n  , staticAssetFilePathRaw\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Control.Monad\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport System.Directory\nimport System.FilePath.Posix\n\n-- | Produces the hashed path of a file\nhashedAssetFilePath :: FilePath -> FilePath -> Q FilePath\nhashedAssetFilePath root relativePath = do\n  qAddDependentFile $ root </> relativePath\n  runIO (toHashedPath root relativePath)\n\n-- | Produces a string literal with the hashed path of the file\nassetPath :: FilePath -> FilePath -> Q Exp\nassetPath root relativePath =\n  LitE . StringL <$> hashedAssetFilePath root relativePath\n\nstaticPrefix :: FilePath\nstaticPrefix = \"/static\"\n\n-- | Location of the symbolic link to static assets and resources.\nstaticOutPath :: FilePath\nstaticOutPath = \"static.out\"\n\n-- | Embed a filepath via template haskell. Resources embedded this way\n-- are requested from the \"/static\" route.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetRaw :: FilePath -> Q Exp\nstaticAssetRaw = staticAssetWorker staticPrefix staticOutPath\n\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp\n\n-- | Embed a filepath via template haskell. Differently to 'staticAssetRaw'\n-- this points to a local filepath instead of an URL during deployment.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetFilePathRaw\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetFilePathRaw root = staticAssetWorker root staticOutPath\n\nstaticAssetFilePath :: FilePath -> FilePath -> Q Exp\nstaticAssetFilePath root relativePath = do\n  let fullPath = root </> relativePath\n  qAddDependentFile fullPath\n  pure $ LitE $ StringL fullPath\n\n-- | @'staticAssetWorker' root staticOut fp@.\n--\n-- Produces @root </> fp@, but checks before that @fp@ has been copied\n-- to 'staticOutPath' and produces a compilation error otherwise.\n-- This helps finding typos in filepaths, etc... at compile-time instead of\n-- run-time.\nstaticAssetWorker\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Directory to which the filepath must have been copied.\n  -- If @fp@ does not exist within this directory, this function will fail.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetWorker root staticOut fp = do\n  exists <- runIO $ doesFileExist $ staticOut </> fp\n  when (not exists) $\n    fail $ \"The file \" <> fp <> \" was not found in \" <> staticOut\n  returnQ $ LitE $ StringL $ root </> fp\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-|\nDescription:\n  Template Haskell for generating asset paths.\n-}\nmodule Obelisk.Asset.TH\n  ( assetPath\n  , staticAssetRaw\n  , staticAssetHashed\n  , staticAssetFilePath\n  , staticAssetFilePathRaw\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Control.Monad\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport System.Directory\nimport System.FilePath.Posix\n\n-- | Produces the hashed path of a file\nhashedAssetFilePath :: FilePath -> FilePath -> Q FilePath\nhashedAssetFilePath root relativePath = do\n  qAddDependentFile $ root </> relativePath\n  runIO (toHashedPath root relativePath)\n\n-- | Produces a string literal with the hashed path of the file\nassetPath :: FilePath -> FilePath -> Q Exp\nassetPath root relativePath =\n  LitE . StringL <$> hashedAssetFilePath root relativePath\n\nstaticPrefix :: FilePath\nstaticPrefix = \"/static\"\n\n-- | Location of the symbolic link to static assets and resources.\nstaticOutPath :: FilePath\nstaticOutPath = \"static.out\"\n\n-- | Embed a filepath via template haskell. Resources embedded this way\n-- are requested from the \"/static\" route.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetRaw :: FilePath -> Q Exp\nstaticAssetRaw = staticAssetWorker staticPrefix staticOutPath\n\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp\n\n-- | Embed a filepath via template haskell. Differently to 'staticAssetRaw'\n-- this points to a local filepath instead of an URL during deployment.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetFilePathRaw\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetFilePathRaw root = staticAssetWorker root staticOutPath\n\nstaticAssetFilePath :: FilePath -> FilePath -> Q Exp\nstaticAssetFilePath root relativePath = do\n  let fullPath = root </> relativePath\n  qAddDependentFile fullPath\n  pure $ LitE $ StringL fullPath\n\n-- | @'staticAssetWorker' root staticOut fp@.\n--\n-- Produces @root </> fp@, but checks before that @fp@ has been copied\n-- to 'staticOutPath' and produces a compilation error otherwise.\n-- This helps finding typos in filepaths, etc... at compile-time instead of\n-- run-time.\nstaticAssetWorker\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Directory to which the filepath must have been copied.\n  -- If @fp@ does not exist within this directory, this function will fail.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetWorker root staticOut fp = do\n  exists <- runIO $ doesFileExist $ staticOut </> fp\n  unless exists $\n    fail $ \"The file \" <> fp <> \" was not found in \" <> staticOut\n  returnQ $ LitE $ StringL $ root </> fp\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 2,
                "sum": 11
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 102,
              "homplexity_lines_of_code": 99,
              "code_quality_score": 68.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 2,
                  "sum": 11
                },
                "homplexity_loc": 99,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"writeStaticProject\": 1,\n        \"staticModuleFile\": 2,\n        \"declareStatic\": 3,\n        \"staticClassWithInstances\": 2,\n        \"staticClass\": 2,\n        \"staticInstance\": 1,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 1.8333333333333333,\n        \"sum\": 11\n    },\n    \"homplexity_loc\": 99\n}"
              },
              "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\nmodule Obelisk.Asset.Promoted\n  ( writeStaticProject\n  , declareStatic\n  , StaticConfig (..)\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Data.Foldable\nimport Language.Haskell.TH (pprint)\nimport Language.Haskell.TH.Syntax hiding (lift)\nimport GHC.TypeLits\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq\nimport Control.Monad.Trans.Writer\nimport System.FilePath\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Obelisk.Asset.Cabal (writeCabalProject, SimplePkg(..))\n\ndata StaticConfig = StaticConfig\n  { _staticConfig_packageName :: Text --TODO: Better type\n  , _staticConfig_moduleName :: Text --TODO: Better type\n  }\n\nwriteStaticProject :: Map FilePath FilePath -> FilePath -> StaticConfig -> IO ()\nwriteStaticProject paths target cfg = do\n  let modName = _staticConfig_moduleName cfg\n  modContents <- staticModuleFile modName paths\n  writeCabalProject target $ SimplePkg\n    { _simplePkg_name = _staticConfig_packageName cfg\n    , _simplePkg_moduleName = _staticConfig_moduleName cfg\n    , _simplePkg_moduleContents = modContents\n    , _simplePkg_dependencies = [\"base\", \"ghc-prim\", \"text\"]\n    }\n\nstaticModuleFile :: Text -> Map FilePath FilePath -> IO Text\nstaticModuleFile moduleName paths = do\n  decs <- runQ $ fmap toList $ execWriterT $ staticClassWithInstances paths\n  return $ T.unlines\n    [ \"{-# LANGUAGE AllowAmbiguousTypes #-}\"\n    , \"{-# LANGUAGE DataKinds #-}\"\n    , \"{-# LANGUAGE FlexibleInstances #-}\"\n    , \"{-# LANGUAGE KindSignatures #-}\"\n    , \"{-# LANGUAGE OverloadedStrings #-}\"\n    , \"{-# LANGUAGE ScopedTypeVariables #-}\"\n    , \"{-# LANGUAGE TypeApplications #-}\"\n    , \"module \" <> moduleName <> \" {-# DEPRECATED \\\"Generate this module with the 'obelisk-asset-th-generate' executable instead.\\\" #-} where\"\n    , \"\"\n    , \"import qualified GHC.Types\"\n    , \"import Data.Text (Text)\"\n    , \"import qualified Data.Text.Internal\"\n    , \"import Data.Monoid ((<>))\"\n    , \"\"\n    , \"static :: forall a. StaticFile a => Text\"\n    , \"static = \\\"static/\\\" <> hashedPath @a\" --TODO: Use obelisk-route to generate this in a more consistent way\n    , \"\"\n    , T.pack $ pprint decs\n    ]\n\ndata StaticContext = StaticContext\n  { _staticContext_className :: Name\n  , _staticContext_methodName :: Name\n  }\n\ndeclareStatic :: FilePath -> Q [Dec]\ndeclareStatic root = do\n  paths <- runIO $ gatherHashedPaths root\n  -- TODO: If https://ghc.haskell.org/trac/ghc/ticket/14623 is implemented, use\n  -- qAddDependentFile to watch the directories as well as the files\n  forM_ (Map.keys paths) $ \\original -> do\n    qAddDependentFile $ root </> original\n  fmap toList $ execWriterT $ staticClassWithInstances paths\n\nstaticClassWithInstances :: Map FilePath FilePath -> WriterT (Seq Dec) Q ()\nstaticClassWithInstances paths = do\n  ctx <- staticClass\n  forM_ (Map.toList paths) $ \\(original, hashed) -> do\n    staticInstance ctx original hashed\n\nstaticClass :: WriterT (Seq Dec) Q StaticContext\nstaticClass = do\n  let n x = Name (OccName x) NameS\n      className = n \"StaticFile\"\n      methodName = n \"hashedPath\"\n      cls = ClassD [] className [KindedTV (n \"s\") (ConT ''Symbol)] [] [SigD methodName (ConT ''Text)]\n  tell $ Seq.singleton cls\n  return $ StaticContext\n    { _staticContext_className = className\n    , _staticContext_methodName = methodName\n    }\n\nstaticInstance :: StaticContext -> FilePath -> FilePath -> WriterT (Seq Dec) Q ()\nstaticInstance ctx relativePath hashedPath = do\n  let headType = ConT (_staticContext_className ctx) `AppT` LitT (StrTyLit relativePath)\n      methodDec = ValD (VarP $ _staticContext_methodName ctx) (NormalB (LitE (StringL hashedPath))) []\n  tell $ Seq.singleton $ InstanceD Nothing [] headType [methodDec]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\nmodule Obelisk.Asset.Promoted\n  ( writeStaticProject\n  , declareStatic\n  , StaticConfig (..)\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Data.Foldable\nimport Language.Haskell.TH (pprint)\nimport Language.Haskell.TH.Syntax hiding (lift)\nimport GHC.TypeLits\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq\nimport Control.Monad.Trans.Writer\nimport System.FilePath\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Obelisk.Asset.Cabal (writeCabalProject, SimplePkg(..))\n\ndata StaticConfig = StaticConfig\n  { _staticConfig_packageName :: Text --TODO: Better type\n  , _staticConfig_moduleName :: Text --TODO: Better type\n  }\n\nwriteStaticProject :: Map FilePath FilePath -> FilePath -> StaticConfig -> IO ()\nwriteStaticProject paths target cfg = do\n  let modName = _staticConfig_moduleName cfg\n  modContents <- staticModuleFile modName paths\n  writeCabalProject target $ SimplePkg\n    { _simplePkg_name = _staticConfig_packageName cfg\n    , _simplePkg_moduleName = _staticConfig_moduleName cfg\n    , _simplePkg_moduleContents = modContents\n    , _simplePkg_dependencies = [\"base\", \"ghc-prim\", \"text\"]\n    }\n\nstaticModuleFile :: Text -> Map FilePath FilePath -> IO Text\nstaticModuleFile moduleName paths = do\n  decs <- runQ $ fmap toList $ execWriterT $ staticClassWithInstances paths\n  return $ T.unlines\n    [ \"{-# LANGUAGE AllowAmbiguousTypes #-}\"\n    , \"{-# LANGUAGE DataKinds #-}\"\n    , \"{-# LANGUAGE FlexibleInstances #-}\"\n    , \"{-# LANGUAGE KindSignatures #-}\"\n    , \"{-# LANGUAGE OverloadedStrings #-}\"\n    , \"{-# LANGUAGE ScopedTypeVariables #-}\"\n    , \"{-# LANGUAGE TypeApplications #-}\"\n    , \"module \" <> moduleName <> \" {-# DEPRECATED \\\"Generate this module with the 'obelisk-asset-th-generate' executable instead.\\\" #-} where\"\n    , \"\"\n    , \"import qualified GHC.Types\"\n    , \"import Data.Text (Text)\"\n    , \"import qualified Data.Text.Internal\"\n    , \"import Data.Monoid ((<>))\"\n    , \"\"\n    , \"static :: forall a. StaticFile a => Text\"\n    , \"static = \\\"static/\\\" <> hashedPath @a\" --TODO: Use obelisk-route to generate this in a more consistent way\n    , \"\"\n    , T.pack $ pprint decs\n    ]\n\ndata StaticContext = StaticContext\n  { _staticContext_className :: Name\n  , _staticContext_methodName :: Name\n  }\n\ndeclareStatic :: FilePath -> Q [Dec]\ndeclareStatic root = do\n  paths <- runIO $ gatherHashedPaths root\n  -- TODO: If https://ghc.haskell.org/trac/ghc/ticket/14623 is implemented, use\n  -- qAddDependentFile to watch the directories as well as the files\n  forM_ (Map.keys paths) $ \\original -> do\n    qAddDependentFile $ root </> original\n  fmap toList $ execWriterT $ staticClassWithInstances paths\n\nstaticClassWithInstances :: Map FilePath FilePath -> WriterT (Seq Dec) Q ()\nstaticClassWithInstances paths = do\n  ctx <- staticClass\n  forM_ (Map.toList paths) $ \\(original, hashed) -> do\n    staticInstance ctx original hashed\n\nstaticClass :: WriterT (Seq Dec) Q StaticContext\nstaticClass = do\n  let n x = Name (OccName x) NameS\n      className = n \"StaticFile\"\n      methodName = n \"hashedPath\"\n      cls = ClassD [] className [KindedTV (n \"s\") (ConT ''Symbol)] [] [SigD methodName (ConT ''Text)]\n  tell $ Seq.singleton cls\n  return $ StaticContext\n    { _staticContext_className = className\n    , _staticContext_methodName = methodName\n    }\n\nstaticInstance :: StaticContext -> FilePath -> FilePath -> WriterT (Seq Dec) Q ()\nstaticInstance ctx relativePath hashedPath = do\n  let headType = ConT (_staticContext_className ctx) `AppT` LitT (StrTyLit relativePath)\n      methodDec = ValD (VarP $ _staticContext_methodName ctx) (NormalB (LitE (StringL hashedPath))) []\n  tell $ Seq.singleton $ InstanceD Nothing [] headType [methodDec]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 30,
              "homplexity_lines_of_code": 21,
              "code_quality_score": 93.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 21,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 1 1: module Obelisk.ExecutableConfig.Inject has 17 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Inject where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad (mapM_)\nimport Data.Semigroup ((<>))\n#endif\n#endif\nimport Control.Monad.IO.Class (MonadIO)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex.Dom.Core hiding (value)\n\n-- | Produces a @<script>@ tag with an @id@ attribute containing the key and\n-- whose value is the provided configuration, encoded in base64.\ninjectPure :: DomBuilder t m => Text -> ByteString -> m ()\ninjectPure key value =\n  let attrs = (\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key <> \"data-hydration-skip\" =: \"\")\n  in elAttr \"script\" attrs $ text (T.decodeUtf8 (B64.encode value))\n\n-- | Produces injectable @<script>@ tags containing the configuration keys\n-- (filepaths) and values.\ninjectExecutableConfigs :: (MonadIO m, DomBuilder t m) => Map Text ByteString -> m ()\ninjectExecutableConfigs = mapM_ (uncurry injectPure) . Map.toList\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Inject where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad (mapM_)\nimport Data.Semigroup ((<>))\n#endif\n#endif\nimport Control.Monad.IO.Class (MonadIO)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex.Dom.Core hiding (value)\n\n-- | Produces a @<script>@ tag with an @id@ attribute containing the key and\n-- whose value is the provided configuration, encoded in base64.\ninjectPure :: DomBuilder t m => Text -> ByteString -> m ()\ninjectPure key value =\n  let attrs = (\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key <> \"data-hydration-skip\" =: \"\")\n  in elAttr \"script\" attrs $ text (T.decodeUtf8 (B64.encode value))\n\n-- | Produces injectable @<script>@ tags containing the configuration keys\n-- (filepaths) and values.\ninjectExecutableConfigs :: (MonadIO m, DomBuilder t m) => Map Text ByteString -> m ()\ninjectExecutableConfigs = mapM_ (uncurry injectPure) . Map.toList\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 3,
                "average": 2.5,
                "sum": 5
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 14,
              "lines_of_code": 51,
              "homplexity_lines_of_code": 59,
              "code_quality_score": 84.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 3,
                  "average": 2.5,
                  "sum": 5
                },
                "homplexity_loc": 59,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 40 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 22 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 22 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has 15 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 23 1: function getConfigs has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 45 1: type signature for nodeListNodes has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 45 1: type signature for nodeListNodes has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs\" 46 1: function nodeListNodes has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Data.Traversable (for)\nimport GHCJS.DOM\nimport GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.DOMStringMap (get)\nimport GHCJS.DOM.Element (getInnerHTML)\nimport GHCJS.DOM.HTMLElement (HTMLElement(HTMLElement), getDataset)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport GHCJS.DOM.Types (MonadJSM, Node(Node), castTo)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = do\n  Just doc <- currentDocument\n  Just hd <- getHead doc\n  nodes <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  fmap Map.fromList $ for nodes $ \\node -> do\n    e <- castTo HTMLElement node >>= \\case\n      Nothing -> error \"Found node with data attribute obelisk-executable-config-inject-key that is not an HTMLElement.\"\n      Just htmlE -> return htmlE\n    dataset <- getDataset e\n    (,)\n      -- the key is camelCased: https://html.spec.whatwg.org/multipage/dom.html#dom-dataset\n      <$> get dataset (\"obeliskExecutableConfigInjectKey\" :: Text)\n      <*> (fmap decodeOrFail (getInnerHTML e))\n  where\n    decodeOrFail x = case B64.decode (T.encodeUtf8 x) of\n      Left e -> error (\"Obelisk.ExecutableConfig.Lookup.getConfigs: error when decoding base64: \" ++ e)\n      Right x' -> x'\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in obelisk-frontend should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ghcjs/Obelisk/ExecutableConfig/Lookup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Data.Traversable (for)\nimport GHCJS.DOM\nimport GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.DOMStringMap (get)\nimport GHCJS.DOM.Element (getInnerHTML)\nimport GHCJS.DOM.HTMLElement (HTMLElement(HTMLElement), getDataset)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport GHCJS.DOM.Types (MonadJSM, Node(Node), castTo)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = do\n  Just doc <- currentDocument\n  Just hd <- getHead doc\n  nodes <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  fmap Map.fromList $ for nodes $ \\node -> do\n    e <- castTo HTMLElement node >>= \\case\n      Nothing -> error \"Found node with data attribute obelisk-executable-config-inject-key that is not an HTMLElement.\"\n      Just htmlE -> return htmlE\n    dataset <- getDataset e\n    (,)\n      -- the key is camelCased: https://html.spec.whatwg.org/multipage/dom.html#dom-dataset\n      <$> get dataset (\"obeliskExecutableConfigInjectKey\" :: Text)\n      <*> fmap decodeOrFail (getInnerHTML e)\n  where\n    decodeOrFail x = case B64.decode (T.encodeUtf8 x) of\n      Left e -> error (\"Obelisk.ExecutableConfig.Lookup.getConfigs: error when decoding base64: \" ++ e)\n      Right x' -> x'\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in obelisk-frontend should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 2,
                "average": 2.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 17,
              "code_quality_score": 94.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 2,
                  "average": 2.0,
                  "sum": 2
                },
                "homplexity_loc": 17,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 14 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle.WKWebView\nimport System.FilePath.Posix\n\nimport Obelisk.Configs.Internal.Directory\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> error \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle.WKWebView\nimport System.FilePath.Posix\n\nimport Obelisk.Configs.Internal.Directory\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> error \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 9,
              "code_quality_score": 97.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 9,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 8 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 10 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 10 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: function getConfigs has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\n\nimport Obelisk.Configs.Internal.Directory (getConfigsFromDirectory)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = getConfigsFromDirectory \"config\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\n\nimport Obelisk.Configs.Internal.Directory (getConfigsFromDirectory)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = getConfigsFromDirectory \"config\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 4,
                "average": 2.6666666666666665,
                "sum": 8
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 60,
              "homplexity_lines_of_code": 93,
              "code_quality_score": 74.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 4,
                  "average": 2.6666666666666665,
                  "sum": 8
                },
                "homplexity_loc": 93,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 55 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 18 1: type signature for getFromMgr has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 18 1: type signature for getFromMgr has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has 12 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 19 1: function getFromMgr has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 32 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 32 1: type signature for getConfigs has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has 21 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 33 1: function getConfigs has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 55 1: type signature for lines0 has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 55 1: type signature for lines0 has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs\" 56 1: function lines0 has cyclomatic complexity of 2 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Control.Exception (bracket)\nimport Control.Monad (forM)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Foreign.C.String (withCString)\nimport Foreign.Ptr (nullPtr)\n\nimport Obelisk.ExecutableConfig.Internal.AssetManager\n\ngetFromMgr :: AAssetManager -> BS.ByteString -> IO (Maybe ByteString)\ngetFromMgr mgr name = do\n  let open = do\n        a <- BS.useAsCString name $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset a == nullPtr\n          then Nothing\n          else Just a\n      close = mapM_ asset_close\n  bracket open close $ mapM $ \\asset -> do\n    b <- asset_getBuffer asset\n    l <- asset_getLength asset\n    BS.packCStringLen (b, fromIntegral l)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = fmap (Map.mapKeys T.decodeUtf8) $ bracket getAssets freeAssetManager $ \\mgrObj -> do\n  mgr <- assetManagerFromJava mgrObj\n  let openDir = do\n        d <- withCString \"config.files\" $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset d == nullPtr\n          then Nothing\n          else Just d\n      closeDir = mapM_ asset_close\n  configPaths <- bracket openDir closeDir $ \\case\n    Just asset -> do\n      b <- asset_getBuffer asset\n      l <- asset_getLength asset\n      lines0 <$> BS.packCStringLen (b, fromIntegral l)\n    Nothing -> error \"could not open configuration manifest 'config.files'\"\n  result <- fmap Map.fromList $ forM configPaths $ \\fp ->\n    getFromMgr mgr (\"config/\" <> fp) >>= \\case\n      Just v -> return (fp, v)\n      Nothing -> error $ \"Config present in config.files but not in assets: \" <> show fp\n  putStrLn $ \"getConfigs: found \" <> show result\n  pure result\n\nlines0 :: BS.ByteString -> [BS.ByteString]\nlines0 ps\n  | BS.null ps = []\n  | otherwise = case BS.elemIndex 0 ps of\n      Nothing -> [ps]\n      Just n  -> BS.take n ps : lines0 (BS.drop (n+1) ps)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-android/Obelisk/ExecutableConfig/Lookup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Control.Exception (bracket)\nimport Control.Monad (forM)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Foreign.C.String (withCString)\nimport Foreign.Ptr (nullPtr)\n\nimport Obelisk.ExecutableConfig.Internal.AssetManager\n\ngetFromMgr :: AAssetManager -> BS.ByteString -> IO (Maybe ByteString)\ngetFromMgr mgr name = do\n  let open = do\n        a <- BS.useAsCString name $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset a == nullPtr\n          then Nothing\n          else Just a\n      close = mapM_ asset_close\n  bracket open close $ mapM $ \\asset -> do\n    b <- asset_getBuffer asset\n    l <- asset_getLength asset\n    BS.packCStringLen (b, fromIntegral l)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = fmap (Map.mapKeys T.decodeUtf8) $ bracket getAssets freeAssetManager $ \\mgrObj -> do\n  mgr <- assetManagerFromJava mgrObj\n  let openDir = do\n        d <- withCString \"config.files\" $ \\fn ->\n          assetManager_open mgr fn 3\n        return $ if unAAsset d == nullPtr\n          then Nothing\n          else Just d\n      closeDir = mapM_ asset_close\n  configPaths <- bracket openDir closeDir $ \\case\n    Just asset -> do\n      b <- asset_getBuffer asset\n      l <- asset_getLength asset\n      lines0 <$> BS.packCStringLen (b, fromIntegral l)\n    Nothing -> error \"could not open configuration manifest 'config.files'\"\n  result <- fmap Map.fromList $ forM configPaths $ \\fp ->\n    getFromMgr mgr (\"config/\" <> fp) >>= \\case\n      Just v -> return (fp, v)\n      Nothing -> error $ \"Config present in config.files but not in assets: \" <> show fp\n  putStrLn $ \"getConfigs: found \" <> show result\n  pure result\n\nlines0 :: BS.ByteString -> [BS.ByteString]\nlines0 ps\n  | BS.null ps = []\n  | otherwise = case BS.elemIndex 0 ps of\n      Nothing -> [ps]\n      Just n  -> BS.take n ps : lines0 (BS.drop (n+1) ps)\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Configs\n  ( HasConfigs(..)\n  , ConfigsT\n  , runConfigsT\n  , mapConfigsT\n  , getTextConfig\n  ) where\n\nimport Control.Applicative (Alternative)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Base (MonadBase)\nimport Control.Monad.Catch (MonadThrow)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail (MonadFail)\n#endif\nimport Control.Monad.Fix (MonadFix)\nimport Control.Monad.IO.Class (MonadIO)\nimport Control.Monad.Morph (MFunctor)\nimport Control.Monad.Primitive (PrimMonad, PrimState, primitive)\nimport Control.Monad.Ref (MonadRef)\nimport Control.Monad.Trans (MonadTrans, lift)\nimport Control.Monad.Trans.Control (MonadBaseControl)\nimport Control.Monad.Trans.Reader (ReaderT (..), ask, mapReaderT)\nimport Control.Monad.Trans.State (StateT)\nimport qualified Control.Monad.Trans.State.Strict as Strict\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex\nimport Reflex.Host.Class (MonadReflexCreateTrigger)\nimport Reflex.Dom.Core\n  ( DomBuilder\n  , DomRenderHook\n  , HasDocument\n  , Prerender (Client)\n  , StaticDomBuilderT\n  , prerender\n  )\n#ifndef ghcjs_HOST_OS\nimport Language.Javascript.JSaddle (MonadJSM)\n#endif\n\nclass Monad m => HasConfigs m where\n  getConfigs :: m (Map Text ByteString)\n  default getConfigs :: (HasConfigs m', m ~ t m', MonadTrans t) => m (Map Text ByteString)\n  getConfigs = lift getConfigs\n  getConfig :: Text -> m (Maybe ByteString)\n  getConfig k = do\n    configs <- getConfigs\n    return $ Map.lookup k configs\n\ninstance Monad m => HasConfigs (ConfigsT m) where\n  getConfigs = ConfigsT ask\n\ngetTextConfig :: HasConfigs m => Text -> m (Maybe Text)\ngetTextConfig k = fmap T.decodeUtf8 <$> getConfig k\n\ninstance HasConfigs m => HasConfigs (BehaviorWriterT t w m)\ninstance HasConfigs m => HasConfigs (DynamicWriterT t w m)\ninstance HasConfigs m => HasConfigs (EventWriterT t w m)\ninstance HasConfigs m => HasConfigs (PostBuildT t m)\ninstance HasConfigs m => HasConfigs (QueryT t q m)\ninstance HasConfigs m => HasConfigs (ReaderT r m)\ninstance HasConfigs m => HasConfigs (RequesterT t request response m)\ninstance HasConfigs m => HasConfigs (StateT w m)\ninstance HasConfigs m => HasConfigs (Strict.StateT w m)\ninstance HasConfigs m => HasConfigs (StaticDomBuilderT t m)\ninstance HasConfigs m => HasConfigs (TriggerEventT t m)\n\nnewtype ConfigsT m a = ConfigsT { unConfigsT :: ReaderT (Map Text ByteString) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadPlus\n    , Alternative\n    , MonadFail\n    , MonadFix\n    , MonadThrow\n    , MonadIO\n    , MonadBase m'\n    , MonadBaseControl m'\n    , MonadRef\n    , MonadTrans\n    , MFunctor\n    , DomBuilder t\n    , MonadHold t\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , NotReady t\n    , PostBuild t\n    , TriggerEvent t\n    , HasDocument\n    , DomRenderHook t\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    )\n\ninstance PerformEvent t m => PerformEvent t (ConfigsT m) where\n  type Performable (ConfigsT m) = ConfigsT (Performable m)\n  performEvent e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent $ runConfigsT configs <$> e\n  performEvent_ e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent_ $ runConfigsT configs <$> e\n\ninstance Adjustable t m => Adjustable t (ConfigsT m) where\n  runWithReplace a e = ConfigsT $ runWithReplace (unConfigsT a) (unConfigsT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = ConfigsT $ traverseDMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = ConfigsT $ traverseIntMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = ConfigsT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unConfigsT $ f k v) m e\n\ninstance Prerender t m => Prerender t (ConfigsT m) where\n  type Client (ConfigsT m) = ConfigsT (Client m)\n  prerender server client = ConfigsT $ ReaderT $ \\configs ->\n    prerender (runConfigsT configs server) (runConfigsT configs client)\n\ninstance PrimMonad m => PrimMonad (ConfigsT m) where\n  type PrimState (ConfigsT m) = PrimState m\n  primitive = lift . primitive\n\nrunConfigsT\n  :: Map Text ByteString\n  -> ConfigsT m a\n  -> m a\nrunConfigsT cs child = runReaderT (unConfigsT child) cs\n\nmapConfigsT\n  :: (forall x. m x -> n x)\n  -> ConfigsT m a\n  -> ConfigsT n a\nmapConfigsT f (ConfigsT x) = ConfigsT $ mapReaderT f x\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": ""
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
              "cyclomatic_complexity": {
                "min": 3,
                "max": 3,
                "average": 3.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 24,
              "homplexity_lines_of_code": 31,
              "code_quality_score": 90.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 3,
                  "max": 3,
                  "average": 3.0,
                  "sum": 3
                },
                "homplexity_loc": 31,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 1 1: module Obelisk.Configs.Internal.Directory has 22 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 15 1: type signature for getConfigsFromDirectory has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 15 1: type signature for getConfigsFromDirectory has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has 9 lines of code \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs\" 16 1: function getConfigsFromDirectory has branching depth of 2 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Configs.Internal.Directory where\n\nimport Control.Monad\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport System.Directory\nimport System.FilePath.Posix\n\ngetConfigsFromDirectory :: FilePath -> IO (Map Text ByteString)\ngetConfigsFromDirectory base = doesDirectoryExist base >>= \\case\n  True -> do\n    ps <- listDirectory base\n    fmap mconcat $ forM ps $ \\p -> do\n      subdirConfigs <- getConfigsFromDirectory $ base </> p\n      pure $ Map.mapKeys (T.pack . (p </>) . T.unpack) subdirConfigs\n  False -> doesFileExist base >>= \\case\n    True -> Map.singleton \"\" <$> BS.readFile base\n    False -> pure mempty\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs/Internal/Directory.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Configs.Internal.Directory where\n\nimport Control.Monad\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport System.Directory\nimport System.FilePath.Posix\n\ngetConfigsFromDirectory :: FilePath -> IO (Map Text ByteString)\ngetConfigsFromDirectory base = doesDirectoryExist base >>= \\case\n  True -> do\n    ps <- listDirectory base\n    fmap mconcat $ forM ps $ \\p -> do\n      subdirConfigs <- getConfigsFromDirectory $ base </> p\n      pure $ Map.mapKeys (T.pack . (p </>) . T.unpack) subdirConfigs\n  False -> doesFileExist base >>= \\case\n    True -> Map.singleton \"\" <$> BS.readFile base\n    False -> pure mempty\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 4,
              "homplexity_lines_of_code": 4,
              "code_quality_score": 97.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 4,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 1 1: <unnamed module> has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 3 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 3 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/selftest/src-bin/obelisk-selftest.hs\" 4 1: function main has branching depth of 0 \n"
              },
              "original_code": "import qualified Obelisk.SelfTest\n\nmain :: IO ()\nmain = Obelisk.SelfTest.main\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/selftest/src-bin/obelisk-selftest.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import qualified Obelisk.SelfTest\n\nmain :: IO ()\nmain = Obelisk.SelfTest.main\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/selftest/src/Obelisk/SelfTest.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 11,
                "average": 5,
                "sum": 115
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 2,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 22,
              "lines_of_code": 837,
              "homplexity_lines_of_code": 1419,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 11,
                  "average": 5,
                  "sum": 115
                },
                "homplexity_loc": 1419,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 11,\n        \"average\": 5.24,\n        \"sum\": 115\n    },\n    \"homplexity_loc\": 1419,\n    \"homplexity_output\": {\n        \"commit\": 2,\n        \"tshow\": 1,\n        \"shellyOb\": 2,\n        \"augmentWithVerbosity\": 3,\n        \"isolatedGitShell\": 4,\n        \"copyForGitRemote\": 6,\n        \"main\": 5,\n        \"main'\": 11,\n        \"testObRunInDir\": 10,\n        \"testObRunCert\": 7,\n        \"testObRunWithInvalidCabalFile\": 3,\n        \"testThunkPack\": 6,\n        \"testObRunInDirWithMissingStaticFileWorker\": 9,\n        \"testObRunInDirWithMissingStaticFile\": 7,\n        \"testObRunInDirWithMissingStaticFilePath\": 8,\n        \"assertRevEQ\": 1,\n        \"assertRevNE\": 1\n    }\n}\n"
              },
              "original_code": "{-# LANGUAGE DoAndIfThenElse #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.SelfTest where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Exception (bracket, throw, try)\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Aeson.Types as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as LBS\nimport Data.Foldable (for_)\nimport Data.Function (fix)\nimport Data.List (isInfixOf)\nimport qualified Data.Map as Map\nimport Data.Semigroup ((<>))\nimport qualified Data.Set as Set\nimport Data.String\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.IO as T\nimport qualified Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Socket as Socket\nimport Shelly\nimport System.Directory (getCurrentDirectory, withCurrentDirectory, getDirectoryContents)\nimport System.Environment\nimport System.Exit (ExitCode (..))\nimport System.FilePath (addTrailingPathSeparator)\nimport qualified System.Info\nimport System.IO (Handle, hClose, hIsEOF, hGetContents)\nimport System.IO.Temp\nimport System.Process (readProcessWithExitCode)\nimport System.Which (staticWhich)\nimport Test.Hspec\nimport Test.HUnit.Base\n\nimport Obelisk.ExecutableConfig.Lookup (getConfigs)\nimport Obelisk.Run (getConfigRoute)\n\ndata ObRunState\n  = ObRunState_Init\n  | ObRunState_Startup\n  | ObRunState_BackendStarted\n  deriving (Eq, Show)\n\ncpPath :: FilePath\ncpPath = $(staticWhich \"cp\")\n\ncabalPath :: FilePath\ncabalPath = $(staticWhich \"cabal\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nchownPath :: FilePath\nchownPath = $(staticWhich \"chown\")\n\nchmodPath :: FilePath\nchmodPath = $(staticWhich \"chmod\")\n\nwhoamiPath :: FilePath\nwhoamiPath = $(staticWhich \"whoami\")\n\nnixInstantiatePath :: FilePath\nnixInstantiatePath = $(staticWhich \"nix-instantiate\")\n\nnixBuildPath :: FilePath\nnixBuildPath = $(staticWhich \"nix-build\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nsedPath :: FilePath\nsedPath = $(staticWhich \"sed\")\n\ngitUserConfig :: [Text]\ngitUserConfig = [\"-c\", \"user.name=Obelisk Selftest\", \"-c\", \"user.email=noreply@example.com\"]\n\ncommit :: Text -> Sh ()\ncommit msg = void $ run gitPath $ gitUserConfig <> [ \"commit\"\n  , \"--no-gpg-sign\"\n  , \"--allow-empty\"\n  , \"-m\"\n  , msg\n  ]\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\n-- | Like `shelly` but used when running `ob` commands\nshellyOb :: MonadIO m => (Sh a -> Sh a) -> Sh a -> m a\nshellyOb f obTest = shelly $ f obTest\n\n-- Set \"ob\" in a single place so it can be replaced with a\n-- link to obelisk in the nix store in the future,\n-- and avoid PATH hacking before calling this script.\nob :: FilePath\nob = \"ob\"\n\naugmentWithVerbosity :: (String -> [Text] -> a) -> String -> Bool -> [Text] -> a\naugmentWithVerbosity runner executable isVerbose args = runner executable $ (if isVerbose then (\"-v\" :) else id) args\n\nisolatedGitShell :: Bool -> FilePath -> (([Text] -> Sh Text) -> Sh a) -> IO a\nisolatedGitShell isVerbose dir f = shelly $ bool silently verbosely isVerbose $ do\n  setenv \"HOME\" \"/dev/null\"\n  setenv \"GIT_CONFIG_NOSYSTEM\" \"1\"\n  _ <- git [\"init\"]\n  _ <- git [\"config\", \"user.name\", \"SelfTest\"]\n  _ <- git [\"config\", \"user.email\", \"self@test\"]\n  f git\n  where\n    git args = run gitPath $ [\"-C\", toTextIgnore dir] <> args\n\n-- | Copies a git repo to a new location and \"resets\" the git history to include\n-- exactly one commit with all files added. It then restricts writing and reading\n-- for group and user to make the repo ideal for being a valid git remote for thunks.\n--\n-- Using this allows dirty repos to be used as git remotes during the test since 'git clone'ing\n-- a dirty repo will not include the uncommitted changes.\ncopyForGitRemote :: Bool -> FilePath -> FilePath -> IO ()\ncopyForGitRemote isVerbose origDir copyDir = isolatedGitShell isVerbose copyDir $ \\git -> do\n  run_ rsyncPath\n    [ \"-r\", \"--no-perms\", \"--no-owner\", \"--no-group\", \"--exclude\", \".git\"\n    , toTextIgnore (addTrailingPathSeparator origDir), toTextIgnore copyDir\n    ]\n  _ <- git [\"add\", \"--all\"]\n  _ <- git [\"commit\", \"-m\", \"Copy repo\"]\n  run_ chmodPath [\"-R\", \"u-w,g-rw,o-rw\", toTextIgnore copyDir] -- Freeze this state\n\nmain :: IO ()\nmain = do\n  -- Note: you can pass hspec arguments as well, eg: `-m <pattern>`\n  isVerbose <- elem \"-v\" <$> getArgs\n  unless isVerbose $\n    putStrLn \"Tests may take longer to run if there are unbuilt derivations: use -v for verbose output\"\n\n  obeliskImplDirtyReadOnly <- getCurrentDirectory\n  httpManager <- HTTP.newManager HTTP.defaultManagerSettings\n\n  withSystemTempDirectory \"obelisk-repo-git-remote\" $ \\copyDir -> do\n    copyForGitRemote isVerbose obeliskImplDirtyReadOnly copyDir\n    main' isVerbose httpManager copyDir\n\nmain' :: Bool -> HTTP.Manager -> FilePath -> IO ()\nmain' isVerbose httpManager obeliskRepoReadOnly = withInitCache $ \\initCache -> hspec $ parallel $ do\n  let\n    inTmpObInit' dirname f = inTmp' dirname $ \\dir -> do\n      run_ cpPath [\"-rT\", fromString initCache, toTextIgnore dir]\n      f dir\n    inTmpObInit = inTmpObInit' defaultTmpDirName\n\n    -- To be used in tests that change the obelisk impl directory\n    inTmpObInitWithImplCopy f = inTmpObInit $ \\dir ->\n      withObeliskImplClean $ \\(fromString -> implClean) -> do\n        run_ rmPath [thunk]\n        run_ lnPath [\"-s\", implClean, thunk]\n        f dir\n\n  describe \"ob init\" $ parallel $ do\n    it \"works with default impl\"       $ inTmp $ \\_ -> runOb [\"init\"]\n    it \"works with master branch impl\" $ inTmp $ \\_ -> runOb [\"init\", \"--branch\", \"master\"]\n    it \"works with symlink\"            $ inTmp $ \\_ -> runOb [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n    it \"doesn't silently overwrite existing files\" $ inTmp $ \\_ -> do\n      let p force = errExit False $ do\n            run_ ob $ \"--no-handoff\" : \"-v\" : \"init\" : [\"--force\"|force]\n            (== 0) <$> lastExitCode\n\n      True <- p False\n      False <- p False\n      True <- p True\n      pure ()\n\n    it \"doesn't create anything when given an invalid impl\" $ inTmp $ \\tmp -> do\n      void $ errExit False $ runOb [\"init\", \"--symlink\", \"/dev/null\"]\n      ls tmp >>= liftIO . assertEqual \"\" []\n\n    it \"produces a valid route config\" $ inTmpObInit $ \\tmp -> liftIO $\n      withCurrentDirectory (T.unpack $ toTextIgnore tmp) $ do\n        configs <- getConfigs\n        return (either (const Nothing) Just $ getConfigRoute configs) `shouldNotReturn` Nothing\n\n    it \"can unpack and repack .obelisk/impl after init with master branch impl\" $ inTmp $ \\_ -> do\n      runOb_ [\"init\", \"--branch\", \"master\"]\n      runOb_ [\"thunk\", \"unpack\", \".obelisk/impl\"]\n      runOb_ [\"thunk\", \"pack\", \".obelisk/impl\"]\n\n  -- These tests fail with \"Could not find module 'Obelisk.Generated.Static'\"\n  -- when not run by 'nix-build --attr selftest'\n  describe \"ob run\" $ {- NOT parallel $ -} do\n    it \"works in root directory\" $ inTmpObInit $ \\_ -> testObRunInDir' Nothing httpManager\n    it \"works in sub directory\" $ inTmpObInit $ \\_ -> testObRunInDir' (Just \"frontend\") httpManager\n    it \"can read external TLS certificates in root directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir Nothing\n    it \"can read external TLS certificates in sub directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir (Just \"frontend\")\n    it \"complains when static files are missing in root directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' Nothing\n    it \"complains when static files are missing in sub directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' (Just \"frontend\")\n    it \"complains when static filepaths are missing in root directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' Nothing\n    it \"complains when static filepaths are missing in sub directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' (Just \"frontend\")\n    it \"fails when given an invalid Cabal file\" $ inTmpObInit $ testObRunWithInvalidCabalFile ob\n\n    it \"respects the port given on the command line\" $ inTmpObInit $ \\testDir -> do\n      [port] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandles ob [\"run\", \"-p\", T.pack (show port)] [] $ \\_stdin stdout stderr -> do\n        uri <- handleObRunStdout httpManager stdout stderr\n        -- Make sure obelisk logs the right thing\n        unless (T.pack (show port ++ \"/\") `T.isSuffixOf` T.strip uri) $\n          error $ \"Expected the URI to end in \" ++ show port ++ \" but it ended in \" ++ T.unpack uri\n        -- But also verify that we can actually reach the server in the\n        -- given path, rather than just listening for the log URL\n        let req = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n        req >>= \\case\n          Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n          e -> errorExit $ \"Request to ob run failed: \" <> T.pack (show e)\n        exit 0\n\n  describe \"ob repl\" $ do\n    it \"accepts stdin commands\" $ inTmpObInit $ \\_ -> do\n      setStdin \"print 3\\n:q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        [ \"*Obelisk.Run Obelisk.Run Frontend Backend> 3\"\n        , \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\"\n        ] `isInfixOf` T.lines (T.strip output)\n    it \"works with custom Prelude\" $ inTmpObInit $ \\_ -> do\n      writefile \"common/src/Prelude.hs\"\n        \"{-# LANGUAGE PackageImports #-} module Prelude (module X) where import \\\"base\\\" Prelude as X\"\n      setStdin \":q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\" `T.isInfixOf` output\n\n  describe \"obelisk project\" $ parallel $ do\n    it \"can build obelisk command\"  $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"command\" , toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk skeleton\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"skeleton\", toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk shell\"    $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"shell\",    toTextIgnore obeliskRepoReadOnly]\n    it \"can build everything\"       $ inTmpObInit $ \\_ -> nixBuild [toTextIgnore obeliskRepoReadOnly]\n\n  describe \"blank initialized project\" $ parallel $ do\n\n    it \"can build ghc.backend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghc.backend\"]\n    it \"can build ghcjs.frontend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghcjs.frontend\"]\n\n    if System.Info.os == \"darwin\"\n      then it \"can build ios\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ios.frontend\"]\n      else it \"can build android after accepting license\" $ inTmpObInit $ \\dir -> do\n        let defaultNixPath = dir </> (\"default.nix\" :: FilePath)\n        writefile defaultNixPath\n          =<< T.replace\n            \"# config.android_sdk.accept_license = false;\"\n            \"config.android_sdk.accept_license = true;\"\n          <$> readfile defaultNixPath\n        nixBuild [\"-A\", \"android.frontend\"]\n\n    forM_ [\"ghc\", \"ghcjs\"] $ \\compiler -> do\n      let\n        shellName = \"shells.\" <> compiler\n        inShell cmd' = run_ \"nix-shell\" [\"default.nix\", \"-A\", fromString shellName, \"--run\", cmd']\n      it (\"can enter \"    <> shellName) $ inTmpObInit $ \\_ -> inShell \"exit\"\n      -- NOTE: We override the temporary directory name because cabal has a bug preventing new-build from working\n      -- in a path that has unicode characters.\n      it (\"can build in \" <> shellName) $ inTmpObInit' \"test\" $ \\_ -> inShell $\n          T.pack cabalPath <> \" --version; \" <> T.pack cabalPath <> \" new-build --\" <> T.pack compiler <> \" all\"\n\n    it \"has idempotent thunk update\" $ inTmpObInitWithImplCopy $ \\_ -> do\n      _  <- pack\n      u  <- update\n      uu <- update\n      assertRevEQ u uu\n\n    it \"can run 'ob doc'\" $ inTmpObInit $ \\_ -> runOb_ [\"doc\", \"reflex\"]\n\n  describe \"ob thunk pack/unpack\" $ parallel $ do\n    it \"has thunk pack and unpack inverses\" $ inTmpObInitWithImplCopy $ \\_ -> do\n\n      _    <- pack\n      e    <- commitAll\n      eu   <- unpack\n      eup  <- pack\n      eupu <- unpack\n      _    <- pack\n\n      assertRevEQ e  eup\n      assertRevEQ eu eupu\n      assertRevNE e  eu\n\n    it \"unpacks the correct branch\" $ withTmp $ \\dir -> do\n      let branch = \"master\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch]\n      runOb_ [\"thunk\", \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"unpack\", toTextIgnore dir]\n      branch' <- run gitPath [\"-C\", toTextIgnore $ dir </> unpackedDirName, \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n      liftIO $ assertEqual \"\" branch (T.strip branch')\n\n    it \"can pack and unpack plain git repos\" $\n      shelly_ $ withSystemTempDirectory \"git-repo\" $ \\dir -> do\n        let repo = toTextIgnore $ dir </> (\"repo\" :: FilePath)\n        run_ gitPath [\"clone\", \"https://github.com/haskell/process.git\", repo]\n        origHash <- chdir (fromText repo) revParseHead\n\n        runOb_ [\"thunk\", \"pack\", repo]\n        packedFiles <- Set.fromList <$> ls (fromText repo)\n        liftIO $ assertEqual \"\" packedFiles $ Set.fromList $ (repo </>) <$>\n          [\"default.nix\", \"thunk.nix\", \"github.json\" :: FilePath]\n\n        runOb_ [\"thunk\", \"unpack\", repo]\n        chdir (fromText repo </> unpackedDirName) $ do\n          unpackHash <- revParseHead\n          assertRevEQ origHash unpackHash\n\n        testThunkPack' $ fromText repo\n\n    it \"aborts thunk pack when there are uncommitted files\" $ inTmpObInitWithImplCopy $ \\dir -> do\n      testThunkPack' (dir </> thunk)\n\n    it \"works on legacy git thunks\" $ testLegacyGitThunks isVerbose\n\n  describe \"ob thunk update --branch\" $ parallel $ do\n    it \"can change a thunk to the latest version of a desired branch\" $ withTmp $ \\dir -> do\n      let branch1 = \"master\"\n          branch2 = \"develop\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch1]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", branch2]\n\n    it \"doesn't create anything when given an invalid branch\" $ withTmp $ \\dir -> do\n      let checkDir dir' = liftIO $ getDirectoryContents $ T.unpack $ toTextIgnore dir'\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", \"master\"]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      startingContents <- checkDir dir\n      void $ errExit False $ runOb [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", \"dumble-palooza\"]\n      checkDir dir >>= liftIO . assertEqual \"\" startingContents\n\n  describe \"ob shell\" $ parallel $ do\n    it \"works with --\" $ inTmpObInit $ \\_ -> do\n      output <- runOb [\"shell\", \"--\", \"ghc-pkg\", \"list\"]\n      liftIO $ assertBool \"Unexpected output from ob shell\" $ (\"Cabal-\" `T.isInfixOf` output) && (\"ghc-\" `T.isInfixOf` output)\n\n  describe \"ob hoogle\" $ {- NOT parallel -} do\n    it \"starts a hoogle server on the given port\" $ inTmpObInit $ \\_ -> do\n      [p0] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandle \"ob\" [\"hoogle\", \"--port\", T.pack (show p0)] $ \\stdout -> flip fix Nothing $ \\loop -> \\case\n        Nothing -> do -- Still waiting for initial signal that the server has started\n          ln <- liftIO $ T.hGetLine stdout\n          let search = \"Server starting on port \" <> T.pack (show p0)\n          case search `T.isInfixOf` ln of\n            False -> loop Nothing -- keep waiting\n            True -> loop $ Just 10\n        Just (n :: Int) -> do -- Server has started and we have n attempts left\n          let req uri = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest uri >>= flip HTTP.httpLbs httpManager\n          req (\"http://127.0.0.1:\" <> show p0) >>= \\case\n            Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n            e -> if n <= 0\n              then errorExit $ \"Request to hoogle server failed: \" <> T.pack (show e)\n              else liftIO (threadDelay (1*10^(6 :: Int))) *> loop (Just $ n - 1)\n  where\n    verbosity = bool silently verbosely isVerbose\n    nixBuild args = run nixBuildPath (\"--no-out-link\" : args)\n\n    runOb_ = augmentWithVerbosity run_ ob isVerbose\n    runOb = augmentWithVerbosity run ob isVerbose\n    testObRunInDir' = augmentWithVerbosity testObRunInDir ob isVerbose [\"run\"]\n    testObRunCert' = augmentWithVerbosity testObRunCert ob isVerbose [\"run\", \"-c\", \".\"]\n    testObRunInDirWithMissingStaticFile' = augmentWithVerbosity testObRunInDirWithMissingStaticFile ob isVerbose [\"run\"]\n    testObRunInDirWithMissingStaticFilePath' = augmentWithVerbosity testObRunInDirWithMissingStaticFilePath ob isVerbose [\"run\"]\n    testThunkPack' = augmentWithVerbosity testThunkPack ob isVerbose []\n\n    withObeliskImplClean f =\n      withSystemTempDirectory \"obelisk-impl-clean\" $ \\obeliskImpl -> do\n        void . shellyOb verbosity $ do\n          dirtyFiles <- T.strip <$> run gitPath [\"-C\", toTextIgnore obeliskRepoReadOnly, \"diff\", \"--stat\"]\n          () <- when (dirtyFiles /= \"\") $ error \"SelfTest does not work correctly with dirty obelisk repos as remote\"\n          run_ gitPath [\"clone\", \"file://\" <> toTextIgnore obeliskRepoReadOnly, toTextIgnore obeliskImpl]\n        f obeliskImpl\n\n    withInitCache f =\n      withSystemTempDirectory \"init Cache \u03bb\" $ \\initCache -> do\n        -- Setup the ob init cache\n        void . shellyOb verbosity $ chdir initCache $ do\n          runOb_ [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n          run_ gitPath [\"init\"]\n\n        f initCache\n\n    shelly_ = void . shellyOb verbosity\n\n    defaultTmpDirName = \"test \u03bb\"\n\n    inTmp' :: FilePath -> (FilePath -> Sh a) -> IO ()\n    inTmp' dirname f = withTmp' dirname (chdir <*> f)\n    inTmp = inTmp' defaultTmpDirName\n\n    withTmp' dirname f = shelly_ . withSystemTempDirectory dirname $ f . fromString\n    withTmp = withTmp' defaultTmpDirName\n\n    assertRevEQ a b = liftIO . assertEqual \"\" \"\"        =<< diff a b\n    assertRevNE a b = liftIO . assertBool  \"\" . (/= \"\") =<< diff a b\n\n    revParseHead = T.strip <$> run gitPath [\"rev-parse\", \"HEAD\"]\n\n    commitAll = do\n      run_ gitPath [\"add\", \".\"]\n      commit \"checkpoint\"\n      revParseHead\n\n    thunk  = \".obelisk/impl\"\n    update = runOb [\"thunk\", \"update\", thunk] *> commitAll\n    pack   = runOb [\"thunk\", \"pack\",   thunk] *> commitAll\n    unpack = runOb [\"thunk\", \"unpack\", thunk] *> commitAll\n\n    diff a b = run gitPath [\"diff\", a, b]\n\n\nmaskExitSuccess :: Sh () -> Sh ()\nmaskExitSuccess = handle_sh (\\case ExitSuccess -> pure (); e -> throw e)\n\n-- | Run `ob run` in the given directory (maximum of one level deep)\ntestObRunInDir :: String -> [Text] -> Maybe FilePath -> HTTP.Manager -> Sh ()\ntestObRunInDir executable extraArgs mdir httpManager = maskExitSuccess $ do\n  [p0, p1] <- liftIO $ getFreePorts 2\n  let uri p = \"http://localhost:\" <> T.pack (show p) <> \"/\" -- trailing slash required for comparison\n  writefile \"config/common/route\" $ uri p0\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    firstUri <- handleObRunStdout httpManager stdout stderr\n    let newUri = uri p1\n    when (firstUri == newUri) $ errorExit $\n      \"Startup URI (\" <> firstUri <> \") is the same as test URI (\" <> newUri <> \")\"\n    maybe id (\\_ -> chdir \"..\") mdir $ alterRouteTo newUri stdout\n    runningUri <- handleObRunStdout httpManager stdout stderr\n    if runningUri /= newUri\n      then errorExit $ \"Reloading failed: expected \" <> newUri <> \" but got \" <> runningUri\n      else exit 0\n\ntestObRunCert :: String -> [Text] -> FilePath -> Maybe FilePath -> Sh ()\ntestObRunCert executable extraArgs testDir mdir = maskExitSuccess $ do\n  -- Generate a TLS key, and then a self-signed certificate using that key\n  mapM_ (\\cmd -> run_ \"nix-shell\" [\"-p\", \"openssl\", \"--command\", cmd])\n    [ \"openssl genrsa -out key.pem 2048\"\n    , \"openssl req -new -key key.pem -out certificate.csr -subj \\\"/C=US/ST=New York/L=New York/O=Development/OU=IT Department/CN=obsidian.com\\\"\"\n    , \"openssl x509 -req -in certificate.csr -signkey key.pem -out cert.pem\"\n    ]\n\n  -- One more command is required, for generating the chain.pem file.\n  -- For testing purposes, we'll keep it the same as the cert.pem file.\n  run_ \"cp\" [\"cert.pem\", \"chain.pem\"]\n\n  -- Also need to change the route inside config/common/route to https\n  -- in order to trigger the certificates option (the -c option is not honored for http)\n  writefile \"config/common/route\" \"https://localhost:8000\"\n\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_ stdout _ -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      isEOF <- liftIO $ hIsEOF h\n      if isEOF\n        then errorExit \"Obelisk exited somehow\"\n        else do\n          line <- liftIO $ hGetLineSkipBlanks h\n          check line h\n\n    -- Here we check that the certificates are read properly by Obelisk\n    -- In case the server is started without reading the certificates, show an error.\n    check line h\n      | \"Using certificate information from:\" `T.isPrefixOf` line = do\n        -- Should be followed by a `Frontend running on <url>` line\n        next <- liftIO $ hGetLineSkipBlanks h\n        if \"Frontend running on\" `T.isPrefixOf` next\n          then exit 0\n          else errorExit $ \"Ran into error: \" <> next\n      | \"Frontend running on\" `T.isPrefixOf` line = errorExit \"Obelisk did not read the certificates provided via -c option\"\n      | otherwise = parseObOutput h\n\n-- | Mess up the Cabal file in the given directory, then make sure that\n-- @ob run@ fails.\ntestObRunWithInvalidCabalFile\n  :: FilePath  -- ^ Obelisk path\n  -> FilePath  -- ^ Directory path (will be made invalid)\n  -> Sh ()\ntestObRunWithInvalidCabalFile executable fp = do\n  let commonCabal :: String\n      commonCabal = \"common/common.cabal\"\n  liftIO $ writeFile (fp </> commonCabal) \"This is not a valid Cabal file.\"\n  errExit False $ do\n    runHandles executable [\"run\"] [] $ \\_ _ _ -> pure ()\n    lastExitCode >>= \\case\n      0 -> pure ()\n      _ -> errorExit \"ob run succeeded even with an invalid Cabal file\"\n\n-- | Check whether embedding a non-existent filepath into an obelisk\n-- project is detected correctly and generates a compile-time error.\n--\n-- @'testObRunInDirWithMissingStaticFileWorker' exe args mdir act checkErrorMessage@.\n--\n-- @checkErrorMessage line1 line2@ is invoked on a compile-time error message of the following form:\n--     frontend/src/Frontend.hs:40:32: error:\n--        \u2022 Static file obelisk.jpg was not found in static.out\n--        \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n--       |\n--    40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n--       |\n--\n-- the arguments to @line1@ and @line2@ contain:\n--\n-- @    \u2022 Static file obelisk.jpg was not found in static.out@\n--\n-- and\n--\n-- @    \u2022 In the untyped splice: $(static \"obelisk.jpg\")@\n--\n-- respectively.\ntestObRunInDirWithMissingStaticFileWorker\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\n  -- ^ Run this action before running @ob run@.\n  -- Gives you the opportunity to modify the project to trigger events.\n  -- In particular, make sure static files do not exist, s.t. a compilation\n  -- error is thrown.\n  -> (Text -> Text -> Sh ())\n  -- ^ Assertion function for error messages.\n  -- Since this function is used for asserting error message contents,\n  -- this function specifies what contents two consecutive non-empty lines\n  -- are supposed to have.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkErrorMessage = maskExitSuccess $ do\n  act\n  -- Now run `ob run` and read the error\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      line <- liftIO $ hGetLineSkipBlanks h\n      -- This means that everything was successful, this should not be the case\n      if line == \"Running test...\"\n        then errorExit \"Could not find any error related to static files\"\n        else checkForErrors line h\n\n    -- As can be seen in the example below, we can parse a lot of data.\n    -- For simplicity, we parse the two lines after the `error:` line.\n    -- We also ensure that the file name is same, as the file that we changed ie `obelisk.jpg`\n    checkForErrors line h\n      -- Found an error, check if it is due to static.out\n      | \"error:\" `T.isSuffixOf` line = do\n        line1 <- liftIO $ hGetLineSkipBlanks h\n        line2 <- liftIO $ hGetLineSkipBlanks h\n        checkErrorMessage line1 line2\n      | otherwise = parseObOutput h\n\n-- | Run an obelisk test-case, where @static@ is embedding an non-existent\n-- filepath.\ntestObRunInDirWithMissingStaticFile\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFile executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(static \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\n-- | Run an obelisk test-case, where @staticFilePath@ is embedding an\n-- non-existent filepath.\ntestObRunInDirWithMissingStaticFilePath\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFilePath executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = do\n      run_ sedPath [\"-e\", \"s/\\\\$(static /\\\\$(staticFilePath /\", \"-i\", \"frontend/src/Frontend.hs\"]\n      run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(staticFilePath \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(staticFilePath \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(staticFilePath \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\ntestThunkPack :: String -> [Text] -> FilePath -> Sh ()\ntestThunkPack executable args path' = withTempFile repoDir \"test-file\" $ \\file handle -> do\n  let\n    pack' = readProcessWithExitCode executable ([\"thunk\", \"pack\", path'] ++ map T.unpack args) \"\"\n    ensureThunkPackFails q = liftIO $ pack' >>= \\case\n      (code, out, err)\n        | code == ExitSuccess -> fail $ \"ob thunk pack succeeded when it should have failed with error '\" <> show q <> \"'\"\n        | q `T.isInfixOf` T.pack (out <> err) -> pure ()\n        | otherwise -> fail $ \"ob thunk pack failed for an unexpected reason, expecting '\" <> show q <> \"', received: \" <> show out <> \"\\nstderr: \" <> err\n    git = chdir repoDir . run_ gitPath\n  -- Untracked files\n  ensureThunkPackFails \"Untracked files\"\n  git [\"add\", T.pack file]\n  -- Uncommitted files (staged)\n  ensureThunkPackFails \"unsaved\"\n  chdir repoDir $ commit \"test commit\"\n  -- Non-pushed commits in any branch\n  ensureThunkPackFails \"not yet pushed\"\n  -- Uncommitted files (unstaged)\n  liftIO $ T.hPutStrLn handle \"test file\" >> hClose handle\n  ensureThunkPackFails \"modified\"\n  -- Existing stashes\n  git $ gitUserConfig <> [ \"stash\" ]\n  ensureThunkPackFails \"has stashes\"\n  where\n    repoDir = path' </> unpackedDirName\n\n-- | Blocks until a non-empty line is available\nhGetLineSkipBlanks :: MonadIO m => Handle -> m Text\nhGetLineSkipBlanks h = liftIO $ fix $ \\loop -> T.hGetLine h >>= \\case\n  \"\" -> loop\n  t -> pure t\n\n-- | Alters the route file and waits for `ob run` to reload\nalterRouteTo :: Text -> Handle -> Sh ()\nalterRouteTo uri stdout = do\n  writefile \"config/common/route\" uri\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Reloading...\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"  config/common/route\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Interrupted.\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n\n-- | Handle stdout of `ob run`: check that the frontend and backend servers are started correctly\nhandleObRunStdout :: HTTP.Manager -> Handle -> Handle -> Sh Text\nhandleObRunStdout httpManager stdout stderr = flip fix (ObRunState_Init, []) $ \\loop (state, msgs) -> do\n  isEOF <- liftIO $ hIsEOF stdout\n  if isEOF\n  then handleObRunError msgs\n  else liftIO (T.hGetLine stdout) >>= \\t -> case state of\n    ObRunState_Init\n      | \"Running test...\" `T.isPrefixOf` t -> loop (ObRunState_BackendStarted, msgs)\n    ObRunState_Startup\n      | t == \"backend stopped; make a change to your code to reload\" -> loop (ObRunState_Startup, msgs)\n      -- | Just port <- \"Backend running on port \" `T.stripPrefix` t -> loop $ ObRunState_BackendStarted port\n      | not (T.null t) -> errorExit $ \"Startup: \" <> t -- If theres any other output here, startup failed\n    ObRunState_BackendStarted\n      | Just uri <- \"Frontend running on \" `T.stripPrefix` t -> do\n        obRunCheck httpManager stdout uri\n        pure uri\n      | not (T.null t) -> errorExit $ \"Started: \" <> t -- If theres any other output here, startup failed\n    _ | \"Failed\" `T.isPrefixOf` t -> handleObRunError (t : msgs)\n      | otherwise -> loop (state, t : msgs)\n  where\n    handleObRunError msgs = do\n      stderrContent <- liftIO $ hGetContents stderr\n      errorExit $ \"ob run failed: \" <> T.unlines (reverse msgs) <> \" stderr: \" <> T.pack stderrContent\n\n-- | Make requests to frontend/backend servers to check they are working properly\nobRunCheck :: HTTP.Manager -> Handle -> Text -> Sh ()\nobRunCheck httpManager _stdout frontendUri = do\n  let req uri = liftIO $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n  req frontendUri >>= \\r -> when (HTTP.responseStatus r /= HTTP.ok200) $ errorExit $\n    \"Request to frontend server failed: \" <> T.pack (show r)\n\ngetFreePorts :: Int -> IO [Socket.PortNumber]\ngetFreePorts 0 = pure []\ngetFreePorts n = Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close $ \\s -> (:) <$> Socket.socketPort s <*> getFreePorts (n - 1)\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      pure sock\n\ntestLegacyGitThunks :: Bool -> IO ()\ntestLegacyGitThunks isVerbose = withSystemTempDirectory \"test-git-repo\" $ \\gitDir -> do\n  isolatedGitShell isVerbose gitDir $ \\git -> do\n    writefile (gitDir </> (\"default.nix\" :: FilePath)) \"{}: \\\"hello\\\"\"\n    _ <- git [\"add\", \"--all\"]\n    _ <- git [\"commit\", \"-m\", \"Initial commit\"]\n    rev <- T.strip <$> git [\"rev-parse\", \"HEAD\"]\n    sha256 :: Text\n      <-  either error pure\n      =<< (Aeson.parseEither (Aeson..: \"sha256\") <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n      <$> run nixPrefetchGitPath [toTextIgnore gitDir]\n\n    for_ (legacyGitThunks (GitThunkParams gitDir rev sha256)) $ \\mkFiles ->\n      withSystemTempDirectory \"test-thunks\" $ \\thunkDir -> do\n        liftIO $ mkFiles thunkDir\n        run_ \"ob\" [\"thunk\", \"unpack\", toTextIgnore thunkDir]\n        run_ \"ob\" [\"thunk\", \"pack\", toTextIgnore thunkDir]\n\ndata GitThunkParams = GitThunkParams\n  { _gitThunkParams_repo :: !FilePath\n  , _gitThunkParams_rev :: !Text\n  , _gitThunkParams_sha256 :: !Text\n  } deriving Show\n\nlegacyGitThunks :: GitThunkParams -> [FilePath -> IO ()]\nlegacyGitThunks (GitThunkParams repo' rev sha256) =\n  [ mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  assert !fetchSubmodules; (import <nixpkgs> {}).fetchgit { inherit url rev sha256; };\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  if builtins.hasAttr \\\"fetchGit\\\" builtins\"\n        , \"    then builtins.fetchGit ({ inherit url rev; } // (if branch == null then {} else { ref = branch; }))\"\n        , \"    else abort \\\"Plain Git repositories are only supported on nix 2.0 or higher.\\\";\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, ref ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, branch ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"    ${if branch == null then null else \\\"ref\\\"} = branch;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  ]\n  where\n    repo = T.pack repo'\n    mkLegacyIO :: Aeson.ToJSON v => Text -> Map.Map Text v -> FilePath -> IO ()\n    mkLegacyIO defaultNix gitJson dir = do\n      T.writeFile (dir </> (\"default.nix\" :: FilePath)) defaultNix\n      LBS.writeFile (dir </> (\"git.json\" :: FilePath)) (Aeson.encode gitJson)\n\nunpackedDirName :: FilePath\nunpackedDirName = \".\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs:(50,1)-(54,21)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data ObRunState",
                    "    = ObRunState_Init | ObRunState_Startup | ObRunState_BackendStarted",
                    "    deriving (Eq, Show)"
                  ],
                  "perhaps_block": [
                    "  data ObRunState",
                    "    = ObRunStateInit | ObRunStateStartup | ObRunStateBackendStarted",
                    "    deriving (Eq, Show)"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs:(368,11)-(370,34)",
                  "suggestion_title": "Use if",
                  "found_block": [
                    "  case search `T.isInfixOf` ln of",
                    "    False -> loop Nothing",
                    "    True -> loop $ Just 10"
                  ],
                  "perhaps_block": [
                    "  (if search `T.isInfixOf` ln then loop $ Just 10 else loop Nothing)"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE DoAndIfThenElse #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.SelfTest where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Exception (bracket, throw, try)\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Aeson.Types as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as LBS\nimport Data.Foldable (for_)\nimport Data.Function (fix)\nimport Data.List (isInfixOf)\nimport qualified Data.Map as Map\nimport Data.Semigroup ((<>))\nimport qualified Data.Set as Set\nimport Data.String\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.IO as T\nimport qualified Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Socket as Socket\nimport Shelly\nimport System.Directory (getCurrentDirectory, withCurrentDirectory, getDirectoryContents)\nimport System.Environment\nimport System.Exit (ExitCode (..))\nimport System.FilePath (addTrailingPathSeparator)\nimport qualified System.Info\nimport System.IO (Handle, hClose, hIsEOF, hGetContents)\nimport System.IO.Temp\nimport System.Process (readProcessWithExitCode)\nimport System.Which (staticWhich)\nimport Test.Hspec\nimport Test.HUnit.Base\n\nimport Obelisk.ExecutableConfig.Lookup (getConfigs)\nimport Obelisk.Run (getConfigRoute)\n\ndata ObRunState\n  = ObRunState_Init\n  | ObRunState_Startup\n  | ObRunState_BackendStarted\n  deriving (Eq, Show)\n\ncpPath :: FilePath\ncpPath = $(staticWhich \"cp\")\n\ncabalPath :: FilePath\ncabalPath = $(staticWhich \"cabal\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nchownPath :: FilePath\nchownPath = $(staticWhich \"chown\")\n\nchmodPath :: FilePath\nchmodPath = $(staticWhich \"chmod\")\n\nwhoamiPath :: FilePath\nwhoamiPath = $(staticWhich \"whoami\")\n\nnixInstantiatePath :: FilePath\nnixInstantiatePath = $(staticWhich \"nix-instantiate\")\n\nnixBuildPath :: FilePath\nnixBuildPath = $(staticWhich \"nix-build\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nsedPath :: FilePath\nsedPath = $(staticWhich \"sed\")\n\ngitUserConfig :: [Text]\ngitUserConfig = [\"-c\", \"user.name=Obelisk Selftest\", \"-c\", \"user.email=noreply@example.com\"]\n\ncommit :: Text -> Sh ()\ncommit msg = void $ run gitPath $ gitUserConfig <> [ \"commit\"\n  , \"--no-gpg-sign\"\n  , \"--allow-empty\"\n  , \"-m\"\n  , msg\n  ]\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\n-- | Like `shelly` but used when running `ob` commands\nshellyOb :: MonadIO m => (Sh a -> Sh a) -> Sh a -> m a\nshellyOb f obTest = shelly $ f obTest\n\n-- Set \"ob\" in a single place so it can be replaced with a\n-- link to obelisk in the nix store in the future,\n-- and avoid PATH hacking before calling this script.\nob :: FilePath\nob = \"ob\"\n\naugmentWithVerbosity :: (String -> [Text] -> a) -> String -> Bool -> [Text] -> a\naugmentWithVerbosity runner executable isVerbose args = runner executable $ (if isVerbose then (\"-v\" :) else id) args\n\nisolatedGitShell :: Bool -> FilePath -> (([Text] -> Sh Text) -> Sh a) -> IO a\nisolatedGitShell isVerbose dir f = shelly $ bool silently verbosely isVerbose $ do\n  setenv \"HOME\" \"/dev/null\"\n  setenv \"GIT_CONFIG_NOSYSTEM\" \"1\"\n  _ <- git [\"init\"]\n  _ <- git [\"config\", \"user.name\", \"SelfTest\"]\n  _ <- git [\"config\", \"user.email\", \"self@test\"]\n  f git\n  where\n    git args = run gitPath $ [\"-C\", toTextIgnore dir] <> args\n\n-- | Copies a git repo to a new location and \"resets\" the git history to include\n-- exactly one commit with all files added. It then restricts writing and reading\n-- for group and user to make the repo ideal for being a valid git remote for thunks.\n--\n-- Using this allows dirty repos to be used as git remotes during the test since 'git clone'ing\n-- a dirty repo will not include the uncommitted changes.\ncopyForGitRemote :: Bool -> FilePath -> FilePath -> IO ()\ncopyForGitRemote isVerbose origDir copyDir = isolatedGitShell isVerbose copyDir $ \\git -> do\n  run_ rsyncPath\n    [ \"-r\", \"--no-perms\", \"--no-owner\", \"--no-group\", \"--exclude\", \".git\"\n    , toTextIgnore (addTrailingPathSeparator origDir), toTextIgnore copyDir\n    ]\n  _ <- git [\"add\", \"--all\"]\n  _ <- git [\"commit\", \"-m\", \"Copy repo\"]\n  run_ chmodPath [\"-R\", \"u-w,g-rw,o-rw\", toTextIgnore copyDir] -- Freeze this state\n\nmain :: IO ()\nmain = do\n  -- Note: you can pass hspec arguments as well, eg: `-m <pattern>`\n  isVerbose <- elem \"-v\" <$> getArgs\n  unless isVerbose $\n    putStrLn \"Tests may take longer to run if there are unbuilt derivations: use -v for verbose output\"\n\n  obeliskImplDirtyReadOnly <- getCurrentDirectory\n  httpManager <- HTTP.newManager HTTP.defaultManagerSettings\n\n  withSystemTempDirectory \"obelisk-repo-git-remote\" $ \\copyDir -> do\n    copyForGitRemote isVerbose obeliskImplDirtyReadOnly copyDir\n    main' isVerbose httpManager copyDir\n\nmain' :: Bool -> HTTP.Manager -> FilePath -> IO ()\nmain' isVerbose httpManager obeliskRepoReadOnly = withInitCache $ \\initCache -> hspec $ parallel $ do\n  let\n    inTmpObInit' dirname f = inTmp' dirname $ \\dir -> do\n      run_ cpPath [\"-rT\", fromString initCache, toTextIgnore dir]\n      f dir\n    inTmpObInit = inTmpObInit' defaultTmpDirName\n\n    -- To be used in tests that change the obelisk impl directory\n    inTmpObInitWithImplCopy f = inTmpObInit $ \\dir ->\n      withObeliskImplClean $ \\(fromString -> implClean) -> do\n        run_ rmPath [thunk]\n        run_ lnPath [\"-s\", implClean, thunk]\n        f dir\n\n  describe \"ob init\" $ parallel $ do\n    it \"works with default impl\"       $ inTmp $ \\_ -> runOb [\"init\"]\n    it \"works with master branch impl\" $ inTmp $ \\_ -> runOb [\"init\", \"--branch\", \"master\"]\n    it \"works with symlink\"            $ inTmp $ \\_ -> runOb [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n    it \"doesn't silently overwrite existing files\" $ inTmp $ \\_ -> do\n      let p force = errExit False $ do\n            run_ ob $ \"--no-handoff\" : \"-v\" : \"init\" : [\"--force\"|force]\n            (== 0) <$> lastExitCode\n\n      True <- p False\n      False <- p False\n      True <- p True\n      pure ()\n\n    it \"doesn't create anything when given an invalid impl\" $ inTmp $ \\tmp -> do\n      void $ errExit False $ runOb [\"init\", \"--symlink\", \"/dev/null\"]\n      ls tmp >>= liftIO . assertEqual \"\" []\n\n    it \"produces a valid route config\" $ inTmpObInit $ \\tmp -> liftIO $\n      withCurrentDirectory (T.unpack $ toTextIgnore tmp) $ do\n        configs <- getConfigs\n        return (either (const Nothing) Just $ getConfigRoute configs) `shouldNotReturn` Nothing\n\n    it \"can unpack and repack .obelisk/impl after init with master branch impl\" $ inTmp $ \\_ -> do\n      runOb_ [\"init\", \"--branch\", \"master\"]\n      runOb_ [\"thunk\", \"unpack\", \".obelisk/impl\"]\n      runOb_ [\"thunk\", \"pack\", \".obelisk/impl\"]\n\n  -- These tests fail with \"Could not find module 'Obelisk.Generated.Static'\"\n  -- when not run by 'nix-build --attr selftest'\n  describe \"ob run\" $ {- NOT parallel $ -} do\n    it \"works in root directory\" $ inTmpObInit $ \\_ -> testObRunInDir' Nothing httpManager\n    it \"works in sub directory\" $ inTmpObInit $ \\_ -> testObRunInDir' (Just \"frontend\") httpManager\n    it \"can read external TLS certificates in root directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir Nothing\n    it \"can read external TLS certificates in sub directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir (Just \"frontend\")\n    it \"complains when static files are missing in root directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' Nothing\n    it \"complains when static files are missing in sub directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' (Just \"frontend\")\n    it \"complains when static filepaths are missing in root directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' Nothing\n    it \"complains when static filepaths are missing in sub directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' (Just \"frontend\")\n    it \"fails when given an invalid Cabal file\" $ inTmpObInit $ testObRunWithInvalidCabalFile ob\n\n    it \"respects the port given on the command line\" $ inTmpObInit $ \\testDir -> do\n      [port] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandles ob [\"run\", \"-p\", T.pack (show port)] [] $ \\_stdin stdout stderr -> do\n        uri <- handleObRunStdout httpManager stdout stderr\n        -- Make sure obelisk logs the right thing\n        unless (T.pack (show port ++ \"/\") `T.isSuffixOf` T.strip uri) $\n          error $ \"Expected the URI to end in \" ++ show port ++ \" but it ended in \" ++ T.unpack uri\n        -- But also verify that we can actually reach the server in the\n        -- given path, rather than just listening for the log URL\n        let req = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n        req >>= \\case\n          Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n          e -> errorExit $ \"Request to ob run failed: \" <> T.pack (show e)\n        exit 0\n\n  describe \"ob repl\" $ do\n    it \"accepts stdin commands\" $ inTmpObInit $ \\_ -> do\n      setStdin \"print 3\\n:q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        [ \"*Obelisk.Run Obelisk.Run Frontend Backend> 3\"\n        , \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\"\n        ] `isInfixOf` T.lines (T.strip output)\n    it \"works with custom Prelude\" $ inTmpObInit $ \\_ -> do\n      writefile \"common/src/Prelude.hs\"\n        \"{-# LANGUAGE PackageImports #-} module Prelude (module X) where import \\\"base\\\" Prelude as X\"\n      setStdin \":q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\" `T.isInfixOf` output\n\n  describe \"obelisk project\" $ parallel $ do\n    it \"can build obelisk command\"  $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"command\" , toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk skeleton\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"skeleton\", toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk shell\"    $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"shell\",    toTextIgnore obeliskRepoReadOnly]\n    it \"can build everything\"       $ inTmpObInit $ \\_ -> nixBuild [toTextIgnore obeliskRepoReadOnly]\n\n  describe \"blank initialized project\" $ parallel $ do\n\n    it \"can build ghc.backend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghc.backend\"]\n    it \"can build ghcjs.frontend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghcjs.frontend\"]\n\n    if System.Info.os == \"darwin\"\n      then it \"can build ios\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ios.frontend\"]\n      else it \"can build android after accepting license\" $ inTmpObInit $ \\dir -> do\n        let defaultNixPath = dir </> (\"default.nix\" :: FilePath)\n        writefile defaultNixPath . T.replace\n            \"# config.android_sdk.accept_license = false;\"\n            \"config.android_sdk.accept_license = true;\" =<< readfile defaultNixPath\n        nixBuild [\"-A\", \"android.frontend\"]\n\n    forM_ [\"ghc\", \"ghcjs\"] $ \\compiler -> do\n      let\n        shellName = \"shells.\" <> compiler\n        inShell cmd' = run_ \"nix-shell\" [\"default.nix\", \"-A\", fromString shellName, \"--run\", cmd']\n      it (\"can enter \"    <> shellName) $ inTmpObInit $ \\_ -> inShell \"exit\"\n      -- NOTE: We override the temporary directory name because cabal has a bug preventing new-build from working\n      -- in a path that has unicode characters.\n      it (\"can build in \" <> shellName) $ inTmpObInit' \"test\" $ \\_ -> inShell $\n          T.pack cabalPath <> \" --version; \" <> T.pack cabalPath <> \" new-build --\" <> T.pack compiler <> \" all\"\n\n    it \"has idempotent thunk update\" $ inTmpObInitWithImplCopy $ \\_ -> do\n      _  <- pack\n      u  <- update\n      uu <- update\n      assertRevEQ u uu\n\n    it \"can run 'ob doc'\" $ inTmpObInit $ \\_ -> runOb_ [\"doc\", \"reflex\"]\n\n  describe \"ob thunk pack/unpack\" $ parallel $ do\n    it \"has thunk pack and unpack inverses\" $ inTmpObInitWithImplCopy $ \\_ -> do\n\n      _    <- pack\n      e    <- commitAll\n      eu   <- unpack\n      eup  <- pack\n      eupu <- unpack\n      _    <- pack\n\n      assertRevEQ e  eup\n      assertRevEQ eu eupu\n      assertRevNE e  eu\n\n    it \"unpacks the correct branch\" $ withTmp $ \\dir -> do\n      let branch = \"master\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch]\n      runOb_ [\"thunk\", \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"unpack\", toTextIgnore dir]\n      branch' <- run gitPath [\"-C\", toTextIgnore $ dir </> unpackedDirName, \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n      liftIO $ assertEqual \"\" branch (T.strip branch')\n\n    it \"can pack and unpack plain git repos\" $\n      shelly_ $ withSystemTempDirectory \"git-repo\" $ \\dir -> do\n        let repo = toTextIgnore $ dir </> (\"repo\" :: FilePath)\n        run_ gitPath [\"clone\", \"https://github.com/haskell/process.git\", repo]\n        origHash <- chdir (fromText repo) revParseHead\n\n        runOb_ [\"thunk\", \"pack\", repo]\n        packedFiles <- Set.fromList <$> ls (fromText repo)\n        liftIO $ assertEqual \"\" packedFiles $ Set.fromList $ (repo </>) <$>\n          [\"default.nix\", \"thunk.nix\", \"github.json\" :: FilePath]\n\n        runOb_ [\"thunk\", \"unpack\", repo]\n        chdir (fromText repo </> unpackedDirName) $ do\n          unpackHash <- revParseHead\n          assertRevEQ origHash unpackHash\n\n        testThunkPack' $ fromText repo\n\n    it \"aborts thunk pack when there are uncommitted files\" $ inTmpObInitWithImplCopy $ \\dir -> do\n      testThunkPack' (dir </> thunk)\n\n    it \"works on legacy git thunks\" $ testLegacyGitThunks isVerbose\n\n  describe \"ob thunk update --branch\" $ parallel $ do\n    it \"can change a thunk to the latest version of a desired branch\" $ withTmp $ \\dir -> do\n      let branch1 = \"master\"\n          branch2 = \"develop\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch1]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", branch2]\n\n    it \"doesn't create anything when given an invalid branch\" $ withTmp $ \\dir -> do\n      let checkDir dir' = liftIO $ getDirectoryContents $ T.unpack $ toTextIgnore dir'\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", \"master\"]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      startingContents <- checkDir dir\n      void $ errExit False $ runOb [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", \"dumble-palooza\"]\n      checkDir dir >>= liftIO . assertEqual \"\" startingContents\n\n  describe \"ob shell\" $ parallel $ do\n    it \"works with --\" $ inTmpObInit $ \\_ -> do\n      output <- runOb [\"shell\", \"--\", \"ghc-pkg\", \"list\"]\n      liftIO $ assertBool \"Unexpected output from ob shell\" $ (\"Cabal-\" `T.isInfixOf` output) && (\"ghc-\" `T.isInfixOf` output)\n\n  describe \"ob hoogle\" $ {- NOT parallel -} do\n    it \"starts a hoogle server on the given port\" $ inTmpObInit $ \\_ -> do\n      [p0] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandle \"ob\" [\"hoogle\", \"--port\", T.pack (show p0)] $ \\stdout -> flip fix Nothing $ \\loop -> \\case\n        Nothing -> do -- Still waiting for initial signal that the server has started\n          ln <- liftIO $ T.hGetLine stdout\n          let search = \"Server starting on port \" <> T.pack (show p0)\n          case search `T.isInfixOf` ln of\n            False -> loop Nothing -- keep waiting\n            True -> loop $ Just 10\n        Just (n :: Int) -> do -- Server has started and we have n attempts left\n          let req uri = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest uri >>= flip HTTP.httpLbs httpManager\n          req (\"http://127.0.0.1:\" <> show p0) >>= \\case\n            Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n            e -> if n <= 0\n              then errorExit $ \"Request to hoogle server failed: \" <> T.pack (show e)\n              else liftIO (threadDelay (1*10^(6 :: Int))) *> loop (Just $ n - 1)\n  where\n    verbosity = bool silently verbosely isVerbose\n    nixBuild args = run nixBuildPath (\"--no-out-link\" : args)\n\n    runOb_ = augmentWithVerbosity run_ ob isVerbose\n    runOb = augmentWithVerbosity run ob isVerbose\n    testObRunInDir' = augmentWithVerbosity testObRunInDir ob isVerbose [\"run\"]\n    testObRunCert' = augmentWithVerbosity testObRunCert ob isVerbose [\"run\", \"-c\", \".\"]\n    testObRunInDirWithMissingStaticFile' = augmentWithVerbosity testObRunInDirWithMissingStaticFile ob isVerbose [\"run\"]\n    testObRunInDirWithMissingStaticFilePath' = augmentWithVerbosity testObRunInDirWithMissingStaticFilePath ob isVerbose [\"run\"]\n    testThunkPack' = augmentWithVerbosity testThunkPack ob isVerbose []\n\n    withObeliskImplClean f =\n      withSystemTempDirectory \"obelisk-impl-clean\" $ \\obeliskImpl -> do\n        void . shellyOb verbosity $ do\n          dirtyFiles <- T.strip <$> run gitPath [\"-C\", toTextIgnore obeliskRepoReadOnly, \"diff\", \"--stat\"]\n          () <- when (dirtyFiles /= \"\") $ error \"SelfTest does not work correctly with dirty obelisk repos as remote\"\n          run_ gitPath [\"clone\", \"file://\" <> toTextIgnore obeliskRepoReadOnly, toTextIgnore obeliskImpl]\n        f obeliskImpl\n\n    withInitCache f =\n      withSystemTempDirectory \"init Cache \u03bb\" $ \\initCache -> do\n        -- Setup the ob init cache\n        void . shellyOb verbosity $ chdir initCache $ do\n          runOb_ [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n          run_ gitPath [\"init\"]\n\n        f initCache\n\n    shelly_ = void . shellyOb verbosity\n\n    defaultTmpDirName = \"test \u03bb\"\n\n    inTmp' :: FilePath -> (FilePath -> Sh a) -> IO ()\n    inTmp' dirname f = withTmp' dirname (chdir <*> f)\n    inTmp = inTmp' defaultTmpDirName\n\n    withTmp' dirname f = shelly_ . withSystemTempDirectory dirname $ f . fromString\n    withTmp = withTmp' defaultTmpDirName\n\n    assertRevEQ a b = liftIO . assertEqual \"\" \"\"        =<< diff a b\n    assertRevNE a b = liftIO . assertBool  \"\" . (/= \"\") =<< diff a b\n\n    revParseHead = T.strip <$> run gitPath [\"rev-parse\", \"HEAD\"]\n\n    commitAll = do\n      run_ gitPath [\"add\", \".\"]\n      commit \"checkpoint\"\n      revParseHead\n\n    thunk  = \".obelisk/impl\"\n    update = runOb [\"thunk\", \"update\", thunk] *> commitAll\n    pack   = runOb [\"thunk\", \"pack\",   thunk] *> commitAll\n    unpack = runOb [\"thunk\", \"unpack\", thunk] *> commitAll\n\n    diff a b = run gitPath [\"diff\", a, b]\n\n\nmaskExitSuccess :: Sh () -> Sh ()\nmaskExitSuccess = handle_sh (\\case ExitSuccess -> pure (); e -> throw e)\n\n-- | Run `ob run` in the given directory (maximum of one level deep)\ntestObRunInDir :: String -> [Text] -> Maybe FilePath -> HTTP.Manager -> Sh ()\ntestObRunInDir executable extraArgs mdir httpManager = maskExitSuccess $ do\n  [p0, p1] <- liftIO $ getFreePorts 2\n  let uri p = \"http://localhost:\" <> T.pack (show p) <> \"/\" -- trailing slash required for comparison\n  writefile \"config/common/route\" $ uri p0\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    firstUri <- handleObRunStdout httpManager stdout stderr\n    let newUri = uri p1\n    when (firstUri == newUri) $ errorExit $\n      \"Startup URI (\" <> firstUri <> \") is the same as test URI (\" <> newUri <> \")\"\n    maybe id (\\_ -> chdir \"..\") mdir $ alterRouteTo newUri stdout\n    runningUri <- handleObRunStdout httpManager stdout stderr\n    if runningUri /= newUri\n      then errorExit $ \"Reloading failed: expected \" <> newUri <> \" but got \" <> runningUri\n      else exit 0\n\ntestObRunCert :: String -> [Text] -> FilePath -> Maybe FilePath -> Sh ()\ntestObRunCert executable extraArgs testDir mdir = maskExitSuccess $ do\n  -- Generate a TLS key, and then a self-signed certificate using that key\n  mapM_ (\\cmd -> run_ \"nix-shell\" [\"-p\", \"openssl\", \"--command\", cmd])\n    [ \"openssl genrsa -out key.pem 2048\"\n    , \"openssl req -new -key key.pem -out certificate.csr -subj \\\"/C=US/ST=New York/L=New York/O=Development/OU=IT Department/CN=obsidian.com\\\"\"\n    , \"openssl x509 -req -in certificate.csr -signkey key.pem -out cert.pem\"\n    ]\n\n  -- One more command is required, for generating the chain.pem file.\n  -- For testing purposes, we'll keep it the same as the cert.pem file.\n  run_ \"cp\" [\"cert.pem\", \"chain.pem\"]\n\n  -- Also need to change the route inside config/common/route to https\n  -- in order to trigger the certificates option (the -c option is not honored for http)\n  writefile \"config/common/route\" \"https://localhost:8000\"\n\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_ stdout _ -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      isEOF <- liftIO $ hIsEOF h\n      if isEOF\n        then errorExit \"Obelisk exited somehow\"\n        else do\n          line <- liftIO $ hGetLineSkipBlanks h\n          check line h\n\n    -- Here we check that the certificates are read properly by Obelisk\n    -- In case the server is started without reading the certificates, show an error.\n    check line h\n      | \"Using certificate information from:\" `T.isPrefixOf` line = do\n        -- Should be followed by a `Frontend running on <url>` line\n        next <- liftIO $ hGetLineSkipBlanks h\n        if \"Frontend running on\" `T.isPrefixOf` next\n          then exit 0\n          else errorExit $ \"Ran into error: \" <> next\n      | \"Frontend running on\" `T.isPrefixOf` line = errorExit \"Obelisk did not read the certificates provided via -c option\"\n      | otherwise = parseObOutput h\n\n-- | Mess up the Cabal file in the given directory, then make sure that\n-- @ob run@ fails.\ntestObRunWithInvalidCabalFile\n  :: FilePath  -- ^ Obelisk path\n  -> FilePath  -- ^ Directory path (will be made invalid)\n  -> Sh ()\ntestObRunWithInvalidCabalFile executable fp = do\n  let commonCabal :: String\n      commonCabal = \"common/common.cabal\"\n  liftIO $ writeFile (fp </> commonCabal) \"This is not a valid Cabal file.\"\n  errExit False $ do\n    runHandles executable [\"run\"] [] $ \\_ _ _ -> pure ()\n    lastExitCode >>= \\case\n      0 -> pure ()\n      _ -> errorExit \"ob run succeeded even with an invalid Cabal file\"\n\n-- | Check whether embedding a non-existent filepath into an obelisk\n-- project is detected correctly and generates a compile-time error.\n--\n-- @'testObRunInDirWithMissingStaticFileWorker' exe args mdir act checkErrorMessage@.\n--\n-- @checkErrorMessage line1 line2@ is invoked on a compile-time error message of the following form:\n--     frontend/src/Frontend.hs:40:32: error:\n--        \u2022 Static file obelisk.jpg was not found in static.out\n--        \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n--       |\n--    40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n--       |\n--\n-- the arguments to @line1@ and @line2@ contain:\n--\n-- @    \u2022 Static file obelisk.jpg was not found in static.out@\n--\n-- and\n--\n-- @    \u2022 In the untyped splice: $(static \"obelisk.jpg\")@\n--\n-- respectively.\ntestObRunInDirWithMissingStaticFileWorker\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\n  -- ^ Run this action before running @ob run@.\n  -- Gives you the opportunity to modify the project to trigger events.\n  -- In particular, make sure static files do not exist, s.t. a compilation\n  -- error is thrown.\n  -> (Text -> Text -> Sh ())\n  -- ^ Assertion function for error messages.\n  -- Since this function is used for asserting error message contents,\n  -- this function specifies what contents two consecutive non-empty lines\n  -- are supposed to have.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkErrorMessage = maskExitSuccess $ do\n  act\n  -- Now run `ob run` and read the error\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      line <- liftIO $ hGetLineSkipBlanks h\n      -- This means that everything was successful, this should not be the case\n      if line == \"Running test...\"\n        then errorExit \"Could not find any error related to static files\"\n        else checkForErrors line h\n\n    -- As can be seen in the example below, we can parse a lot of data.\n    -- For simplicity, we parse the two lines after the `error:` line.\n    -- We also ensure that the file name is same, as the file that we changed ie `obelisk.jpg`\n    checkForErrors line h\n      -- Found an error, check if it is due to static.out\n      | \"error:\" `T.isSuffixOf` line = do\n        line1 <- liftIO $ hGetLineSkipBlanks h\n        line2 <- liftIO $ hGetLineSkipBlanks h\n        checkErrorMessage line1 line2\n      | otherwise = parseObOutput h\n\n-- | Run an obelisk test-case, where @static@ is embedding an non-existent\n-- filepath.\ntestObRunInDirWithMissingStaticFile\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFile executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(static \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\n-- | Run an obelisk test-case, where @staticFilePath@ is embedding an\n-- non-existent filepath.\ntestObRunInDirWithMissingStaticFilePath\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFilePath executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = do\n      run_ sedPath [\"-e\", \"s/\\\\$(static /\\\\$(staticFilePath /\", \"-i\", \"frontend/src/Frontend.hs\"]\n      run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(staticFilePath \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(staticFilePath \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(staticFilePath \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\ntestThunkPack :: String -> [Text] -> FilePath -> Sh ()\ntestThunkPack executable args path' = withTempFile repoDir \"test-file\" $ \\file handle -> do\n  let\n    pack' = readProcessWithExitCode executable ([\"thunk\", \"pack\", path'] ++ map T.unpack args) \"\"\n    ensureThunkPackFails q = liftIO $ pack' >>= \\case\n      (code, out, err)\n        | code == ExitSuccess -> fail $ \"ob thunk pack succeeded when it should have failed with error '\" <> show q <> \"'\"\n        | q `T.isInfixOf` T.pack (out <> err) -> pure ()\n        | otherwise -> fail $ \"ob thunk pack failed for an unexpected reason, expecting '\" <> show q <> \"', received: \" <> show out <> \"\\nstderr: \" <> err\n    git = chdir repoDir . run_ gitPath\n  -- Untracked files\n  ensureThunkPackFails \"Untracked files\"\n  git [\"add\", T.pack file]\n  -- Uncommitted files (staged)\n  ensureThunkPackFails \"unsaved\"\n  chdir repoDir $ commit \"test commit\"\n  -- Non-pushed commits in any branch\n  ensureThunkPackFails \"not yet pushed\"\n  -- Uncommitted files (unstaged)\n  liftIO $ T.hPutStrLn handle \"test file\" >> hClose handle\n  ensureThunkPackFails \"modified\"\n  -- Existing stashes\n  git $ gitUserConfig <> [ \"stash\" ]\n  ensureThunkPackFails \"has stashes\"\n  where\n    repoDir = path' </> unpackedDirName\n\n-- | Blocks until a non-empty line is available\nhGetLineSkipBlanks :: MonadIO m => Handle -> m Text\nhGetLineSkipBlanks h = liftIO $ fix $ \\loop -> T.hGetLine h >>= \\case\n  \"\" -> loop\n  t -> pure t\n\n-- | Alters the route file and waits for `ob run` to reload\nalterRouteTo :: Text -> Handle -> Sh ()\nalterRouteTo uri stdout = do\n  writefile \"config/common/route\" uri\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Reloading...\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"  config/common/route\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Interrupted.\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n\n-- | Handle stdout of `ob run`: check that the frontend and backend servers are started correctly\nhandleObRunStdout :: HTTP.Manager -> Handle -> Handle -> Sh Text\nhandleObRunStdout httpManager stdout stderr = flip fix (ObRunState_Init, []) $ \\loop (state, msgs) -> do\n  isEOF <- liftIO $ hIsEOF stdout\n  if isEOF\n  then handleObRunError msgs\n  else liftIO (T.hGetLine stdout) >>= \\t -> case state of\n    ObRunState_Init\n      | \"Running test...\" `T.isPrefixOf` t -> loop (ObRunState_BackendStarted, msgs)\n    ObRunState_Startup\n      | t == \"backend stopped; make a change to your code to reload\" -> loop (ObRunState_Startup, msgs)\n      -- | Just port <- \"Backend running on port \" `T.stripPrefix` t -> loop $ ObRunState_BackendStarted port\n      | not (T.null t) -> errorExit $ \"Startup: \" <> t -- If theres any other output here, startup failed\n    ObRunState_BackendStarted\n      | Just uri <- \"Frontend running on \" `T.stripPrefix` t -> do\n        obRunCheck httpManager stdout uri\n        pure uri\n      | not (T.null t) -> errorExit $ \"Started: \" <> t -- If theres any other output here, startup failed\n    _ | \"Failed\" `T.isPrefixOf` t -> handleObRunError (t : msgs)\n      | otherwise -> loop (state, t : msgs)\n  where\n    handleObRunError msgs = do\n      stderrContent <- liftIO $ hGetContents stderr\n      errorExit $ \"ob run failed: \" <> T.unlines (reverse msgs) <> \" stderr: \" <> T.pack stderrContent\n\n-- | Make requests to frontend/backend servers to check they are working properly\nobRunCheck :: HTTP.Manager -> Handle -> Text -> Sh ()\nobRunCheck httpManager _stdout frontendUri = do\n  let req uri = liftIO $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n  req frontendUri >>= \\r -> when (HTTP.responseStatus r /= HTTP.ok200) $ errorExit $\n    \"Request to frontend server failed: \" <> T.pack (show r)\n\ngetFreePorts :: Int -> IO [Socket.PortNumber]\ngetFreePorts 0 = pure []\ngetFreePorts n = Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close $ \\s -> (:) <$> Socket.socketPort s <*> getFreePorts (n - 1)\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      pure sock\n\ntestLegacyGitThunks :: Bool -> IO ()\ntestLegacyGitThunks isVerbose = withSystemTempDirectory \"test-git-repo\" $ \\gitDir -> do\n  isolatedGitShell isVerbose gitDir $ \\git -> do\n    writefile (gitDir </> (\"default.nix\" :: FilePath)) \"{}: \\\"hello\\\"\"\n    _ <- git [\"add\", \"--all\"]\n    _ <- git [\"commit\", \"-m\", \"Initial commit\"]\n    rev <- T.strip <$> git [\"rev-parse\", \"HEAD\"]\n    sha256 :: Text\n      <-  either error pure . (Aeson.parseEither (Aeson..: \"sha256\") <=< Aeson.eitherDecodeStrict . T.encodeUtf8) =<< run nixPrefetchGitPath [toTextIgnore gitDir]\n\n    for_ (legacyGitThunks (GitThunkParams gitDir rev sha256)) $ \\mkFiles ->\n      withSystemTempDirectory \"test-thunks\" $ \\thunkDir -> do\n        liftIO $ mkFiles thunkDir\n        run_ \"ob\" [\"thunk\", \"unpack\", toTextIgnore thunkDir]\n        run_ \"ob\" [\"thunk\", \"pack\", toTextIgnore thunkDir]\n\ndata GitThunkParams = GitThunkParams\n  { _gitThunkParams_repo :: !FilePath\n  , _gitThunkParams_rev :: !Text\n  , _gitThunkParams_sha256 :: !Text\n  } deriving Show\n\nlegacyGitThunks :: GitThunkParams -> [FilePath -> IO ()]\nlegacyGitThunks (GitThunkParams repo' rev sha256) =\n  [ mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  assert !fetchSubmodules; (import <nixpkgs> {}).fetchgit { inherit url rev sha256; };\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  if builtins.hasAttr \\\"fetchGit\\\" builtins\"\n        , \"    then builtins.fetchGit ({ inherit url rev; } // (if branch == null then {} else { ref = branch; }))\"\n        , \"    else abort \\\"Plain Git repositories are only supported on nix 2.0 or higher.\\\";\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, ref ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, branch ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"    ${if branch == null then null else \\\"ref\\\"} = branch;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  ]\n  where\n    repo = T.pack repo'\n    mkLegacyIO :: Aeson.ToJSON v => Text -> Map.Map Text v -> FilePath -> IO ()\n    mkLegacyIO defaultNix gitJson dir = do\n      T.writeFile (dir </> (\"default.nix\" :: FilePath)) defaultNix\n      LBS.writeFile (dir </> (\"git.json\" :: FilePath)) (Aeson.encode gitJson)\n\nunpackedDirName :: FilePath\nunpackedDirName = \".\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.3181818181818181,
                "sum": 29
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 17,
              "lines_of_code": 304,
              "homplexity_lines_of_code": 320,
              "code_quality_score": 10.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.3181818181818181,
                  "sum": 29
                },
                "homplexity_loc": 320,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): module Obelisk.Backend has 240 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data BackendConfig has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data StaticAssets has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data GhcjsApp has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 74 43: data Backend has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 94 23: data GhcjsWidgets has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 171 1: type signature for renderAllJsPath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 171 1: type signature for renderAllJsPath has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 172 1: function renderAllJsPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 172 1: function renderAllJsPath has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 172 1: function renderAllJsPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 175 1: type signature for serveObeliskApp has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 175 1: type signature for serveObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 184 1: function serveObeliskApp has branching depth of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 184 1: function serveObeliskApp has cyclomatic complexity of 5 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 184 1: function serveObeliskApp has 10 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 195 1: type signature for serveStaticAssets has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 195 1: type signature for serveStaticAssets has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 196 1: function serveStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 196 1: function serveStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 196 1: function serveStaticAssets has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 205 3: data GhcjsAppRoute has record fields count of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 208 1: type signature for staticRenderContentType has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 208 1: type signature for staticRenderContentType has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 209 1: function staticRenderContentType has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 209 1: function staticRenderContentType has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 209 1: function staticRenderContentType has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 212 1: type signature for serveGhcjsApp has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 212 1: type signature for serveGhcjsApp has 6 arguments should be less than 5\nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 220 1: function serveGhcjsApp has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 220 1: function serveGhcjsApp has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 220 1: function serveGhcjsApp has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 228 1: type signature for defaultBackendConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 228 1: type signature for defaultBackendConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 229 1: function defaultBackendConfig has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 229 1: function defaultBackendConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 229 1: function defaultBackendConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 232 1: type signature for runBackend has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 232 1: type signature for runBackend has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 233 1: function runBackend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 233 1: function runBackend has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 233 1: function runBackend has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 236 1: type signature for runBackendWith has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 236 1: type signature for runBackendWith has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 241 1: function runBackendWith has 14 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 241 1: function runBackendWith has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 241 1: function runBackendWith has branching depth of 3 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 257 1: type signature for renderGhcjsFrontend has type constructor nesting of 1 \nWarning:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 257 1: type signature for renderGhcjsFrontend has 6 arguments should be less than 5\nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function renderGhcjsFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function renderGhcjsFrontend has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function renderGhcjsFrontend has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 271 1: type signature for preloadGhcjs has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 271 1: type signature for preloadGhcjs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 272 1: function preloadGhcjs has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 272 1: function preloadGhcjs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 272 1: function preloadGhcjs has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 276 1: type signature for deferredGhcjsScript has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 276 1: type signature for deferredGhcjsScript has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 277 1: function deferredGhcjsScript has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 277 1: function deferredGhcjsScript has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 277 1: function deferredGhcjsScript has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 282 1: type signature for delayedGhcjsScript has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 282 1: type signature for delayedGhcjsScript has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 286 1: function delayedGhcjsScript has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 286 1: function delayedGhcjsScript has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 286 1: function delayedGhcjsScript has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 300 1: type signature for getPublicConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 300 1: type signature for getPublicConfigs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 301 1: function getPublicConfigs has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 301 1: function getPublicConfigs has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/backend/src/Obelisk/Backend.hs\" 301 1: function getPublicConfigs has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Obelisk.Backend\n  ( Backend (..)\n  , BackendConfig (..)\n  , defaultBackendConfig\n  , StaticAssets (..)\n  , defaultStaticAssets\n  -- * Running a backend\n  , runBackend\n  , runBackendWith\n  -- * Configuration of backend\n  , GhcjsWidgets(..)\n  , defaultGhcjsWidgets\n  -- * all.js script loading functions\n  , deferredGhcjsScript\n  , delayedGhcjsScript\n  -- * all.js preload functions\n  , preloadGhcjs\n  , renderAllJsPath\n  -- * Re-exports\n  , Default (def)\n  , getPageName\n  , getRouteWith\n  , runSnapWithCommandLineArgs\n  , runSnapWithConfig\n  , serveDefaultObeliskApp\n  , prettifyOutput\n  , staticRenderContentType\n  , getPublicConfigs\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Fail (MonadFail)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad\nimport Control.Monad.Except\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as BSC8\nimport Data.Default (Default (..))\nimport Data.Dependent.Sum\nimport Data.Functor.Identity\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport GHC.Generics (Generic)\nimport Obelisk.Asset.Serve.Snap (serveAsset)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport Obelisk.Frontend\nimport Obelisk.Route\nimport Obelisk.Snap.Extras (doNotCache, serveFileIfExistsAs)\nimport Reflex.Dom.Core\nimport Snap (MonadSnap, Snap, commandLineConfig, defaultConfig, getsRequest, httpServe, modifyResponse\n            , rqPathInfo, rqQueryString, setContentType, writeBS, writeText\n            , rqCookies, Cookie(..) , setHeader)\nimport Snap.Internal.Http.Server.Config (Config (accessLog, errorLog), ConfigLog (ConfigIoLog))\nimport System.IO (BufferMode (..), hSetBuffering, stderr, stdout)\n\ndata Backend backendRoute frontendRoute = Backend\n  { _backend_routeEncoder :: Encoder (Either Text) Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  , _backend_run :: ((R backendRoute -> Snap ()) -> IO ()) -> IO ()\n  } deriving (Generic)\n\ndata BackendConfig frontendRoute = BackendConfig\n  { _backendConfig_runSnap :: !(Snap () -> IO ()) -- ^ Function to run the snap server\n  , _backendConfig_staticAssets :: !StaticAssets -- ^ Static assets\n  , _backendConfig_ghcjsWidgets :: !(GhcjsWidgets (Text -> FrontendWidgetT (R frontendRoute) ()))\n    -- ^ Given the URL of all.js, return the widgets which are responsible for\n    -- loading the script.\n  } deriving (Generic)\n\n-- | The static assets provided must contain a compiled GHCJS app that corresponds exactly to the Frontend provided\ndata GhcjsApp route = GhcjsApp\n  { _ghcjsApp_compiled :: !StaticAssets\n  , _ghcjsApp_value :: !(Frontend route)\n  } deriving (Generic)\n\n-- | Widgets used to load all.js on the frontend\ndata GhcjsWidgets a = GhcjsWidgets\n  { _ghcjsWidgets_preload :: a\n  -- ^ A preload widget, placed in the document head\n  , _ghcjsWidgets_script :: a\n  -- ^ A script widget, placed in the document body\n  } deriving (Functor, Generic)\n\n\n-- | Given the URL of all.js, return the widgets which are responsible for\n-- loading the script. Defaults to 'preloadGhcjs' and 'deferredGhcjsScript'.\ndefaultGhcjsWidgets :: GhcjsWidgets (Text -> FrontendWidgetT r ())\ndefaultGhcjsWidgets = GhcjsWidgets\n  { _ghcjsWidgets_preload = preloadGhcjs\n  , _ghcjsWidgets_script = deferredGhcjsScript\n  }\n\n-- | Serve a frontend, which must be the same frontend that Obelisk has built and placed in the default location\n--TODO: The frontend should be provided together with the asset paths so that this isn't so easily breakable; that will probably make this function obsolete\nserveDefaultObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> Frontend (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveDefaultObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontend =\n  serveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp\n  where frontendApp = GhcjsApp\n          { _ghcjsApp_compiled = defaultFrontendGhcjsAssets\n          , _ghcjsApp_value = frontend\n          }\n\nprettifyOutput :: IO ()\nprettifyOutput = do\n  -- Make output more legible by decreasing the likelihood of output from\n  -- multiple threads being interleaved\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\ndefaultStaticAssets :: StaticAssets\ndefaultStaticAssets = StaticAssets\n  { _staticAssets_processed = \"static.assets\"\n  , _staticAssets_unprocessed = \"static\"\n  }\n\ndefaultFrontendGhcjsAssets :: StaticAssets\ndefaultFrontendGhcjsAssets = StaticAssets\n  { _staticAssets_processed = \"frontend.jsexe.assets\"\n  , _staticAssets_unprocessed = \"frontend.jsexe\"\n  }\n\nrunSnapWithConfig :: MonadIO m => Config Snap a -> Snap () -> m ()\nrunSnapWithConfig conf a = do\n  let httpConf = conf\n        { accessLog = Just $ ConfigIoLog BSC8.putStrLn\n        , errorLog = Just $ ConfigIoLog BSC8.putStrLn\n        }\n  -- Start the web server\n  liftIO $ httpServe httpConf a\n\n-- Get the web server configuration from the command line\nrunSnapWithCommandLineArgs :: MonadIO m => Snap () -> m ()\nrunSnapWithCommandLineArgs s = liftIO (commandLineConfig defaultConfig) >>= \\c ->\n  runSnapWithConfig c s\n\ngetPageName :: (MonadSnap m) => m PageName\ngetPageName = do\n  p <- getsRequest rqPathInfo\n  q <- getsRequest rqQueryString\n  return $ byteStringsToPageName p q\n\ngetRouteWith :: (MonadSnap m) => Encoder Identity parse route PageName -> m (parse route)\ngetRouteWith e = do\n  pageName <- getPageName\n  return $ tryDecode e pageName\n\nrenderAllJsPath :: Encoder Identity Identity (R (FullRoute a b)) PageName -> Text\nrenderAllJsPath validFullEncoder =\n  renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_Ghcjs) :/ [\"all.js\"]\n\nserveObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> GhcjsApp (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp config = \\case\n  ObeliskRoute_App appRouteComponent :=> Identity appRouteRest -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_App appRouteComponent :/ appRouteRest\n  ObeliskRoute_Resource resComponent :=> Identity resRest -> case resComponent :=> Identity resRest of\n    ResourceRoute_Static :=> Identity pathSegments -> serveStaticAsset pathSegments\n    ResourceRoute_Ghcjs :=> Identity pathSegments -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_Resource :/ pathSegments\n    ResourceRoute_JSaddleWarp :=> Identity _ -> do\n      let msg = \"Error: Obelisk.Backend received jsaddle request\"\n      liftIO $ putStrLn $ T.unpack msg\n      writeText msg\n    ResourceRoute_Version :=> Identity () -> doNotCache >> serveFileIfExistsAs \"text/plain\" \"version\"\n\nserveStaticAssets :: (MonadSnap m, MonadFail m) => StaticAssets -> [Text] -> m ()\nserveStaticAssets assets pathSegments = serveAsset (_staticAssets_processed assets) (_staticAssets_unprocessed assets) $ T.unpack $ T.intercalate \"/\" pathSegments\n\ndata StaticAssets = StaticAssets\n  { _staticAssets_processed :: !FilePath\n  , _staticAssets_unprocessed :: !FilePath\n  }\n  deriving (Show, Read, Eq, Ord)\n\ndata GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRoute_App :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]\n\nstaticRenderContentType :: ByteString\nstaticRenderContentType = \"text/html; charset=utf-8\"\n\n--TODO: Don't assume we're being served at \"/\"\nserveGhcjsApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRouteComponent -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRouteComponent) ())\n  -> GhcjsApp (R appRouteComponent)\n  -> Map Text ByteString\n  -> R (GhcjsAppRoute appRouteComponent)\n  -> m ()\nserveGhcjsApp urlEnc ghcjsWidgets app config = \\case\n  GhcjsAppRoute_App appRouteComponent :=> Identity appRouteRest -> do\n    modifyResponse $ setContentType staticRenderContentType\n    modifyResponse $ setHeader \"Cache-Control\" \"no-store private\"\n    writeBS <=< renderGhcjsFrontend urlEnc ghcjsWidgets (appRouteComponent :/ appRouteRest) config $ _ghcjsApp_value app\n  GhcjsAppRoute_Resource :=> Identity pathSegments -> serveStaticAssets (_ghcjsApp_compiled app) pathSegments\n\n-- | Default obelisk backend configuration.\ndefaultBackendConfig :: BackendConfig frontendRoute\ndefaultBackendConfig = BackendConfig runSnapWithCommandLineArgs defaultStaticAssets defaultGhcjsWidgets\n\n-- | Run an obelisk backend with the default configuration.\nrunBackend :: Backend backendRoute frontendRoute -> Frontend (R frontendRoute) -> IO ()\nrunBackend = runBackendWith defaultBackendConfig\n\n-- | Run an obelisk backend with the given configuration.\nrunBackendWith\n  :: BackendConfig frontendRoute\n  -> Backend backendRoute frontendRoute\n  -> Frontend (R frontendRoute)\n  -> IO ()\nrunBackendWith (BackendConfig runSnap staticAssets ghcjsWidgets) backend frontend = case checkEncoder $ _backend_routeEncoder backend of\n  Left e -> fail $ \"backend error:\\n\" <> T.unpack e\n  Right validFullEncoder -> do\n    publicConfigs <- getPublicConfigs\n    _backend_run backend $ \\serveRoute ->\n      runSnap $\n        getRouteWith validFullEncoder >>= \\case\n          Identity r -> case r of\n            FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n            FullRoute_Frontend obeliskRoute :/ a ->\n              serveDefaultObeliskApp routeToUrl (($ allJsUrl) <$> ghcjsWidgets) (serveStaticAssets staticAssets) frontend publicConfigs $\n                obeliskRoute :/ a\n              where\n                routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n                allJsUrl = renderAllJsPath validFullEncoder\n\nrenderGhcjsFrontend\n  :: (MonadSnap m, HasCookies m)\n  => (route -> Text)\n  -> GhcjsWidgets (FrontendWidgetT route ())\n  -> route\n  -> Map Text ByteString\n  -> Frontend route\n  -> m ByteString\nrenderGhcjsFrontend urlEnc ghcjsWidgets route configs f = do\n  cookies <- askCookies\n  renderFrontendHtml configs cookies urlEnc route f (_ghcjsWidgets_preload ghcjsWidgets) (_ghcjsWidgets_script ghcjsWidgets)\n\n-- | Preload all.js in a link tag.\n-- This is the default preload method.\npreloadGhcjs :: Text -> FrontendWidgetT r ()\npreloadGhcjs allJsUrl = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: allJsUrl) blank\n\n-- | Load the script from the given URL in a deferred script tag.\n-- This is the default method.\ndeferredGhcjsScript :: Text -> FrontendWidgetT r ()\ndeferredGhcjsScript allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\" <> \"src\" =: allJsUrl <> \"defer\" =: \"defer\") blank\n\n-- | An all.js script which is loaded after waiting for some time to pass. This\n-- is useful to ensure any CSS animations on the page can play smoothly before\n-- blocking the UI thread by running all.js.\ndelayedGhcjsScript\n  :: Int -- ^ The number of milliseconds to delay loading by\n  -> Text -- ^ URL to GHCJS app JavaScript\n  -> FrontendWidgetT r ()\ndelayedGhcjsScript n allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\") $ text $ T.unlines\n  [ \"setTimeout(function() {\"\n  , \"  var all_js_script = document.createElement('script');\"\n  , \"  all_js_script.type = 'text/javascript';\"\n  , \"  all_js_script.src = '\" <> allJsUrl <> \"';\"\n  , \"  document.body.appendChild(all_js_script);\"\n  , \"}, \" <> T.pack (show n) <> \");\"\n  ]\n\ninstance HasCookies Snap where\n  askCookies = map (\\c -> (cookieName c, cookieValue c)) <$> getsRequest rqCookies\n\n-- | Get configs from the canonical \"public\" locations (i.e., locations that obelisk expects to make available\n-- to frontend applications, and hence visible to end users).\ngetPublicConfigs :: IO (Map Text ByteString)\ngetPublicConfigs = Map.filterWithKey (\\k _ -> isMemberOf k [\"common\", \"frontend\"]) <$> Lookup.getConfigs\n  where\n    isMemberOf k = any (`T.isPrefixOf` k)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs:(205,1)-(207,66)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data GhcjsAppRoute :: (* -> *) -> * -> *",
                    "    where",
                    "      GhcjsAppRoute_App :: appRouteComponent a ->",
                    "                           GhcjsAppRoute appRouteComponent a",
                    "      GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]"
                  ],
                  "perhaps_block": [
                    "  data GhcjsAppRoute :: (* -> *) -> * -> *",
                    "    where",
                    "      GhcjsAppRouteApp :: appRouteComponent a ->",
                    "                          GhcjsAppRoute appRouteComponent a",
                    "      GhcjsAppRouteResource :: GhcjsAppRoute appRouteComponent [Text]"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Obelisk.Backend\n  ( Backend (..)\n  , BackendConfig (..)\n  , defaultBackendConfig\n  , StaticAssets (..)\n  , defaultStaticAssets\n  -- * Running a backend\n  , runBackend\n  , runBackendWith\n  -- * Configuration of backend\n  , GhcjsWidgets(..)\n  , defaultGhcjsWidgets\n  -- * all.js script loading functions\n  , deferredGhcjsScript\n  , delayedGhcjsScript\n  -- * all.js preload functions\n  , preloadGhcjs\n  , renderAllJsPath\n  -- * Re-exports\n  , Default (def)\n  , getPageName\n  , getRouteWith\n  , runSnapWithCommandLineArgs\n  , runSnapWithConfig\n  , serveDefaultObeliskApp\n  , prettifyOutput\n  , staticRenderContentType\n  , getPublicConfigs\n  ) where\n\n\n\n\n\n\n\n\nimport Control.Monad\nimport Control.Monad.Except\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as BSC8\nimport Data.Default (Default (..))\nimport Data.Dependent.Sum\nimport Data.Functor.Identity\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport GHC.Generics (Generic)\nimport Obelisk.Asset.Serve.Snap (serveAsset)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport Obelisk.Frontend\nimport Obelisk.Route\nimport Obelisk.Snap.Extras (doNotCache, serveFileIfExistsAs)\nimport Reflex.Dom.Core\nimport Snap (MonadSnap, Snap, commandLineConfig, defaultConfig, getsRequest, httpServe, modifyResponse\n            , rqPathInfo, rqQueryString, setContentType, writeBS, writeText\n            , rqCookies, Cookie(..) , setHeader)\nimport Snap.Internal.Http.Server.Config (Config (accessLog, errorLog), ConfigLog (ConfigIoLog))\nimport System.IO (BufferMode (..), hSetBuffering, stderr, stdout)\n\ndata Backend backendRoute frontendRoute = Backend\n  { _backend_routeEncoder :: Encoder (Either Text) Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  , _backend_run :: ((R backendRoute -> Snap ()) -> IO ()) -> IO ()\n  } deriving (Generic)\n\ndata BackendConfig frontendRoute = BackendConfig\n  { _backendConfig_runSnap :: !(Snap () -> IO ()) -- ^ Function to run the snap server\n  , _backendConfig_staticAssets :: !StaticAssets -- ^ Static assets\n  , _backendConfig_ghcjsWidgets :: !(GhcjsWidgets (Text -> FrontendWidgetT (R frontendRoute) ()))\n    -- ^ Given the URL of all.js, return the widgets which are responsible for\n    -- loading the script.\n  } deriving (Generic)\n\n-- | The static assets provided must contain a compiled GHCJS app that corresponds exactly to the Frontend provided\ndata GhcjsApp route = GhcjsApp\n  { _ghcjsApp_compiled :: !StaticAssets\n  , _ghcjsApp_value :: !(Frontend route)\n  } deriving (Generic)\n\n-- | Widgets used to load all.js on the frontend\ndata GhcjsWidgets a = GhcjsWidgets\n  { _ghcjsWidgets_preload :: a\n  -- ^ A preload widget, placed in the document head\n  , _ghcjsWidgets_script :: a\n  -- ^ A script widget, placed in the document body\n  } deriving (Functor, Generic)\n\n\n-- | Given the URL of all.js, return the widgets which are responsible for\n-- loading the script. Defaults to 'preloadGhcjs' and 'deferredGhcjsScript'.\ndefaultGhcjsWidgets :: GhcjsWidgets (Text -> FrontendWidgetT r ())\ndefaultGhcjsWidgets = GhcjsWidgets\n  { _ghcjsWidgets_preload = preloadGhcjs\n  , _ghcjsWidgets_script = deferredGhcjsScript\n  }\n\n-- | Serve a frontend, which must be the same frontend that Obelisk has built and placed in the default location\n--TODO: The frontend should be provided together with the asset paths so that this isn't so easily breakable; that will probably make this function obsolete\nserveDefaultObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> Frontend (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveDefaultObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontend =\n  serveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp\n  where frontendApp = GhcjsApp\n          { _ghcjsApp_compiled = defaultFrontendGhcjsAssets\n          , _ghcjsApp_value = frontend\n          }\n\nprettifyOutput :: IO ()\nprettifyOutput = do\n  -- Make output more legible by decreasing the likelihood of output from\n  -- multiple threads being interleaved\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\ndefaultStaticAssets :: StaticAssets\ndefaultStaticAssets = StaticAssets\n  { _staticAssets_processed = \"static.assets\"\n  , _staticAssets_unprocessed = \"static\"\n  }\n\ndefaultFrontendGhcjsAssets :: StaticAssets\ndefaultFrontendGhcjsAssets = StaticAssets\n  { _staticAssets_processed = \"frontend.jsexe.assets\"\n  , _staticAssets_unprocessed = \"frontend.jsexe\"\n  }\n\nrunSnapWithConfig :: MonadIO m => Config Snap a -> Snap () -> m ()\nrunSnapWithConfig conf a = do\n  let httpConf = conf\n        { accessLog = Just $ ConfigIoLog BSC8.putStrLn\n        , errorLog = Just $ ConfigIoLog BSC8.putStrLn\n        }\n  -- Start the web server\n  liftIO $ httpServe httpConf a\n\n-- Get the web server configuration from the command line\nrunSnapWithCommandLineArgs :: MonadIO m => Snap () -> m ()\nrunSnapWithCommandLineArgs s = liftIO (commandLineConfig defaultConfig) >>= \\c ->\n  runSnapWithConfig c s\n\ngetPageName :: (MonadSnap m) => m PageName\ngetPageName = do\n  p <- getsRequest rqPathInfo\n  q <- getsRequest rqQueryString\n  return $ byteStringsToPageName p q\n\ngetRouteWith :: (MonadSnap m) => Encoder Identity parse route PageName -> m (parse route)\ngetRouteWith e = do\n  tryDecode e <$> getPageName\n\nrenderAllJsPath :: Encoder Identity Identity (R (FullRoute a b)) PageName -> Text\nrenderAllJsPath validFullEncoder =\n  renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_Ghcjs) :/ [\"all.js\"]\n\nserveObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> GhcjsApp (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp config = \\case\n  ObeliskRoute_App appRouteComponent :=> Identity appRouteRest -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_App appRouteComponent :/ appRouteRest\n  ObeliskRoute_Resource resComponent :=> Identity resRest -> case resComponent :=> Identity resRest of\n    ResourceRoute_Static :=> Identity pathSegments -> serveStaticAsset pathSegments\n    ResourceRoute_Ghcjs :=> Identity pathSegments -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_Resource :/ pathSegments\n    ResourceRoute_JSaddleWarp :=> Identity _ -> do\n      let msg = \"Error: Obelisk.Backend received jsaddle request\"\n      liftIO $ putStrLn $ T.unpack msg\n      writeText msg\n    ResourceRoute_Version :=> Identity () -> doNotCache >> serveFileIfExistsAs \"text/plain\" \"version\"\n\nserveStaticAssets :: (MonadSnap m, MonadFail m) => StaticAssets -> [Text] -> m ()\nserveStaticAssets assets pathSegments = serveAsset (_staticAssets_processed assets) (_staticAssets_unprocessed assets) $ T.unpack $ T.intercalate \"/\" pathSegments\n\ndata StaticAssets = StaticAssets\n  { _staticAssets_processed :: !FilePath\n  , _staticAssets_unprocessed :: !FilePath\n  }\n  deriving (Show, Read, Eq, Ord)\n\ndata GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRoute_App :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]\n\nstaticRenderContentType :: ByteString\nstaticRenderContentType = \"text/html; charset=utf-8\"\n\n--TODO: Don't assume we're being served at \"/\"\nserveGhcjsApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRouteComponent -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRouteComponent) ())\n  -> GhcjsApp (R appRouteComponent)\n  -> Map Text ByteString\n  -> R (GhcjsAppRoute appRouteComponent)\n  -> m ()\nserveGhcjsApp urlEnc ghcjsWidgets app config = \\case\n  GhcjsAppRoute_App appRouteComponent :=> Identity appRouteRest -> do\n    modifyResponse $ setContentType staticRenderContentType\n    modifyResponse $ setHeader \"Cache-Control\" \"no-store private\"\n    writeBS <=< renderGhcjsFrontend urlEnc ghcjsWidgets (appRouteComponent :/ appRouteRest) config $ _ghcjsApp_value app\n  GhcjsAppRoute_Resource :=> Identity pathSegments -> serveStaticAssets (_ghcjsApp_compiled app) pathSegments\n\n-- | Default obelisk backend configuration.\ndefaultBackendConfig :: BackendConfig frontendRoute\ndefaultBackendConfig = BackendConfig runSnapWithCommandLineArgs defaultStaticAssets defaultGhcjsWidgets\n\n-- | Run an obelisk backend with the default configuration.\nrunBackend :: Backend backendRoute frontendRoute -> Frontend (R frontendRoute) -> IO ()\nrunBackend = runBackendWith defaultBackendConfig\n\n-- | Run an obelisk backend with the given configuration.\nrunBackendWith\n  :: BackendConfig frontendRoute\n  -> Backend backendRoute frontendRoute\n  -> Frontend (R frontendRoute)\n  -> IO ()\nrunBackendWith (BackendConfig runSnap staticAssets ghcjsWidgets) backend frontend = case checkEncoder $ _backend_routeEncoder backend of\n  Left e -> fail $ \"backend error:\\n\" <> T.unpack e\n  Right validFullEncoder -> do\n    publicConfigs <- getPublicConfigs\n    _backend_run backend $ \\serveRoute ->\n      runSnap $\n        getRouteWith validFullEncoder >>= \\case\n          Identity r -> case r of\n            FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n            FullRoute_Frontend obeliskRoute :/ a ->\n              serveDefaultObeliskApp routeToUrl (($ allJsUrl) <$> ghcjsWidgets) (serveStaticAssets staticAssets) frontend publicConfigs $\n                obeliskRoute :/ a\n              where\n                routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n                allJsUrl = renderAllJsPath validFullEncoder\n\nrenderGhcjsFrontend\n  :: (MonadSnap m, HasCookies m)\n  => (route -> Text)\n  -> GhcjsWidgets (FrontendWidgetT route ())\n  -> route\n  -> Map Text ByteString\n  -> Frontend route\n  -> m ByteString\nrenderGhcjsFrontend urlEnc ghcjsWidgets route configs f = do\n  cookies <- askCookies\n  renderFrontendHtml configs cookies urlEnc route f (_ghcjsWidgets_preload ghcjsWidgets) (_ghcjsWidgets_script ghcjsWidgets)\n\n-- | Preload all.js in a link tag.\n-- This is the default preload method.\npreloadGhcjs :: Text -> FrontendWidgetT r ()\npreloadGhcjs allJsUrl = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: allJsUrl) blank\n\n-- | Load the script from the given URL in a deferred script tag.\n-- This is the default method.\ndeferredGhcjsScript :: Text -> FrontendWidgetT r ()\ndeferredGhcjsScript allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\" <> \"src\" =: allJsUrl <> \"defer\" =: \"defer\") blank\n\n-- | An all.js script which is loaded after waiting for some time to pass. This\n-- is useful to ensure any CSS animations on the page can play smoothly before\n-- blocking the UI thread by running all.js.\ndelayedGhcjsScript\n  :: Int -- ^ The number of milliseconds to delay loading by\n  -> Text -- ^ URL to GHCJS app JavaScript\n  -> FrontendWidgetT r ()\ndelayedGhcjsScript n allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\") $ text $ T.unlines\n  [ \"setTimeout(function() {\"\n  , \"  var all_js_script = document.createElement('script');\"\n  , \"  all_js_script.type = 'text/javascript';\"\n  , \"  all_js_script.src = '\" <> allJsUrl <> \"';\"\n  , \"  document.body.appendChild(all_js_script);\"\n  , \"}, \" <> T.pack (show n) <> \");\"\n  ]\n\ninstance HasCookies Snap where\n  askCookies = map (\\c -> (cookieName c, cookieValue c)) <$> getsRequest rqCookies\n\n-- | Get configs from the canonical \"public\" locations (i.e., locations that obelisk expects to make available\n-- to frontend applications, and hence visible to end users).\ngetPublicConfigs :: IO (Map Text ByteString)\ngetPublicConfigs = Map.filterWithKey (\\k _ -> isMemberOf k [\"common\", \"frontend\"]) <$> Lookup.getConfigs\n  where\n    isMemberOf k = any (`T.isPrefixOf` k)\n\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.6666666666666667,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 63,
              "homplexity_lines_of_code": 67,
              "code_quality_score": 73.3,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.6666666666666667,
                  "sum": 10
                },
                "homplexity_loc": 67,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 1 1: module Obelisk.Snap.Extras has 46 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 22 1: type signature for modernMimeTypes has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 22 1: type signature for modernMimeTypes has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 23 1: function modernMimeTypes has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 27 1: type signature for cachePermanently has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 27 1: type signature for cachePermanently has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 28 1: function cachePermanently has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 33 1: type signature for doNotCache has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 33 1: type signature for doNotCache has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 34 1: function doNotCache has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 39 1: type signature for serveFileIfExists has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 39 1: type signature for serveFileIfExists has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 40 1: function serveFileIfExists has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 47 1: type signature for serveFileIfExistsAs has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 47 1: type signature for serveFileIfExistsAs has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 48 1: function serveFileIfExistsAs has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 53 1: type signature for ensureSecure has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 53 1: type signature for ensureSecure has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has branching depth of 2 \nInfo:/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs\" 58 1: function ensureSecure has 6 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Snap.Extras\n  ( cachePermanently\n  , doNotCache\n  , ensureSecure\n  , serveFileIfExists\n  , serveFileIfExistsAs\n  , modernMimeTypes\n  ) where\n\nimport Control.Monad.IO.Class\nimport Data.ByteString (ByteString)\nimport Data.String\nimport Snap.Core\nimport Snap.Util.FileServe\nimport System.Directory\n\nimport qualified Data.HashMap.Strict as Map\n\n\n-- | Default mime types with some modern extras\nmodernMimeTypes :: MimeMap\nmodernMimeTypes =\n  defaultMimeTypes <> Map.fromList [ (\".wasm\", \"application/wasm\") ]\n\n-- | Set response header for \"permanent\" caching\ncachePermanently :: MonadSnap m => m ()\ncachePermanently = do\n  modifyResponse $ setHeader \"Cache-Control\" \"public, max-age=315360000, immutable\"\n  modifyResponse $ setHeader \"Expires\" \"Tue, 01 Feb 2050 00:00:00 GMT\" --TODO: This should be set to \"approximately one year from the time the response is sent\"\n\n-- | Set response header to not cache\ndoNotCache :: MonadSnap m => m ()\ndoNotCache = do\n  modifyResponse $ setHeader \"Cache-Control\" \"no-cache, no-store, must-revalidate\"\n  modifyResponse $ setHeader \"Expires\" \"0\"\n\n-- | Serves the specified file if it exists; otherwise, 'pass'es\nserveFileIfExists :: MonadSnap m => FilePath -> m ()\nserveFileIfExists f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n  where\n    mimeType = fileType modernMimeTypes f\n\n-- | Like 'serveFileIfExists', but with a given MIME type\nserveFileIfExistsAs :: MonadSnap m => ByteString -> FilePath -> m ()\nserveFileIfExistsAs mimeType f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n\n-- | Only run the given handler when the connection is \"secure\" (i.e. made with HTTPS)\nensureSecure\n  :: MonadSnap m\n  => Int -- ^ The port where this server answers HTTPS requests\n  -> m () -- ^ A handler to be run only when the connection is secure\n  -> m ()\nensureSecure port h = do\n  s <- getsRequest rqIsSecure\n  if s then h else do\n    uri <- getsRequest rqURI\n    host <- getsRequest rqHostName --TODO: It might be better to use the canonical base of the server\n    redirect $ \"https://\" <> host <> (if port == 443 then \"\" else \":\" <> fromString (show port)) <> uri\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Snap.Extras\n  ( cachePermanently\n  , doNotCache\n  , ensureSecure\n  , serveFileIfExists\n  , serveFileIfExistsAs\n  , modernMimeTypes\n  ) where\n\nimport Control.Monad.IO.Class\nimport Data.ByteString (ByteString)\nimport Data.String\nimport Snap.Core\nimport Snap.Util.FileServe\nimport System.Directory\n\nimport qualified Data.HashMap.Strict as Map\n\n\n-- | Default mime types with some modern extras\nmodernMimeTypes :: MimeMap\nmodernMimeTypes =\n  defaultMimeTypes <> Map.fromList [ (\".wasm\", \"application/wasm\") ]\n\n-- | Set response header for \"permanent\" caching\ncachePermanently :: MonadSnap m => m ()\ncachePermanently = do\n  modifyResponse $ setHeader \"Cache-Control\" \"public, max-age=315360000, immutable\"\n  modifyResponse $ setHeader \"Expires\" \"Tue, 01 Feb 2050 00:00:00 GMT\" --TODO: This should be set to \"approximately one year from the time the response is sent\"\n\n-- | Set response header to not cache\ndoNotCache :: MonadSnap m => m ()\ndoNotCache = do\n  modifyResponse $ setHeader \"Cache-Control\" \"no-cache, no-store, must-revalidate\"\n  modifyResponse $ setHeader \"Expires\" \"0\"\n\n-- | Serves the specified file if it exists; otherwise, 'pass'es\nserveFileIfExists :: MonadSnap m => FilePath -> m ()\nserveFileIfExists f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n  where\n    mimeType = fileType modernMimeTypes f\n\n-- | Like 'serveFileIfExists', but with a given MIME type\nserveFileIfExistsAs :: MonadSnap m => ByteString -> FilePath -> m ()\nserveFileIfExistsAs mimeType f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n\n-- | Only run the given handler when the connection is \"secure\" (i.e. made with HTTPS)\nensureSecure\n  :: MonadSnap m\n  => Int -- ^ The port where this server answers HTTPS requests\n  -> m () -- ^ A handler to be run only when the connection is secure\n  -> m ()\nensureSecure port h = do\n  s <- getsRequest rqIsSecure\n  if s then h else do\n    uri <- getsRequest rqURI\n    host <- getsRequest rqHostName --TODO: It might be better to use the canonical base of the server\n    redirect $ \"https://\" <> host <> (if port == 443 then \"\" else \":\" <> fromString (show port)) <> uri\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/tabulation/Setup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 2,
              "homplexity_lines_of_code": 3,
              "code_quality_score": 97.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 3,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/Setup.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/Setup.hs\" 2 1: function main has branching depth of 0 \n"
              },
              "original_code": "import Distribution.Simple\nmain = defaultMain\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/tabulation/Setup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import Distribution.Simple\nmain = defaultMain\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 152,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 93.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 1 1: module Data.Tabulation has 26 lines of code \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has method + value count of 5 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has associated type count of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 142 3: data FieldHKD has record fields count of 0 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Tabulation where\n\nimport Control.Lens\n\n-- | This is a class for record types whose fields can be enumerated by an associated GADT. It's closely related to the concept of a representable functor, except without the functor part, and the fields are not all the same type.\nclass HasFields a where\n  type Field a :: * -> *\n\n  fieldLens :: Field a x -> Lens' a x\n  tabulateFieldsA :: Applicative f => (forall x. Field a x -> f x) -> f a\n\n  tabulateFields :: (forall x. Field a x -> x) -> a\n  tabulateFields f = runIdentity (tabulateFieldsA (Identity . f))\n  traverseWithField :: Applicative m => (forall x. Field a x -> x -> m x) -> a -> m a\n  traverseWithField t r = tabulateFieldsA (\\f -> t f (indexField r f))\n  indexField :: a -> Field a x -> x\n  indexField a f = a ^. fieldLens f\n  {-# MINIMAL fieldLens, tabulateFieldsA #-}\n\n-- | A wrapper to allow mixing/reusing a non-HKD associated GADT with the higher kinded data record.\n\n{- |\n==== __Usage example__\nWe can do\n\n@\ndata XY = XY\n  { _x :: ()\n  , _y :: 'Bool'\n  }\n\ndata XYField a where\n  XYField_X :: XYField ()\n  XYField_Y :: XYField 'Bool'\n\ninstance HasFields XY where\n  type Field XY = XYField\n  fieldLens = \\\\case\n    XYField_X -> \\\\f (XY x y) -> flip XY y '<$>' f x\n    XYField_Y -> lens _y $ \\\\xy y -> xy { _y = y }\n  tabulateFieldsA g = pure XY\n    '<*>' g XYField_X\n    '<*>' g XYField_Y\n@\n\nso one would expect being able to\n\n@\ndata XYHKD f = XYHKD\n  { _x' :: f ()\n  , _y' :: f Bool\n  }\n\ndata XYHKDField a where\n  XYHKDField_X :: XYHKDField (f ())\n  XYHKDField_Y :: XYHKDField (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField\n  fieldLens = \\\\case\n    XYHKDField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    XYHKDField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g XYHKDField_X\n    '<*>' g XYHKDField_Y\n@\n\nWhile `tabulateFieldsA` compiles, `fieldLens` doesn't, with the same sort of error in both its cases.\n\n@\n   \u2022 Could not deduce: f2 ~ f\n      from the context: x ~ f2 ()\n        bound by a pattern with constructor:\n                   XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n                 in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f2\u2019 is a rigid type variable bound by\n        a pattern with constructor:\n          XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n        in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f\u2019 is a rigid type variable bound by\n        the instance declaration\n        at ../lib/tabulation/src/Data/Tabulation.hs:65:10-28\n      Expected type: x\n        Actual type: f ()\n@\n\nThe `XYHKDField` constructors must work for all `f`, but the one from `XYHKD` is a specific one (it's quantified outside), so this direction doesn't work, but the one in `tabulateFieldsA` does.\n\nWe can fix this by threading the `f` from the record to the associated GADT.\n\n@\ndata XYHKDField f a where\n  XYHKDField_X :: XYHKDField f (f ())\n  XYHKDField_Y :: XYHKDField f (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField f\n@\n\nbut that's cumbersome and takes some work to figure out once you first try to use `Field` with HKD.\n\nTo solve these problems, one can use `FieldHKD` instead.\n\n@\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = FieldHKD XYField f\n  fieldLens = \\\\case\n    FieldHKD XYField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    FieldHKD XYField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g (FieldHKD XYField_X)\n    '<*>' g (FieldHKD XYField_Y)\n@\n\nThis also lets us capture the notion that the fields of the HKD version are related to the base version by a `f` layer by transforming one into the other.\n\n@\nliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = 'tabulateFields' $ \\(FieldHKD field) -> f ('indexField' r field)\n\nunliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = 'tabulateFields' $ \\field -> f ('indexField' r (FieldHKD field))\n\nxyPure :: 'Applicative' f => XY -> XYHKD f\nxyPure = 'liftKind' 'pure'\n\nxyRunIdentity :: XYHKD 'Identity' -> XY\nxyRunIdentity = 'unliftKind' 'runIdentity'\n@\n-}\ndata FieldHKD field f x where\n  FieldHKD :: field x -> FieldHKD field f (f x)\n\nliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = tabulateFields $ \\(FieldHKD field) -> f (indexField r field)\n\nunliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = tabulateFields $ \\field -> f (indexField r (FieldHKD field))\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Tabulation where\n\nimport Control.Lens\n\n-- | This is a class for record types whose fields can be enumerated by an associated GADT. It's closely related to the concept of a representable functor, except without the functor part, and the fields are not all the same type.\nclass HasFields a where\n  type Field a :: * -> *\n\n  fieldLens :: Field a x -> Lens' a x\n  tabulateFieldsA :: Applicative f => (forall x. Field a x -> f x) -> f a\n\n  tabulateFields :: (forall x. Field a x -> x) -> a\n  tabulateFields f = runIdentity (tabulateFieldsA (Identity . f))\n  traverseWithField :: Applicative m => (forall x. Field a x -> x -> m x) -> a -> m a\n  traverseWithField t r = tabulateFieldsA (\\f -> t f (indexField r f))\n  indexField :: a -> Field a x -> x\n  indexField a f = a ^. fieldLens f\n  {-# MINIMAL fieldLens, tabulateFieldsA #-}\n\n-- | A wrapper to allow mixing/reusing a non-HKD associated GADT with the higher kinded data record.\n\n{- |\n==== __Usage example__\nWe can do\n\n@\ndata XY = XY\n  { _x :: ()\n  , _y :: 'Bool'\n  }\n\ndata XYField a where\n  XYField_X :: XYField ()\n  XYField_Y :: XYField 'Bool'\n\ninstance HasFields XY where\n  type Field XY = XYField\n  fieldLens = \\\\case\n    XYField_X -> \\\\f (XY x y) -> flip XY y '<$>' f x\n    XYField_Y -> lens _y $ \\\\xy y -> xy { _y = y }\n  tabulateFieldsA g = pure XY\n    '<*>' g XYField_X\n    '<*>' g XYField_Y\n@\n\nso one would expect being able to\n\n@\ndata XYHKD f = XYHKD\n  { _x' :: f ()\n  , _y' :: f Bool\n  }\n\ndata XYHKDField a where\n  XYHKDField_X :: XYHKDField (f ())\n  XYHKDField_Y :: XYHKDField (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField\n  fieldLens = \\\\case\n    XYHKDField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    XYHKDField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g XYHKDField_X\n    '<*>' g XYHKDField_Y\n@\n\nWhile `tabulateFieldsA` compiles, `fieldLens` doesn't, with the same sort of error in both its cases.\n\n@\n   \u2022 Could not deduce: f2 ~ f\n      from the context: x ~ f2 ()\n        bound by a pattern with constructor:\n                   XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n                 in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f2\u2019 is a rigid type variable bound by\n        a pattern with constructor:\n          XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n        in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f\u2019 is a rigid type variable bound by\n        the instance declaration\n        at ../lib/tabulation/src/Data/Tabulation.hs:65:10-28\n      Expected type: x\n        Actual type: f ()\n@\n\nThe `XYHKDField` constructors must work for all `f`, but the one from `XYHKD` is a specific one (it's quantified outside), so this direction doesn't work, but the one in `tabulateFieldsA` does.\n\nWe can fix this by threading the `f` from the record to the associated GADT.\n\n@\ndata XYHKDField f a where\n  XYHKDField_X :: XYHKDField f (f ())\n  XYHKDField_Y :: XYHKDField f (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField f\n@\n\nbut that's cumbersome and takes some work to figure out once you first try to use `Field` with HKD.\n\nTo solve these problems, one can use `FieldHKD` instead.\n\n@\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = FieldHKD XYField f\n  fieldLens = \\\\case\n    FieldHKD XYField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    FieldHKD XYField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g (FieldHKD XYField_X)\n    '<*>' g (FieldHKD XYField_Y)\n@\n\nThis also lets us capture the notion that the fields of the HKD version are related to the base version by a `f` layer by transforming one into the other.\n\n@\nliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = 'tabulateFields' $ \\(FieldHKD field) -> f ('indexField' r field)\n\nunliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = 'tabulateFields' $ \\field -> f ('indexField' r (FieldHKD field))\n\nxyPure :: 'Applicative' f => XY -> XYHKD f\nxyPure = 'liftKind' 'pure'\n\nxyRunIdentity :: XYHKD 'Identity' -> XY\nxyRunIdentity = 'unliftKind' 'runIdentity'\n@\n-}\ndata FieldHKD field f x where\n  FieldHKD :: field x -> FieldHKD field f (f x)\n\nliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = tabulateFields $ \\(FieldHKD field) -> f (indexField r field)\n\nunliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = tabulateFields $ \\field -> f (indexField r (FieldHKD field))\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 4,
              "homplexity_lines_of_code": 4,
              "code_quality_score": 97.6,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 4,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 1 1: <unnamed module> has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 3 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 3 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 4 1: function main has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 4 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src-bin/ob.hs\" 4 1: function main has branching depth of 0 \n"
              },
              "original_code": "import qualified Obelisk.Command\n\nmain :: IO ()\nmain = Obelisk.Command.main\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src-bin/ob.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import qualified Obelisk.Command\n\nmain :: IO ()\nmain = Obelisk.Command.main\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 13,
              "lines_of_code": 142,
              "homplexity_lines_of_code": 109,
              "code_quality_score": 83.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 109,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 1 1: module Obelisk.App has 100 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 44 5: data ObeliskProcessError has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 55 5: data ObeliskError has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 74 19: data Obelisk has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 78 24: data ObeliskT has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 92 3: type class HasObelisk has associated type count of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 92 3: type class HasObelisk has method + value count of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 109 1: type signature for runObelisk has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 109 1: type signature for runObelisk has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 110 1: function runObelisk has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 118 1: type signature for wrapNixThunkError has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 118 1: type signature for wrapNixThunkError has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 122 1: function wrapNixThunkError has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 141 1: type signature for getObeliskUserStateDir has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 141 1: type signature for getObeliskUserStateDir has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/App.hs\" 142 1: function getObeliskUserStateDir has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.App where\n\nimport Control.Lens\nimport Control.Monad.Catch (MonadCatch, MonadMask, MonadThrow)\nimport Control.Monad.Fail (MonadFail)\nimport Control.Monad.Reader (MonadIO, ReaderT (..), ask, runReaderT)\nimport Control.Monad.Writer (WriterT)\nimport Control.Monad.State (StateT)\nimport Control.Monad.Except (ExceptT, MonadError)\nimport Control.Monad.Trans.Class (MonadTrans, lift)\nimport Data.Text (Text)\nimport System.Directory (XdgDirectory (XdgData), getXdgDirectory)\nimport Control.Monad.Log (MonadLog)\nimport Cli.Extras.Types\nimport \"nix-thunk\" Nix.Thunk (NixThunkError)\n\nimport Cli.Extras\n  ( CliConfig\n  , CliLog\n  , CliThrow\n  , CliT (..)\n  , ProcessFailure\n  , AsProcessFailure (..)\n  , AsUnstructuredError (..)\n  , HasCliConfig\n  , Output\n  , runCli\n  )\n\n-- | An error thrown by one of the child processes invoked during\n-- execution of Obelisk.\ndata ObeliskProcessError\n  = ObeliskProcessError\n    { _obeliskProcessError_failure :: ProcessFailure\n      -- ^ The 'ProcessFailure' indicating both how the process was\n      -- created and its eventual exit code.\n    , _obeliskProcessError_mComment :: Maybe Text\n      -- ^ Optionally, a comment can be attached to the 'ProcessFailure'\n      -- to give the user more details.\n    }\n\n-- | An error thrown by the Obelisk app.\ndata ObeliskError\n  = ObeliskError_ProcessError ObeliskProcessError\n    -- ^ Indicates an error in one of our child processes.\n  | ObeliskError_NixThunkError NixThunkError\n    -- ^ Propagated errors from @nix-thunk@\n  | ObeliskError_Unstructured Text\n    -- ^ An ad-hoc error.\n\nmakePrisms ''ObeliskError\n\ninstance AsUnstructuredError ObeliskError where\n  asUnstructuredError = _ObeliskError_Unstructured\n\n-- Only project when the other field is null, otherwise we are not law abiding.\ninstance AsProcessFailure ObeliskError where\n  asProcessFailure = _ObeliskError_ProcessError . prism (flip ObeliskProcessError Nothing) f\n    where f = \\case\n            ObeliskProcessError pf Nothing -> Right pf\n            pann@(ObeliskProcessError _ (Just _)) -> Left pann\n\nnewtype Obelisk = Obelisk\n  { _obelisk_cliConfig :: CliConfig ObeliskError\n  }\n\nnewtype ObeliskT m a = ObeliskT\n  { unObeliskT :: ReaderT Obelisk (CliT ObeliskError m) a\n  }\n  deriving\n    ( Functor, Applicative, Monad, MonadIO, MonadThrow, MonadCatch, MonadMask, MonadFail\n    , MonadLog Output -- CliLog\n    , MonadError ObeliskError -- CliThrow ObeliskError\n    , HasCliConfig ObeliskError\n    )\n\ninstance MonadTrans ObeliskT where\n  lift = ObeliskT . lift . lift\n\nclass Monad m => HasObelisk m where\n  getObelisk :: m Obelisk\n\ninstance Monad m => HasObelisk (ObeliskT m) where\n  getObelisk = ObeliskT ask\n\ninstance HasObelisk m => HasObelisk (ReaderT r m) where\n  getObelisk = lift getObelisk\n\ninstance (Monoid w, HasObelisk m) => HasObelisk (WriterT w m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (StateT r m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (ExceptT e m) where\n  getObelisk = lift getObelisk\n\nrunObelisk :: MonadIO m => Obelisk -> ObeliskT m a -> m a\nrunObelisk c =\n    runCli (_obelisk_cliConfig c)\n  . flip runReaderT c\n  . unObeliskT\n\n-- | Wrap an action which may throw 'NixThunkError' (e.g.\n-- 'nixBuildAttrWithCache') in a 'MonadError' which supports throwing\n-- 'ObeliskError'.\nwrapNixThunkError\n  :: (MonadError ObeliskError m, HasCliConfig ObeliskError m, MonadIO m)\n  => CliT NixThunkError m a\n  -> m a\nwrapNixThunkError k = do\n  cfg <- getCliConfig\n  let cfg' = cfg { _cliConfig_errorLogExitCode = _cliConfig_errorLogExitCode cfg . ObeliskError_NixThunkError }\n  runCli cfg' k\n\ntype MonadInfallibleObelisk m =\n  ( CliLog m\n  , HasCliConfig ObeliskError m\n  , HasObelisk m\n  , MonadIO m\n  , MonadMask m\n  )\n\ntype MonadObelisk m =\n  ( MonadInfallibleObelisk m\n  , CliThrow ObeliskError m\n  , MonadFail m\n  )\n\ngetObeliskUserStateDir :: IO FilePath\ngetObeliskUserStateDir = getXdgDirectory XdgData \"obelisk\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/App.hs:(54,1)-(59,34)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data ObeliskError",
                    "    = ObeliskError_ProcessError ObeliskProcessError |",
                    "      ObeliskError_NixThunkError NixThunkError |",
                    "      ObeliskError_Unstructured Text"
                  ],
                  "perhaps_block": [
                    "  data ObeliskError",
                    "    = ObeliskErrorProcessError ObeliskProcessError |",
                    "      ObeliskErrorNixThunkError NixThunkError |",
                    "      ObeliskErrorUnstructured Text"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.App where\n\nimport Control.Lens\nimport Control.Monad.Catch (MonadCatch, MonadMask, MonadThrow)\nimport Control.Monad.Fail (MonadFail)\nimport Control.Monad.Reader (MonadIO, ReaderT (..), ask, runReaderT)\nimport Control.Monad.Writer (WriterT)\nimport Control.Monad.State (StateT)\nimport Control.Monad.Except (ExceptT, MonadError)\nimport Control.Monad.Trans.Class (MonadTrans, lift)\nimport Data.Text (Text)\nimport System.Directory (XdgDirectory (XdgData), getXdgDirectory)\nimport Control.Monad.Log (MonadLog)\nimport Cli.Extras.Types\nimport \"nix-thunk\" Nix.Thunk (NixThunkError)\n\nimport Cli.Extras\n  ( CliConfig\n  , CliLog\n  , CliThrow\n  , CliT (..)\n  , ProcessFailure\n  , AsProcessFailure (..)\n  , AsUnstructuredError (..)\n  , HasCliConfig\n  , Output\n  , runCli\n  )\n\n-- | An error thrown by one of the child processes invoked during\n-- execution of Obelisk.\ndata ObeliskProcessError\n  = ObeliskProcessError\n    { _obeliskProcessError_failure :: ProcessFailure\n      -- ^ The 'ProcessFailure' indicating both how the process was\n      -- created and its eventual exit code.\n    , _obeliskProcessError_mComment :: Maybe Text\n      -- ^ Optionally, a comment can be attached to the 'ProcessFailure'\n      -- to give the user more details.\n    }\n\n-- | An error thrown by the Obelisk app.\ndata ObeliskError\n  = ObeliskError_ProcessError ObeliskProcessError\n    -- ^ Indicates an error in one of our child processes.\n  | ObeliskError_NixThunkError NixThunkError\n    -- ^ Propagated errors from @nix-thunk@\n  | ObeliskError_Unstructured Text\n    -- ^ An ad-hoc error.\n\nmakePrisms ''ObeliskError\n\ninstance AsUnstructuredError ObeliskError where\n  asUnstructuredError = _ObeliskError_Unstructured\n\n-- Only project when the other field is null, otherwise we are not law abiding.\ninstance AsProcessFailure ObeliskError where\n  asProcessFailure = _ObeliskError_ProcessError . prism (`ObeliskProcessError` Nothing) f\n    where f = \\case\n            ObeliskProcessError pf Nothing -> Right pf\n            pann@(ObeliskProcessError _ (Just _)) -> Left pann\n\nnewtype Obelisk = Obelisk\n  { _obelisk_cliConfig :: CliConfig ObeliskError\n  }\n\nnewtype ObeliskT m a = ObeliskT\n  { unObeliskT :: ReaderT Obelisk (CliT ObeliskError m) a\n  }\n  deriving\n    ( Functor, Applicative, Monad, MonadIO, MonadThrow, MonadCatch, MonadMask, MonadFail\n    , MonadLog Output -- CliLog\n    , MonadError ObeliskError -- CliThrow ObeliskError\n    , HasCliConfig ObeliskError\n    )\n\ninstance MonadTrans ObeliskT where\n  lift = ObeliskT . lift . lift\n\nclass Monad m => HasObelisk m where\n  getObelisk :: m Obelisk\n\ninstance Monad m => HasObelisk (ObeliskT m) where\n  getObelisk = ObeliskT ask\n\ninstance HasObelisk m => HasObelisk (ReaderT r m) where\n  getObelisk = lift getObelisk\n\ninstance (Monoid w, HasObelisk m) => HasObelisk (WriterT w m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (StateT r m) where\n  getObelisk = lift getObelisk\n\ninstance HasObelisk m => HasObelisk (ExceptT e m) where\n  getObelisk = lift getObelisk\n\nrunObelisk :: MonadIO m => Obelisk -> ObeliskT m a -> m a\nrunObelisk c =\n    runCli (_obelisk_cliConfig c)\n  . flip runReaderT c\n  . unObeliskT\n\n-- | Wrap an action which may throw 'NixThunkError' (e.g.\n-- 'nixBuildAttrWithCache') in a 'MonadError' which supports throwing\n-- 'ObeliskError'.\nwrapNixThunkError\n  :: (MonadError ObeliskError m, HasCliConfig ObeliskError m, MonadIO m)\n  => CliT NixThunkError m a\n  -> m a\nwrapNixThunkError k = do\n  cfg <- getCliConfig\n  let cfg' = cfg { _cliConfig_errorLogExitCode = _cliConfig_errorLogExitCode cfg . ObeliskError_NixThunkError }\n  runCli cfg' k\n\ntype MonadInfallibleObelisk m =\n  ( CliLog m\n  , HasCliConfig ObeliskError m\n  , HasObelisk m\n  , MonadIO m\n  , MonadMask m\n  )\n\ntype MonadObelisk m =\n  ( MonadInfallibleObelisk m\n  , CliThrow ObeliskError m\n  , MonadFail m\n  )\n\ngetObeliskUserStateDir :: IO FilePath\ngetObeliskUserStateDir = getXdgDirectory XdgData \"obelisk\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 18,
                "average": 1.8823529411764706,
                "sum": 64
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 7,
                "ignore": 0,
                "total": 9
              },
              "syntax_errors": 16,
              "lines_of_code": 503,
              "homplexity_lines_of_code": 605,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 18,
                  "average": 1.8823529411764706,
                  "sum": 64
                },
                "homplexity_loc": 605,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 1 1: module Obelisk.Command has 362 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 41 13: data Args has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 51 22: data ArgsConfig has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has cyclomatic complexity of 1 \nCritical:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 89 6: data ObCommand has record fields count of 18 must never reach 9\nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 105 6: data ObInternal has record fields count of 5 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has 2 arguments \nWarning:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has 20 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has 8 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 185 22: data RemoteBuilder has record fields count of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 189 5: data DeployCommand has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 196 1: type signature for thunkDirectoryParser has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 196 1: type signature for thunkDirectoryParser has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 197 1: function thunkDirectoryParser has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 203 1: type signature for profileCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 203 1: type signature for profileCommand has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has 14 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 204 1: function profileCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 221 1: type signature for thunkConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 221 1: type signature for thunkConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 222 1: function thunkConfig has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 229 1: type signature for thunkUpdateConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 229 1: type signature for thunkUpdateConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 230 1: function thunkUpdateConfig has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 234 1: type signature for thunkPackConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 234 1: type signature for thunkPackConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 235 1: function thunkPackConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 239 20: data ThunkOption has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 245 5: data ThunkCommand has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 250 1: type signature for thunkOption has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 250 1: type signature for thunkOption has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has 10 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 251 1: function thunkOption has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 266 5: data ShellOpts has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 273 1: type signature for shellFlags has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 273 1: type signature for shellFlags has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 274 1: function shellFlags has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 279 1: type signature for userGhciConfigOpt has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 279 1: type signature for userGhciConfigOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 280 1: function userGhciConfigOpt has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 287 1: type signature for interpretOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 287 1: type signature for interpretOpts has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has 8 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 288 1: function interpretOpts has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 307 1: type signature for certDirOpts has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 307 1: type signature for certDirOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 308 1: function certDirOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 312 1: type signature for shellOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 312 1: type signature for shellOpts has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 313 1: function shellOpts has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 321 1: type signature for portOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 321 1: type signature for portOpt has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 322 1: function portOpt has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 324 1: type signature for parserPrefs has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 324 1: type signature for parserPrefs has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 325 1: function parserPrefs has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 330 1: type signature for mkObeliskConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 330 1: type signature for mkObeliskConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has 19 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 331 1: function mkObeliskConfig has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 366 1: type signature for runCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 366 1: type signature for runCommand has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 367 1: function runCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 369 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 369 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 370 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 370 1: function main has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 370 1: function main has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 374 1: type signature for hSetTranslit has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 374 1: type signature for hSetTranslit has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 375 1: function hSetTranslit has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 383 1: type signature for main' has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 383 1: type signature for main' has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has branching depth of 1 \nWarning:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has 30 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 384 1: function main' has cyclomatic complexity of 6 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 428 1: type signature for ob has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 428 1: type signature for ob has 2 arguments \nWarning:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 429 1: function ob has 33 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 429 1: function ob has branching depth of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 429 1: function ob has cyclomatic complexity of 18 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 466 1: type signature for withInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 466 1: type signature for withInterpretPaths has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 467 1: function withInterpretPaths has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 467 1: function withInterpretPaths has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 467 1: function withInterpretPaths has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 473 1: type signature for haddockCommand has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 473 1: type signature for haddockCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 474 1: function haddockCommand has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 474 1: function haddockCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 474 1: function haddockCommand has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 483 1: type signature for getArgsConfig has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 483 1: type signature for getArgsConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 484 1: function getArgsConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 484 1: function getArgsConfig has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 484 1: function getArgsConfig has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 496 1: type signature for resolveInterpretPaths has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 496 1: type signature for resolveInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 497 1: function resolveInterpretPaths has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 497 1: function resolveInterpretPaths has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command.hs\" 497 1: function resolveInterpretPaths has 5 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command where\n\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Bool (bool)\nimport Data.Foldable (for_)\nimport Data.List (isInfixOf, isPrefixOf, notElem)\nimport Data.List.NonEmpty (NonEmpty, nonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport qualified Data.Map as Map\nimport qualified Data.Text as T\nimport Data.Traversable (for)\nimport Options.Applicative\nimport Options.Applicative.Help.Pretty (text, (<$$>))\nimport System.Directory\nimport System.Environment\nimport System.FilePath\nimport System.Exit\nimport qualified System.Info\nimport System.IO (hIsTerminalDevice, Handle, stdout, stderr, hGetEncoding, hSetEncoding, mkTextEncoding)\nimport GHC.IO.Encoding.Types (textEncodingName)\nimport System.Process (rawSystem)\nimport Network.Socket (PortNumber)\n\nimport Obelisk.App\nimport Obelisk.Command.Deploy\nimport Obelisk.Command.Project\nimport Obelisk.Command.Run\nimport qualified Obelisk.Command.VmBuilder as VmBuilder\nimport qualified Obelisk.Command.Preprocessor as Preprocessor\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n\ndata Args = Args\n  { _args_noHandOffPassed :: Bool\n  -- ^ This flag is actually handled outside of the optparse-applicative parser, but we detect whether\n  -- it has gotten through in order to notify the user that it should only be passed once and as the very\n  -- first argument\n  , _args_verbose :: Bool\n  , _args_command :: ObCommand\n  }\n  deriving Show\n\nnewtype ArgsConfig = ArgsConfig\n  { _argsConfig_enableVmBuilderByDefault :: Bool\n  }\n\nargs :: ArgsConfig -> Parser Args\nargs cfg = Args <$> noHandoff <*> verbose <*> obCommand cfg\n\nnoHandoff :: Parser Bool\nnoHandoff = flag False True $ mconcat\n  [ long \"no-handoff\"\n  , help \"Do not hand off execution to project-specific implementation of this command\"\n  , hidden\n  ]\n\nverbose :: Parser Bool\nverbose = flag False True $ mconcat\n  [ long \"verbose\"\n  , short 'v'\n  , help \"Be more verbose\"\n  ]\n\nargsInfo :: ArgsConfig -> ParserInfo Args\nargsInfo cfg = info (args cfg <**> helper) $ mconcat\n  [ fullDesc\n  , progDesc \"Manage Obelisk projects\"\n  ]\n\ninitSource :: Parser InitSource\ninitSource = foldl1 (<|>)\n  [ pure InitSource_Default\n  , InitSource_Branch <$> strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Initialize the project using the given BRANCH of Obelisk's official repository\")\n  , InitSource_Symlink <$> strOption (long \"symlink\" <> action \"directory\" <> metavar \"PATH\" <> help \"(Use with caution) Initialize the project using the copy of Obelisk found at the given PATH\")\n  ]\n\ninitForce :: Parser Bool\ninitForce = switch (long \"force\" <> help \"Allow ob init to overwrite files\")\n\ndata ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] -- user @.ghci@ config\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String] -- shell and list of packages\n   | ObCommand_Hoogle String Int -- shell and port\n   | ObCommand_Internal ObInternal\n   deriving Show\n\ndata ObInternal\n   -- the preprocessor argument syntax is also handled outside\n   -- optparse-applicative, but it shouldn't ever conflict with another syntax\n   = ObInternal_ApplyPackages String String String [String]\n   | ObInternal_ExportGhciConfig\n      [(FilePath, Interpret)]\n   deriving Show\n\nobCommand :: ArgsConfig -> Parser ObCommand\nobCommand cfg = hsubparser\n  (mconcat\n    [ command \"init\" $ info (ObCommand_Init <$> initSource <*> initForce) $ progDesc \"Initialize an Obelisk project\"\n    , command \"deploy\" $ info (ObCommand_Deploy <$> deployCommand cfg) $ progDesc \"Prepare a deployment for an Obelisk project\"\n    , command \"run\" $ info\n      (   ObCommand_Run\n      <$> interpretOpts\n      <*> certDirOpts\n      <*> (Just <$> option auto (long \"port\" <> short 'p' <> help \"Port number for server; overrides common/config/route\" <> metavar \"INT\") <|> pure Nothing))\n      $ progDesc \"Run current project in development mode\"\n    , command \"profile\" $ info (uncurry ObCommand_Profile <$> profileCommand) $ progDesc \"Run current project with profiling enabled\"\n    , command \"thunk\" $ info (ObCommand_Thunk <$> thunkOption) $ progDesc \"Manipulate thunk directories\"\n    , command \"repl\" $ info (ObCommand_Repl <$> optional userGhciConfigOpt  <*> interpretOpts) $ progDesc \"Open an interactive interpreter\"\n    , command \"watch\" $ info (ObCommand_Watch <$> interpretOpts) $ progDesc \"Watch current project for errors and warnings\"\n    , command \"shell\" $ info (ObCommand_Shell <$> shellOpts) $ progDesc \"Enter a shell with project dependencies or run a command in such a shell. E.g. ob shell -- ghc-pkg list\"\n    , command \"doc\" $ info (ObCommand_Doc <$> shellFlags <*> packageNames) $\n        progDesc \"List paths to haddock documentation for specified packages\"\n        <> footerDoc (Just $\n              text \"Hint: To open the documentation you can pipe the output of this command like\"\n              <$$> text \"ob doc reflex reflex-dom-core | xargs -n1 xdg-open\")\n    , command \"hoogle\" $ info (ObCommand_Hoogle <$> shellFlags <*> portOpt 8080) $ progDesc \"Run a hoogle server locally for your project's dependency tree\"\n    , command \"internal\" $ info (ObCommand_Internal <$> internalCommand) $ progDesc \"Internal Obelisk commands with unstable APIs\"\n    ])\n\ninternalCommand :: Parser ObInternal\ninternalCommand = hsubparser $ mconcat\n  [ command \"export-ghci-configuration\" $ info (ObInternal_ExportGhciConfig <$> interpretOpts)\n      $ progDesc \"Export the GHCi configuration used by ob run, etc.; useful for IDE integration\"\n  ]\n\npackageNames :: Parser [String]\npackageNames = some (strArgument (metavar \"PACKAGE-NAME...\"))\n\ndeployCommand :: ArgsConfig -> Parser DeployCommand\ndeployCommand cfg = hsubparser $ mconcat\n  [ command \"init\" $ info (DeployCommand_Init <$> deployInitOpts) $ progDesc \"Initialize a deployment configuration directory\"\n  , command \"push\" $ info (DeployCommand_Push <$> remoteBuilderParser) mempty\n  , command \"test\" $ info (DeployCommand_Test <$> platformP) $ progDesc \"Test your obelisk project from a mobile platform.\"\n  , command \"update\" $ info (pure DeployCommand_Update) $ progDesc \"Update the deployment's src thunk to latest\"\n  ]\n  where\n    platformP = hsubparser $ mconcat\n      [ command \"android\" $ info (pure (Android, [])) mempty\n      , command \"ios\" $ info ((,) <$> pure IOS <*> fmap pure (strArgument (metavar \"TEAMID\" <> help \"Your Team ID - found in the Apple developer portal\"))) mempty\n      ]\n\n    remoteBuilderParser :: Parser (Maybe RemoteBuilder)\n    remoteBuilderParser =\n      flag (if enabledByDefault then enabled else Nothing) enabled (mconcat\n        [ long $ \"enable-\" <> flagBase\n        , help $ \"Enable \" <> flagDesc <> (if enabledByDefault then \" (default)\" else \"\")\n        ])\n      <|> flag enabled Nothing (mconcat\n        [ long $ \"disable-\" <> flagBase\n        , help $ \"Disable a \" <> flagDesc <> (if not enabledByDefault then \" (default)\" else \"\")\n        ])\n      where\n        enabledByDefault = _argsConfig_enableVmBuilderByDefault cfg\n        enabled = Just RemoteBuilder_ObeliskVM\n        flagBase = \"vm-builder\"\n        flagDesc = \"managed Linux virtual machine as a Nix remote builder (requires Docker)\"\n\n\ndeployInitOpts :: Parser DeployInitOpts\ndeployInitOpts = DeployInitOpts\n  <$> strArgument (action \"directory\" <> metavar \"DEPLOYDIR\" <> help \"Path to a directory where the deployment repository will be initialized\")\n  <*> strOption (long \"ssh-key\" <> action \"file\" <> metavar \"SSHKEY\" <> help \"Path to an SSH key that will be *copied* to the deployment repository\")\n  <*> some (strOption (long \"hostname\" <> metavar \"HOSTNAME\" <> help \"hostname of the deployment target\"))\n  <*> strOption (long \"route\" <> metavar \"PUBLICROUTE\" <> help \"Publicly accessible URL of your app\")\n  <*> strOption (long \"admin-email\" <> metavar \"ADMINEMAIL\" <> help \"Email address where administrative alerts will be sent\")\n  <*> flag True False (long \"disable-https\" <> help \"Disable automatic https configuration for the backend\")\n  <*> flag False True (long \"check-known-hosts\" <> help \"Add keys for the system's known_hosts matching the hostname to the configuration's known_hosts\")\n\ntype TeamID = String\ndata RemoteBuilder = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)\n\ndata DeployCommand\n  = DeployCommand_Init DeployInitOpts\n  | DeployCommand_Push (Maybe RemoteBuilder)\n  | DeployCommand_Test (PlatformDeployment, [String])\n  | DeployCommand_Update\n  deriving Show\n\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]\n\nprofileCommand :: Parser (String, [String])\nprofileCommand = (,)\n  <$> strOption\n    (  long \"output\"\n    <> short 'o'\n    <> help \"Base output to use for profiling output. Suffixes are added to this based on the profiling type. Defaults to a timestamped path in the profile/ directory in the project's root.\"\n    <> metavar \"PATH\"\n    <> value \"profile/%Y-%m-%dT%H:%M:%S\"\n    <> showDefault\n    )\n  <*> (words <$> strOption\n    (  long \"rts-flags\"\n    <> help \"RTS Flags to pass to the executable.\"\n    <> value \"-p -hc\"\n    <> metavar \"FLAGS\"\n    <> showDefault\n    ))\n\nthunkConfig :: Parser ThunkConfig\nthunkConfig = ThunkConfig\n  <$>\n    (   flag' (Just True) (long \"private\" <> help \"Mark thunks as pointing to a private repository\")\n    <|> flag' (Just False) (long \"public\" <> help \"Mark thunks as pointing to a public repository\")\n    <|> pure Nothing\n    )\n\nthunkUpdateConfig :: Parser ThunkUpdateConfig\nthunkUpdateConfig = ThunkUpdateConfig\n  <$> optional (strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Use the given branch when looking for the latest revision\"))\n  <*> thunkConfig\n\nthunkPackConfig :: Parser ThunkPackConfig\nthunkPackConfig = ThunkPackConfig\n  <$> switch (long \"force\" <> short 'f' <> help \"Force packing thunks even if there are branches not pushed upstream, uncommitted changes, stashes. This will cause changes that have not been pushed upstream to be lost; use with care.\")\n  <*> thunkConfig\n\ndata ThunkOption = ThunkOption\n  { _thunkOption_thunks :: NonEmpty FilePath\n  , _thunkOption_command :: ThunkCommand\n  } deriving Show\n\ndata ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig\n  | ThunkCommand_Unpack\n  | ThunkCommand_Pack ThunkPackConfig\n  deriving Show\n\nthunkOption :: Parser ThunkOption\nthunkOption = hsubparser $ mconcat\n  [ command \"update\" $ info (thunkOptionWith $ ThunkCommand_Update <$> thunkUpdateConfig) $ progDesc \"Update packed thunk to latest revision available on the tracked branch\"\n  , command \"unpack\" $ info (thunkOptionWith $ pure ThunkCommand_Unpack) $ progDesc \"Unpack thunk into git checkout of revision it points to\"\n  , command \"pack\" $ info (thunkOptionWith $ ThunkCommand_Pack <$> thunkPackConfig) $ progDesc \"Pack git checkout or unpacked thunk into thunk that points at the current branch's upstream\"\n  ]\n  where\n    thunkOptionWith f = ThunkOption\n      <$> ((NonEmpty.:|)\n            <$> thunkDirArg (metavar \"THUNKDIRS...\" <> help \"Paths to directories containing thunk data\")\n            <*> many (thunkDirArg mempty)\n          )\n      <*> f\n    thunkDirArg opts = fmap (dropTrailingPathSeparator . normalise) $ strArgument $ action \"directory\" <> opts\n\ndata ShellOpts\n  = ShellOpts\n    { _shellOpts_shell :: String\n    , _shellOpts_interpretPaths :: [(FilePath, Interpret)]\n    , _shellOpts_command :: Maybe String\n    }\n  deriving Show\n\nshellFlags :: Parser String\nshellFlags =\n  flag' \"ghc\" (long \"ghc\" <> help \"Enter a shell environment having ghc (default)\")\n  <|> flag \"ghc\" \"ghcjs\" (long \"ghcjs\" <> help \"Enter a shell having ghcjs rather than ghc\")\n  <|> strOption (short 'A' <> long \"argument\" <> metavar \"NIXARG\" <> help \"Use the environment specified by the given nix argument of `shells'\")\n\nuserGhciConfigOpt :: Parser FilePath\nuserGhciConfigOpt = strOption $ mconcat\n  [ long \"config\"\n  , short 'c'\n  , metavar \"CONFIG\"\n  , help \"User .ghci config file (use at your own risk)\"\n  ]\n\ninterpretOpts :: Parser [(FilePath, Interpret)]\ninterpretOpts = many\n    (   (, Interpret_Interpret) <$>\n          strOption (common <> long \"interpret\" <> help\n            \"Don't pre-build packages found in DIR when constructing the package database. The default behavior is \\\n            \\'--interpret <project-root>', which will load everything which is unpacked into GHCi. \\\n            \\ Use --interpret and --no-interpret multiple times to add or remove multiple trees \\\n            \\ from the environment. Settings for right-most directories will \\\n            \\ override settings for any identical directories given earlier.\"\n          )\n    <|> (, Interpret_NoInterpret) <$>\n          strOption (common <> long \"no-interpret\" <> help\n            \"Make packages found in DIR available in the package database (but only when they are used dependencies). \\\n            \\ This will build the packages in DIR before loading GHCi. \\\n            \\See help for --interpret for how the two options are related.\"\n          )\n    )\n  where\n    common = action \"directory\" <> metavar \"DIR\"\n\ncertDirOpts :: Parser (Maybe FilePath)\ncertDirOpts = optional (strOption (short 'c' <> long \"cert\" <> metavar \"DIRECTORY\" <> help helpText))\n  where\n    helpText = \"Specify a directory in which to find \\'cert.pem\\', \\'chain.pem\\' and \\'privkey.pem\\' for use with TLS.\"\n\nshellOpts :: Parser ShellOpts\nshellOpts = ShellOpts\n  <$> shellFlags\n  <*> interpretOpts\n  -- This funny construction is used to support optparse-applicative's @--@ parsing.\n  -- All arguments after @--@ are left unparsed and instead provided to the last positional parser\n  -- which must therefore be 'many' in order to consume the rest of the input.\n  <*> ((\\xs -> if null xs then Nothing else Just $ unwords xs) <$> many (strArgument (metavar \"COMMAND\")))\n\nportOpt :: Int -> Parser Int\nportOpt dfault = option auto (long \"port\" <> short 'p' <> help \"Port number for server\" <> showDefault <> value dfault <> metavar \"INT\")\n\nparserPrefs :: ParserPrefs\nparserPrefs = defaultPrefs\n  { prefShowHelpOnEmpty = True\n  }\n\n-- | Create an Obelisk config for the current process.\nmkObeliskConfig :: IO Obelisk\nmkObeliskConfig = do\n  cliArgs <- getArgs\n  -- This function should not use argument parser (full argument parsing happens post handoff)\n  -- TODO: See if we can use the argument parser with a subset of the parsers to get logging level out.\n  let logLevel = toLogLevel $ any (`elem` [\"-v\", \"--verbose\"]) cliArgs\n  notInteractive <- not <$> isInteractiveTerm\n  cliConf <- newCliConfig logLevel notInteractive notInteractive $ \\case\n    ObeliskError_ProcessError ObeliskProcessError{_obeliskProcessError_failure = ProcessFailure p code, _obeliskProcessError_mComment = ann } ->\n      ( \"Process exited with code \" <> T.pack (show code) <> \"; \" <> reconstructCommand p\n        <> maybe \"\" (\"\\n\" <>) ann\n      , ExitFailure 2\n      )\n    ObeliskError_NixThunkError e -> (prettyNixThunkError e, ExitFailure 2)\n    ObeliskError_Unstructured msg -> (msg, ExitFailure 2)\n\n  return $ Obelisk cliConf\n  where\n    toLogLevel = bool Notice Debug\n    isInteractiveTerm = do\n      isTerm <- hIsTerminalDevice stdout\n      -- Running in bash/fish/zsh completion\n      inShellCompletion <- liftIO $ isInfixOf \"completion\" . unwords <$> getArgs\n\n      -- Respect the user\u2019s TERM environment variable. Dumb terminals\n      -- like Eshell cannot handle lots of control sequences that the\n      -- spinner uses.\n      termEnv <- lookupEnv \"TERM\"\n      let isDumb = termEnv == Just \"dumb\"\n\n      return $ isTerm && not inShellCompletion && not isDumb\n\n-- | For use from development obelisk repls\n--\n-- Example:\n-- > runCommand $ someFuncInMonadObelisk ...\nrunCommand :: ObeliskT IO a -> IO a\nrunCommand f = flip runObelisk f =<< mkObeliskConfig\n\nmain :: IO ()\nmain = runCommand . main' =<< getArgsConfig\n\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()\n\nmain' :: MonadObelisk m => ArgsConfig -> m ()\nmain' argsCfg = do\n  obPath <- liftIO getExecutablePath\n  myArgs <- liftIO getArgs\n  logLevel <- getLogLevel\n\n  -- NB: We set the standard output and standard error streams to\n  -- TransliterateCodingFailure so that, on encodings which do not\n  -- support our fancy characters, we print a replacement character\n  -- instead of exploding.\n  liftIO $ hSetTranslit stdout\n  liftIO $ hSetTranslit stderr\n\n  putLog Debug $ T.pack $ unwords\n    [ \"Starting Obelisk <\" <> obPath <> \">\"\n    , \"args=\" <> show myArgs\n    , \"logging-level=\" <> show logLevel\n    ]\n\n  --TODO: We'd like to actually use the parser to determine whether to hand off,\n  --but in the case where this implementation of 'ob' doesn't support all\n  --arguments being passed along, this could fail.  For now, we don't bother\n  --with optparse-applicative until we've done the handoff.\n  let go as = do\n        args' <- liftIO $ handleParseResult (execParserPure parserPrefs (argsInfo argsCfg) as)\n        case _args_noHandOffPassed args' of\n          False -> return ()\n          True -> putLog Warning \"--no-handoff should only be passed once and as the first argument; ignoring\"\n        ob $ _args_command args'\n      handoffAndGo as = findProjectObeliskCommand \".\" >>= \\case\n        Nothing -> go as -- If not in a project, just run ourselves\n        Just impl -> do\n          -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n          putLog Debug $ \"Handing off to \" <> T.pack impl\n          _ <- liftIO $ rawSystem impl (\"--no-handoff\" : myArgs)\n          return ()\n  case myArgs of\n    \"--no-handoff\" : as -> go as -- If we've been told not to hand off, don't hand off\n    origPath:inPath:outPath:preprocessorName:packagePaths\n      | preprocessorName == preprocessorIdentifier && any (\\c -> c == '.' || c == pathSeparator) origPath ->\n        ob $ ObCommand_Internal $ ObInternal_ApplyPackages origPath inPath outPath packagePaths\n    a:as -- Otherwise bash completion would always hand-off even if the user isn't trying to\n      | \"--bash-completion\" `isPrefixOf` a\n      && \"--no-handoff\" `elem` as -> go (a:as)\n      | otherwise -> handoffAndGo (a:as)\n    as -> handoffAndGo as\n\nob :: MonadObelisk m => ObCommand -> m ()\nob = \\case\n  ObCommand_Init source force -> initProject source force\n  ObCommand_Deploy dc -> case dc of\n    DeployCommand_Init deployOpts -> withProjectRoot \".\" $ \\root -> deployInit deployOpts root\n    DeployCommand_Push remoteBuilder -> do\n      deployPath <- liftIO $ canonicalizePath \".\"\n      deployBuilders <- case remoteBuilder of\n        Nothing -> pure []\n        Just RemoteBuilder_ObeliskVM -> (:[]) <$> VmBuilder.getNixBuildersArg\n      deployPush deployPath deployBuilders\n    DeployCommand_Update -> deployUpdate \".\"\n    DeployCommand_Test (platform, extraArgs) -> deployMobile platform extraArgs\n  ObCommand_Run interpretPathsList certDir servePort -> withInterpretPaths interpretPathsList (run certDir servePort)\n  ObCommand_Profile basePath rtsFlags -> profile basePath rtsFlags\n  ObCommand_Thunk to -> wrapNixThunkError $ case _thunkOption_command to of\n    ThunkCommand_Update config -> for_ thunks (updateThunkToLatest config)\n    ThunkCommand_Unpack -> for_ thunks unpackThunk\n    ThunkCommand_Pack config -> for_ thunks (packThunk config)\n    where\n      thunks = _thunkOption_thunks to\n  ObCommand_Repl mUserGhciConfig interpretPathsList -> withInterpretPaths interpretPathsList $ runRepl mUserGhciConfig\n  ObCommand_Watch interpretPathsList -> withInterpretPaths interpretPathsList runWatch\n  ObCommand_Shell (ShellOpts shellAttr interpretPathsList cmd) -> withInterpretPaths interpretPathsList $ \\root interpretPaths -> do\n    putLog Notice \"Hint: use '--no-interpret path/to/dependency' to force building an unpacked dependency and include it in this shell.\"\n    nixShellForInterpretPaths False shellAttr root interpretPaths cmd -- N.B. We do NOT bash escape here; we want to run the command as-is\n  ObCommand_Doc shellAttr pkgs -> withInterpretPaths [] $ \\root interpretPaths ->\n    nixShellForInterpretPaths True shellAttr root interpretPaths $ Just $ haddockCommand pkgs\n  ObCommand_Hoogle shell' port -> withProjectRoot \".\" $ \\root -> do\n    nixShellWithHoogle root True shell' $ Just $ \"hoogle server -p\" <> show port <> \" --local\"\n  ObCommand_Internal icmd -> case icmd of\n    ObInternal_ApplyPackages origPath inPath outPath packagePaths -> do\n      liftIO $ Preprocessor.applyPackages origPath inPath outPath packagePaths\n    ObInternal_ExportGhciConfig interpretPathsList ->\n      liftIO . putStrLn . unlines =<< withInterpretPaths interpretPathsList exportGhciConfig\n\n-- | A helper for the common case that the command you want to run needs the project root and a resolved\n-- set of interpret paths.\nwithInterpretPaths :: MonadObelisk m => [(FilePath, Interpret)] -> (FilePath -> PathTree Interpret -> m a) -> m a\nwithInterpretPaths interpretPathsList f = withProjectRoot \".\" $ \\root -> do\n  interpretPaths' <- resolveInterpretPaths $ (root, Interpret_Interpret) : interpretPathsList\n  case interpretPaths' of\n    Nothing -> failWith \"No paths provided for finding packages\"\n    Just interpretPaths -> f root interpretPaths\n\nhaddockCommand :: [String] -> String\nhaddockCommand pkgs = unwords\n  [ \"for p in\"\n  , unwords [getHaddockPath p ++ \"/index.html\" | p <- pkgs]\n  , \"; do echo $p; done\"\n  ]\n  where getHaddockPath p = \"$(ghc-pkg field \" ++ p ++ \" haddock-html --simple-output)\"\n\n--TODO: Clean up all the magic strings throughout this codebase\n\ngetArgsConfig :: IO ArgsConfig\ngetArgsConfig = pure $ ArgsConfig { _argsConfig_enableVmBuilderByDefault = System.Info.os == \"darwin\" }\n\n-- | Resolves an ordered list of paths for use with @--interpret@/@--no-interpret@ by coalescing\n--   paths into a non-ambiguous set of paths. Ambiguity is resolved by choosing right-most paths\n--   over any preceeding identical paths.\n--\n--   For example: @a/b=ON a/b/c=OFF@ and @a/b/c=OFF a/b=ON@ are the same.\n--   @a/b=ON a/b=OFF@ is reduced to @a/b=OFF@. We prefer right-biased choice to increase\n--   scriptability.\n--\n--   N.B. All the paths in the result will be canonicalized. It's impossible to determine path\n--   overlap otherwise.\nresolveInterpretPaths :: MonadIO m => [(FilePath, a)] -> m (Maybe (PathTree a))\nresolveInterpretPaths ps = do\n  trees <- liftIO $ for ps $ \\(p, a) -> pathToTree a <$> canonicalizePath p\n  pure $ foldr1 mergeTrees <$> nonEmpty trees\n  where\n    -- | Merge two 'PathTree's preferring leaves on the right in as much as they overlap with paths on the left.\n    mergeTrees :: PathTree a -> PathTree a -> PathTree a\n    mergeTrees (PathTree_Node ax x) (PathTree_Node ay y) = PathTree_Node (ay <|> ax) $ Map.unionWith mergeTrees x y\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:(88,1)-(100,16)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data ObCommand",
                    "    = ObCommand_Init InitSource Bool |",
                    "      ObCommand_Deploy DeployCommand |",
                    "      ObCommand_Run [(FilePath,",
                    "                      Interpret)] (Maybe FilePath) (Maybe PortNumber) |",
                    "      ObCommand_Profile String [String] |",
                    "      ObCommand_Thunk ThunkOption |",
                    "      ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] |",
                    "      ObCommand_Watch [(FilePath, Interpret)] |",
                    "      ObCommand_Shell ShellOpts |",
                    "      ObCommand_Doc String [String] |",
                    "      ObCommand_Hoogle String Int |",
                    "      ObCommand_Internal ObInternal",
                    "    deriving Show"
                  ],
                  "perhaps_block": [
                    "  data ObCommand",
                    "    = ObCommandInit InitSource Bool |",
                    "      ObCommandDeploy DeployCommand |",
                    "      ObCommandRun [(FilePath,",
                    "                     Interpret)] (Maybe FilePath) (Maybe PortNumber) |",
                    "      ObCommandProfile String [String] |",
                    "      ObCommandThunk ThunkOption |",
                    "      ObCommandRepl (Maybe FilePath) [(FilePath, Interpret)] |",
                    "      ObCommandWatch [(FilePath, Interpret)] |",
                    "      ObCommandShell ShellOpts |",
                    "      ObCommandDoc String [String] |",
                    "      ObCommandHoogle String Int |",
                    "      ObCommandInternal ObInternal",
                    "    deriving Show"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:(185,1)-(186,21)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data RemoteBuilder",
                    "    = RemoteBuilder_ObeliskVM",
                    "    deriving (Eq, Show)"
                  ],
                  "perhaps_block": [
                    "  data RemoteBuilder",
                    "    = RemoteBuilderObeliskVM",
                    "    deriving (Eq, Show)"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs:(244,1)-(248,15)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data ThunkCommand",
                    "    = ThunkCommand_Update ThunkUpdateConfig |",
                    "      ThunkCommand_Unpack |",
                    "      ThunkCommand_Pack ThunkPackConfig",
                    "    deriving Show"
                  ],
                  "perhaps_block": [
                    "  data ThunkCommand",
                    "    = ThunkCommandUpdate ThunkUpdateConfig |",
                    "      ThunkCommandUnpack |",
                    "      ThunkCommandPack ThunkPackConfig",
                    "    deriving Show"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command where\n\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Bool (bool)\nimport Data.Foldable (for_)\nimport Data.List (isInfixOf, isPrefixOf, notElem)\nimport Data.List.NonEmpty (NonEmpty, nonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport qualified Data.Map as Map\nimport qualified Data.Text as T\nimport Data.Traversable (for)\nimport Options.Applicative\nimport Options.Applicative.Help.Pretty (text, (<$$>))\nimport System.Directory\nimport System.Environment\nimport System.FilePath\nimport System.Exit\nimport qualified System.Info\nimport System.IO (hIsTerminalDevice, Handle, stdout, stderr, hGetEncoding, hSetEncoding, mkTextEncoding)\nimport GHC.IO.Encoding.Types (textEncodingName)\nimport System.Process (rawSystem)\nimport Network.Socket (PortNumber)\n\nimport Obelisk.App\nimport Obelisk.Command.Deploy\nimport Obelisk.Command.Project\nimport Obelisk.Command.Run\nimport qualified Obelisk.Command.VmBuilder as VmBuilder\nimport qualified Obelisk.Command.Preprocessor as Preprocessor\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n\ndata Args = Args\n  { _args_noHandOffPassed :: Bool\n  -- ^ This flag is actually handled outside of the optparse-applicative parser, but we detect whether\n  -- it has gotten through in order to notify the user that it should only be passed once and as the very\n  -- first argument\n  , _args_verbose :: Bool\n  , _args_command :: ObCommand\n  }\n  deriving Show\n\nnewtype ArgsConfig = ArgsConfig\n  { _argsConfig_enableVmBuilderByDefault :: Bool\n  }\n\nargs :: ArgsConfig -> Parser Args\nargs cfg = Args <$> noHandoff <*> verbose <*> obCommand cfg\n\nnoHandoff :: Parser Bool\nnoHandoff = flag False True $ mconcat\n  [ long \"no-handoff\"\n  , help \"Do not hand off execution to project-specific implementation of this command\"\n  , hidden\n  ]\n\nverbose :: Parser Bool\nverbose = flag False True $ mconcat\n  [ long \"verbose\"\n  , short 'v'\n  , help \"Be more verbose\"\n  ]\n\nargsInfo :: ArgsConfig -> ParserInfo Args\nargsInfo cfg = info (args cfg <**> helper) $ mconcat\n  [ fullDesc\n  , progDesc \"Manage Obelisk projects\"\n  ]\n\ninitSource :: Parser InitSource\ninitSource = foldl1 (<|>)\n  [ pure InitSource_Default\n  , InitSource_Branch <$> strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Initialize the project using the given BRANCH of Obelisk's official repository\")\n  , InitSource_Symlink <$> strOption (long \"symlink\" <> action \"directory\" <> metavar \"PATH\" <> help \"(Use with caution) Initialize the project using the copy of Obelisk found at the given PATH\")\n  ]\n\ninitForce :: Parser Bool\ninitForce = switch (long \"force\" <> help \"Allow ob init to overwrite files\")\n\ndata ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] -- user @.ghci@ config\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String] -- shell and list of packages\n   | ObCommand_Hoogle String Int -- shell and port\n   | ObCommand_Internal ObInternal\n   deriving Show\n\ndata ObInternal\n   -- the preprocessor argument syntax is also handled outside\n   -- optparse-applicative, but it shouldn't ever conflict with another syntax\n   = ObInternal_ApplyPackages String String String [String]\n   | ObInternal_ExportGhciConfig\n      [(FilePath, Interpret)]\n   deriving Show\n\nobCommand :: ArgsConfig -> Parser ObCommand\nobCommand cfg = hsubparser\n  (mconcat\n    [ command \"init\" $ info (ObCommand_Init <$> initSource <*> initForce) $ progDesc \"Initialize an Obelisk project\"\n    , command \"deploy\" $ info (ObCommand_Deploy <$> deployCommand cfg) $ progDesc \"Prepare a deployment for an Obelisk project\"\n    , command \"run\" $ info\n      (   ObCommand_Run\n      <$> interpretOpts\n      <*> certDirOpts\n      <*> (optional (option auto (long \"port\" <> short 'p' <> help \"Port number for server; overrides common/config/route\" <> metavar \"INT\"))))\n      $ progDesc \"Run current project in development mode\"\n    , command \"profile\" $ info (uncurry ObCommand_Profile <$> profileCommand) $ progDesc \"Run current project with profiling enabled\"\n    , command \"thunk\" $ info (ObCommand_Thunk <$> thunkOption) $ progDesc \"Manipulate thunk directories\"\n    , command \"repl\" $ info (ObCommand_Repl <$> optional userGhciConfigOpt  <*> interpretOpts) $ progDesc \"Open an interactive interpreter\"\n    , command \"watch\" $ info (ObCommand_Watch <$> interpretOpts) $ progDesc \"Watch current project for errors and warnings\"\n    , command \"shell\" $ info (ObCommand_Shell <$> shellOpts) $ progDesc \"Enter a shell with project dependencies or run a command in such a shell. E.g. ob shell -- ghc-pkg list\"\n    , command \"doc\" $ info (ObCommand_Doc <$> shellFlags <*> packageNames) $\n        progDesc \"List paths to haddock documentation for specified packages\"\n        <> footerDoc (Just $\n              text \"Hint: To open the documentation you can pipe the output of this command like\"\n              <$$> text \"ob doc reflex reflex-dom-core | xargs -n1 xdg-open\")\n    , command \"hoogle\" $ info (ObCommand_Hoogle <$> shellFlags <*> portOpt 8080) $ progDesc \"Run a hoogle server locally for your project's dependency tree\"\n    , command \"internal\" $ info (ObCommand_Internal <$> internalCommand) $ progDesc \"Internal Obelisk commands with unstable APIs\"\n    ])\n\ninternalCommand :: Parser ObInternal\ninternalCommand = hsubparser $ mconcat\n  [ command \"export-ghci-configuration\" $ info (ObInternal_ExportGhciConfig <$> interpretOpts)\n      $ progDesc \"Export the GHCi configuration used by ob run, etc.; useful for IDE integration\"\n  ]\n\npackageNames :: Parser [String]\npackageNames = some (strArgument (metavar \"PACKAGE-NAME...\"))\n\ndeployCommand :: ArgsConfig -> Parser DeployCommand\ndeployCommand cfg = hsubparser $ mconcat\n  [ command \"init\" $ info (DeployCommand_Init <$> deployInitOpts) $ progDesc \"Initialize a deployment configuration directory\"\n  , command \"push\" $ info (DeployCommand_Push <$> remoteBuilderParser) mempty\n  , command \"test\" $ info (DeployCommand_Test <$> platformP) $ progDesc \"Test your obelisk project from a mobile platform.\"\n  , command \"update\" $ info (pure DeployCommand_Update) $ progDesc \"Update the deployment's src thunk to latest\"\n  ]\n  where\n    platformP = hsubparser $ mconcat\n      [ command \"android\" $ info (pure (Android, [])) mempty\n      , command \"ios\" $ info (pure ((,) IOS) <*> fmap pure (strArgument (metavar \"TEAMID\" <> help \"Your Team ID - found in the Apple developer portal\"))) mempty\n      ]\n\n    remoteBuilderParser :: Parser (Maybe RemoteBuilder)\n    remoteBuilderParser =\n      flag (if enabledByDefault then enabled else Nothing) enabled (mconcat\n        [ long $ \"enable-\" <> flagBase\n        , help $ \"Enable \" <> flagDesc <> (if enabledByDefault then \" (default)\" else \"\")\n        ])\n      <|> flag enabled Nothing (mconcat\n        [ long $ \"disable-\" <> flagBase\n        , help $ \"Disable a \" <> flagDesc <> (if not enabledByDefault then \" (default)\" else \"\")\n        ])\n      where\n        enabledByDefault = _argsConfig_enableVmBuilderByDefault cfg\n        enabled = Just RemoteBuilder_ObeliskVM\n        flagBase = \"vm-builder\"\n        flagDesc = \"managed Linux virtual machine as a Nix remote builder (requires Docker)\"\n\n\ndeployInitOpts :: Parser DeployInitOpts\ndeployInitOpts = DeployInitOpts\n  <$> strArgument (action \"directory\" <> metavar \"DEPLOYDIR\" <> help \"Path to a directory where the deployment repository will be initialized\")\n  <*> strOption (long \"ssh-key\" <> action \"file\" <> metavar \"SSHKEY\" <> help \"Path to an SSH key that will be *copied* to the deployment repository\")\n  <*> some (strOption (long \"hostname\" <> metavar \"HOSTNAME\" <> help \"hostname of the deployment target\"))\n  <*> strOption (long \"route\" <> metavar \"PUBLICROUTE\" <> help \"Publicly accessible URL of your app\")\n  <*> strOption (long \"admin-email\" <> metavar \"ADMINEMAIL\" <> help \"Email address where administrative alerts will be sent\")\n  <*> flag True False (long \"disable-https\" <> help \"Disable automatic https configuration for the backend\")\n  <*> flag False True (long \"check-known-hosts\" <> help \"Add keys for the system's known_hosts matching the hostname to the configuration's known_hosts\")\n\ntype TeamID = String\ndata RemoteBuilder = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)\n\ndata DeployCommand\n  = DeployCommand_Init DeployInitOpts\n  | DeployCommand_Push (Maybe RemoteBuilder)\n  | DeployCommand_Test (PlatformDeployment, [String])\n  | DeployCommand_Update\n  deriving Show\n\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]\n\nprofileCommand :: Parser (String, [String])\nprofileCommand = (,)\n  <$> strOption\n    (  long \"output\"\n    <> short 'o'\n    <> help \"Base output to use for profiling output. Suffixes are added to this based on the profiling type. Defaults to a timestamped path in the profile/ directory in the project's root.\"\n    <> metavar \"PATH\"\n    <> value \"profile/%Y-%m-%dT%H:%M:%S\"\n    <> showDefault\n    )\n  <*> (words <$> strOption\n    (  long \"rts-flags\"\n    <> help \"RTS Flags to pass to the executable.\"\n    <> value \"-p -hc\"\n    <> metavar \"FLAGS\"\n    <> showDefault\n    ))\n\nthunkConfig :: Parser ThunkConfig\nthunkConfig = ThunkConfig\n  <$>\n    (   flag' (Just True) (long \"private\" <> help \"Mark thunks as pointing to a private repository\")\n    <|> flag' (Just False) (long \"public\" <> help \"Mark thunks as pointing to a public repository\")\n    <|> pure Nothing\n    )\n\nthunkUpdateConfig :: Parser ThunkUpdateConfig\nthunkUpdateConfig = ThunkUpdateConfig\n  <$> optional (strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Use the given branch when looking for the latest revision\"))\n  <*> thunkConfig\n\nthunkPackConfig :: Parser ThunkPackConfig\nthunkPackConfig = ThunkPackConfig\n  <$> switch (long \"force\" <> short 'f' <> help \"Force packing thunks even if there are branches not pushed upstream, uncommitted changes, stashes. This will cause changes that have not been pushed upstream to be lost; use with care.\")\n  <*> thunkConfig\n\ndata ThunkOption = ThunkOption\n  { _thunkOption_thunks :: NonEmpty FilePath\n  , _thunkOption_command :: ThunkCommand\n  } deriving Show\n\ndata ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig\n  | ThunkCommand_Unpack\n  | ThunkCommand_Pack ThunkPackConfig\n  deriving Show\n\nthunkOption :: Parser ThunkOption\nthunkOption = hsubparser $ mconcat\n  [ command \"update\" $ info (thunkOptionWith $ ThunkCommand_Update <$> thunkUpdateConfig) $ progDesc \"Update packed thunk to latest revision available on the tracked branch\"\n  , command \"unpack\" $ info (thunkOptionWith $ pure ThunkCommand_Unpack) $ progDesc \"Unpack thunk into git checkout of revision it points to\"\n  , command \"pack\" $ info (thunkOptionWith $ ThunkCommand_Pack <$> thunkPackConfig) $ progDesc \"Pack git checkout or unpacked thunk into thunk that points at the current branch's upstream\"\n  ]\n  where\n    thunkOptionWith f = ThunkOption\n      <$> ((NonEmpty.:|)\n            <$> thunkDirArg (metavar \"THUNKDIRS...\" <> help \"Paths to directories containing thunk data\")\n            <*> many (thunkDirArg mempty)\n          )\n      <*> f\n    thunkDirArg opts = fmap (dropTrailingPathSeparator . normalise) $ strArgument $ action \"directory\" <> opts\n\ndata ShellOpts\n  = ShellOpts\n    { _shellOpts_shell :: String\n    , _shellOpts_interpretPaths :: [(FilePath, Interpret)]\n    , _shellOpts_command :: Maybe String\n    }\n  deriving Show\n\nshellFlags :: Parser String\nshellFlags =\n  flag' \"ghc\" (long \"ghc\" <> help \"Enter a shell environment having ghc (default)\")\n  <|> flag \"ghc\" \"ghcjs\" (long \"ghcjs\" <> help \"Enter a shell having ghcjs rather than ghc\")\n  <|> strOption (short 'A' <> long \"argument\" <> metavar \"NIXARG\" <> help \"Use the environment specified by the given nix argument of `shells'\")\n\nuserGhciConfigOpt :: Parser FilePath\nuserGhciConfigOpt = strOption $ mconcat\n  [ long \"config\"\n  , short 'c'\n  , metavar \"CONFIG\"\n  , help \"User .ghci config file (use at your own risk)\"\n  ]\n\ninterpretOpts :: Parser [(FilePath, Interpret)]\ninterpretOpts = many\n    (   (, Interpret_Interpret) <$>\n          strOption (common <> long \"interpret\" <> help\n            \"Don't pre-build packages found in DIR when constructing the package database. The default behavior is \\\n            \\'--interpret <project-root>', which will load everything which is unpacked into GHCi. \\\n            \\ Use --interpret and --no-interpret multiple times to add or remove multiple trees \\\n            \\ from the environment. Settings for right-most directories will \\\n            \\ override settings for any identical directories given earlier.\"\n          )\n    <|> (, Interpret_NoInterpret) <$>\n          strOption (common <> long \"no-interpret\" <> help\n            \"Make packages found in DIR available in the package database (but only when they are used dependencies). \\\n            \\ This will build the packages in DIR before loading GHCi. \\\n            \\See help for --interpret for how the two options are related.\"\n          )\n    )\n  where\n    common = action \"directory\" <> metavar \"DIR\"\n\ncertDirOpts :: Parser (Maybe FilePath)\ncertDirOpts = optional (strOption (short 'c' <> long \"cert\" <> metavar \"DIRECTORY\" <> help helpText))\n  where\n    helpText = \"Specify a directory in which to find \\'cert.pem\\', \\'chain.pem\\' and \\'privkey.pem\\' for use with TLS.\"\n\nshellOpts :: Parser ShellOpts\nshellOpts = ShellOpts\n  <$> shellFlags\n  <*> interpretOpts\n  -- This funny construction is used to support optparse-applicative's @--@ parsing.\n  -- All arguments after @--@ are left unparsed and instead provided to the last positional parser\n  -- which must therefore be 'many' in order to consume the rest of the input.\n  <*> ((\\xs -> if null xs then Nothing else Just $ unwords xs) <$> many (strArgument (metavar \"COMMAND\")))\n\nportOpt :: Int -> Parser Int\nportOpt dfault = option auto (long \"port\" <> short 'p' <> help \"Port number for server\" <> showDefault <> value dfault <> metavar \"INT\")\n\nparserPrefs :: ParserPrefs\nparserPrefs = defaultPrefs\n  { prefShowHelpOnEmpty = True\n  }\n\n-- | Create an Obelisk config for the current process.\nmkObeliskConfig :: IO Obelisk\nmkObeliskConfig = do\n  cliArgs <- getArgs\n  -- This function should not use argument parser (full argument parsing happens post handoff)\n  -- TODO: See if we can use the argument parser with a subset of the parsers to get logging level out.\n  let logLevel = toLogLevel $ any (`elem` [\"-v\", \"--verbose\"]) cliArgs\n  notInteractive <- not <$> isInteractiveTerm\n  cliConf <- newCliConfig logLevel notInteractive notInteractive $ \\case\n    ObeliskError_ProcessError ObeliskProcessError{_obeliskProcessError_failure = ProcessFailure p code, _obeliskProcessError_mComment = ann } ->\n      ( \"Process exited with code \" <> T.pack (show code) <> \"; \" <> reconstructCommand p\n        <> maybe \"\" (\"\\n\" <>) ann\n      , ExitFailure 2\n      )\n    ObeliskError_NixThunkError e -> (prettyNixThunkError e, ExitFailure 2)\n    ObeliskError_Unstructured msg -> (msg, ExitFailure 2)\n\n  return $ Obelisk cliConf\n  where\n    toLogLevel = bool Notice Debug\n    isInteractiveTerm = do\n      isTerm <- hIsTerminalDevice stdout\n      -- Running in bash/fish/zsh completion\n      inShellCompletion <- liftIO $ isInfixOf \"completion\" . unwords <$> getArgs\n\n      -- Respect the user\u2019s TERM environment variable. Dumb terminals\n      -- like Eshell cannot handle lots of control sequences that the\n      -- spinner uses.\n      termEnv <- lookupEnv \"TERM\"\n      let isDumb = termEnv == Just \"dumb\"\n\n      return $ isTerm && not inShellCompletion && not isDumb\n\n-- | For use from development obelisk repls\n--\n-- Example:\n-- > runCommand $ someFuncInMonadObelisk ...\nrunCommand :: ObeliskT IO a -> IO a\nrunCommand f = flip runObelisk f =<< mkObeliskConfig\n\nmain :: IO ()\nmain = runCommand . main' =<< getArgsConfig\n\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()\n\nmain' :: MonadObelisk m => ArgsConfig -> m ()\nmain' argsCfg = do\n  obPath <- liftIO getExecutablePath\n  myArgs <- liftIO getArgs\n  logLevel <- getLogLevel\n\n  -- NB: We set the standard output and standard error streams to\n  -- TransliterateCodingFailure so that, on encodings which do not\n  -- support our fancy characters, we print a replacement character\n  -- instead of exploding.\n  liftIO $ hSetTranslit stdout\n  liftIO $ hSetTranslit stderr\n\n  putLog Debug $ T.pack $ unwords\n    [ \"Starting Obelisk <\" <> obPath <> \">\"\n    , \"args=\" <> show myArgs\n    , \"logging-level=\" <> show logLevel\n    ]\n\n  --TODO: We'd like to actually use the parser to determine whether to hand off,\n  --but in the case where this implementation of 'ob' doesn't support all\n  --arguments being passed along, this could fail.  For now, we don't bother\n  --with optparse-applicative until we've done the handoff.\n  let go as = do\n        args' <- liftIO $ handleParseResult (execParserPure parserPrefs (argsInfo argsCfg) as)\n        (if _args_noHandOffPassed args' then putLog Warning \"--no-handoff should only be passed once and as the first argument; ignoring\" else return ())\n        ob $ _args_command args'\n      handoffAndGo as = findProjectObeliskCommand \".\" >>= \\case\n        Nothing -> go as -- If not in a project, just run ourselves\n        Just impl -> do\n          -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n          putLog Debug $ \"Handing off to \" <> T.pack impl\n          _ <- liftIO $ rawSystem impl (\"--no-handoff\" : myArgs)\n          return ()\n  case myArgs of\n    \"--no-handoff\" : as -> go as -- If we've been told not to hand off, don't hand off\n    origPath:inPath:outPath:preprocessorName:packagePaths\n      | preprocessorName == preprocessorIdentifier && any (\\c -> c == '.' || c == pathSeparator) origPath ->\n        ob $ ObCommand_Internal $ ObInternal_ApplyPackages origPath inPath outPath packagePaths\n    a:as -- Otherwise bash completion would always hand-off even if the user isn't trying to\n      | \"--bash-completion\" `isPrefixOf` a\n      && \"--no-handoff\" `elem` as -> go (a:as)\n      | otherwise -> handoffAndGo (a:as)\n    as -> handoffAndGo as\n\nob :: MonadObelisk m => ObCommand -> m ()\nob = \\case\n  ObCommand_Init source force -> initProject source force\n  ObCommand_Deploy dc -> case dc of\n    DeployCommand_Init deployOpts -> withProjectRoot \".\" $ \\root -> deployInit deployOpts root\n    DeployCommand_Push remoteBuilder -> do\n      deployPath <- liftIO $ canonicalizePath \".\"\n      deployBuilders <- case remoteBuilder of\n        Nothing -> pure []\n        Just RemoteBuilder_ObeliskVM -> (:[]) <$> VmBuilder.getNixBuildersArg\n      deployPush deployPath deployBuilders\n    DeployCommand_Update -> deployUpdate \".\"\n    DeployCommand_Test (platform, extraArgs) -> deployMobile platform extraArgs\n  ObCommand_Run interpretPathsList certDir servePort -> withInterpretPaths interpretPathsList (run certDir servePort)\n  ObCommand_Profile basePath rtsFlags -> profile basePath rtsFlags\n  ObCommand_Thunk to -> wrapNixThunkError $ case _thunkOption_command to of\n    ThunkCommand_Update config -> for_ thunks (updateThunkToLatest config)\n    ThunkCommand_Unpack -> for_ thunks unpackThunk\n    ThunkCommand_Pack config -> for_ thunks (packThunk config)\n    where\n      thunks = _thunkOption_thunks to\n  ObCommand_Repl mUserGhciConfig interpretPathsList -> withInterpretPaths interpretPathsList $ runRepl mUserGhciConfig\n  ObCommand_Watch interpretPathsList -> withInterpretPaths interpretPathsList runWatch\n  ObCommand_Shell (ShellOpts shellAttr interpretPathsList cmd) -> withInterpretPaths interpretPathsList $ \\root interpretPaths -> do\n    putLog Notice \"Hint: use '--no-interpret path/to/dependency' to force building an unpacked dependency and include it in this shell.\"\n    nixShellForInterpretPaths False shellAttr root interpretPaths cmd -- N.B. We do NOT bash escape here; we want to run the command as-is\n  ObCommand_Doc shellAttr pkgs -> withInterpretPaths [] $ \\root interpretPaths ->\n    nixShellForInterpretPaths True shellAttr root interpretPaths $ Just $ haddockCommand pkgs\n  ObCommand_Hoogle shell' port -> withProjectRoot \".\" $ \\root -> do\n    nixShellWithHoogle root True shell' $ Just $ \"hoogle server -p\" <> show port <> \" --local\"\n  ObCommand_Internal icmd -> case icmd of\n    ObInternal_ApplyPackages origPath inPath outPath packagePaths -> do\n      liftIO $ Preprocessor.applyPackages origPath inPath outPath packagePaths\n    ObInternal_ExportGhciConfig interpretPathsList ->\n      liftIO . putStrLn . unlines =<< withInterpretPaths interpretPathsList exportGhciConfig\n\n-- | A helper for the common case that the command you want to run needs the project root and a resolved\n-- set of interpret paths.\nwithInterpretPaths :: MonadObelisk m => [(FilePath, Interpret)] -> (FilePath -> PathTree Interpret -> m a) -> m a\nwithInterpretPaths interpretPathsList f = withProjectRoot \".\" $ \\root -> do\n  interpretPaths' <- resolveInterpretPaths $ (root, Interpret_Interpret) : interpretPathsList\n  case interpretPaths' of\n    Nothing -> failWith \"No paths provided for finding packages\"\n    Just interpretPaths -> f root interpretPaths\n\nhaddockCommand :: [String] -> String\nhaddockCommand pkgs = unwords\n  [ \"for p in\"\n  , unwords [getHaddockPath p ++ \"/index.html\" | p <- pkgs]\n  , \"; do echo $p; done\"\n  ]\n  where getHaddockPath p = \"$(ghc-pkg field \" ++ p ++ \" haddock-html --simple-output)\"\n\n--TODO: Clean up all the magic strings throughout this codebase\n\ngetArgsConfig :: IO ArgsConfig\ngetArgsConfig = pure $ ArgsConfig { _argsConfig_enableVmBuilderByDefault = System.Info.os == \"darwin\" }\n\n-- | Resolves an ordered list of paths for use with @--interpret@/@--no-interpret@ by coalescing\n--   paths into a non-ambiguous set of paths. Ambiguity is resolved by choosing right-most paths\n--   over any preceeding identical paths.\n--\n--   For example: @a/b=ON a/b/c=OFF@ and @a/b/c=OFF a/b=ON@ are the same.\n--   @a/b=ON a/b=OFF@ is reduced to @a/b=OFF@. We prefer right-biased choice to increase\n--   scriptability.\n--\n--   N.B. All the paths in the result will be canonicalized. It's impossible to determine path\n--   overlap otherwise.\nresolveInterpretPaths :: MonadIO m => [(FilePath, a)] -> m (Maybe (PathTree a))\nresolveInterpretPaths ps = do\n  trees <- liftIO $ for ps $ \\(p, a) -> pathToTree a <$> canonicalizePath p\n  pure $ foldr1 mergeTrees <$> nonEmpty trees\n  where\n    -- | Merge two 'PathTree's preferring leaves on the right in as much as they overlap with paths on the left.\n    mergeTrees :: PathTree a -> PathTree a -> PathTree a\n    mergeTrees (PathTree_Node ax x) (PathTree_Node ay y) = PathTree_Node (ay <|> ax) $ Map.unionWith mergeTrees x y\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.3333333333333333,
                "sum": 52
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 11,
              "lines_of_code": 274,
              "homplexity_lines_of_code": 314,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.3333333333333333,
                  "sum": 52
                },
                "homplexity_loc": 314,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 1 1: module Obelisk.Command.Utils has 200 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has 9 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has 9 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has cyclomatic complexity of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has 13 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has 2 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has 13 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 233 5: data GitRef has record fields count of 3 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has branching depth of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 257 19: data GitHash has record fields count of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Obelisk.Command.Utils where\n\nimport Control.Applicative hiding (many)\nimport Control.Monad.Except\nimport Data.Bool (bool)\nimport Data.Bifunctor\nimport Data.Char\nimport Data.Either\nimport Data.List (isInfixOf)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Maybe (maybeToList)\nimport Data.Semigroup ((<>))\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Void (Void)\nimport System.Exit (ExitCode)\nimport System.Which (staticWhich)\nimport qualified Text.Megaparsec.Char.Lexer as ML\nimport Text.Megaparsec as MP\nimport Text.Megaparsec.Char as MP\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\ncp :: FilePath\ncp = $(staticWhich \"cp\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nghcidExePath :: FilePath\nghcidExePath = $(staticWhich \"ghcid\")\n\nfindExePath :: FilePath\nfindExePath = $(staticWhich \"find\")\n\nnixExePath :: FilePath\nnixExePath = $(staticWhich \"nix\")\n\nnixBuildExePath :: FilePath\nnixBuildExePath = $(staticWhich \"nix-build\")\n\njreKeyToolPath :: FilePath\njreKeyToolPath = $(staticWhich \"keytool\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nnixPrefetchUrlPath :: FilePath\nnixPrefetchUrlPath = $(staticWhich \"nix-prefetch-url\")\n\nnixShellPath :: FilePath\nnixShellPath = $(staticWhich \"nix-shell\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nsshPath :: FilePath\nsshPath = $(staticWhich \"ssh\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nwhichPath :: FilePath\nwhichPath = $(staticWhich \"which\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nsshKeygenPath :: FilePath\nsshKeygenPath = $(staticWhich \"ssh-keygen\")\n\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\n-- TODO: Investigate the tradeoffs associated with this choice\ndockerPath :: FilePath\ndockerPath = \"docker\"\n\n-- | Nix syntax requires relative paths to be prefixed by @./@ or\n-- @../@. This will make a 'FilePath' that can be embedded in a Nix\n-- expression.\ntoNixPath :: FilePath -> FilePath\ntoNixPath root | \"/\" `isInfixOf` root = root\n               | otherwise = \"./\" <> root\n\n\n-- Check whether the working directory is clean\ncheckGitCleanStatus :: MonadObelisk m => FilePath -> Bool -> m Bool\ncheckGitCleanStatus repo withIgnored = do\n  let\n    runGit = readProcessAndLogStderr Debug . gitProc repo\n    gitStatus = runGit $ [\"status\", \"--porcelain\"] <> bool [] [\"--ignored\"] withIgnored\n    gitDiff = runGit [\"diff\"]\n  T.null <$> liftA2 (<>) gitStatus gitDiff\n\n-- | Ensure that git repo is clean\nensureCleanGitRepo :: MonadObelisk m => FilePath -> Bool -> Text -> m ()\nensureCleanGitRepo path withIgnored s =\n  withSpinnerNoTrail (\"Ensuring clean git repo at \" <> T.pack path) $ do\n    checkGitCleanStatus path withIgnored >>= \\case\n      False -> do\n        statusDebug <- readGitProcess path $ [\"status\"] <> bool [] [\"--ignored\"] withIgnored\n        putLog Warning \"Working copy is unsaved; git status:\"\n        putLog Notice statusDebug\n        failWith s\n      True -> pure ()\n\ninitGit :: MonadObelisk m => FilePath -> m ()\ninitGit repo = do\n  let git = callProcessAndLogOutput (Debug, Debug) . gitProc repo\n  git [\"init\"]\n  git [\"add\", \".\"]\n  git [\"commit\", \"-m\", \"Initial commit.\"]\n\ngitProcNoRepo :: [String] -> ProcessSpec\ngitProcNoRepo args = setEnvOverride (M.singleton \"GIT_TERMINAL_PROMPT\" \"0\" <>) $ proc gitPath args\n\ngitProc :: FilePath -> [String] -> ProcessSpec\ngitProc repo = gitProcNoRepo . runGitInDir\n  where\n    runGitInDir args' = case filter (not . null) args' of\n      args@(\"clone\":_) -> args <> [repo]\n      args -> [\"-C\", repo] <> args\n\nisolateGitProc :: ProcessSpec -> ProcessSpec\nisolateGitProc = setEnvOverride (overrides <>)\n  where\n    overrides = M.fromList\n      [ (\"HOME\", \"/dev/null\")\n      , (\"GIT_CONFIG_NOSYSTEM\", \"1\")\n      , (\"GIT_TERMINAL_PROMPT\", \"0\") -- git 2.3+\n      , (\"GIT_ASKPASS\", \"echo\") -- pre git 2.3 to just use empty password\n      , (\"GIT_SSH_COMMAND\", \"ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o GSSAPIAuthentication=no\")\n      ]\n\n-- | Recursively copy a directory using `cp -a` -- TODO: Should use -rT instead of -a\ncopyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-a\", \".\", dest] -- TODO: This will break if dest is relative since we change cwd\n\nreadGitProcess :: MonadObelisk m => FilePath -> [String] -> m Text\nreadGitProcess repo = readProcessAndLogOutput (Debug, Notice) . gitProc repo\n\nreadGitProcessNoRepo :: MonadObelisk m => [String] -> m Text\nreadGitProcessNoRepo = readProcessAndLogOutput (Debug, Notice) . gitProcNoRepo\n\nprocessToShellString :: FilePath -> [String] -> String\nprocessToShellString cmd args = unwords $ map quoteAndEscape (cmd : args)\n  where quoteAndEscape x = T.unpack $ \"'\" <> T.replace \"'\" \"'\\''\" (T.pack x) <> \"'\"\n\n-- | A simpler wrapper for CliApp's readProcessAndLogStderr with sensible defaults.\nreadProc :: MonadObelisk m => ProcessSpec -> m Text\nreadProc = readProcessAndLogOutput (Debug, Error)\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\ngitLookupDefaultBranch :: GitLsRemoteMaps -> Either Text Text\ngitLookupDefaultBranch (refs, _) = do\n  ref <- case M.lookup GitRef_Head refs of\n    Just ref -> pure ref\n    Nothing -> throwError\n      \"No symref entry for HEAD. \\\n      \\ Is your git version at least 1.8.5? \\\n      \\ Otherwise `git ls-remote --symref` will not work.\"\n  case ref of\n    GitRef_Branch b -> pure b\n    _ -> throwError $\n      \"Default ref \" <> showGitRef ref <> \" is not a branch!\"\n\ngitLookupCommitForRef :: GitLsRemoteMaps -> GitRef -> Either Text CommitId\ngitLookupCommitForRef (_, commits) ref = case M.lookup ref commits of\n  Just a -> pure a\n  Nothing -> throwError $ \"Did not find commit for \" <> showGitRef ref\n\ngitLsRemote\n  :: MonadObelisk m\n  => String\n  -> Maybe GitRef\n  -> Maybe String\n  -> m (ExitCode, GitLsRemoteMaps)\ngitLsRemote repository mRef mBranch = do\n  (exitCode, out, _err) <- case mBranch of\n    Nothing -> readCreateProcessWithExitCode $ gitProcNoRepo $\n        [\"ls-remote\", \"--exit-code\", \"--symref\", repository]\n        ++ maybeToList (T.unpack . showGitRef <$> mRef)\n    Just branchName -> readCreateProcessWithExitCode $ gitProcNoRepo\n        [\"ls-remote\", \"--exit-code\", repository, branchName]\n  let t = T.pack out\n  maps <- case MP.runParser parseLsRemote \"\" t of\n    Left err -> failWith $ T.pack $ MP.errorBundlePretty err\n    Right table -> pure $ bimap M.fromList M.fromList $ partitionEithers table\n  putLog Debug $ \"git ls-remote maps: \" <> T.pack (show maps)\n  pure (exitCode, maps)\n\nlexeme :: Parsec Void Text a -> Parsec Void Text a\nlexeme = ML.lexeme $ void $ MP.takeWhileP (Just \"within-line white space\") $\n  flip elem [' ', '\\t']\n\n-- $ git ls-remote --symref git@github.com:obsidiansystems/obelisk.git HEAD\n-- ref: refs/heads/master\tHEAD\n-- d0a8d25dc93f0acd096bc4ff2f550da9e2d0c8f5\trefs/heads/master\nparseLsRemote :: Parsec Void Text [Either (GitRef, GitRef) (GitRef, CommitId)]\nparseLsRemote =\n  many ((fmap Left (try parseRef) <|> fmap Right parseCommit) <* try MP.eol) <* MP.eof\n  where\n    parseRef :: Parsec Void Text (GitRef, GitRef)\n    parseRef = MP.label \"ref and symbolic ref\" $ do\n      _ <- lexeme \"ref:\"\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      symbolicRef <- lexeme $ MP.takeWhileP (Just \"symbolic ref\") $ not . isSpace\n      return (toGitRef symbolicRef, toGitRef ref)\n    parseCommit :: Parsec Void Text (GitRef, CommitId)\n    parseCommit = MP.label \"commit and ref\" $ do\n      commitId <- lexeme $ MP.takeWhileP (Just \"commit id\") $ not . isSpace\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      return (toGitRef ref, commitId)\n\ndata GitRef\n  = GitRef_Head\n  | GitRef_Branch Text\n  | GitRef_Tag Text\n  | GitRef_Other Text\n  deriving (Show, Eq, Ord)\n\nshowGitRef :: GitRef -> Text\nshowGitRef = \\case\n  GitRef_Head -> \"HEAD\"\n  GitRef_Branch x -> \"refs/heads/\" <> x\n  GitRef_Tag x -> \"refs/tags/\" <> x\n  GitRef_Other x -> x\n\ntoGitRef :: Text -> GitRef\ntoGitRef = \\case\n  \"HEAD\" -> GitRef_Head\n  r -> if\n    | Just s <- \"refs/heads/\" `T.stripPrefix` r -> GitRef_Branch s\n    | Just s <- \"refs/tags/\" `T.stripPrefix` r -> GitRef_Tag s\n    | otherwise -> GitRef_Other r\n\n\n-- | A Git hash. Can represent a specific commit, or a file within a\n-- commit.\nnewtype GitHash = GitHash { _gitHash_text :: T.Text }\n\n-- | Ask @git@ for the hash of a specific tree (file, directory) within\n-- the given repository. The hash of the given path is always computed\n-- with respect to the @HEAD@ revision.\ngetGitHash\n  :: MonadObelisk m\n  => FilePath -- ^ The repository to call @git@ in\n  -> FilePath -- ^ The tree to hash\n  -> m GitHash\ngetGitHash repo pathWithinRepo = do\n  let git = readProcessAndLogOutput (Debug, Debug) . gitProc repo\n  GitHash <$> git [\"rev-parse\", \"HEAD:\" <> pathWithinRepo]\n\n\ntype CommitId = Text\n\ntype GitLsRemoteMaps = (Map GitRef GitRef, Map GitRef CommitId)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs:(232,1)-(237,26)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data GitRef",
                    "    = GitRef_Head |",
                    "      GitRef_Branch Text |",
                    "      GitRef_Tag Text |",
                    "      GitRef_Other Text",
                    "    deriving (Show, Eq, Ord)"
                  ],
                  "perhaps_block": [
                    "  data GitRef",
                    "    = GitRefHead |",
                    "      GitRefBranch Text |",
                    "      GitRefTag Text |",
                    "      GitRefOther Text",
                    "    deriving (Show, Eq, Ord)"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Obelisk.Command.Utils where\n\nimport Control.Applicative hiding (many)\nimport Control.Monad.Except\nimport Data.Bool (bool)\nimport Data.Bifunctor\nimport Data.Char\nimport Data.Either\nimport Data.List (isInfixOf)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Maybe (maybeToList)\nimport Data.Semigroup ((<>))\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Void (Void)\nimport System.Exit (ExitCode)\nimport System.Which (staticWhich)\nimport qualified Text.Megaparsec.Char.Lexer as ML\nimport Text.Megaparsec as MP\nimport Text.Megaparsec.Char as MP\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\ncp :: FilePath\ncp = $(staticWhich \"cp\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nghcidExePath :: FilePath\nghcidExePath = $(staticWhich \"ghcid\")\n\nfindExePath :: FilePath\nfindExePath = $(staticWhich \"find\")\n\nnixExePath :: FilePath\nnixExePath = $(staticWhich \"nix\")\n\nnixBuildExePath :: FilePath\nnixBuildExePath = $(staticWhich \"nix-build\")\n\njreKeyToolPath :: FilePath\njreKeyToolPath = $(staticWhich \"keytool\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nnixPrefetchUrlPath :: FilePath\nnixPrefetchUrlPath = $(staticWhich \"nix-prefetch-url\")\n\nnixShellPath :: FilePath\nnixShellPath = $(staticWhich \"nix-shell\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nsshPath :: FilePath\nsshPath = $(staticWhich \"ssh\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nwhichPath :: FilePath\nwhichPath = $(staticWhich \"which\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nsshKeygenPath :: FilePath\nsshKeygenPath = $(staticWhich \"ssh-keygen\")\n\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\n-- TODO: Investigate the tradeoffs associated with this choice\ndockerPath :: FilePath\ndockerPath = \"docker\"\n\n-- | Nix syntax requires relative paths to be prefixed by @./@ or\n-- @../@. This will make a 'FilePath' that can be embedded in a Nix\n-- expression.\ntoNixPath :: FilePath -> FilePath\ntoNixPath root | \"/\" `isInfixOf` root = root\n               | otherwise = \"./\" <> root\n\n\n-- Check whether the working directory is clean\ncheckGitCleanStatus :: MonadObelisk m => FilePath -> Bool -> m Bool\ncheckGitCleanStatus repo withIgnored = do\n  let\n    runGit = readProcessAndLogStderr Debug . gitProc repo\n    gitStatus = runGit $ [\"status\", \"--porcelain\"] <> bool [] [\"--ignored\"] withIgnored\n    gitDiff = runGit [\"diff\"]\n  T.null <$> liftA2 (<>) gitStatus gitDiff\n\n-- | Ensure that git repo is clean\nensureCleanGitRepo :: MonadObelisk m => FilePath -> Bool -> Text -> m ()\nensureCleanGitRepo path withIgnored s =\n  withSpinnerNoTrail (\"Ensuring clean git repo at \" <> T.pack path) $ do\n    checkGitCleanStatus path withIgnored >>= \\case\n      False -> do\n        statusDebug <- readGitProcess path $ [\"status\"] <> bool [] [\"--ignored\"] withIgnored\n        putLog Warning \"Working copy is unsaved; git status:\"\n        putLog Notice statusDebug\n        failWith s\n      True -> pure ()\n\ninitGit :: MonadObelisk m => FilePath -> m ()\ninitGit repo = do\n  let git = callProcessAndLogOutput (Debug, Debug) . gitProc repo\n  git [\"init\"]\n  git [\"add\", \".\"]\n  git [\"commit\", \"-m\", \"Initial commit.\"]\n\ngitProcNoRepo :: [String] -> ProcessSpec\ngitProcNoRepo args = setEnvOverride (M.singleton \"GIT_TERMINAL_PROMPT\" \"0\" <>) $ proc gitPath args\n\ngitProc :: FilePath -> [String] -> ProcessSpec\ngitProc repo = gitProcNoRepo . runGitInDir\n  where\n    runGitInDir args' = case filter (not . null) args' of\n      args@(\"clone\":_) -> args <> [repo]\n      args -> [\"-C\", repo] <> args\n\nisolateGitProc :: ProcessSpec -> ProcessSpec\nisolateGitProc = setEnvOverride (overrides <>)\n  where\n    overrides = M.fromList\n      [ (\"HOME\", \"/dev/null\")\n      , (\"GIT_CONFIG_NOSYSTEM\", \"1\")\n      , (\"GIT_TERMINAL_PROMPT\", \"0\") -- git 2.3+\n      , (\"GIT_ASKPASS\", \"echo\") -- pre git 2.3 to just use empty password\n      , (\"GIT_SSH_COMMAND\", \"ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o GSSAPIAuthentication=no\")\n      ]\n\n-- | Recursively copy a directory using `cp -a` -- TODO: Should use -rT instead of -a\ncopyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-a\", \".\", dest] -- TODO: This will break if dest is relative since we change cwd\n\nreadGitProcess :: MonadObelisk m => FilePath -> [String] -> m Text\nreadGitProcess repo = readProcessAndLogOutput (Debug, Notice) . gitProc repo\n\nreadGitProcessNoRepo :: MonadObelisk m => [String] -> m Text\nreadGitProcessNoRepo = readProcessAndLogOutput (Debug, Notice) . gitProcNoRepo\n\nprocessToShellString :: FilePath -> [String] -> String\nprocessToShellString cmd args = unwords $ map quoteAndEscape (cmd : args)\n  where quoteAndEscape x = T.unpack $ \"'\" <> T.replace \"'\" \"'\\''\" (T.pack x) <> \"'\"\n\n-- | A simpler wrapper for CliApp's readProcessAndLogStderr with sensible defaults.\nreadProc :: MonadObelisk m => ProcessSpec -> m Text\nreadProc = readProcessAndLogOutput (Debug, Error)\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\ngitLookupDefaultBranch :: GitLsRemoteMaps -> Either Text Text\ngitLookupDefaultBranch (refs, _) = do\n  ref <- case M.lookup GitRef_Head refs of\n    Just ref -> pure ref\n    Nothing -> throwError\n      \"No symref entry for HEAD. \\\n      \\ Is your git version at least 1.8.5? \\\n      \\ Otherwise `git ls-remote --symref` will not work.\"\n  case ref of\n    GitRef_Branch b -> pure b\n    _ -> throwError $\n      \"Default ref \" <> showGitRef ref <> \" is not a branch!\"\n\ngitLookupCommitForRef :: GitLsRemoteMaps -> GitRef -> Either Text CommitId\ngitLookupCommitForRef (_, commits) ref = case M.lookup ref commits of\n  Just a -> pure a\n  Nothing -> throwError $ \"Did not find commit for \" <> showGitRef ref\n\ngitLsRemote\n  :: MonadObelisk m\n  => String\n  -> Maybe GitRef\n  -> Maybe String\n  -> m (ExitCode, GitLsRemoteMaps)\ngitLsRemote repository mRef mBranch = do\n  (exitCode, out, _err) <- case mBranch of\n    Nothing -> readCreateProcessWithExitCode $ gitProcNoRepo $\n        [\"ls-remote\", \"--exit-code\", \"--symref\", repository]\n        ++ maybeToList (T.unpack . showGitRef <$> mRef)\n    Just branchName -> readCreateProcessWithExitCode $ gitProcNoRepo\n        [\"ls-remote\", \"--exit-code\", repository, branchName]\n  let t = T.pack out\n  maps <- case MP.runParser parseLsRemote \"\" t of\n    Left err -> failWith $ T.pack $ MP.errorBundlePretty err\n    Right table -> pure $ bimap M.fromList M.fromList $ partitionEithers table\n  putLog Debug $ \"git ls-remote maps: \" <> T.pack (show maps)\n  pure (exitCode, maps)\n\nlexeme :: Parsec Void Text a -> Parsec Void Text a\nlexeme = ML.lexeme $ void $ MP.takeWhileP (Just \"within-line white space\") $\n  flip elem [' ', '\\t']\n\n-- $ git ls-remote --symref git@github.com:obsidiansystems/obelisk.git HEAD\n-- ref: refs/heads/master\tHEAD\n-- d0a8d25dc93f0acd096bc4ff2f550da9e2d0c8f5\trefs/heads/master\nparseLsRemote :: Parsec Void Text [Either (GitRef, GitRef) (GitRef, CommitId)]\nparseLsRemote =\n  many ((fmap Left (try parseRef) <|> fmap Right parseCommit) <* try MP.eol) <* MP.eof\n  where\n    parseRef :: Parsec Void Text (GitRef, GitRef)\n    parseRef = MP.label \"ref and symbolic ref\" $ do\n      _ <- lexeme \"ref:\"\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      symbolicRef <- lexeme $ MP.takeWhileP (Just \"symbolic ref\") $ not . isSpace\n      return (toGitRef symbolicRef, toGitRef ref)\n    parseCommit :: Parsec Void Text (GitRef, CommitId)\n    parseCommit = MP.label \"commit and ref\" $ do\n      commitId <- lexeme $ MP.takeWhileP (Just \"commit id\") $ not . isSpace\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      return (toGitRef ref, commitId)\n\ndata GitRef\n  = GitRef_Head\n  | GitRef_Branch Text\n  | GitRef_Tag Text\n  | GitRef_Other Text\n  deriving (Show, Eq, Ord)\n\nshowGitRef :: GitRef -> Text\nshowGitRef = \\case\n  GitRef_Head -> \"HEAD\"\n  GitRef_Branch x -> \"refs/heads/\" <> x\n  GitRef_Tag x -> \"refs/tags/\" <> x\n  GitRef_Other x -> x\n\ntoGitRef :: Text -> GitRef\ntoGitRef = \\case\n  \"HEAD\" -> GitRef_Head\n  r -> if\n    | Just s <- \"refs/heads/\" `T.stripPrefix` r -> GitRef_Branch s\n    | Just s <- \"refs/tags/\" `T.stripPrefix` r -> GitRef_Tag s\n    | otherwise -> GitRef_Other r\n\n\n-- | A Git hash. Can represent a specific commit, or a file within a\n-- commit.\nnewtype GitHash = GitHash { _gitHash_text :: T.Text }\n\n-- | Ask @git@ for the hash of a specific tree (file, directory) within\n-- the given repository. The hash of the given path is always computed\n-- with respect to the @HEAD@ revision.\ngetGitHash\n  :: MonadObelisk m\n  => FilePath -- ^ The repository to call @git@ in\n  -> FilePath -- ^ The tree to hash\n  -> m GitHash\ngetGitHash repo pathWithinRepo = do\n  let git = readProcessAndLogOutput (Debug, Debug) . gitProc repo\n  GitHash <$> git [\"rev-parse\", \"HEAD:\" <> pathWithinRepo]\n\n\ntype CommitId = Text\n\ntype GitLsRemoteMaps = (Map GitRef GitRef, Map GitRef CommitId)\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Project.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 2,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 32,
              "lines_of_code": 530,
              "homplexity_lines_of_code": 591,
              "code_quality_score": 40.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 591,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"obeliskSourceWithBranch\": 2,\n        \"initProject\": 12,\n        \"callHandoffOb\": 3,\n        \"findProjectObeliskCommand\": 10,\n        \"getUmask\": 4,\n        \"findProjectRoot\": 5,\n        \"withProjectRoot\": 2,\n        \"walkToProjectRoot\": 13,\n        \"walkToImplDir\": 4,\n        \"isWellOwnedAndWellPermissioned\": 3,\n        \"isOwnedBy\": 1,\n        \"filePermissionIsSafe\": 4,\n        \"nixShellRunConfig\": 5,\n        \"bashEscape\": 1,\n        \"shEscape\": 1,\n        \"nixShellRunProc\": 1,\n        \"mkObNixShellProc\": 6,\n        \"nixShellWithoutPkgs\": 3,\n        \"nixShellWithHoogle\": 4,\n        \"describeImpureAssetSource\": 2,\n        \"findProjectAssets\": 9,\n        \"getHaskellManifestProjectPath\": 2,\n        \"watchStaticFilesDerivation\": 13,\n        \"handleBuildFailure\": 5,\n        \"buildStaticCatchErrors\": 2,\n        \"buildStaticFilesDerivationAndSymlink\": 1\n    },\n    \"cyclomatic_complexity_summary\": {\n        \"min\": 1,\n        \"max\": 13,\n        \"average\": 4.08,\n        \"sum\": 102\n    },\n    \"homplexity_loc\": 591\n}\n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\n\nmodule Obelisk.Command.Project\n  ( InitSource (..)\n  , findProjectObeliskCommand\n  , findProjectRoot\n  , findProjectAssets\n  , initProject\n  , nixShellRunConfig\n  , nixShellRunProc\n  , nixShellWithHoogle\n  , nixShellWithoutPkgs\n  , mkObNixShellProc\n  , obeliskDirName\n  , toImplDir\n  , toObeliskDir\n  , withProjectRoot\n  , bashEscape\n  , shEscape\n  , getHaskellManifestProjectPath\n  , AssetSource(..)\n  , describeImpureAssetSource\n  , watchStaticFilesDerivation\n  ) where\n\nimport Control.Concurrent.MVar (MVar, newMVar, withMVarMasked)\nimport Control.Lens ((.~), (?~), (<&>))\nimport Control.Monad\nimport Control.Monad.Except\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Log\nimport Control.Monad.State\nimport qualified Data.Aeson as Json\nimport qualified Data.ByteString.UTF8 as BSU\nimport Data.Bits\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default (def)\nimport qualified Data.Foldable as F (toList)\nimport Data.Function ((&), on)\nimport Data.Map (Map)\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8, encodeUtf8)\nimport Data.Traversable (for)\nimport \"nix-thunk\" Nix.Thunk\nimport Reflex\nimport Reflex.FSNotify\nimport Reflex.Host.Headless\nimport System.Directory\nimport System.Environment (lookupEnv)\nimport System.Exit (ExitCode(..))\nimport System.FilePath\nimport System.FSNotify (defaultConfig, eventPath, WatchConfig(..), WatchMode(..))\nimport qualified System.Info as Sys\nimport System.IO.Temp\nimport System.IO.Unsafe (unsafePerformIO)\nimport System.PosixCompat.Files\nimport System.PosixCompat.Types\nimport System.PosixCompat.User\nimport qualified System.Process as Proc\nimport Text.ShellEscape (sh, bash, bytes)\n\nimport GitHub.Data.GitData (Branch)\nimport GitHub.Data.Name (Name)\n\nimport Obelisk.App (MonadObelisk, runObelisk, getObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Cli.Extras\nimport Obelisk.Command.Utils (nixBuildExePath, nixExePath, toNixPath, cp, nixShellPath, lnPath)\n\n--TODO: Make this module resilient to random exceptions\n\n--TODO: Don't hardcode this\n-- | Source for the Obelisk project\nobeliskSource :: ThunkSource\nobeliskSource = obeliskSourceWithBranch \"master\"\n\n-- | Source for obelisk developer targeting a specific obelisk branch\nobeliskSourceWithBranch :: Name Branch -> ThunkSource\nobeliskSourceWithBranch branch = ThunkSource_GitHub $ GitHubSource\n  { _gitHubSource_owner = \"obsidiansystems\"\n  , _gitHubSource_repo = \"obelisk\"\n  , _gitHubSource_branch = Just branch\n  , _gitHubSource_private = False\n  }\n\ndata InitSource\n  = InitSource_Default\n  | InitSource_Branch (Name Branch)\n  | InitSource_Symlink FilePath\n  deriving Show\n\nobeliskDirName :: FilePath\nobeliskDirName = \".obelisk\"\n\n-- | Path to obelisk directory in given path\ntoObeliskDir :: FilePath -> FilePath\ntoObeliskDir p = p </> obeliskDirName\n\n-- | Path to impl file in given path\ntoImplDir :: FilePath -> FilePath\ntoImplDir p = toObeliskDir p </> \"impl\"\n\n-- | Create a new project rooted in the current directory\ninitProject :: forall m. MonadObelisk m => InitSource -> Bool -> m ()\ninitProject source force = withSystemTempDirectory \"ob-init\" $ \\tmpDir -> do\n  let implDir = toImplDir tmpDir\n      obDir   = toObeliskDir tmpDir\n  liftIO (listDirectory \".\") >>= \\case\n    [] -> pure ()\n    _ | force -> putLog Warning \"Initializing in non-empty directory\"\n      | otherwise -> failWith \"ob init requires an empty directory. Use the flag --force to init anyway, potentially overwriting files.\"\n  skeleton <- withSpinner \"Setting up obelisk\" $ do\n    liftIO $ createDirectory obDir\n    -- Clone the git source and repack it with the init source obelisk\n    -- The purpose of this is to ensure we use the correct thunk spec.\n    let cloneAndRepack :: ThunkSource -> m ()\n        cloneAndRepack src = do\n          putLog Debug $ \"Cloning obelisk into \" <> T.pack implDir <> \" and repacking using itself\"\n          commit <- wrapNixThunkError $ getLatestRev src\n          wrapNixThunkError $ gitCloneForThunkUnpack (thunkSourceToGitSource src) (_thunkRev_commit commit) implDir\n          callHandoffOb implDir [\"thunk\", \"pack\", implDir]\n    case source of\n      InitSource_Default -> cloneAndRepack obeliskSource\n      InitSource_Branch branch -> cloneAndRepack $ obeliskSourceWithBranch branch\n      InitSource_Symlink path -> do\n        let symlinkPath = if isAbsolute path\n              then path\n              else \"..\" </> path\n        liftIO $ createSymbolicLink symlinkPath implDir\n    _ <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"command\"\n    skel <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"skeleton\" --TODO: I don't think there's actually any reason to cache this\n\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--preserve=links\"\n        , obDir\n        , toObeliskDir \".\"\n        ]\n    pure skel\n\n  withSpinner \"Copying project skeleton\" $ do\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--no-preserve=mode\"\n        , \"-T\"\n        , skeleton </> \".\"\n        , \".\"\n        ]\n  liftIO $ do\n    let configDir = \"config\"\n    createDirectoryIfMissing False configDir\n    mapM_ (createDirectoryIfMissing False . (configDir </>)) [\"backend\", \"common\", \"frontend\"]\n  putLog Notice $ T.intercalate \"\\n\"\n    [ \"An obelisk project has been successfully initialized. Next steps:\"\n    , \"  'ob run': Start a development server\"\n    , \"  'ob watch': Watch for changes without starting a server\"\n    , \"  'ob repl': Load your project into GHCi\"\n    ]\n\ncallHandoffOb\n  :: MonadObelisk m\n  => FilePath -- ^ Directory of the obelisk we want to handoff to\n  -> [String] -- ^ Arguments to pass to ob\n  -> m ()\ncallHandoffOb dir args = do\n  obeliskCommandPkg <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ Target\n      { _target_path = Just dir\n      , _target_attr = Just \"command\"\n      , _target_expr = Nothing\n      }\n  let impl = obeliskCommandPkg </> \"bin\" </> \"ob\"\n  -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n  putLog Debug $ \"Running '\" <> T.pack (unwords args) <> \"' with \" <> T.pack impl\n  callProcessAndLogOutput (Debug, Warning) (proc impl (\"--no-handoff\" : args))\n\n--TODO: Allow the user to ignore our security concerns\n-- | Find the Obelisk implementation for the project at the given path\nfindProjectObeliskCommand :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectObeliskCommand target = do\n  myUid <- liftIO getRealUserID\n  processUmask <- liftIO getUmask\n  targetStat <- liftIO $ getFileStatus target\n  (result, insecurePaths) <- flip runStateT [] $ walkToProjectRoot target targetStat processUmask myUid >>= \\case\n    Nothing -> pure Nothing\n    Just projectRoot -> liftIO (doesDirectoryExist $ toImplDir projectRoot) >>= \\case\n      False -> do\n        putLog Warning $ \"Found obelisk directory in \" <> T.pack projectRoot <> \" but the implementation (impl) file is missing\"\n        pure Nothing\n      True -> do\n        walkToImplDir projectRoot myUid processUmask -- For security check\n        return $ Just projectRoot\n  case (result, insecurePaths) of\n    (Just projDir, []) -> do\n      obeliskCommandPkg <- wrapNixThunkError $ nixBuildAttrWithCache (toImplDir projDir) \"command\"\n      return $ Just $ obeliskCommandPkg </> \"bin\" </> \"ob\"\n    (Nothing, _) -> return Nothing\n    (Just projDir, _) -> do\n      putLog Error $ T.unlines\n        [ \"Error: Found a project at \" <> T.pack (normalise projDir) <> \", but had to traverse one or more insecure directories to get there:\"\n        , T.unlines $ fmap (T.pack . normalise) insecurePaths\n        , \"Please ensure that all of these directories are owned by you, not world-writable, and no more group-writable than permitted by your umask.\"\n        ]\n      return Nothing\n\n-- | Get the umask for the Obelisk process.\n--\n-- Because of\n-- http://man7.org/linux/man-pages/man2/umask.2.html#NOTES we have to set the\n-- umask to read it. We are using 'withMVarMasked' to guarantee that setting and\n-- reading isn't interrupted by any exception or interleaved with another thread.\ngetUmask :: IO FileMode\ngetUmask = withMVarMasked globalUmaskLock $ \\() -> do\n  initialMask <- setFileCreationMask safeUmask\n  void (setFileCreationMask initialMask)\n  pure initialMask\n  where\n    safeUmask :: FileMode\n    safeUmask = CMode 0o22\n\n{-# NOINLINE globalUmaskLock #-}\nglobalUmaskLock :: MVar ()\nglobalUmaskLock = unsafePerformIO (newMVar ())\n\n-- | Get the FilePath to the containing project directory, if there is one\nfindProjectRoot :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectRoot target = do\n  myUid <- liftIO getRealUserID\n  targetStat <- liftIO $ getFileStatus target\n  umask <- liftIO getUmask\n  (result, _) <- liftIO $ runStateT (walkToProjectRoot target targetStat umask myUid) []\n  return $ makeRelative \".\" <$> result\n\nwithProjectRoot :: MonadObelisk m => FilePath -> (FilePath -> m a) -> m a\nwithProjectRoot target f = findProjectRoot target >>= \\case\n  Nothing -> failWith \"Must be used inside of an Obelisk project\"\n  Just root -> f root\n\n-- | Walk from the current directory to the containing project's root directory,\n-- if there is one, accumulating potentially insecure directories that were\n-- traversed in the process.  Return the project root directory, if found.\nwalkToProjectRoot\n  :: (MonadState [FilePath] m, MonadIO m)\n  => FilePath -> FileStatus -> FileMode -> UserID -> m (Maybe FilePath)\nwalkToProjectRoot this thisStat desiredUmask myUid = liftIO (doesDirectoryExist this) >>= \\case\n  -- It's not a directory, so it can't be a project\n  False -> do\n    let dir = takeDirectory this\n    dirStat <- liftIO $ getFileStatus dir\n    walkToProjectRoot dir dirStat desiredUmask myUid\n  True -> do\n    when (not $ isWellOwnedAndWellPermissioned thisStat myUid desiredUmask) $ modify (this:)\n    liftIO (doesDirectoryExist $ toObeliskDir this) >>= \\case\n      True -> return $ Just this\n      False -> do\n        let next = this </> \"..\" -- Use \"..\" instead of chopping off path segments, so that if the current directory is moved during the traversal, the traversal stays consistent\n        nextStat <- liftIO $ getFileStatus next\n        let fileIdentity fs = (deviceID fs, fileID fs)\n            isSameFileAs = (==) `on` fileIdentity\n        if thisStat `isSameFileAs` nextStat\n          then return Nothing -- Found a cycle; probably hit root directory\n          else walkToProjectRoot next nextStat desiredUmask myUid\n\n-- | Walk from the given project root directory to its Obelisk implementation\n-- directory, accumulating potentially insecure directories that were traversed\n-- in the process.\nwalkToImplDir :: (MonadState [FilePath] m, MonadIO m) => FilePath -> UserID -> FileMode -> m ()\nwalkToImplDir projectRoot myUid umask = do\n  let obDir = toObeliskDir projectRoot\n  obDirStat <- liftIO $ getFileStatus obDir\n  when (not $ isWellOwnedAndWellPermissioned obDirStat myUid umask) $ modify (obDir:)\n  let implThunk = obDir </> \"impl\"\n  implThunkStat <- liftIO $ getFileStatus implThunk\n  when (not $ isWellOwnedAndWellPermissioned implThunkStat myUid umask) $ modify (implThunk:)\n\n-- | Check to see if directory is writable by a user whose User ID matches the\n-- second argument provided, and if the fact that other people can write to that\n-- directory is in accordance with the umask of the system, passed as the third\n-- argument.\nisWellOwnedAndWellPermissioned :: FileStatus -> UserID -> FileMode -> Bool\nisWellOwnedAndWellPermissioned s uid umask = isOwnedBy s uid && filePermissionIsSafe s umask\n\nisOwnedBy :: FileStatus -> UserID -> Bool\nisOwnedBy s uid = fileOwner s == uid\n\n-- | Check to see if a directory respect the umask, but check explicitly that\n-- it's not world writable in any case.\nfilePermissionIsSafe :: FileStatus -> FileMode -> Bool\nfilePermissionIsSafe s umask = not fileWorldWritable && fileGroupWritable <= umaskGroupWritable\n  where\n    fileWorldWritable = fileMode s .&. 0o002 == 0o002\n    fileGroupWritable = fileMode s .&. 0o020 == 0o020\n    umaskGroupWritable = umask .&. 0o020 == 0\n\nnixShellRunConfig :: MonadObelisk m => FilePath -> Bool -> Maybe String -> m NixShellConfig\nnixShellRunConfig root isPure command = do\n  nixpkgsPath <- fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath [\"eval\", \"--impure\", \"--expr\", \"(import .obelisk/impl {}).nixpkgs.path\"]\n  nixRemote <- liftIO $ lookupEnv \"NIX_REMOTE\"\n  pure $ def\n    & nixShellConfig_pure .~ isPure\n    & nixShellConfig_common . nixCmdConfig_target .~ (def & target_path .~ Nothing)\n    & nixShellConfig_run .~ (command <&> \\cs -> unwords $ concat\n      [ [\"export\", BSU.toString . bytes . bash $ \"NIX_PATH=nixpkgs=\" <> encodeUtf8 nixpkgsPath, \";\"]\n      , maybe [] (\\v -> [\"export\", BSU.toString . bytes . bash $ \"NIX_REMOTE=\" <> encodeUtf8 (T.pack v), \";\"]) nixRemote\n      , [cs]\n      ])\n\n-- | Escape using ANSI C-style quotes @$''@\n-- This does not work with all shells! Ideally, we would control exactly which shell is used,\n-- down to its sourced configuration, throughout the obelisk environment. At this time, this\n-- is not feasible.\nbashEscape :: String -> String\nbashEscape = BSU.toString . bytes . bash . BSU.fromString\n\n-- | Escape using Bourne style shell escaping\n-- This is not as robust, but is necessary if we are passing to a shell we don't control.\n-- The most prominent issue is that 'System.Process' executes shell commands by invoking\n-- @\\/bin\\/sh@ instead of something configurable. While we can avoid this by specifying a shell manually,\n-- we cannot guarantee that our dependencies do the same. In particular, ghcid invokes its\n-- subcommands that way.\nshEscape :: String -> String\nshEscape = BSU.toString . bytes . sh . BSU.fromString\n\nnixShellRunProc :: NixShellConfig -> ProcessSpec\nnixShellRunProc cfg = setDelegateCtlc True $ proc nixShellPath $ runNixShellConfig cfg\n\nmkObNixShellProc\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ProcessSpec\nmkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  packageNamesAndAbsPaths <- liftIO $ for packageNamesAndPaths makeAbsolute\n  defShellConfig <- nixShellRunConfig root isPure command\n  let setCwd_ = if chdirToRoot then setCwd (Just root) else id\n  pure $ setCwd_ $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{root, pkgs, shell}: ((import root {}).passthru.__unstable__.self.extend (_: _: {\\\n          \\shellPackages = builtins.fromJSON pkgs;\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~\n        [ rawArg \"root\" $ toNixPath $ if chdirToRoot then \".\" else root\n        , strArg \"pkgs\" (T.unpack $ decodeUtf8 $ BSL.toStrict $ Json.encode packageNamesAndAbsPaths)\n        , strArg \"shell\" shellAttr\n        ]\n\nnixShellWithoutPkgs\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ()\nnixShellWithoutPkgs root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  runProcess_ =<< mkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command\n\nnixShellWithHoogle :: MonadObelisk m => FilePath -> Bool -> String -> Maybe String -> m ()\nnixShellWithHoogle root isPure shell' command = do\n  defShellConfig <- nixShellRunConfig root isPure command\n  runProcess_ $ setCwd (Just root) $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{shell}: ((import ./. {}).passthru.__unstable__.self.extend (_: super: {\\\n          \\userSettings = super.userSettings // { withHoogle = true; };\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~ [ strArg \"shell\" shell' ]\n\n-- | Describes the provenance of static assets (i.e., are they the result of a derivation\n-- that was built, or just a folder full of files.\ndata AssetSource = AssetSource_Derivation\n                 | AssetSource_Files\n  deriving (Eq)\n\n-- | Some log messages to make it easier to tell where static files are coming from\ndescribeImpureAssetSource :: AssetSource -> Text -> Text\ndescribeImpureAssetSource src path = case src of\n  AssetSource_Files -> \"Assets impurely loaded from: \" <> path\n  AssetSource_Derivation -> \"Assets derivation built and impurely loaded from: \" <> path\n\n-- | Determine where the static files of a project are and whether they're plain files or a derivation.\n-- If they are a derivation, that derivation will be built.\nfindProjectAssets :: MonadObelisk m => FilePath -> m (AssetSource, Text)\nfindProjectAssets root = do\n  isDerivation <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath\n      [ \"eval\"\n      , \"--impure\"\n      , \"--expr\"\n      , \"(let a = import ./. {}; in toString (a.reflex.nixpkgs.lib.isDerivation a.passthru.staticFilesImpure))\"\n      , \"--raw\"\n      -- `--raw` is not available with old nix-instantiate. It drops quotation\n      -- marks and trailing newline, so is very convenient for shelling out.\n      ]\n  -- Check whether the impure static files are a derivation (and so must be built)\n  if isDerivation == \"1\"\n    then do\n      _ <- buildStaticFilesDerivationAndSymlink\n        (readProcessAndLogStderr Debug)\n        root\n      pure (AssetSource_Derivation, T.pack $ root </> \"static.out\")\n    else fmap (AssetSource_Files,) $ do\n      path <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc nixExePath [\"eval\", \"-f\", \".\", \"passthru.staticFilesImpure\", \"--raw\"]\n      _ <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc lnPath [\"-sfT\", T.unpack path, \"./static.out\"]\n      pure path\n\n-- | Get the nix store path to the generated static asset manifest module (e.g., \"obelisk-generated-static\")\ngetHaskellManifestProjectPath :: MonadObelisk m => FilePath -> m Text\ngetHaskellManifestProjectPath root = fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n  proc nixBuildExePath\n    [ \"--no-out-link\"\n    , \"-E\"\n    , \"(let a = import ./. {}; in a.passthru.processedStatic.haskellManifest)\"\n    ]\n\n-- | Watch the common, backend, frontend, and static directories for file\n-- changes and check whether those file changes cause changes in the static\n-- files nix derivation. If so, rebuild it.\nwatchStaticFilesDerivation\n  :: (MonadIO m, MonadObelisk m)\n  => FilePath\n  -> m ()\nwatchStaticFilesDerivation root = do\n  ob <- getObelisk\n  liftIO $ runHeadlessApp $ do\n    pb <- getPostBuild\n    -- TODO: Instead of filtering like this, we should figure out what the\n    -- derivation actually relies on, or at least use the gitignore\n    let filterEvents x =\n          let fn = takeFileName x\n              dirs = Set.fromList $ splitDirectories x\n              ignoredFilenames = Set.fromList\n                [ \"4913\" -- Vim temporary file\n                ]\n              ignoredExtensions = Set.fromList\n                [ \".hi\"\n                , \".o\"\n                , \".swo\"\n                , \".swp\"\n                ]\n          in not $\n              fn `Set.member` ignoredFilenames ||\n              takeExtension fn `Set.member` ignoredExtensions\n        cfg = defaultConfig\n          -- On macOS, use the polling backend due to\n          -- https://github.com/luite/hfsevents/issues/13\n            { confWatchMode =\n                if Sys.os == \"darwin\"\n                  then WatchModePoll 250000\n                  else WatchModeOS\n            }\n        watch' pkg = fmap (:[]) <$> watchDirectoryTree cfg (root </> pkg <$ pb) (filterEvents . eventPath)\n    rebuild <- batchOccurrences 0.25 =<< mergeWith (<>) <$> mapM watch'\n      [ \"frontend\"\n      , \"backend\"\n      , \"common\"\n      , \"static\"\n      ]\n    performEvent_\n      $ liftIO\n      . runObelisk ob\n      . putLog Debug\n      . (\"Regenerating static.out due to file changes: \"<>)\n      . T.intercalate \", \"\n      . Set.toList\n      . Set.fromList\n      . fmap (T.pack . eventPath)\n      . concat\n      . F.toList\n      <$> rebuild\n    void $ flip throttleBatchWithLag rebuild $ \\e ->\n      performEvent $ ffor e $ \\_ -> liftIO $ runObelisk ob $ do\n        putLog Notice \"Static assets being built...\"\n        buildStaticCatchErrors >>= \\case\n          Nothing -> pure ()\n          Just n -> do\n            putLog Notice $ \"Static assets built and symlinked to static.out\"\n            putLog Debug $ \"Generated static asset nix path: \" <> n\n    pure never\n  where\n    handleBuildFailure\n      :: MonadObelisk m\n      => (ExitCode, String, String)\n      -> m (Maybe Text)\n    handleBuildFailure (ex, out, err) = case ex of\n      ExitSuccess ->\n        let out' = T.strip $ T.pack out\n        in pure $ if T.null out' then Nothing else Just out'\n      _ -> do\n        putLog Error $\n          (\"Static assets build failed: \" <>) $\n            T.unlines $ reverse $ take 20 $ reverse $ T.lines $ T.pack err\n        pure Nothing\n    buildStaticCatchErrors :: MonadObelisk m => m (Maybe Text)\n    buildStaticCatchErrors = handleBuildFailure =<<\n      buildStaticFilesDerivationAndSymlink\n        readCreateProcessWithExitCode\n        root\n\nbuildStaticFilesDerivationAndSymlink\n  :: MonadObelisk m\n  => (ProcessSpec -> m a)\n  -> FilePath\n  -> m a\nbuildStaticFilesDerivationAndSymlink f root = f $\n  setCwd (Just root) $ ProcessSpec\n    { _processSpec_createProcess = Proc.proc\n        nixBuildExePath\n        [ \"-o\", \"static.out\"\n        , \"-E\", \"(import ./. {}).passthru.staticFilesImpure\"\n        ]\n    , _processSpec_overrideEnv = Nothing\n    }\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs:(93,1)-(97,15)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data InitSource",
                    "    = InitSource_Default |",
                    "      InitSource_Branch (Name Branch) |",
                    "      InitSource_Symlink FilePath",
                    "    deriving Show"
                  ],
                  "perhaps_block": [
                    "  data InitSource",
                    "    = InitSourceDefault |",
                    "      InitSourceBranch (Name Branch) |",
                    "      InitSourceSymlink FilePath",
                    "    deriving Show"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Project.hs:(386,1)-(388,15)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data AssetSource",
                    "    = AssetSource_Derivation | AssetSource_Files",
                    "    deriving (Eq)"
                  ],
                  "perhaps_block": [
                    "  data AssetSource",
                    "    = AssetSourceDerivation | AssetSourceFiles",
                    "    deriving (Eq)"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\n\nmodule Obelisk.Command.Project\n  ( InitSource (..)\n  , findProjectObeliskCommand\n  , findProjectRoot\n  , findProjectAssets\n  , initProject\n  , nixShellRunConfig\n  , nixShellRunProc\n  , nixShellWithHoogle\n  , nixShellWithoutPkgs\n  , mkObNixShellProc\n  , obeliskDirName\n  , toImplDir\n  , toObeliskDir\n  , withProjectRoot\n  , bashEscape\n  , shEscape\n  , getHaskellManifestProjectPath\n  , AssetSource(..)\n  , describeImpureAssetSource\n  , watchStaticFilesDerivation\n  ) where\n\nimport Control.Concurrent.MVar (MVar, newMVar, withMVarMasked)\nimport Control.Lens ((.~), (?~), (<&>))\nimport Control.Monad\nimport Control.Monad.Except\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Log\nimport Control.Monad.State\nimport qualified Data.Aeson as Json\nimport qualified Data.ByteString.UTF8 as BSU\nimport Data.Bits\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default (def)\nimport qualified Data.Foldable as F (toList)\nimport Data.Function ((&), on)\nimport Data.Map (Map)\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Text.Encoding (decodeUtf8, encodeUtf8)\nimport Data.Traversable (for)\nimport \"nix-thunk\" Nix.Thunk\nimport Reflex\nimport Reflex.FSNotify\nimport Reflex.Host.Headless\nimport System.Directory\nimport System.Environment (lookupEnv)\nimport System.Exit (ExitCode(..))\nimport System.FilePath\nimport System.FSNotify (defaultConfig, eventPath, WatchConfig(..), WatchMode(..))\nimport qualified System.Info as Sys\nimport System.IO.Temp\nimport System.IO.Unsafe (unsafePerformIO)\nimport System.PosixCompat.Files\nimport System.PosixCompat.Types\nimport System.PosixCompat.User\nimport qualified System.Process as Proc\nimport Text.ShellEscape (sh, bash, bytes)\n\nimport GitHub.Data.GitData (Branch)\nimport GitHub.Data.Name (Name)\n\nimport Obelisk.App (MonadObelisk, runObelisk, getObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Cli.Extras\nimport Obelisk.Command.Utils (nixBuildExePath, nixExePath, toNixPath, cp, nixShellPath, lnPath)\n\n--TODO: Make this module resilient to random exceptions\n\n--TODO: Don't hardcode this\n-- | Source for the Obelisk project\nobeliskSource :: ThunkSource\nobeliskSource = obeliskSourceWithBranch \"master\"\n\n-- | Source for obelisk developer targeting a specific obelisk branch\nobeliskSourceWithBranch :: Name Branch -> ThunkSource\nobeliskSourceWithBranch branch = ThunkSource_GitHub $ GitHubSource\n  { _gitHubSource_owner = \"obsidiansystems\"\n  , _gitHubSource_repo = \"obelisk\"\n  , _gitHubSource_branch = Just branch\n  , _gitHubSource_private = False\n  }\n\ndata InitSource\n  = InitSource_Default\n  | InitSource_Branch (Name Branch)\n  | InitSource_Symlink FilePath\n  deriving Show\n\nobeliskDirName :: FilePath\nobeliskDirName = \".obelisk\"\n\n-- | Path to obelisk directory in given path\ntoObeliskDir :: FilePath -> FilePath\ntoObeliskDir p = p </> obeliskDirName\n\n-- | Path to impl file in given path\ntoImplDir :: FilePath -> FilePath\ntoImplDir p = toObeliskDir p </> \"impl\"\n\n-- | Create a new project rooted in the current directory\ninitProject :: forall m. MonadObelisk m => InitSource -> Bool -> m ()\ninitProject source force = withSystemTempDirectory \"ob-init\" $ \\tmpDir -> do\n  let implDir = toImplDir tmpDir\n      obDir   = toObeliskDir tmpDir\n  liftIO (listDirectory \".\") >>= \\case\n    [] -> pure ()\n    _ | force -> putLog Warning \"Initializing in non-empty directory\"\n      | otherwise -> failWith \"ob init requires an empty directory. Use the flag --force to init anyway, potentially overwriting files.\"\n  skeleton <- withSpinner \"Setting up obelisk\" $ do\n    liftIO $ createDirectory obDir\n    -- Clone the git source and repack it with the init source obelisk\n    -- The purpose of this is to ensure we use the correct thunk spec.\n    let cloneAndRepack :: ThunkSource -> m ()\n        cloneAndRepack src = do\n          putLog Debug $ \"Cloning obelisk into \" <> T.pack implDir <> \" and repacking using itself\"\n          commit <- wrapNixThunkError $ getLatestRev src\n          wrapNixThunkError $ gitCloneForThunkUnpack (thunkSourceToGitSource src) (_thunkRev_commit commit) implDir\n          callHandoffOb implDir [\"thunk\", \"pack\", implDir]\n    case source of\n      InitSource_Default -> cloneAndRepack obeliskSource\n      InitSource_Branch branch -> cloneAndRepack $ obeliskSourceWithBranch branch\n      InitSource_Symlink path -> do\n        let symlinkPath = if isAbsolute path\n              then path\n              else \"..\" </> path\n        liftIO $ createSymbolicLink symlinkPath implDir\n    _ <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"command\"\n    skel <- wrapNixThunkError $ nixBuildAttrWithCache implDir \"skeleton\" --TODO: I don't think there's actually any reason to cache this\n\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--preserve=links\"\n        , obDir\n        , toObeliskDir \".\"\n        ]\n    pure skel\n\n  withSpinner \"Copying project skeleton\" $ do\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp\n        [ \"-r\"\n        , \"--no-preserve=mode\"\n        , \"-T\"\n        , skeleton </> \".\"\n        , \".\"\n        ]\n  liftIO $ do\n    let configDir = \"config\"\n    createDirectoryIfMissing False configDir\n    mapM_ (createDirectoryIfMissing False . (configDir </>)) [\"backend\", \"common\", \"frontend\"]\n  putLog Notice $ T.intercalate \"\\n\"\n    [ \"An obelisk project has been successfully initialized. Next steps:\"\n    , \"  'ob run': Start a development server\"\n    , \"  'ob watch': Watch for changes without starting a server\"\n    , \"  'ob repl': Load your project into GHCi\"\n    ]\n\ncallHandoffOb\n  :: MonadObelisk m\n  => FilePath -- ^ Directory of the obelisk we want to handoff to\n  -> [String] -- ^ Arguments to pass to ob\n  -> m ()\ncallHandoffOb dir args = do\n  obeliskCommandPkg <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ Target\n      { _target_path = Just dir\n      , _target_attr = Just \"command\"\n      , _target_expr = Nothing\n      }\n  let impl = obeliskCommandPkg </> \"bin\" </> \"ob\"\n  -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n  putLog Debug $ \"Running '\" <> T.pack (unwords args) <> \"' with \" <> T.pack impl\n  callProcessAndLogOutput (Debug, Warning) (proc impl (\"--no-handoff\" : args))\n\n--TODO: Allow the user to ignore our security concerns\n-- | Find the Obelisk implementation for the project at the given path\nfindProjectObeliskCommand :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectObeliskCommand target = do\n  myUid <- liftIO getRealUserID\n  processUmask <- liftIO getUmask\n  targetStat <- liftIO $ getFileStatus target\n  (result, insecurePaths) <- flip runStateT [] $ walkToProjectRoot target targetStat processUmask myUid >>= \\case\n    Nothing -> pure Nothing\n    Just projectRoot -> liftIO (doesDirectoryExist $ toImplDir projectRoot) >>= \\case\n      False -> do\n        putLog Warning $ \"Found obelisk directory in \" <> T.pack projectRoot <> \" but the implementation (impl) file is missing\"\n        pure Nothing\n      True -> do\n        walkToImplDir projectRoot myUid processUmask -- For security check\n        return $ Just projectRoot\n  case (result, insecurePaths) of\n    (Just projDir, []) -> do\n      obeliskCommandPkg <- wrapNixThunkError $ nixBuildAttrWithCache (toImplDir projDir) \"command\"\n      return $ Just $ obeliskCommandPkg </> \"bin\" </> \"ob\"\n    (Nothing, _) -> return Nothing\n    (Just projDir, _) -> do\n      putLog Error $ T.unlines\n        [ \"Error: Found a project at \" <> T.pack (normalise projDir) <> \", but had to traverse one or more insecure directories to get there:\"\n        , T.unlines $ fmap (T.pack . normalise) insecurePaths\n        , \"Please ensure that all of these directories are owned by you, not world-writable, and no more group-writable than permitted by your umask.\"\n        ]\n      return Nothing\n\n-- | Get the umask for the Obelisk process.\n--\n-- Because of\n-- http://man7.org/linux/man-pages/man2/umask.2.html#NOTES we have to set the\n-- umask to read it. We are using 'withMVarMasked' to guarantee that setting and\n-- reading isn't interrupted by any exception or interleaved with another thread.\ngetUmask :: IO FileMode\ngetUmask = withMVarMasked globalUmaskLock $ \\() -> do\n  initialMask <- setFileCreationMask safeUmask\n  void (setFileCreationMask initialMask)\n  pure initialMask\n  where\n    safeUmask :: FileMode\n    safeUmask = CMode 0o22\n\n{-# NOINLINE globalUmaskLock #-}\nglobalUmaskLock :: MVar ()\nglobalUmaskLock = unsafePerformIO (newMVar ())\n\n-- | Get the FilePath to the containing project directory, if there is one\nfindProjectRoot :: MonadObelisk m => FilePath -> m (Maybe FilePath)\nfindProjectRoot target = do\n  myUid <- liftIO getRealUserID\n  targetStat <- liftIO $ getFileStatus target\n  umask <- liftIO getUmask\n  (result, _) <- liftIO $ runStateT (walkToProjectRoot target targetStat umask myUid) []\n  return $ makeRelative \".\" <$> result\n\nwithProjectRoot :: MonadObelisk m => FilePath -> (FilePath -> m a) -> m a\nwithProjectRoot target f = findProjectRoot target >>= \\case\n  Nothing -> failWith \"Must be used inside of an Obelisk project\"\n  Just root -> f root\n\n-- | Walk from the current directory to the containing project's root directory,\n-- if there is one, accumulating potentially insecure directories that were\n-- traversed in the process.  Return the project root directory, if found.\nwalkToProjectRoot\n  :: (MonadState [FilePath] m, MonadIO m)\n  => FilePath -> FileStatus -> FileMode -> UserID -> m (Maybe FilePath)\nwalkToProjectRoot this thisStat desiredUmask myUid = liftIO (doesDirectoryExist this) >>= \\case\n  -- It's not a directory, so it can't be a project\n  False -> do\n    let dir = takeDirectory this\n    dirStat <- liftIO $ getFileStatus dir\n    walkToProjectRoot dir dirStat desiredUmask myUid\n  True -> do\n    unless (isWellOwnedAndWellPermissioned thisStat myUid desiredUmask) $ modify (this:)\n    liftIO (doesDirectoryExist $ toObeliskDir this) >>= \\case\n      True -> return $ Just this\n      False -> do\n        let next = this </> \"..\" -- Use \"..\" instead of chopping off path segments, so that if the current directory is moved during the traversal, the traversal stays consistent\n        nextStat <- liftIO $ getFileStatus next\n        let fileIdentity fs = (deviceID fs, fileID fs)\n            isSameFileAs = (==) `on` fileIdentity\n        if thisStat `isSameFileAs` nextStat\n          then return Nothing -- Found a cycle; probably hit root directory\n          else walkToProjectRoot next nextStat desiredUmask myUid\n\n-- | Walk from the given project root directory to its Obelisk implementation\n-- directory, accumulating potentially insecure directories that were traversed\n-- in the process.\nwalkToImplDir :: (MonadState [FilePath] m, MonadIO m) => FilePath -> UserID -> FileMode -> m ()\nwalkToImplDir projectRoot myUid umask = do\n  let obDir = toObeliskDir projectRoot\n  obDirStat <- liftIO $ getFileStatus obDir\n  unless (isWellOwnedAndWellPermissioned obDirStat myUid umask) $ modify (obDir:)\n  let implThunk = obDir </> \"impl\"\n  implThunkStat <- liftIO $ getFileStatus implThunk\n  unless (isWellOwnedAndWellPermissioned implThunkStat myUid umask) $ modify (implThunk:)\n\n-- | Check to see if directory is writable by a user whose User ID matches the\n-- second argument provided, and if the fact that other people can write to that\n-- directory is in accordance with the umask of the system, passed as the third\n-- argument.\nisWellOwnedAndWellPermissioned :: FileStatus -> UserID -> FileMode -> Bool\nisWellOwnedAndWellPermissioned s uid umask = isOwnedBy s uid && filePermissionIsSafe s umask\n\nisOwnedBy :: FileStatus -> UserID -> Bool\nisOwnedBy s uid = fileOwner s == uid\n\n-- | Check to see if a directory respect the umask, but check explicitly that\n-- it's not world writable in any case.\nfilePermissionIsSafe :: FileStatus -> FileMode -> Bool\nfilePermissionIsSafe s umask = not fileWorldWritable && fileGroupWritable <= umaskGroupWritable\n  where\n    fileWorldWritable = fileMode s .&. 0o002 == 0o002\n    fileGroupWritable = fileMode s .&. 0o020 == 0o020\n    umaskGroupWritable = umask .&. 0o020 == 0\n\nnixShellRunConfig :: MonadObelisk m => FilePath -> Bool -> Maybe String -> m NixShellConfig\nnixShellRunConfig root isPure command = do\n  nixpkgsPath <- fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath [\"eval\", \"--impure\", \"--expr\", \"(import .obelisk/impl {}).nixpkgs.path\"]\n  nixRemote <- liftIO $ lookupEnv \"NIX_REMOTE\"\n  pure $ def\n    & nixShellConfig_pure .~ isPure\n    & nixShellConfig_common . nixCmdConfig_target .~ (def & target_path .~ Nothing)\n    & nixShellConfig_run .~ (command <&> \\cs -> unwords $ concat\n      [ [\"export\", BSU.toString . bytes . bash $ \"NIX_PATH=nixpkgs=\" <> encodeUtf8 nixpkgsPath, \";\"]\n      , maybe [] (\\v -> [\"export\", BSU.toString . bytes . bash $ \"NIX_REMOTE=\" <> encodeUtf8 (T.pack v), \";\"]) nixRemote\n      , [cs]\n      ])\n\n-- | Escape using ANSI C-style quotes @$''@\n-- This does not work with all shells! Ideally, we would control exactly which shell is used,\n-- down to its sourced configuration, throughout the obelisk environment. At this time, this\n-- is not feasible.\nbashEscape :: String -> String\nbashEscape = BSU.toString . bytes . bash . BSU.fromString\n\n-- | Escape using Bourne style shell escaping\n-- This is not as robust, but is necessary if we are passing to a shell we don't control.\n-- The most prominent issue is that 'System.Process' executes shell commands by invoking\n-- @\\/bin\\/sh@ instead of something configurable. While we can avoid this by specifying a shell manually,\n-- we cannot guarantee that our dependencies do the same. In particular, ghcid invokes its\n-- subcommands that way.\nshEscape :: String -> String\nshEscape = BSU.toString . bytes . sh . BSU.fromString\n\nnixShellRunProc :: NixShellConfig -> ProcessSpec\nnixShellRunProc cfg = setDelegateCtlc True $ proc nixShellPath $ runNixShellConfig cfg\n\nmkObNixShellProc\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ProcessSpec\nmkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  packageNamesAndAbsPaths <- liftIO $ for packageNamesAndPaths makeAbsolute\n  defShellConfig <- nixShellRunConfig root isPure command\n  let setCwd_ = if chdirToRoot then setCwd (Just root) else id\n  pure $ setCwd_ $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{root, pkgs, shell}: ((import root {}).passthru.__unstable__.self.extend (_: _: {\\\n          \\shellPackages = builtins.fromJSON pkgs;\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~\n        [ rawArg \"root\" $ toNixPath $ if chdirToRoot then \".\" else root\n        , strArg \"pkgs\" (T.unpack $ decodeUtf8 $ BSL.toStrict $ Json.encode packageNamesAndAbsPaths)\n        , strArg \"shell\" shellAttr\n        ]\n\nnixShellWithoutPkgs\n  :: MonadObelisk m\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should this be a pure shell?\n  -> Bool -- ^ Should we chdir to the package root in the shell?\n  -> Map Text FilePath -- ^ Package names mapped to their paths\n  -> String -- ^ Shell attribute to use (e.g. @\"ghc\"@, @\"ghcjs\"@, etc.)\n  -> Maybe String -- ^ If 'Just' run the given command; otherwise just open the interactive shell\n  -> m ()\nnixShellWithoutPkgs root isPure chdirToRoot packageNamesAndPaths shellAttr command = do\n  runProcess_ =<< mkObNixShellProc root isPure chdirToRoot packageNamesAndPaths shellAttr command\n\nnixShellWithHoogle :: MonadObelisk m => FilePath -> Bool -> String -> Maybe String -> m ()\nnixShellWithHoogle root isPure shell' command = do\n  defShellConfig <- nixShellRunConfig root isPure command\n  runProcess_ $ setCwd (Just root) $ nixShellRunProc $ defShellConfig\n    & nixShellConfig_common . nixCmdConfig_target . target_expr ?~\n        \"{shell}: ((import ./. {}).passthru.__unstable__.self.extend (_: super: {\\\n          \\userSettings = super.userSettings // { withHoogle = true; };\\\n        \\})).project.shells.${shell}\"\n    & nixShellConfig_common . nixCmdConfig_args .~ [ strArg \"shell\" shell' ]\n\n-- | Describes the provenance of static assets (i.e., are they the result of a derivation\n-- that was built, or just a folder full of files.\ndata AssetSource = AssetSource_Derivation\n                 | AssetSource_Files\n  deriving (Eq)\n\n-- | Some log messages to make it easier to tell where static files are coming from\ndescribeImpureAssetSource :: AssetSource -> Text -> Text\ndescribeImpureAssetSource src path = case src of\n  AssetSource_Files -> \"Assets impurely loaded from: \" <> path\n  AssetSource_Derivation -> \"Assets derivation built and impurely loaded from: \" <> path\n\n-- | Determine where the static files of a project are and whether they're plain files or a derivation.\n-- If they are a derivation, that derivation will be built.\nfindProjectAssets :: MonadObelisk m => FilePath -> m (AssetSource, Text)\nfindProjectAssets root = do\n  isDerivation <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n    proc nixExePath\n      [ \"eval\"\n      , \"--impure\"\n      , \"--expr\"\n      , \"(let a = import ./. {}; in toString (a.reflex.nixpkgs.lib.isDerivation a.passthru.staticFilesImpure))\"\n      , \"--raw\"\n      -- `--raw` is not available with old nix-instantiate. It drops quotation\n      -- marks and trailing newline, so is very convenient for shelling out.\n      ]\n  -- Check whether the impure static files are a derivation (and so must be built)\n  if isDerivation == \"1\"\n    then do\n      _ <- buildStaticFilesDerivationAndSymlink\n        (readProcessAndLogStderr Debug)\n        root\n      pure (AssetSource_Derivation, T.pack $ root </> \"static.out\")\n    else fmap (AssetSource_Files,) $ do\n      path <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc nixExePath [\"eval\", \"-f\", \".\", \"passthru.staticFilesImpure\", \"--raw\"]\n      _ <- readProcessAndLogStderr Debug $ setCwd (Just root) $\n        proc lnPath [\"-sfT\", T.unpack path, \"./static.out\"]\n      pure path\n\n-- | Get the nix store path to the generated static asset manifest module (e.g., \"obelisk-generated-static\")\ngetHaskellManifestProjectPath :: MonadObelisk m => FilePath -> m Text\ngetHaskellManifestProjectPath root = fmap T.strip $ readProcessAndLogStderr Debug $ setCwd (Just root) $\n  proc nixBuildExePath\n    [ \"--no-out-link\"\n    , \"-E\"\n    , \"(let a = import ./. {}; in a.passthru.processedStatic.haskellManifest)\"\n    ]\n\n-- | Watch the common, backend, frontend, and static directories for file\n-- changes and check whether those file changes cause changes in the static\n-- files nix derivation. If so, rebuild it.\nwatchStaticFilesDerivation\n  :: (MonadIO m, MonadObelisk m)\n  => FilePath\n  -> m ()\nwatchStaticFilesDerivation root = do\n  ob <- getObelisk\n  liftIO $ runHeadlessApp $ do\n    pb <- getPostBuild\n    -- TODO: Instead of filtering like this, we should figure out what the\n    -- derivation actually relies on, or at least use the gitignore\n    let filterEvents x =\n          let fn = takeFileName x\n              dirs = Set.fromList $ splitDirectories x\n              ignoredFilenames = Set.fromList\n                [ \"4913\" -- Vim temporary file\n                ]\n              ignoredExtensions = Set.fromList\n                [ \".hi\"\n                , \".o\"\n                , \".swo\"\n                , \".swp\"\n                ]\n          in not $\n              fn `Set.member` ignoredFilenames ||\n              takeExtension fn `Set.member` ignoredExtensions\n        cfg = defaultConfig\n          -- On macOS, use the polling backend due to\n          -- https://github.com/luite/hfsevents/issues/13\n            { confWatchMode =\n                if Sys.os == \"darwin\"\n                  then WatchModePoll 250000\n                  else WatchModeOS\n            }\n        watch' pkg = fmap (:[]) <$> watchDirectoryTree cfg (root </> pkg <$ pb) (filterEvents . eventPath)\n    rebuild <- batchOccurrences 0.25 . mergeWith (<>) =<< mapM watch'\n      [ \"frontend\"\n      , \"backend\"\n      , \"common\"\n      , \"static\"\n      ]\n    performEvent_\n      $ liftIO\n      . runObelisk ob\n      . putLog Debug\n      . (\"Regenerating static.out due to file changes: \"<>)\n      . T.intercalate \", \"\n      . Set.toList\n      . Set.fromList\n      . fmap (T.pack . eventPath)\n      . concat\n      . F.toList\n      <$> rebuild\n    void $ flip throttleBatchWithLag rebuild $ \\e ->\n      performEvent $ ffor e $ \\_ -> liftIO $ runObelisk ob $ do\n        putLog Notice \"Static assets being built...\"\n        buildStaticCatchErrors >>= \\case\n          Nothing -> pure ()\n          Just n -> do\n            putLog Notice \"Static assets built and symlinked to static.out\"\n            putLog Debug $ \"Generated static asset nix path: \" <> n\n    pure never\n  where\n    handleBuildFailure\n      :: MonadObelisk m\n      => (ExitCode, String, String)\n      -> m (Maybe Text)\n    handleBuildFailure (ex, out, err) = case ex of\n      ExitSuccess ->\n        let out' = T.strip $ T.pack out\n        in pure $ if T.null out' then Nothing else Just out'\n      _ -> do\n        putLog Error $\n          (\"Static assets build failed: \" <>) $\n            T.unlines $ reverse $ take 20 $ reverse $ T.lines $ T.pack err\n        pure Nothing\n    buildStaticCatchErrors :: MonadObelisk m => m (Maybe Text)\n    buildStaticCatchErrors = handleBuildFailure =<<\n      buildStaticFilesDerivationAndSymlink\n        readCreateProcessWithExitCode\n        root\n\nbuildStaticFilesDerivationAndSymlink\n  :: MonadObelisk m\n  => (ProcessSpec -> m a)\n  -> FilePath\n  -> m a\nbuildStaticFilesDerivationAndSymlink f root = f $\n  setCwd (Just root) $ ProcessSpec\n    { _processSpec_createProcess = Proc.proc\n        nixBuildExePath\n        [ \"-o\", \"static.out\"\n        , \"-E\", \"(import ./. {}).passthru.staticFilesImpure\"\n        ]\n    , _processSpec_overrideEnv = Nothing\n    }\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.0714285714285714,
                "sum": 15
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 10,
              "lines_of_code": 202,
              "homplexity_lines_of_code": 236,
              "code_quality_score": 46.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.0714285714285714,
                  "sum": 15
                },
                "homplexity_loc": 236,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 1 1: module Obelisk.Command.VmBuilder has 136 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 27 1: type signature for getNixBuildersArg has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 27 1: type signature for getNixBuildersArg has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has 7 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 28 1: function getNixBuildersArg has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 36 1: type signature for checkForNixDarwin has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 36 1: type signature for checkForNixDarwin has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has 17 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 37 1: function checkForNixDarwin has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 58 1: type signature for nixBuildersArgString has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 58 1: type signature for nixBuildersArgString has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 59 1: function nixBuildersArgString has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 62 1: type signature for containerName has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 62 1: type signature for containerName has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 63 1: function containerName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 66 1: type signature for containerExists has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 66 1: type signature for containerExists has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has 10 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 67 1: function containerExists has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 81 1: type signature for containerSshPort has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 81 1: type signature for containerSshPort has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 82 1: function containerSshPort has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 85 1: type signature for startContainer has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 85 1: type signature for startContainer has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has 3 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 86 1: function startContainer has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 91 1: type signature for setupNixDocker has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 91 1: type signature for setupNixDocker has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 92 1: function setupNixDocker has 20 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 120 1: type signature for setupInstructions has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 120 1: type signature for setupInstructions has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has 16 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 121 1: function setupInstructions has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 140 1: type signature for sshConfigHost has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 140 1: type signature for sshConfigHost has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has 6 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 141 1: function sshConfigHost has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 150 1: type signature for getDockerBuilderStateDir has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 150 1: type signature for getDockerBuilderStateDir has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 151 1: function getDockerBuilderStateDir has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 154 1: type signature for testLinuxBuild has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 154 1: type signature for testLinuxBuild has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has 11 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 155 1: function testLinuxBuild has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 170 1: type signature for dockerfile has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 170 1: type signature for dockerfile has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has 5 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 171 1: function dockerfile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 201 1: type signature for sshKeyFileName has type constructor nesting of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 201 1: type signature for sshKeyFileName has 1 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/VmBuilder.hs\" 202 1: function sshKeyFileName has 1 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\nmodule Obelisk.Command.VmBuilder where\n\nimport Control.Applicative (liftA2)\nimport Control.Monad (when, unless)\nimport Control.Monad.Catch (handle)\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Monoid ((<>))\nimport Data.String (IsString)\nimport Data.String.Here.Uninterpolated (hereLit)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory (createDirectoryIfMissing)\nimport System.Exit (ExitCode(..))\nimport System.FilePath ((<.>), (</>))\nimport qualified System.Info\n\nimport Obelisk.App (MonadObelisk, getObeliskUserStateDir)\nimport Obelisk.Command.Utils (rmPath, whichPath, sshKeygenPath, nixBuildExePath, dockerPath)\nimport Cli.Extras\n\n-- | Generate the `--builders` argument string to enable the VM builder after ensuring it is available.\ngetNixBuildersArg :: MonadObelisk m => m String\ngetNixBuildersArg = do\n  stateDir <- liftIO getDockerBuilderStateDir\n  let sshIdFile = stateDir </> sshKeyFileName\n  checkForNixDarwin sshIdFile\n  exists <- containerExists stateDir\n  if exists then startContainer else setupNixDocker stateDir\n  pure $ nixBuildersArgString stateDir\n\ncheckForNixDarwin :: MonadObelisk m => String -> m ()\ncheckForNixDarwin sshIdFile = do\n  (exitCode, _, _) <- readCreateProcessWithExitCode $ proc whichPath [\"darwin-rebuild\"]\n  unless (exitCode == ExitSuccess) $ failWith $ T.intercalate \"\\n\"\n    [ \"Deployments from macOS require nix-darwin to be installed.\"\n    , \"Follow the installation instructions here: https://github.com/LnL7/nix-darwin\"\n    , \"You'll also need to add the following to your 'configuration.nix' and run 'darwin-rebuild switch':\"\n    , \"\"\n    , T.intercalate \"\\n\" $ map (\"  \" <>)\n      [ \"nix.distributedBuilds = true;\"\n      , \"nix.buildMachines = [{\"\n      , \" hostName = \" <> T.pack (show (containerName :: String)) <> \";\"\n      , \" sshUser = \\\"root\\\";\"\n      , \" sshKey = \" <> T.pack (show sshIdFile) <> \";\"\n      , \" sshPort = \" <> T.pack (show containerSshPort) <> \";\"\n      , \" systems = [ \\\"x86_64-linux\\\" ];\"\n      , \" maxJobs = 2;\"\n      , \"}];\"\n      ]\n    ]\n\n-- | String to pass to nix's `--builders` arguments to enable the VM builder.\nnixBuildersArgString :: FilePath -> String\nnixBuildersArgString stateDir = unwords [containerName, \"x86_64-linux\", stateDir </> sshKeyFileName, \"1\", \"1\", \"kvm\"]\n\n-- | Name of Docker container used for the VM builder.\ncontainerName :: IsString str => str\ncontainerName = \"obelisk-docker-nix-builder\"\n\n-- | Check to see if the Docker container exists. This will exit with a helpful message if Docker is not installed.\ncontainerExists :: MonadObelisk m => FilePath -> m Bool\ncontainerExists stateDir = handle (\\(_ :: IOError) -> failWith needDockerMsg) $ do\n  containerNames <- fmap (map T.strip . T.lines) $\n    readProcessAndLogStderr Error $\n      proc dockerPath [\"container\", \"list\", \"--all\", \"--format\", \"{{.Names}}\"]\n  let exists = containerName `elem` containerNames\n  when exists $ testLinuxBuild stateDir\n  pure exists\n  where\n    needDockerMsg = T.intercalate \"\\n\"\n      [ \"This feature requires that you have Docker installed and the `docker` command available on your PATH.\"\n      , \"Please go https://docs.docker.com/ to install Docker and try this command again.\"\n      ]\n\n-- | SSH port on localhost that connects to the container.\ncontainerSshPort :: Int\ncontainerSshPort = 2222\n\n-- | Start the Docker container; assumes it already exists.\nstartContainer :: MonadObelisk m => m ()\nstartContainer = withSpinner \"Starting VM builder\" $\n  callProcessAndLogOutput (Debug, Debug) $\n    proc dockerPath [\"start\", containerName]\n\n-- | Creates the Docker container; assumes it does not exist.\nsetupNixDocker :: MonadObelisk m => FilePath -> m ()\nsetupNixDocker stateDir = withSpinner (\"Creating Docker container named \" <> containerName) $ do\n  liftIO $ do\n    createDirectoryIfMissing True stateDir\n    T.writeFile (stateDir </> \"Dockerfile\") dockerfile\n\n  -- Create new SSH keys for this container\n  callProcessAndLogOutput (Debug, Error) $\n    proc rmPath [\"-f\", stateDir </> sshKeyFileName, stateDir </> sshKeyFileName <.> \"pub\"]\n  callProcessAndLogOutput (Debug, Error) $\n    proc sshKeygenPath [\"-t\", \"ed25519\", \"-f\", stateDir </> sshKeyFileName, \"-P\", \"\"]\n\n  -- Build the docker container (which uses the SSH keys in the 'ssh' folder)\n  containerId <- fmap T.strip $ readProcessAndLogStderr Error $\n    proc dockerPath [\"build\", stateDir, \"--quiet\"]\n  callProcessAndLogOutput (Debug, Error) $ proc dockerPath\n    [ \"run\"\n    , \"--restart\", \"always\"\n    , \"--detach\"\n    , \"--publish\", show containerSshPort <> \":22\"\n    , \"--name\", T.unpack containerName, T.unpack containerId\n    ]\n  exists <- containerExists stateDir\n  unless exists $\n    failWith $ \"Expected to see docker container named \" <> containerName <> \" but it does not exist.\"\n\n  testLinuxBuild stateDir\n\n-- | The instructions for setting up SSH access to the container for the Nix daemon.\nsetupInstructions :: FilePath -> Text\nsetupInstructions sshIdFile = T.unlines\n  [ \"Setting Up Docker Nix Builder\"\n  , \"-----------------------------\"\n  , \"\"\n  , \"We've created a Docker container that can build for Linux. However, the Nix\"\n  , \"daemon needs to connect to this container as root. Please run the following\"\n  , \"commands in a root shell (`sudo su -`) to tell SSH how to access the\"\n  , \"container. Then try your obelisk command again.\"\n  , \"\"\n  , \"# sudo su -\"\n  , \"touch ~/.ssh/config\"\n  , \"cat >> ~/.ssh/config <<CONF\"\n  , \"\"\n  , sshConfigHost sshIdFile\n  , \"CONF\"\n  , \"ssh \" <> containerName <> \" nix --version # Answer 'yes' if prompted\"\n  ]\n\n-- | SSH configuration for `.ssh/config` to connect to the Docker container.\nsshConfigHost :: FilePath -> Text\nsshConfigHost sshIdFile = T.unlines\n  [ \"Host \" <> containerName\n  , \"  User root\"\n  , \"  HostName 127.0.0.1\"\n  , \"  Port \" <> T.pack (show containerSshPort)\n  , \"  IdentityFile \" <> T.pack (show sshIdFile) -- TODO: Check to see how weird paths should be encoded here.\n  ]\n\n-- | User directory where state (namely the SSH keys) is kept for the Docker container.\ngetDockerBuilderStateDir :: IO FilePath\ngetDockerBuilderStateDir = liftA2 (</>) getObeliskUserStateDir (pure \"nix-docker-builder\")\n\n-- | Run a test build to see if a Linux build can finish successfully.\ntestLinuxBuild :: MonadObelisk m => FilePath -> m ()\ntestLinuxBuild stateDir\n  | System.Info.os == \"linux\" = failWith \"Using the docker builder is not necessary on linux.\"\n  | otherwise = do\n    (exitCode, _stdout, stderr) <- readCreateProcessWithExitCode $ proc nixBuildExePath\n      [ \"--no-out-link\"\n      , \"-E\", \"(import <nixpkgs> { system = \\\"x86_64-linux\\\"; }).writeText \\\"test\\\" builtins.currentTime\"\n      , \"--builders\", nixBuildersArgString stateDir\n      ]\n    unless (exitCode == ExitSuccess) $ do\n      let sshIdFile = stateDir </> sshKeyFileName\n      putLog Error $ T.pack stderr\n      failWith $ setupInstructions sshIdFile\n\n-- Copied from https://github.com/LnL7/nix-docker/blob/8dcfb3aff1f87cdafeecb0d27964b27c3fb8b1d2/ssh/Dockerfile\n-- Renamed \"insecure_rsa\" to 'sshKeyFileName'\ndockerfile :: Text\ndockerfile = [hereLit|\nFROM lnl7/nix:2018-09-21\n\nRUN nix-env -f '<nixpkgs>' -iA \\\n    gnused \\\n    openssh \\\n && nix-store --gc\n\nRUN mkdir -p /etc/ssh \\\n && echo \"sshd:x:498:65534::/var/empty:/run/current-system/sw/bin/nologin\" >> /etc/passwd \\\n && cp /root/.nix-profile/etc/ssh/sshd_config /etc/ssh \\\n && sed -i '/^PermitRootLogin/d' /etc/ssh/sshd_config \\\n && echo \"PermitRootLogin yes\" >> /etc/ssh/sshd_config \\\n && ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N \"\" -t rsa \\\n && ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N \"\" -t dsa \\\n && echo \"export SSL_CERT_FILE=$SSL_CERT_FILE\" >> /etc/bashrc \\\n && echo \"export PATH=$PATH\" >> /etc/bashrc \\\n && echo \"export NIX_PATH=$NIX_PATH\" >> /etc/bashrc \\\n && echo \"source /etc/bashrc\" >> /etc/profile\n\n|] <> T.unlines\n  [ \"ADD \" <> T.pack sshKeyFileName <> \" /root/.ssh/id_rsa\"\n  , \"ADD \" <> T.pack (sshKeyFileName <.> \"pub\") <> \" /root/.ssh/authorized_keys\"\n  ] <> [hereLit|\n\nEXPOSE 22\nCMD [\"/nix/store/mydwfxzk8bka4iwjml033dir6gkmqwic-openssh-7.7p1/bin/sshd\", \"-D\", \"-e\"]\n\n|]\n\nsshKeyFileName :: FilePath\nsshKeyFileName = \"id_ed25519_obelisk_vm\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/VmBuilder.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\nmodule Obelisk.Command.VmBuilder where\n\nimport Control.Applicative (liftA2)\nimport Control.Monad (when, unless)\nimport Control.Monad.Catch (handle)\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Monoid ((<>))\nimport Data.String (IsString)\nimport Data.String.Here.Uninterpolated (hereLit)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport System.Directory (createDirectoryIfMissing)\nimport System.Exit (ExitCode(..))\nimport System.FilePath ((<.>), (</>))\nimport qualified System.Info\n\nimport Obelisk.App (MonadObelisk, getObeliskUserStateDir)\nimport Obelisk.Command.Utils (rmPath, whichPath, sshKeygenPath, nixBuildExePath, dockerPath)\nimport Cli.Extras\n\n-- | Generate the `--builders` argument string to enable the VM builder after ensuring it is available.\ngetNixBuildersArg :: MonadObelisk m => m String\ngetNixBuildersArg = do\n  stateDir <- liftIO getDockerBuilderStateDir\n  let sshIdFile = stateDir </> sshKeyFileName\n  checkForNixDarwin sshIdFile\n  exists <- containerExists stateDir\n  if exists then startContainer else setupNixDocker stateDir\n  pure $ nixBuildersArgString stateDir\n\ncheckForNixDarwin :: MonadObelisk m => String -> m ()\ncheckForNixDarwin sshIdFile = do\n  (exitCode, _, _) <- readCreateProcessWithExitCode $ proc whichPath [\"darwin-rebuild\"]\n  unless (exitCode == ExitSuccess) $ failWith $ T.intercalate \"\\n\"\n    [ \"Deployments from macOS require nix-darwin to be installed.\"\n    , \"Follow the installation instructions here: https://github.com/LnL7/nix-darwin\"\n    , \"You'll also need to add the following to your 'configuration.nix' and run 'darwin-rebuild switch':\"\n    , \"\"\n    , T.intercalate \"\\n\" $ map (\"  \" <>)\n      [ \"nix.distributedBuilds = true;\"\n      , \"nix.buildMachines = [{\"\n      , \" hostName = \" <> T.pack (show (containerName :: String)) <> \";\"\n      , \" sshUser = \\\"root\\\";\"\n      , \" sshKey = \" <> T.pack (show sshIdFile) <> \";\"\n      , \" sshPort = \" <> T.pack (show containerSshPort) <> \";\"\n      , \" systems = [ \\\"x86_64-linux\\\" ];\"\n      , \" maxJobs = 2;\"\n      , \"}];\"\n      ]\n    ]\n\n-- | String to pass to nix's `--builders` arguments to enable the VM builder.\nnixBuildersArgString :: FilePath -> String\nnixBuildersArgString stateDir = unwords [containerName, \"x86_64-linux\", stateDir </> sshKeyFileName, \"1\", \"1\", \"kvm\"]\n\n-- | Name of Docker container used for the VM builder.\ncontainerName :: IsString str => str\ncontainerName = \"obelisk-docker-nix-builder\"\n\n-- | Check to see if the Docker container exists. This will exit with a helpful message if Docker is not installed.\ncontainerExists :: MonadObelisk m => FilePath -> m Bool\ncontainerExists stateDir = handle (\\(_ :: IOError) -> failWith needDockerMsg) $ do\n  containerNames <- fmap (map T.strip . T.lines) $\n    readProcessAndLogStderr Error $\n      proc dockerPath [\"container\", \"list\", \"--all\", \"--format\", \"{{.Names}}\"]\n  let exists = containerName `elem` containerNames\n  when exists $ testLinuxBuild stateDir\n  pure exists\n  where\n    needDockerMsg = T.intercalate \"\\n\"\n      [ \"This feature requires that you have Docker installed and the `docker` command available on your PATH.\"\n      , \"Please go https://docs.docker.com/ to install Docker and try this command again.\"\n      ]\n\n-- | SSH port on localhost that connects to the container.\ncontainerSshPort :: Int\ncontainerSshPort = 2222\n\n-- | Start the Docker container; assumes it already exists.\nstartContainer :: MonadObelisk m => m ()\nstartContainer = withSpinner \"Starting VM builder\" $\n  callProcessAndLogOutput (Debug, Debug) $\n    proc dockerPath [\"start\", containerName]\n\n-- | Creates the Docker container; assumes it does not exist.\nsetupNixDocker :: MonadObelisk m => FilePath -> m ()\nsetupNixDocker stateDir = withSpinner (\"Creating Docker container named \" <> containerName) $ do\n  liftIO $ do\n    createDirectoryIfMissing True stateDir\n    T.writeFile (stateDir </> \"Dockerfile\") dockerfile\n\n  -- Create new SSH keys for this container\n  callProcessAndLogOutput (Debug, Error) $\n    proc rmPath [\"-f\", stateDir </> sshKeyFileName, stateDir </> sshKeyFileName <.> \"pub\"]\n  callProcessAndLogOutput (Debug, Error) $\n    proc sshKeygenPath [\"-t\", \"ed25519\", \"-f\", stateDir </> sshKeyFileName, \"-P\", \"\"]\n\n  -- Build the docker container (which uses the SSH keys in the 'ssh' folder)\n  containerId <- fmap T.strip $ readProcessAndLogStderr Error $\n    proc dockerPath [\"build\", stateDir, \"--quiet\"]\n  callProcessAndLogOutput (Debug, Error) $ proc dockerPath\n    [ \"run\"\n    , \"--restart\", \"always\"\n    , \"--detach\"\n    , \"--publish\", show containerSshPort <> \":22\"\n    , \"--name\", T.unpack containerName, T.unpack containerId\n    ]\n  exists <- containerExists stateDir\n  unless exists $\n    failWith $ \"Expected to see docker container named \" <> containerName <> \" but it does not exist.\"\n\n  testLinuxBuild stateDir\n\n-- | The instructions for setting up SSH access to the container for the Nix daemon.\nsetupInstructions :: FilePath -> Text\nsetupInstructions sshIdFile = T.unlines\n  [ \"Setting Up Docker Nix Builder\"\n  , \"-----------------------------\"\n  , \"\"\n  , \"We've created a Docker container that can build for Linux. However, the Nix\"\n  , \"daemon needs to connect to this container as root. Please run the following\"\n  , \"commands in a root shell (`sudo su -`) to tell SSH how to access the\"\n  , \"container. Then try your obelisk command again.\"\n  , \"\"\n  , \"# sudo su -\"\n  , \"touch ~/.ssh/config\"\n  , \"cat >> ~/.ssh/config <<CONF\"\n  , \"\"\n  , sshConfigHost sshIdFile\n  , \"CONF\"\n  , \"ssh \" <> containerName <> \" nix --version # Answer 'yes' if prompted\"\n  ]\n\n-- | SSH configuration for `.ssh/config` to connect to the Docker container.\nsshConfigHost :: FilePath -> Text\nsshConfigHost sshIdFile = T.unlines\n  [ \"Host \" <> containerName\n  , \"  User root\"\n  , \"  HostName 127.0.0.1\"\n  , \"  Port \" <> T.pack (show containerSshPort)\n  , \"  IdentityFile \" <> T.pack (show sshIdFile) -- TODO: Check to see how weird paths should be encoded here.\n  ]\n\n-- | User directory where state (namely the SSH keys) is kept for the Docker container.\ngetDockerBuilderStateDir :: IO FilePath\ngetDockerBuilderStateDir = liftA2 (</>) getObeliskUserStateDir (pure \"nix-docker-builder\")\n\n-- | Run a test build to see if a Linux build can finish successfully.\ntestLinuxBuild :: MonadObelisk m => FilePath -> m ()\ntestLinuxBuild stateDir\n  | System.Info.os == \"linux\" = failWith \"Using the docker builder is not necessary on linux.\"\n  | otherwise = do\n    (exitCode, _stdout, stderr) <- readCreateProcessWithExitCode $ proc nixBuildExePath\n      [ \"--no-out-link\"\n      , \"-E\", \"(import <nixpkgs> { system = \\\"x86_64-linux\\\"; }).writeText \\\"test\\\" builtins.currentTime\"\n      , \"--builders\", nixBuildersArgString stateDir\n      ]\n    unless (exitCode == ExitSuccess) $ do\n      let sshIdFile = stateDir </> sshKeyFileName\n      putLog Error $ T.pack stderr\n      failWith $ setupInstructions sshIdFile\n\n-- Copied from https://github.com/LnL7/nix-docker/blob/8dcfb3aff1f87cdafeecb0d27964b27c3fb8b1d2/ssh/Dockerfile\n-- Renamed \"insecure_rsa\" to 'sshKeyFileName'\ndockerfile :: Text\ndockerfile = [hereLit|\nFROM lnl7/nix:2018-09-21\n\nRUN nix-env -f '<nixpkgs>' -iA \\\n    gnused \\\n    openssh \\\n && nix-store --gc\n\nRUN mkdir -p /etc/ssh \\\n && echo \"sshd:x:498:65534::/var/empty:/run/current-system/sw/bin/nologin\" >> /etc/passwd \\\n && cp /root/.nix-profile/etc/ssh/sshd_config /etc/ssh \\\n && sed -i '/^PermitRootLogin/d' /etc/ssh/sshd_config \\\n && echo \"PermitRootLogin yes\" >> /etc/ssh/sshd_config \\\n && ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N \"\" -t rsa \\\n && ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N \"\" -t dsa \\\n && echo \"export SSL_CERT_FILE=$SSL_CERT_FILE\" >> /etc/bashrc \\\n && echo \"export PATH=$PATH\" >> /etc/bashrc \\\n && echo \"export NIX_PATH=$NIX_PATH\" >> /etc/bashrc \\\n && echo \"source /etc/bashrc\" >> /etc/profile\n\n|] <> T.unlines\n  [ \"ADD \" <> T.pack sshKeyFileName <> \" /root/.ssh/id_rsa\"\n  , \"ADD \" <> T.pack (sshKeyFileName <.> \"pub\") <> \" /root/.ssh/authorized_keys\"\n  ] <> [hereLit|\n\nEXPOSE 22\nCMD [\"/nix/store/mydwfxzk8bka4iwjml033dir6gkmqwic-openssh-7.7p1/bin/sshd\", \"-D\", \"-e\"]\n\n|]\n\nsshKeyFileName :: FilePath\nsshKeyFileName = \"id_ed25519_obelisk_vm\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Deploy.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 2,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 29,
              "lines_of_code": 547,
              "homplexity_lines_of_code": 731,
              "code_quality_score": 26.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 731,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"deployInit\": 3,\n        \"deployInit'\": 13,\n        \"setupObeliskImpl\": 1,\n        \"deployPush\": 19,\n        \"deployActivationScript\": 1,\n        \"deployUpdate\": 1,\n        \"renderPlatformDeployment\": 2,\n        \"deployMobile\": 14,\n        \"createKeystore\": 1,\n        \"writeDeployConfig\": 1,\n        \"readDeployConfig\": 1,\n        \"lookupKnownHosts\": 3,\n        \"addKnownHostFromEnv\": 3,\n        \"verifyHostKey\": 1,\n        \"sshArgs\": 1,\n        \"getHostFromRoute\": 2,\n        \"validateCommonRouteAndGetHost\": 6\n    },\n    \"complexity_stats\": {\n        \"min\": 1,\n        \"max\": 19,\n        \"average\": 5.18,\n        \"sum\": 88\n    },\n    \"homplexity_loc\": 731\n}\n"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE ViewPatterns #-}\n{-|\n   Description:\n   Implementation of the CLI deploy commands. Deployment is done by intializing\n   a staging area for deployment configuration, and then by actually executing\n   the deployment by installing a NixOS configuration at the configured deployment\n   locations.\n-}\nmodule Obelisk.Command.Deploy where\n\nimport Control.Applicative (liftA2)\nimport Control.Lens\nimport Control.Monad\nimport Control.Monad.Catch (Exception (displayException), MonadThrow, bracket, throwM, try)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Aeson (FromJSON, ToJSON, encode, eitherDecode)\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport GHC.Generics\nimport System.Directory\nimport System.Exit (ExitCode(ExitSuccess))\nimport System.FilePath\nimport System.IO\nimport System.Which\nimport System.PosixCompat.Files\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Nix.Pretty (prettyNix)\nimport qualified Nix.Expr.Shorthands as Nix\nimport Prettyprinter (layoutCompact)\nimport Prettyprinter.Render.String (renderString)\n\nimport Obelisk.App (MonadObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils\n\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n-- | Options passed to the `init` verb\ndata DeployInitOpts = DeployInitOpts\n  { _deployInitOpts_outputDir :: FilePath\n  -- ^ Where to set up the deployment staging area\n  , _deployInitOpts_sshKey :: FilePath\n  -- ^ Which SSH Key will be used to interface with the deployment hosts\n  , _deployInitOpts_hostname :: [String]\n  -- ^ The hostnames that locate the deployment hosts\n  , _deployInitOpts_route :: String\n  -- ^ The route they are serving\n  , _deployInitOpts_adminEmail :: String\n  -- ^ The administrator email, for ACME\n  , _deployInitOpts_enableHttps :: Bool\n  -- ^ Whether or not to use HTTPS, which entails using Lets Encrypt by default\n  , _deployInitOpts_checkKnownHosts :: Bool\n  -- ^ Whether or not to use known_hosts file when assessing the identity of the deployment hosts\n  } deriving Show\n\n-- | The `init` verb\ndeployInit\n  :: MonadObelisk m\n  => DeployInitOpts\n  -- ^ Command line arguments\n  -> FilePath\n  -- ^ Project root, which cannot be the same as the deployment dir\n  -> m ()\ndeployInit deployOpts root = do\n  let deployDir = _deployInitOpts_outputDir deployOpts\n  rootEqualsTarget <- liftIO $ liftA2 equalFilePath (canonicalizePath root) (canonicalizePath deployDir)\n  when rootEqualsTarget $\n    failWith [i|Deploy directory ${deployDir} should not be the same as project root.|]\n  thunkPtr <- wrapNixThunkError (readThunk root) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    _ -> wrapNixThunkError (getThunkPtr CheckClean_NotIgnored root Nothing)\n  deployInit' thunkPtr deployOpts\n\n-- | The preamble in 'deployInit' provides deployInit' with a 'ThunkPtr' that it can install in\n-- the staging directory.\ndeployInit'\n  :: MonadObelisk m\n  => ThunkPtr\n  -> DeployInitOpts\n  -> m ()\ndeployInit' thunkPtr (DeployInitOpts deployDir sshKeyPath hostnames route adminEmail enableHttps checkKnownHosts) = do\n  liftIO $ createDirectoryIfMissing True deployDir\n  localKey <- withSpinner (\"Preparing \" <> T.pack deployDir) $ do\n    localKey <- liftIO (doesFileExist sshKeyPath) >>= \\case\n      False -> failWith $ T.pack $ \"ob deploy init: file does not exist: \" <> sshKeyPath\n      True -> pure $ deployDir </> \"ssh_key\"\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp [sshKeyPath, localKey]\n    liftIO $ setFileMode localKey $ ownerReadMode .|. ownerWriteMode\n    return localKey\n  withSpinner \"Validating configuration\" $ do\n    void $ getHostFromRoute enableHttps route -- make sure that hostname is present\n  let obKnownHostsPath = deployDir </> \"backend_known_hosts\"\n  forM_ hostnames $ \\hostname -> do\n    putLog Notice $ \"Verifying host keys (\" <> T.pack hostname <> \")\"\n    -- Note: we can't use a spinner here as this function will prompt the user.\n    when checkKnownHosts $ addKnownHostFromEnv hostname obKnownHostsPath\n    verifyHostKey obKnownHostsPath localKey hostname\n  --IMPORTANT: We cannot copy config directory from the development project to\n  --the deployment directory.  If we do, it's very likely someone will\n  --accidentally create a production deployment that uses development\n  --credentials to connect to some resources.  This could result in, e.g.,\n  --production data backed up to a dev environment.\n  withSpinner \"Creating project configuration directories\" $ liftIO $ do\n    mapM_ (createDirectoryIfMissing True)\n      [ deployDir </> \"config\" </> \"backend\"\n      , deployDir </> \"config\" </> \"common\"\n      , deployDir </> \"config\" </> \"frontend\"\n      ]\n\n  let srcDir = deployDir </> \"src\"\n  withSpinner (\"Creating source thunk (\" <> T.pack (makeRelative deployDir srcDir) <> \")\") $ do\n    wrapNixThunkError . createThunk srcDir $ Right thunkPtr\n    setupObeliskImpl deployDir\n\n  withSpinner \"Writing deployment configuration\" $ do\n    writeDeployConfig deployDir \"backend_hosts\" $ unlines hostnames\n    writeDeployConfig deployDir \"enable_https\" $ show enableHttps\n    writeDeployConfig deployDir \"admin_email\" adminEmail\n    writeDeployConfig deployDir (\"config\" </> \"common\" </> \"route\") route\n    writeDeployConfig deployDir \"module.nix\" $\n      \"(import \" <> toNixPath (makeRelative deployDir srcDir) <> \" {}).obelisk.serverModules.mkBaseEc2\"\n\n  withSpinner (\"Initializing git repository (\" <> T.pack deployDir <> \")\") $\n    initGit deployDir\n\n-- | Installs an obelisk impl in the staging dir that points at the obelisk of the\n-- project thunk.\nsetupObeliskImpl :: MonadIO m => FilePath -> m ()\nsetupObeliskImpl deployDir = liftIO $ do\n  let\n    implDir = toImplDir deployDir\n    goBackUp = foldr (</>) \"\" $ (\"..\" <$) $ splitPath $ makeRelative deployDir implDir\n  createDirectoryIfMissing True implDir\n  writeFile (implDir </> \"default.nix\") $ \"(import \" <> toNixPath (goBackUp </> \"src\") <> \" {}).obelisk\"\n\n-- | Executes the deployment specified in the supplied staging dir\ndeployPush\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Path to the staging directory\n  -> [String]\n  -- ^ nix builders arg string for the nix-build that builds the deployment artefacts\n  -> m ()\ndeployPush deployPath builders = do\n  hosts <- Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"backend_hosts\"\n  adminEmail <- readDeployConfig deployPath \"admin_email\"\n  enableHttps <- read <$> readDeployConfig deployPath \"enable_https\"\n  route <- readDeployConfig deployPath $ \"config\" </> \"common\" </> \"route\"\n  routeHost <- getHostFromRoute enableHttps route\n  redirectHosts <- liftIO (doesFileExist \"redirect_hosts\") >>= \\case\n    True -> Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"redirect_hosts\"\n    False -> pure mempty\n  let srcPath = deployPath </> \"src\"\n  thunkPtr <- wrapNixThunkError (readThunk srcPath) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    Right ThunkData_Checkout -> do\n      checkGitCleanStatus srcPath True >>= \\case\n        True -> wrapNixThunkError $ packThunk (ThunkPackConfig False (ThunkConfig Nothing)) srcPath\n        False -> failWith $ T.pack $ \"ob deploy push: ensure \" <> srcPath <> \" has no pending changes and latest is pushed upstream.\"\n    Left err -> failWith $ \"ob deploy push: couldn't read src thunk: \" <> T.pack (show err)\n  let version = show . _thunkRev_commit $ _thunkPtr_rev thunkPtr\n  let moduleFile = deployPath </> \"module.nix\"\n  moduleFileExists <- liftIO $ doesFileExist moduleFile\n\n  configHash <- getGitHash deployPath \"config\"\n  buildOutputByHost <- ifor (Map.fromSet (const ()) hosts) $ \\host () -> do\n    --TODO: What does it mean if this returns more or less than 1 line of output?\n    [result] <- fmap lines $ nixCmd $ NixCmd_Build $ def\n      & nixCmdConfig_target .~ Target\n        { _target_path = Just srcPath\n        , _target_attr = Just \"server.system\"\n        , _target_expr = Nothing\n        }\n      & nixBuildConfig_outLink .~ OutLink_None\n      & nixCmdConfig_args .~ (\n        [ strArg \"hostName\" $ fmap (\\c -> if c == '.' then '_' else c) host\n        , strArg \"adminEmail\" adminEmail\n        , strArg \"routeHost\" routeHost\n        , rawArg \"redirectHosts\" $ renderString $ layoutCompact $ prettyNix $ Nix.mkList $ Nix.mkStr . T.pack <$> Set.toList redirectHosts\n        , strArg \"version\" version\n        , boolArg \"enableHttps\" enableHttps\n        , strArg \"configHash\" $ T.unpack $ T.strip (_gitHash_text configHash)\n        ] <> [rawArg \"module\" (\"import \" <> toNixPath moduleFile) | moduleFileExists ])\n      & nixCmdConfig_builders .~ builders\n    pure result\n  let knownHostsPath = deployPath </> \"backend_known_hosts\"\n      sshOpts = sshArgs knownHostsPath (deployPath </> \"ssh_key\") False\n  withSpinner \"Uploading closures\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcess'\n      (Map.fromList [(\"NIX_SSHOPTS\", unwords sshOpts)])\n      \"nix-copy-closure\" [\"-v\", \"--to\", \"--use-substitutes\", \"root@\" <> host, \"--gzip\", outputPath]\n  withSpinner \"Uploading config\" $ ifor_ buildOutputByHost $ \\host _ -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc rsyncPath\n        [ \"-e \" <> sshPath <> \" \" <> unwords sshOpts\n        , \"--chown=backend:backend\"\n        , \"-qarvz\"\n        , deployPath </> \"config\"\n        , \"root@\" <> host <> \":/var/lib/backend\"\n        ]\n  --TODO: Create GC root so we're sure our closure won't go away during this time period\n  withSpinner \"Switching to new configuration\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc sshPath $ sshOpts <>\n        [ \"root@\" <> host\n        , unwords\n            [ \"bash -c\"\n            , bashEscape (deployActivationScript outputPath)\n            ]\n        ]\n  isClean <- checkGitCleanStatus deployPath True\n  when (not isClean) $ do\n    withSpinner \"Committing changes to Git\" $ do\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"add\", \".\"]\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"commit\", \"-m\", \"New deployment\"]\n  putLog Notice $ \"Deployed => \" <> T.pack route\n  where\n    callProcess' envMap cmd args = do\n      let p = setEnvOverride (envMap <>) $ setDelegateCtlc True $ proc cmd args\n      callProcessAndLogOutput (Notice, Notice) p\n\n-- | Bash command that will be run on the deployed machine to actually switch the NixOS configuration\n-- This has some more involved logic than merely activating the right profile. It also determines\n-- whether the kernel parameters have changed so that the deployed NixOS instance should be restarted.\ndeployActivationScript\n  :: String\n  -- ^ The out path of the configuration to activate\n  -> String\ndeployActivationScript outPath =\n-- Note that we don't want to $(staticWhich \"nix-env\") here, because this is executing on a remote machine\n-- This logic follows the nixos auto-upgrade module as of writing.\n-- If the workflow is added to switch-to-configuration proper, we can simplify this:\n-- https://github.com/obsidiansystems/obelisk/issues/958\n  [i|set -euxo pipefail\nnix-env -p /nix/var/nix/profiles/system --set \"${bashEscape outPath}\"\n/nix/var/nix/profiles/system/bin/switch-to-configuration boot\nbooted=\"$(readlink /run/booted-system/{initrd,kernel,kernel-modules})\"\nbuilt=\"$(readlink /nix/var/nix/profiles/system/{initrd,kernel,kernel-modules})\"\nif [ \"$booted\" = \"$built\" ]; then\n  /nix/var/nix/profiles/system/bin/switch-to-configuration switch\nelse\n  /run/current-system/sw/bin/shutdown -r +1\nfi\n|]\n\n-- | Update the source thunk in the staging directory to the HEAD of the branch.\ndeployUpdate :: MonadObelisk m => FilePath -> m ()\ndeployUpdate deployPath = wrapNixThunkError $\n  updateThunkToLatest (ThunkUpdateConfig Nothing (ThunkConfig Nothing)) (deployPath </> \"src\")\n\n-- | Platforms that we deploy obelisk artefacts to.\ndata PlatformDeployment = Android | IOS\n  deriving (Show, Eq)\n\n-- | Pretty print PlatformDeployment\nrenderPlatformDeployment :: PlatformDeployment -> String\nrenderPlatformDeployment = \\case\n  Android -> \"android\"\n  IOS -> \"ios\"\n\n-- | Produce the mobile app for an Obelisk project and deploy it onto a personal device.\n-- This does not submit the artefacts to any app stores, or anything like that. It is\n-- primarily useful for testing, or individual use of an Obelisk project.\ndeployMobile\n  :: forall m. MonadObelisk m\n  => PlatformDeployment\n  -- ^ Which mobile artefact to deploy; e.g. Android or iOS\n  -> [String]\n  -- ^ Extra arguments to pass to the executable that actually loads\n  -- the artefact onto the testing device. An example is the Team ID\n  -- associated with an Apple developer account.\n  -> m ()\ndeployMobile platform mobileArgs = withProjectRoot \".\" $ \\root -> do\n  let srcDir = root </> \"src\"\n      configDir = root </> \"config\"\n  exists <- liftIO $ doesDirectoryExist srcDir\n  unless exists $ failWith \"ob test should be run inside of a deploy directory\"\n  (nixBuildTarget, extraArgs) <- case platform of\n    Android -> do\n      let keystorePath = root </> \"android_keystore.jks\"\n          keytoolConfPath = root </> \"android_keytool_config.json\"\n      hasKeystore <- liftIO $ doesFileExist keystorePath\n      when (not hasKeystore) $ do\n        -- TODO log instructions for how to modify the keystore\n        putLog Notice $ \"Creating keystore: \" <> T.pack keystorePath\n        putLog Notice \"Enter a keystore password: \"\n        keyStorePassword <- liftIO $ withEcho False getLine\n        putLog Notice \"Re-enter the keystore password: \"\n        keyStorePassword' <- liftIO $ withEcho False getLine\n        unless (keyStorePassword' == keyStorePassword) $ failWith \"passwords do not match\"\n        let keyToolConf = KeytoolConfig\n              { _keytoolConfig_keystore = keystorePath\n              , _keytoolConfig_alias = \"obelisk\"\n              , _keytoolConfig_storepass = keyStorePassword\n              , _keytoolConfig_keypass = keyStorePassword\n              }\n        createKeystore root keyToolConf\n        liftIO $ BSL.writeFile keytoolConfPath $ encode keyToolConf\n      checkKeytoolConfExist <- liftIO $ doesFileExist keytoolConfPath\n      unless checkKeytoolConfExist $ failWith \"Missing android KeytoolConfig\"\n      keytoolConfContents <- liftIO $ BSL.readFile keytoolConfPath\n      keyArgs <- case eitherDecode keytoolConfContents :: Either String KeytoolConfig of\n        Left err -> failWith $ T.pack err\n        Right conf -> pure\n          [ \"--sign\"\n          , \"--store-file\", _keytoolConfig_keystore conf\n          , \"--store-password\", _keytoolConfig_storepass conf\n          , \"--key-alias\", _keytoolConfig_alias conf\n          , \"--key-password\", _keytoolConfig_keypass conf\n          ]\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"android.frontend.override (drv: {\"\n            , \"isRelease = true;\"\n            , \"staticSrc = (passthru.__androidWithConfig \", configDir, \").frontend.staticSrc;\"\n            , \"assets = (passthru.__androidWithConfig \", configDir, \").frontend.assets;\"\n            , \"})\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, keyArgs)\n    IOS -> do\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"ios.frontend.override (_: { staticSrc = (passthru.__iosWithConfig \", toNixPath configDir, \").frontend.staticSrc; })\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, [])\n  result <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ nixBuildTarget\n  let mobileArtifact = case platform of\n                         IOS -> \"iOS App\"\n                         Android -> \"Android APK\"\n  putLog Notice $ T.pack $ unwords [\"Your recently built\", mobileArtifact, \"can be found at the following path:\", show result]\n  callProcessAndLogOutput (Notice, Error) $ proc (result </> \"bin\" </> \"deploy\") (mobileArgs ++ extraArgs)\n  where\n    withEcho showEcho f = bracket\n      (do\n        prevEcho <- hGetEcho stdin\n        hSetEcho stdin showEcho\n        pure prevEcho\n      )\n      (hSetEcho stdin)\n      (const f)\n\n-- | obelisk uses keytool, a certificate and keypair management tool that comes with Java,\n-- to manage the cryptographic assets needed to deploy to an Android device.\ndata KeytoolConfig = KeytoolConfig\n  { _keytoolConfig_keystore :: FilePath\n  -- ^ Where is the keystore that keytool should create keypairs?\n  , _keytoolConfig_alias :: String\n  -- ^ Name of the entry in the keystore to process\n  , _keytoolConfig_storepass :: String\n  -- ^ Password for the keystore\n  , _keytoolConfig_keypass :: String\n  -- ^ Password for the keypair under consideration\n  } deriving (Show, Generic)\n\ninstance FromJSON KeytoolConfig\ninstance ToJSON KeytoolConfig\n\n-- | Creates a keystore, and a keypair in that keystore.\ncreateKeystore :: MonadObelisk m => FilePath -> KeytoolConfig -> m ()\ncreateKeystore root config =\n  callProcessAndLogOutput (Notice, Notice) $ setCwd (Just root) $ proc jreKeyToolPath\n    [ \"-genkeypair\", \"-noprompt\"\n    , \"-keystore\", _keytoolConfig_keystore config\n    , \"-keyalg\", \"RSA\", \"-keysize\", \"2048\"\n    , \"-validity\", \"1000000\"\n    , \"-storepass\", _keytoolConfig_storepass config\n    , \"-alias\", _keytoolConfig_alias config\n    , \"-keypass\", _keytoolConfig_keypass config\n    ]\n\n-- | Simplified deployment configuration mechanism. At one point we may revisit this.\nwriteDeployConfig :: MonadObelisk m => FilePath -> FilePath -> String -> m ()\nwriteDeployConfig deployDir fname = liftIO . writeFile (deployDir </> fname)\n\n-- | Read the deployment config file from a deployment staging directory.\nreadDeployConfig\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Deployment staging directory\n  -> FilePath\n  -- ^ The path to the config file relative to the staging directory.\n  -> m String\nreadDeployConfig deployDir fname = liftIO $ do\n  fmap (T.unpack . T.strip) $ T.readFile $ deployDir </> fname\n\n-- | Lookup known hosts using ssh-keygen command\nlookupKnownHosts :: MonadObelisk m\n                 => String\n                 -- ^ the host name\n                 -> m [BS.ByteString]\n                 -- ^ obtained hosts\nlookupKnownHosts hostName =\n  fmap filterComments $ readCreateProcessWithExitCode $ proc $(staticWhichNix \"ssh-keygen\") [\"-F\", hostName]\n   where\n     filterComments (exitCode, out, _) =\n       if exitCode /= ExitSuccess || null out\n         then []\n         else\n           -- ssh-keygen prints the following above each result it finds: \"# Host <hostname> found: line <lineno>\"\n           filter (not . C.isPrefixOf \"# Host\") $ C.lines $ C.pack out\n\n-- | insert a host/pair in backend_known_hosts file\naddKnownHostFromEnv :: MonadObelisk m\n                    => String\n                    -- ^ hostname\n                    -> FilePath\n                    -- ^ path to backend_known_hosts file\n                    -> m ()\naddKnownHostFromEnv hostName obKnownHostsPath = do\n  lookupKnownHosts hostName >>= \\res -> case res of\n    [knownKey] -> liftIO $ BS.appendFile obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    [] -> putLog Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog Notice \"Found more than one matching host/key pair in user's known_hosts\"\n\n-- | Verify the identity of a remote host that we would like to deploy to.\nverifyHostKey\n  :: MonadObelisk m\n  => FilePath\n  -- ^ known_hosts file to use for hosts that have already been verified.\n  -> FilePath\n  -- ^ Path to the ssh key used to connect to the host\n  -> String\n  -- ^ Name of the host\n  -> m ()\nverifyHostKey knownHostsPath keyPath hostName =\n  callProcessAndLogOutput (Notice, Warning) $ proc sshPath $\n    sshArgs knownHostsPath keyPath True <>\n      [ \"root@\" <> hostName\n      , \"-o\", \"NumberOfPasswordPrompts=0\"\n      , \"exit\"\n      ]\n\n-- | Create arguments to pass to ssh on the command line\nsshArgs\n  :: FilePath\n  -- ^ Path to known_hosts file\n  -> FilePath\n  -- ^ Path to the ssh key to use\n  -> Bool\n  -- ^ If true, then prompt the user when a host is not in the known_hosts file,\n  -- otherwise use strict host checking.\n  -> [String]\nsshArgs knownHostsPath keyPath askHostKeyCheck =\n  [ \"-o\", \"UserKnownHostsFile=\" <> knownHostsPath\n  , \"-o\", \"StrictHostKeyChecking=\" <> if askHostKeyCheck then \"ask\" else \"yes\"\n  , \"-i\", keyPath\n  ]\n\n-- common/route validation\n-- TODO: move these to executable-config once the typed-config stuff is done.\n\n-- | Ways in which the route configured for a deployment host can be invalid\ndata InvalidRoute\n  = InvalidRoute_NotHttps URI\n  -- ^ We do not deploy non-https routes unless explicitly asked for\n  | InvalidRoute_MissingScheme URI\n  -- ^ We demand a URI scheme\n  | InvalidRoute_MissingHost URI\n  -- ^ We demand a hostname\n  | InvalidRoute_HasPort URI\n  -- ^ We do not deploy to a route with a particular port number\n  | InvalidRoute_HasPath URI\n  -- ^ We do not deploy to a route that is served at a particular path\n  deriving Show\n\ninstance Exception InvalidRoute where\n  displayException = \\case\n    InvalidRoute_MissingScheme uri -> route uri \"must have an URI scheme\"\n    InvalidRoute_NotHttps uri -> route uri \"must be HTTPS\"\n    InvalidRoute_MissingHost uri -> route uri \"must contain a hostname\"\n    InvalidRoute_HasPort uri -> route uri \"cannot specify port\"\n    InvalidRoute_HasPath uri -> route uri \"cannot contain path\"\n    where\n      route uri err = T.unpack $ \"Route (\" <> URI.render uri <> \") \" <> err\n\n-- | Get the hostname from a https route\n--\n-- Fail if the route is invalid (i.e, no host present or scheme is not https)\ngetHostFromRoute\n  :: MonadObelisk m\n  => Bool  -- ^ Ensure https?\n  -> String\n  -> m String\ngetHostFromRoute mustBeHttps route = do\n  result :: Either InvalidRoute String <- try $ do\n    validateCommonRouteAndGetHost mustBeHttps =<< URI.mkURI (T.strip $ T.pack route)\n  either (failWith . T.pack . displayException) pure result\n\n-- | When deploying, we ensure that the route we are deploying for makes sense.\n-- In particular, we extract the hostname that we are deploying to from the\n-- route.\nvalidateCommonRouteAndGetHost\n  :: (MonadThrow m, MonadObelisk m)\n  => Bool\n  -- ^ If true, demand that the route we are deploying is an HTTPS route\n  -> URI\n  -- ^ The route to validate\n  -> m String\nvalidateCommonRouteAndGetHost mustBeHttps uri = do\n  case uri ^? uriScheme of\n    Just (Just (URI.unRText -> s)) -> case (mustBeHttps, s) of\n      (False, _) -> pure ()\n      (True, \"https\") -> pure ()\n      _ -> throwM $ InvalidRoute_NotHttps uri\n    _ -> throwM $ InvalidRoute_MissingScheme uri\n  case uri ^. uriPath of\n    [] -> pure ()\n    _path -> throwM $ InvalidRoute_HasPath uri\n  case uri ^? uriAuthority . _Right . authPort of\n    Just (Just _port) -> throwM $ InvalidRoute_HasPort uri\n    _ -> pure ()\n  case uri ^? uriAuthority . _Right . authHost of\n    Nothing -> throwM $ InvalidRoute_MissingHost uri\n    Just sslHost -> return $ T.unpack $ URI.unRText sslHost\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs:(443,33)-(446,89)",
                  "suggestion_title": "Use lambda-case",
                  "found_block": [
                    "  \\ res",
                    "    -> case res of",
                    "         [knownKey]",
                    "           -> liftIO",
                    "                $ BS.appendFile",
                    "                    obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')",
                    "         []",
                    "           -> putLog",
                    "                Notice \"Found no matching hosts in user's known_hosts file\"",
                    "         _ -> putLog",
                    "                Notice",
                    "                \"Found more than one matching host/key pair in user's known_hosts\""
                  ],
                  "perhaps_block": [
                    "  \\case",
                    "    [knownKey]",
                    "      -> liftIO",
                    "           $ BS.appendFile",
                    "               obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')",
                    "    []",
                    "      -> putLog",
                    "           Notice \"Found no matching hosts in user's known_hosts file\"",
                    "    _ -> putLog",
                    "           Notice",
                    "           \"Found more than one matching host/key pair in user's known_hosts\""
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE ViewPatterns #-}\n{-|\n   Description:\n   Implementation of the CLI deploy commands. Deployment is done by intializing\n   a staging area for deployment configuration, and then by actually executing\n   the deployment by installing a NixOS configuration at the configured deployment\n   locations.\n-}\nmodule Obelisk.Command.Deploy where\n\nimport Control.Applicative (liftA2)\nimport Control.Lens\nimport Control.Monad\nimport Control.Monad.Catch (Exception (displayException), MonadThrow, bracket, throwM, try)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Aeson (FromJSON, ToJSON, encode, eitherDecode)\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport GHC.Generics\nimport System.Directory\nimport System.Exit (ExitCode(ExitSuccess))\nimport System.FilePath\nimport System.IO\nimport System.Which\nimport System.PosixCompat.Files\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Nix.Pretty (prettyNix)\nimport qualified Nix.Expr.Shorthands as Nix\nimport Prettyprinter (layoutCompact)\nimport Prettyprinter.Render.String (renderString)\n\nimport Obelisk.App (MonadObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils\n\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n-- | Options passed to the `init` verb\ndata DeployInitOpts = DeployInitOpts\n  { _deployInitOpts_outputDir :: FilePath\n  -- ^ Where to set up the deployment staging area\n  , _deployInitOpts_sshKey :: FilePath\n  -- ^ Which SSH Key will be used to interface with the deployment hosts\n  , _deployInitOpts_hostname :: [String]\n  -- ^ The hostnames that locate the deployment hosts\n  , _deployInitOpts_route :: String\n  -- ^ The route they are serving\n  , _deployInitOpts_adminEmail :: String\n  -- ^ The administrator email, for ACME\n  , _deployInitOpts_enableHttps :: Bool\n  -- ^ Whether or not to use HTTPS, which entails using Lets Encrypt by default\n  , _deployInitOpts_checkKnownHosts :: Bool\n  -- ^ Whether or not to use known_hosts file when assessing the identity of the deployment hosts\n  } deriving Show\n\n-- | The `init` verb\ndeployInit\n  :: MonadObelisk m\n  => DeployInitOpts\n  -- ^ Command line arguments\n  -> FilePath\n  -- ^ Project root, which cannot be the same as the deployment dir\n  -> m ()\ndeployInit deployOpts root = do\n  let deployDir = _deployInitOpts_outputDir deployOpts\n  rootEqualsTarget <- liftIO $ liftA2 equalFilePath (canonicalizePath root) (canonicalizePath deployDir)\n  when rootEqualsTarget $\n    failWith [i|Deploy directory ${deployDir} should not be the same as project root.|]\n  thunkPtr <- wrapNixThunkError (readThunk root) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    _ -> wrapNixThunkError (getThunkPtr CheckClean_NotIgnored root Nothing)\n  deployInit' thunkPtr deployOpts\n\n-- | The preamble in 'deployInit' provides deployInit' with a 'ThunkPtr' that it can install in\n-- the staging directory.\ndeployInit'\n  :: MonadObelisk m\n  => ThunkPtr\n  -> DeployInitOpts\n  -> m ()\ndeployInit' thunkPtr (DeployInitOpts deployDir sshKeyPath hostnames route adminEmail enableHttps checkKnownHosts) = do\n  liftIO $ createDirectoryIfMissing True deployDir\n  localKey <- withSpinner (\"Preparing \" <> T.pack deployDir) $ do\n    localKey <- liftIO (doesFileExist sshKeyPath) >>= \\case\n      False -> failWith $ T.pack $ \"ob deploy init: file does not exist: \" <> sshKeyPath\n      True -> pure $ deployDir </> \"ssh_key\"\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp [sshKeyPath, localKey]\n    liftIO $ setFileMode localKey $ ownerReadMode .|. ownerWriteMode\n    return localKey\n  withSpinner \"Validating configuration\" $ do\n    void $ getHostFromRoute enableHttps route -- make sure that hostname is present\n  let obKnownHostsPath = deployDir </> \"backend_known_hosts\"\n  forM_ hostnames $ \\hostname -> do\n    putLog Notice $ \"Verifying host keys (\" <> T.pack hostname <> \")\"\n    -- Note: we can't use a spinner here as this function will prompt the user.\n    when checkKnownHosts $ addKnownHostFromEnv hostname obKnownHostsPath\n    verifyHostKey obKnownHostsPath localKey hostname\n  --IMPORTANT: We cannot copy config directory from the development project to\n  --the deployment directory.  If we do, it's very likely someone will\n  --accidentally create a production deployment that uses development\n  --credentials to connect to some resources.  This could result in, e.g.,\n  --production data backed up to a dev environment.\n  withSpinner \"Creating project configuration directories\" $ liftIO $ do\n    mapM_ (createDirectoryIfMissing True)\n      [ deployDir </> \"config\" </> \"backend\"\n      , deployDir </> \"config\" </> \"common\"\n      , deployDir </> \"config\" </> \"frontend\"\n      ]\n\n  let srcDir = deployDir </> \"src\"\n  withSpinner (\"Creating source thunk (\" <> T.pack (makeRelative deployDir srcDir) <> \")\") $ do\n    wrapNixThunkError . createThunk srcDir $ Right thunkPtr\n    setupObeliskImpl deployDir\n\n  withSpinner \"Writing deployment configuration\" $ do\n    writeDeployConfig deployDir \"backend_hosts\" $ unlines hostnames\n    writeDeployConfig deployDir \"enable_https\" $ show enableHttps\n    writeDeployConfig deployDir \"admin_email\" adminEmail\n    writeDeployConfig deployDir (\"config\" </> \"common\" </> \"route\") route\n    writeDeployConfig deployDir \"module.nix\" $\n      \"(import \" <> toNixPath (makeRelative deployDir srcDir) <> \" {}).obelisk.serverModules.mkBaseEc2\"\n\n  withSpinner (\"Initializing git repository (\" <> T.pack deployDir <> \")\") $\n    initGit deployDir\n\n-- | Installs an obelisk impl in the staging dir that points at the obelisk of the\n-- project thunk.\nsetupObeliskImpl :: MonadIO m => FilePath -> m ()\nsetupObeliskImpl deployDir = liftIO $ do\n  let\n    implDir = toImplDir deployDir\n    goBackUp = foldr (</>) \"\" $ (\"..\" <$) $ splitPath $ makeRelative deployDir implDir\n  createDirectoryIfMissing True implDir\n  writeFile (implDir </> \"default.nix\") $ \"(import \" <> toNixPath (goBackUp </> \"src\") <> \" {}).obelisk\"\n\n-- | Executes the deployment specified in the supplied staging dir\ndeployPush\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Path to the staging directory\n  -> [String]\n  -- ^ nix builders arg string for the nix-build that builds the deployment artefacts\n  -> m ()\ndeployPush deployPath builders = do\n  hosts <- Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"backend_hosts\"\n  adminEmail <- readDeployConfig deployPath \"admin_email\"\n  enableHttps <- read <$> readDeployConfig deployPath \"enable_https\"\n  route <- readDeployConfig deployPath $ \"config\" </> \"common\" </> \"route\"\n  routeHost <- getHostFromRoute enableHttps route\n  redirectHosts <- liftIO (doesFileExist \"redirect_hosts\") >>= \\case\n    True -> Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"redirect_hosts\"\n    False -> pure mempty\n  let srcPath = deployPath </> \"src\"\n  thunkPtr <- wrapNixThunkError (readThunk srcPath) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    Right ThunkData_Checkout -> do\n      checkGitCleanStatus srcPath True >>= \\case\n        True -> wrapNixThunkError $ packThunk (ThunkPackConfig False (ThunkConfig Nothing)) srcPath\n        False -> failWith $ T.pack $ \"ob deploy push: ensure \" <> srcPath <> \" has no pending changes and latest is pushed upstream.\"\n    Left err -> failWith $ \"ob deploy push: couldn't read src thunk: \" <> T.pack (show err)\n  let version = show . _thunkRev_commit $ _thunkPtr_rev thunkPtr\n  let moduleFile = deployPath </> \"module.nix\"\n  moduleFileExists <- liftIO $ doesFileExist moduleFile\n\n  configHash <- getGitHash deployPath \"config\"\n  buildOutputByHost <- ifor (Map.fromSet (const ()) hosts) $ \\host () -> do\n    --TODO: What does it mean if this returns more or less than 1 line of output?\n    [result] <- fmap lines $ nixCmd $ NixCmd_Build $ def\n      & nixCmdConfig_target .~ Target\n        { _target_path = Just srcPath\n        , _target_attr = Just \"server.system\"\n        , _target_expr = Nothing\n        }\n      & nixBuildConfig_outLink .~ OutLink_None\n      & nixCmdConfig_args .~ (\n        [ strArg \"hostName\" $ fmap (\\c -> if c == '.' then '_' else c) host\n        , strArg \"adminEmail\" adminEmail\n        , strArg \"routeHost\" routeHost\n        , rawArg \"redirectHosts\" $ renderString $ layoutCompact $ prettyNix $ Nix.mkList $ Nix.mkStr . T.pack <$> Set.toList redirectHosts\n        , strArg \"version\" version\n        , boolArg \"enableHttps\" enableHttps\n        , strArg \"configHash\" $ T.unpack $ T.strip (_gitHash_text configHash)\n        ] <> [rawArg \"module\" (\"import \" <> toNixPath moduleFile) | moduleFileExists ])\n      & nixCmdConfig_builders .~ builders\n    pure result\n  let knownHostsPath = deployPath </> \"backend_known_hosts\"\n      sshOpts = sshArgs knownHostsPath (deployPath </> \"ssh_key\") False\n  withSpinner \"Uploading closures\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcess'\n      (Map.fromList [(\"NIX_SSHOPTS\", unwords sshOpts)])\n      \"nix-copy-closure\" [\"-v\", \"--to\", \"--use-substitutes\", \"root@\" <> host, \"--gzip\", outputPath]\n  withSpinner \"Uploading config\" $ ifor_ buildOutputByHost $ \\host _ -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc rsyncPath\n        [ \"-e \" <> sshPath <> \" \" <> unwords sshOpts\n        , \"--chown=backend:backend\"\n        , \"-qarvz\"\n        , deployPath </> \"config\"\n        , \"root@\" <> host <> \":/var/lib/backend\"\n        ]\n  --TODO: Create GC root so we're sure our closure won't go away during this time period\n  withSpinner \"Switching to new configuration\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc sshPath $ sshOpts <>\n        [ \"root@\" <> host\n        , unwords\n            [ \"bash -c\"\n            , bashEscape (deployActivationScript outputPath)\n            ]\n        ]\n  isClean <- checkGitCleanStatus deployPath True\n  unless isClean $ do\n    withSpinner \"Committing changes to Git\" $ do\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"add\", \".\"]\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"commit\", \"-m\", \"New deployment\"]\n  putLog Notice $ \"Deployed => \" <> T.pack route\n  where\n    callProcess' envMap cmd args = do\n      let p = setEnvOverride (envMap <>) $ setDelegateCtlc True $ proc cmd args\n      callProcessAndLogOutput (Notice, Notice) p\n\n-- | Bash command that will be run on the deployed machine to actually switch the NixOS configuration\n-- This has some more involved logic than merely activating the right profile. It also determines\n-- whether the kernel parameters have changed so that the deployed NixOS instance should be restarted.\ndeployActivationScript\n  :: String\n  -- ^ The out path of the configuration to activate\n  -> String\ndeployActivationScript outPath =\n-- Note that we don't want to $(staticWhich \"nix-env\") here, because this is executing on a remote machine\n-- This logic follows the nixos auto-upgrade module as of writing.\n-- If the workflow is added to switch-to-configuration proper, we can simplify this:\n-- https://github.com/obsidiansystems/obelisk/issues/958\n  [i|set -euxo pipefail\nnix-env -p /nix/var/nix/profiles/system --set \"${bashEscape outPath}\"\n/nix/var/nix/profiles/system/bin/switch-to-configuration boot\nbooted=\"$(readlink /run/booted-system/{initrd,kernel,kernel-modules})\"\nbuilt=\"$(readlink /nix/var/nix/profiles/system/{initrd,kernel,kernel-modules})\"\nif [ \"$booted\" = \"$built\" ]; then\n  /nix/var/nix/profiles/system/bin/switch-to-configuration switch\nelse\n  /run/current-system/sw/bin/shutdown -r +1\nfi\n|]\n\n-- | Update the source thunk in the staging directory to the HEAD of the branch.\ndeployUpdate :: MonadObelisk m => FilePath -> m ()\ndeployUpdate deployPath = wrapNixThunkError $\n  updateThunkToLatest (ThunkUpdateConfig Nothing (ThunkConfig Nothing)) (deployPath </> \"src\")\n\n-- | Platforms that we deploy obelisk artefacts to.\ndata PlatformDeployment = Android | IOS\n  deriving (Show, Eq)\n\n-- | Pretty print PlatformDeployment\nrenderPlatformDeployment :: PlatformDeployment -> String\nrenderPlatformDeployment = \\case\n  Android -> \"android\"\n  IOS -> \"ios\"\n\n-- | Produce the mobile app for an Obelisk project and deploy it onto a personal device.\n-- This does not submit the artefacts to any app stores, or anything like that. It is\n-- primarily useful for testing, or individual use of an Obelisk project.\ndeployMobile\n  :: forall m. MonadObelisk m\n  => PlatformDeployment\n  -- ^ Which mobile artefact to deploy; e.g. Android or iOS\n  -> [String]\n  -- ^ Extra arguments to pass to the executable that actually loads\n  -- the artefact onto the testing device. An example is the Team ID\n  -- associated with an Apple developer account.\n  -> m ()\ndeployMobile platform mobileArgs = withProjectRoot \".\" $ \\root -> do\n  let srcDir = root </> \"src\"\n      configDir = root </> \"config\"\n  exists <- liftIO $ doesDirectoryExist srcDir\n  unless exists $ failWith \"ob test should be run inside of a deploy directory\"\n  (nixBuildTarget, extraArgs) <- case platform of\n    Android -> do\n      let keystorePath = root </> \"android_keystore.jks\"\n          keytoolConfPath = root </> \"android_keytool_config.json\"\n      hasKeystore <- liftIO $ doesFileExist keystorePath\n      unless hasKeystore $ do\n        -- TODO log instructions for how to modify the keystore\n        putLog Notice $ \"Creating keystore: \" <> T.pack keystorePath\n        putLog Notice \"Enter a keystore password: \"\n        keyStorePassword <- liftIO $ withEcho False getLine\n        putLog Notice \"Re-enter the keystore password: \"\n        keyStorePassword' <- liftIO $ withEcho False getLine\n        unless (keyStorePassword' == keyStorePassword) $ failWith \"passwords do not match\"\n        let keyToolConf = KeytoolConfig\n              { _keytoolConfig_keystore = keystorePath\n              , _keytoolConfig_alias = \"obelisk\"\n              , _keytoolConfig_storepass = keyStorePassword\n              , _keytoolConfig_keypass = keyStorePassword\n              }\n        createKeystore root keyToolConf\n        liftIO $ BSL.writeFile keytoolConfPath $ encode keyToolConf\n      checkKeytoolConfExist <- liftIO $ doesFileExist keytoolConfPath\n      unless checkKeytoolConfExist $ failWith \"Missing android KeytoolConfig\"\n      keytoolConfContents <- liftIO $ BSL.readFile keytoolConfPath\n      keyArgs <- case eitherDecode keytoolConfContents :: Either String KeytoolConfig of\n        Left err -> failWith $ T.pack err\n        Right conf -> pure\n          [ \"--sign\"\n          , \"--store-file\", _keytoolConfig_keystore conf\n          , \"--store-password\", _keytoolConfig_storepass conf\n          , \"--key-alias\", _keytoolConfig_alias conf\n          , \"--key-password\", _keytoolConfig_keypass conf\n          ]\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"android.frontend.override (drv: {\"\n            , \"isRelease = true;\"\n            , \"staticSrc = (passthru.__androidWithConfig \", configDir, \").frontend.staticSrc;\"\n            , \"assets = (passthru.__androidWithConfig \", configDir, \").frontend.assets;\"\n            , \"})\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, keyArgs)\n    IOS -> do\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"ios.frontend.override (_: { staticSrc = (passthru.__iosWithConfig \", toNixPath configDir, \").frontend.staticSrc; })\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, [])\n  result <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ nixBuildTarget\n  let mobileArtifact = case platform of\n                         IOS -> \"iOS App\"\n                         Android -> \"Android APK\"\n  putLog Notice $ T.pack $ unwords [\"Your recently built\", mobileArtifact, \"can be found at the following path:\", show result]\n  callProcessAndLogOutput (Notice, Error) $ proc (result </> \"bin\" </> \"deploy\") (mobileArgs ++ extraArgs)\n  where\n    withEcho showEcho f = bracket\n      (do\n        prevEcho <- hGetEcho stdin\n        hSetEcho stdin showEcho\n        pure prevEcho\n      )\n      (hSetEcho stdin)\n      (const f)\n\n-- | obelisk uses keytool, a certificate and keypair management tool that comes with Java,\n-- to manage the cryptographic assets needed to deploy to an Android device.\ndata KeytoolConfig = KeytoolConfig\n  { _keytoolConfig_keystore :: FilePath\n  -- ^ Where is the keystore that keytool should create keypairs?\n  , _keytoolConfig_alias :: String\n  -- ^ Name of the entry in the keystore to process\n  , _keytoolConfig_storepass :: String\n  -- ^ Password for the keystore\n  , _keytoolConfig_keypass :: String\n  -- ^ Password for the keypair under consideration\n  } deriving (Show, Generic)\n\ninstance FromJSON KeytoolConfig\ninstance ToJSON KeytoolConfig\n\n-- | Creates a keystore, and a keypair in that keystore.\ncreateKeystore :: MonadObelisk m => FilePath -> KeytoolConfig -> m ()\ncreateKeystore root config =\n  callProcessAndLogOutput (Notice, Notice) $ setCwd (Just root) $ proc jreKeyToolPath\n    [ \"-genkeypair\", \"-noprompt\"\n    , \"-keystore\", _keytoolConfig_keystore config\n    , \"-keyalg\", \"RSA\", \"-keysize\", \"2048\"\n    , \"-validity\", \"1000000\"\n    , \"-storepass\", _keytoolConfig_storepass config\n    , \"-alias\", _keytoolConfig_alias config\n    , \"-keypass\", _keytoolConfig_keypass config\n    ]\n\n-- | Simplified deployment configuration mechanism. At one point we may revisit this.\nwriteDeployConfig :: MonadObelisk m => FilePath -> FilePath -> String -> m ()\nwriteDeployConfig deployDir fname = liftIO . writeFile (deployDir </> fname)\n\n-- | Read the deployment config file from a deployment staging directory.\nreadDeployConfig\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Deployment staging directory\n  -> FilePath\n  -- ^ The path to the config file relative to the staging directory.\n  -> m String\nreadDeployConfig deployDir fname = liftIO $ do\n  fmap (T.unpack . T.strip) $ T.readFile $ deployDir </> fname\n\n-- | Lookup known hosts using ssh-keygen command\nlookupKnownHosts :: MonadObelisk m\n                 => String\n                 -- ^ the host name\n                 -> m [BS.ByteString]\n                 -- ^ obtained hosts\nlookupKnownHosts hostName =\n  fmap filterComments $ readCreateProcessWithExitCode $ proc $(staticWhichNix \"ssh-keygen\") [\"-F\", hostName]\n   where\n     filterComments (exitCode, out, _) =\n       if exitCode /= ExitSuccess || null out\n         then []\n         else\n           -- ssh-keygen prints the following above each result it finds: \"# Host <hostname> found: line <lineno>\"\n           filter (not . C.isPrefixOf \"# Host\") $ C.lines $ C.pack out\n\n-- | insert a host/pair in backend_known_hosts file\naddKnownHostFromEnv :: MonadObelisk m\n                    => String\n                    -- ^ hostname\n                    -> FilePath\n                    -- ^ path to backend_known_hosts file\n                    -> m ()\naddKnownHostFromEnv hostName obKnownHostsPath = do\n  lookupKnownHosts hostName >>= \\res -> case res of\n    [knownKey] -> liftIO $ BS.appendFile obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    [] -> putLog Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog Notice \"Found more than one matching host/key pair in user's known_hosts\"\n\n-- | Verify the identity of a remote host that we would like to deploy to.\nverifyHostKey\n  :: MonadObelisk m\n  => FilePath\n  -- ^ known_hosts file to use for hosts that have already been verified.\n  -> FilePath\n  -- ^ Path to the ssh key used to connect to the host\n  -> String\n  -- ^ Name of the host\n  -> m ()\nverifyHostKey knownHostsPath keyPath hostName =\n  callProcessAndLogOutput (Notice, Warning) $ proc sshPath $\n    sshArgs knownHostsPath keyPath True <>\n      [ \"root@\" <> hostName\n      , \"-o\", \"NumberOfPasswordPrompts=0\"\n      , \"exit\"\n      ]\n\n-- | Create arguments to pass to ssh on the command line\nsshArgs\n  :: FilePath\n  -- ^ Path to known_hosts file\n  -> FilePath\n  -- ^ Path to the ssh key to use\n  -> Bool\n  -- ^ If true, then prompt the user when a host is not in the known_hosts file,\n  -- otherwise use strict host checking.\n  -> [String]\nsshArgs knownHostsPath keyPath askHostKeyCheck =\n  [ \"-o\", \"UserKnownHostsFile=\" <> knownHostsPath\n  , \"-o\", \"StrictHostKeyChecking=\" <> if askHostKeyCheck then \"ask\" else \"yes\"\n  , \"-i\", keyPath\n  ]\n\n-- common/route validation\n-- TODO: move these to executable-config once the typed-config stuff is done.\n\n-- | Ways in which the route configured for a deployment host can be invalid\ndata InvalidRoute\n  = InvalidRoute_NotHttps URI\n  -- ^ We do not deploy non-https routes unless explicitly asked for\n  | InvalidRoute_MissingScheme URI\n  -- ^ We demand a URI scheme\n  | InvalidRoute_MissingHost URI\n  -- ^ We demand a hostname\n  | InvalidRoute_HasPort URI\n  -- ^ We do not deploy to a route with a particular port number\n  | InvalidRoute_HasPath URI\n  -- ^ We do not deploy to a route that is served at a particular path\n  deriving Show\n\ninstance Exception InvalidRoute where\n  displayException = \\case\n    InvalidRoute_MissingScheme uri -> route uri \"must have an URI scheme\"\n    InvalidRoute_NotHttps uri -> route uri \"must be HTTPS\"\n    InvalidRoute_MissingHost uri -> route uri \"must contain a hostname\"\n    InvalidRoute_HasPort uri -> route uri \"cannot specify port\"\n    InvalidRoute_HasPath uri -> route uri \"cannot contain path\"\n    where\n      route uri err = T.unpack $ \"Route (\" <> URI.render uri <> \") \" <> err\n\n-- | Get the hostname from a https route\n--\n-- Fail if the route is invalid (i.e, no host present or scheme is not https)\ngetHostFromRoute\n  :: MonadObelisk m\n  => Bool  -- ^ Ensure https?\n  -> String\n  -> m String\ngetHostFromRoute mustBeHttps route = do\n  result :: Either InvalidRoute String <- try $ do\n    validateCommonRouteAndGetHost mustBeHttps =<< URI.mkURI (T.strip $ T.pack route)\n  either (failWith . T.pack . displayException) pure result\n\n-- | When deploying, we ensure that the route we are deploying for makes sense.\n-- In particular, we extract the hostname that we are deploying to from the\n-- route.\nvalidateCommonRouteAndGetHost\n  :: (MonadThrow m, MonadObelisk m)\n  => Bool\n  -- ^ If true, demand that the route we are deploying is an HTTPS route\n  -> URI\n  -- ^ The route to validate\n  -> m String\nvalidateCommonRouteAndGetHost mustBeHttps uri = do\n  case uri ^? uriScheme of\n    Just (Just (URI.unRText -> s)) -> case (mustBeHttps, s) of\n      (False, _) -> pure ()\n      (True, \"https\") -> pure ()\n      _ -> throwM $ InvalidRoute_NotHttps uri\n    _ -> throwM $ InvalidRoute_MissingScheme uri\n  case uri ^. uriPath of\n    [] -> pure ()\n    _path -> throwM $ InvalidRoute_HasPath uri\n  case uri ^? uriAuthority . _Right . authPort of\n    Just (Just _port) -> throwM $ InvalidRoute_HasPort uri\n    _ -> pure ()\n  case uri ^? uriAuthority . _Right . authHost of\n    Nothing -> throwM $ InvalidRoute_MissingHost uri\n    Just sslHost -> return $ T.unpack $ URI.unRText sslHost\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Nix.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 8,
                "average": 4,
                "sum": 42
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 3,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 5,
              "lines_of_code": 224,
              "homplexity_lines_of_code": 189,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 8,
                  "average": 4,
                  "sum": 42
                },
                "homplexity_loc": 189,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"strArg\": 1,\n        \"rawArg\": 1,\n        \"boolArg\": 1,\n        \"cliFromArgs\": 3,\n        \"runNixCommonConfig\": 8,\n        \"runNixBuildConfig\": 4,\n        \"runNixInstantiateConfig\": 4,\n        \"runNixShellConfig\": 5,\n        \"nixCmdProc\": 1,\n        \"nixCmdProc'\": 6,\n        \"nixCmd\": 7,\n        \"min\": 1,\n        \"max\": 8,\n        \"average\": 3.8181818181818183,\n        \"sum\": 42\n    },\n    \"homplexity_loc\": 189,\n    \"homplexity_output\": \"Analyzed successfully\"\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Obelisk.Command.Nix\n  ( Arg (..)\n  , NixBuildConfig (..)\n  , nixBuildConfig_common\n  , nixBuildConfig_outLink\n  , NixCmd (..)\n  , nixCmdConfig_args\n  , nixCmdConfig_builders\n  , nixCmdConfig_target\n  , NixCommonConfig (..)\n  , NixInstantiateConfig (..)\n  , nixInstantiateConfig_eval\n  , NixShellConfig (..)\n  , nixShellConfig_common\n  , nixShellConfig_pure\n  , nixShellConfig_run\n  , OutLink (..)\n  , Target (..)\n  , target_attr\n  , target_expr\n  , target_path\n\n  , boolArg\n  , nixCmd\n  , nixCmdProc\n  , nixCmdProc'\n  , rawArg\n  , runNixShellConfig\n  , strArg\n  ) where\n\nimport Control.Monad (guard)\nimport Control.Lens\n\nimport Data.Bool (bool)\nimport Data.Default\nimport Data.List (intercalate)\nimport Data.Maybe\nimport Data.Monoid ((<>))\nimport qualified Data.Text as T\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\n-- | What to build\ndata Target = Target\n  { _target_path :: Maybe FilePath\n  , _target_attr :: Maybe String\n  , _target_expr :: Maybe String\n  }\nmakeClassy ''Target\n\ninstance Default Target where\n  def = Target\n    { _target_path = Just \".\"\n    , _target_attr = Nothing\n    , _target_expr = Nothing\n    }\n\ndata Arg\n  = Arg_Str String String\n  | Arg_Expr String String\n  deriving (Eq, Show)\n\nstrArg :: String -> String -> Arg\nstrArg = Arg_Str\n\nrawArg :: String -> String -> Arg\nrawArg = Arg_Expr\n\nboolArg :: String -> Bool -> Arg\nboolArg k = Arg_Expr k . bool \"false\" \"true\"\n\ncliFromArgs :: [Arg] -> [String]\ncliFromArgs = concatMap $ \\case\n  Arg_Str k v -> [\"--argstr\", k, v]\n  Arg_Expr k v -> [\"--arg\", k, v]\n\ndata NixCommonConfig = NixCommonConfig\n  { _nixCmdConfig_target :: Target\n  , _nixCmdConfig_args :: [Arg]\n  , _nixCmdConfig_builders :: [String]\n  }\nmakeClassy ''NixCommonConfig\n\ninstance Default NixCommonConfig where\n  def = NixCommonConfig def mempty mempty\n\nrunNixCommonConfig :: NixCommonConfig -> [String]\nrunNixCommonConfig cfg = mconcat [maybeToList path, attrArg, exprArg, args, buildersArg]\n  where\n    path = _target_path $ _nixCmdConfig_target cfg\n    attr = _target_attr $ _nixCmdConfig_target cfg\n    expr = _target_expr $ _nixCmdConfig_target cfg\n    attrArg = case attr of\n      Nothing -> []\n      Just a -> [\"-A\", a]\n    exprArg = case expr of\n      Nothing -> []\n      Just a -> [\"-E\", a]\n    args = cliFromArgs $ _nixCmdConfig_args cfg\n    buildersArg = case _nixCmdConfig_builders cfg of\n      [] -> []\n      builders -> [\"--builders\", intercalate \";\" builders]\n\n-- | Where to put nix-build output\ndata OutLink\n  = OutLink_Default\n  | OutLink_None\n  | OutLink_IndirectRoot FilePath\n\ninstance Default OutLink where\n  def = OutLink_Default\n\ndata NixBuildConfig = NixBuildConfig\n  { _nixBuildConfig_common :: NixCommonConfig\n  , _nixBuildConfig_outLink :: OutLink\n  }\nmakeLenses ''NixBuildConfig\n\ninstance HasNixCommonConfig NixBuildConfig where\n  nixCommonConfig = nixBuildConfig_common\n\ninstance Default NixBuildConfig where\n  def = NixBuildConfig def def\n\nrunNixBuildConfig :: NixBuildConfig -> [String]\nrunNixBuildConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , case _nixBuildConfig_outLink cfg of\n      OutLink_Default -> []\n      OutLink_None -> [\"--no-out-link\"]\n      OutLink_IndirectRoot l -> [\"--out-link\", l]\n  ]\n\ndata NixInstantiateConfig = NixInstantiateConfig\n  { _nixInstantiateConfig_common :: NixCommonConfig\n  , _nixInstantiateConfig_eval :: Bool\n  }\nmakeLenses ''NixInstantiateConfig\n\ninstance HasNixCommonConfig NixInstantiateConfig where\n  nixCommonConfig = nixInstantiateConfig_common\n\ninstance Default NixInstantiateConfig where\n  def = NixInstantiateConfig def False\n\nrunNixInstantiateConfig :: NixInstantiateConfig -> [String]\nrunNixInstantiateConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , \"--eval\" <$ guard (_nixInstantiateConfig_eval cfg)\n  ]\n\ndata NixShellConfig = NixShellConfig\n  { _nixShellConfig_common :: NixCommonConfig\n  , _nixShellConfig_pure :: Bool\n  , _nixShellConfig_run :: Maybe String\n  }\n\nmakeLenses ''NixShellConfig\n\ninstance HasNixCommonConfig NixShellConfig where\n  nixCommonConfig = nixShellConfig_common\n\ninstance Default NixShellConfig where\n  def = NixShellConfig def False Nothing\n\ndata NixCmd\n  = NixCmd_Build NixBuildConfig\n  | NixCmd_Instantiate NixInstantiateConfig\n\ninstance Default NixCmd where\n  def = NixCmd_Build def\n\nrunNixShellConfig :: NixShellConfig -> [String]\nrunNixShellConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , [ \"--pure\" | cfg ^. nixShellConfig_pure ]\n  ] ++ mconcat [\n    [\"--run\", run] | run <- maybeToList $ cfg ^. nixShellConfig_run\n  ]\n\nnixCmdProc :: NixCmd -> ProcessSpec\nnixCmdProc = fst . nixCmdProc'\n\nnixCmdProc' :: NixCmd -> (ProcessSpec, T.Text)\nnixCmdProc' cmdCfg = (proc (T.unpack cmd) options, cmd)\n  where\n    (cmd, options) = case cmdCfg of\n      NixCmd_Build cfg' ->\n        ( \"nix-build\"\n        , runNixBuildConfig cfg'\n        )\n      NixCmd_Instantiate cfg' ->\n        ( \"nix-instantiate\"\n        , runNixInstantiateConfig cfg'\n        )\n\nnixCmd :: MonadObelisk m => NixCmd -> m FilePath\nnixCmd cmdCfg = withSpinner' (T.unwords $ \"Running\" : cmd : desc) (Just $ const $ T.unwords $ \"Built\" : desc) $ do\n  output <- readProcessAndLogStderr Debug cmdProc\n  -- Remove final newline that Nix appends\n  Just (outPath, '\\n') <- pure $ T.unsnoc output\n  pure $ T.unpack outPath\n  where\n    (cmdProc, cmd) = nixCmdProc' cmdCfg\n    commonCfg = case cmdCfg of\n      NixCmd_Build cfg' -> cfg' ^. nixCommonConfig\n      NixCmd_Instantiate cfg' -> cfg' ^. nixCommonConfig\n    path = commonCfg ^. nixCmdConfig_target . target_path\n    desc = concat $ catMaybes\n      [ (\\x -> [\"on\", T.pack x]) <$> path\n      , (\\a -> [\"[\" <> T.pack a <> \"]\"]) <$> (commonCfg ^. nixCmdConfig_target . target_attr)\n      ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs:(70,1)-(73,21)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data Arg",
                    "    = Arg_Str String String | Arg_Expr String String",
                    "    deriving (Eq, Show)"
                  ],
                  "perhaps_block": [
                    "  data Arg",
                    "    = ArgStr String String | ArgExpr String String",
                    "    deriving (Eq, Show)"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs:(178,1)-(180,43)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data NixCmd",
                    "    = NixCmd_Build NixBuildConfig |",
                    "      NixCmd_Instantiate NixInstantiateConfig"
                  ],
                  "perhaps_block": [
                    "  data NixCmd",
                    "    = NixCmdBuild NixBuildConfig |",
                    "      NixCmdInstantiate NixInstantiateConfig"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Obelisk.Command.Nix\n  ( Arg (..)\n  , NixBuildConfig (..)\n  , nixBuildConfig_common\n  , nixBuildConfig_outLink\n  , NixCmd (..)\n  , nixCmdConfig_args\n  , nixCmdConfig_builders\n  , nixCmdConfig_target\n  , NixCommonConfig (..)\n  , NixInstantiateConfig (..)\n  , nixInstantiateConfig_eval\n  , NixShellConfig (..)\n  , nixShellConfig_common\n  , nixShellConfig_pure\n  , nixShellConfig_run\n  , OutLink (..)\n  , Target (..)\n  , target_attr\n  , target_expr\n  , target_path\n\n  , boolArg\n  , nixCmd\n  , nixCmdProc\n  , nixCmdProc'\n  , rawArg\n  , runNixShellConfig\n  , strArg\n  ) where\n\nimport Control.Monad (guard)\nimport Control.Lens\n\nimport Data.Bool (bool)\nimport Data.Default\nimport Data.List (intercalate)\nimport Data.Maybe\nimport Data.Monoid ((<>))\nimport qualified Data.Text as T\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\n-- | What to build\ndata Target = Target\n  { _target_path :: Maybe FilePath\n  , _target_attr :: Maybe String\n  , _target_expr :: Maybe String\n  }\nmakeClassy ''Target\n\ninstance Default Target where\n  def = Target\n    { _target_path = Just \".\"\n    , _target_attr = Nothing\n    , _target_expr = Nothing\n    }\n\ndata Arg\n  = Arg_Str String String\n  | Arg_Expr String String\n  deriving (Eq, Show)\n\nstrArg :: String -> String -> Arg\nstrArg = Arg_Str\n\nrawArg :: String -> String -> Arg\nrawArg = Arg_Expr\n\nboolArg :: String -> Bool -> Arg\nboolArg k = Arg_Expr k . bool \"false\" \"true\"\n\ncliFromArgs :: [Arg] -> [String]\ncliFromArgs = concatMap $ \\case\n  Arg_Str k v -> [\"--argstr\", k, v]\n  Arg_Expr k v -> [\"--arg\", k, v]\n\ndata NixCommonConfig = NixCommonConfig\n  { _nixCmdConfig_target :: Target\n  , _nixCmdConfig_args :: [Arg]\n  , _nixCmdConfig_builders :: [String]\n  }\nmakeClassy ''NixCommonConfig\n\ninstance Default NixCommonConfig where\n  def = NixCommonConfig def mempty mempty\n\nrunNixCommonConfig :: NixCommonConfig -> [String]\nrunNixCommonConfig cfg = mconcat [maybeToList path, attrArg, exprArg, args, buildersArg]\n  where\n    path = _target_path $ _nixCmdConfig_target cfg\n    attr = _target_attr $ _nixCmdConfig_target cfg\n    expr = _target_expr $ _nixCmdConfig_target cfg\n    attrArg = case attr of\n      Nothing -> []\n      Just a -> [\"-A\", a]\n    exprArg = case expr of\n      Nothing -> []\n      Just a -> [\"-E\", a]\n    args = cliFromArgs $ _nixCmdConfig_args cfg\n    buildersArg = case _nixCmdConfig_builders cfg of\n      [] -> []\n      builders -> [\"--builders\", intercalate \";\" builders]\n\n-- | Where to put nix-build output\ndata OutLink\n  = OutLink_Default\n  | OutLink_None\n  | OutLink_IndirectRoot FilePath\n\ninstance Default OutLink where\n  def = OutLink_Default\n\ndata NixBuildConfig = NixBuildConfig\n  { _nixBuildConfig_common :: NixCommonConfig\n  , _nixBuildConfig_outLink :: OutLink\n  }\nmakeLenses ''NixBuildConfig\n\ninstance HasNixCommonConfig NixBuildConfig where\n  nixCommonConfig = nixBuildConfig_common\n\ninstance Default NixBuildConfig where\n  def = NixBuildConfig def def\n\nrunNixBuildConfig :: NixBuildConfig -> [String]\nrunNixBuildConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , case _nixBuildConfig_outLink cfg of\n      OutLink_Default -> []\n      OutLink_None -> [\"--no-out-link\"]\n      OutLink_IndirectRoot l -> [\"--out-link\", l]\n  ]\n\ndata NixInstantiateConfig = NixInstantiateConfig\n  { _nixInstantiateConfig_common :: NixCommonConfig\n  , _nixInstantiateConfig_eval :: Bool\n  }\nmakeLenses ''NixInstantiateConfig\n\ninstance HasNixCommonConfig NixInstantiateConfig where\n  nixCommonConfig = nixInstantiateConfig_common\n\ninstance Default NixInstantiateConfig where\n  def = NixInstantiateConfig def False\n\nrunNixInstantiateConfig :: NixInstantiateConfig -> [String]\nrunNixInstantiateConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , \"--eval\" <$ guard (_nixInstantiateConfig_eval cfg)\n  ]\n\ndata NixShellConfig = NixShellConfig\n  { _nixShellConfig_common :: NixCommonConfig\n  , _nixShellConfig_pure :: Bool\n  , _nixShellConfig_run :: Maybe String\n  }\n\nmakeLenses ''NixShellConfig\n\ninstance HasNixCommonConfig NixShellConfig where\n  nixCommonConfig = nixShellConfig_common\n\ninstance Default NixShellConfig where\n  def = NixShellConfig def False Nothing\n\ndata NixCmd\n  = NixCmd_Build NixBuildConfig\n  | NixCmd_Instantiate NixInstantiateConfig\n\ninstance Default NixCmd where\n  def = NixCmd_Build def\n\nrunNixShellConfig :: NixShellConfig -> [String]\nrunNixShellConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , [ \"--pure\" | cfg ^. nixShellConfig_pure ]\n  ] ++ mconcat [\n    [\"--run\", run] | run <- maybeToList $ cfg ^. nixShellConfig_run\n  ]\n\nnixCmdProc :: NixCmd -> ProcessSpec\nnixCmdProc = fst . nixCmdProc'\n\nnixCmdProc' :: NixCmd -> (ProcessSpec, T.Text)\nnixCmdProc' cmdCfg = (proc (T.unpack cmd) options, cmd)\n  where\n    (cmd, options) = case cmdCfg of\n      NixCmd_Build cfg' ->\n        ( \"nix-build\"\n        , runNixBuildConfig cfg'\n        )\n      NixCmd_Instantiate cfg' ->\n        ( \"nix-instantiate\"\n        , runNixInstantiateConfig cfg'\n        )\n\nnixCmd :: MonadObelisk m => NixCmd -> m FilePath\nnixCmd cmdCfg = withSpinner' (T.unwords $ \"Running\" : cmd : desc) (Just $ const $ T.unwords $ \"Built\" : desc) $ do\n  output <- readProcessAndLogStderr Debug cmdProc\n  -- Remove final newline that Nix appends\n  Just (outPath, '\\n') <- pure $ T.unsnoc output\n  pure $ T.unpack outPath\n  where\n    (cmdProc, cmd) = nixCmdProc' cmdCfg\n    commonCfg = case cmdCfg of\n      NixCmd_Build cfg' -> cfg' ^. nixCommonConfig\n      NixCmd_Instantiate cfg' -> cfg' ^. nixCommonConfig\n    path = commonCfg ^. nixCmdConfig_target . target_path\n    desc = concat $ catMaybes\n      [ (\\x -> [\"on\", T.pack x]) <$> path\n      , (\\a -> [\"[\" <> T.pack a <> \"]\"]) <$> (commonCfg ^. nixCmdConfig_target . target_attr)\n      ]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Run.hs",
              "cyclomatic_complexity": {
                "min": 0,
                "max": 0,
                "average": 0,
                "sum": 0
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 0,
              "code_quality_score": 100.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 0,
                  "max": 0,
                  "average": 0,
                  "sum": 0
                },
                "homplexity_loc": 0,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 0,\n        \"max\": 0,\n        \"average\": 0,\n        \"sum\": 0\n    },\n    \"homplexity_loc\": 0,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFoldable #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command.Run where\n\nimport Control.Arrow ((&&&))\nimport Control.Exception (Exception, bracket)\nimport Control.Lens (ifor, (.~), (&), view)\nimport Control.Concurrent (forkIO)\nimport Control.Monad (filterM, void)\nimport Control.Monad.Except (runExceptT, throwError)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Reader (MonadIO)\nimport Data.Bifoldable (bifoldr1)\nimport Data.Bifunctor (bimap)\nimport Data.Coerce (coerce)\nimport Data.Default (def)\nimport Data.Foldable (fold, for_, toList)\nimport Data.Functor.Identity (runIdentity)\nimport Data.List (intercalate)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Either\nimport qualified Data.List.NonEmpty as NE\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport qualified Data.Map.Monoidal as MMap\nimport Data.Maybe (catMaybes, fromMaybe, mapMaybe)\nimport Data.Ord (comparing)\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Time.Clock (getCurrentTime)\nimport Data.Time.Format (formatTime, defaultTimeLocale)\nimport Data.Traversable (for)\nimport Debug.Trace (trace)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Compiler (CompilerFlavor(..), perCompilerFlavorToList, PerCompilerFlavor)\n#else\nimport Distribution.Compiler (CompilerFlavor(..), PerCompilerFlavor)\n#endif\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Fields.ParseResult (runParseResult)\n#else\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription, runParseResult)\n#endif\nimport Distribution.Pretty (prettyShow)\nimport Distribution.Simple.Compiler (PackageDB (GlobalPackageDB))\nimport Distribution.Simple.Configure (configCompilerEx, getInstalledPackages)\nimport Distribution.Simple.PackageIndex (InstalledPackageIndex, lookupDependency)\nimport Distribution.Simple.Program.Db (defaultProgramDb)\nimport qualified Distribution.System as Dist\nimport Distribution.Types.BuildInfo (buildable, cppOptions, defaultExtensions, defaultLanguage, hsSourceDirs, options, targetBuildDepends)\nimport Distribution.Types.CondTree (simplifyCondTree)\nimport Distribution.Types.Dependency (Dependency (..), depPkgName)\nimport Distribution.Parsec.Warning (PWarning)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Types.GenericPackageDescription.Lens (ConfVar (Arch, Impl, OS), condLibrary)\n#else\nimport Distribution.Types.GenericPackageDescription (condLibrary)\nimport Distribution.Types.ConfVar (ConfVar (Arch, Impl, OS))\n#endif\nimport Distribution.Types.InstalledPackageInfo (compatPackageKey)\nimport Distribution.Types.Library (libBuildInfo)\nimport Distribution.Types.LibraryName (LibraryName(..))\nimport Distribution.Types.PackageName (mkPackageName)\nimport Distribution.Types.VersionRange (anyVersion)\nimport Distribution.Utils.Generic (toUTF8BS, readUTF8File)\n#if MIN_VERSION_Cabal(3,2,1)\nimport qualified Distribution.Parsec.Warning as Dist\n#else\nimport qualified Distribution.System as Dist\n#endif\nimport Distribution.Types.Dependency (Dependency (..), depPkgName, depVerRange)\nimport qualified Distribution.Verbosity as Verbosity (silent)\nimport qualified Hpack.Config as Hpack\nimport qualified Hpack.Render as Hpack\nimport qualified Hpack.Yaml as Hpack\nimport Language.Haskell.Extension (Extension, Language)\nimport qualified Network.Socket as Socket\nimport System.Directory\nimport System.Environment (getExecutablePath)\nimport System.FilePath\nimport qualified System.Info\nimport System.IO.Temp (withSystemTempDirectory)\n\nimport Obelisk.App (MonadObelisk, ObeliskError(..), getObelisk, runObelisk)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils (findExePath, ghcidExePath)\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\ndata CabalPackageInfo = CabalPackageInfo\n  { _cabalPackageInfo_packageFile :: FilePath\n  , _cabalPackageInfo_packageName :: T.Text\n  , _cabalPackageInfo_packageRoot :: FilePath\n  , _cabalPackageInfo_buildable :: Bool\n  , _cabalPackageInfo_sourceDirs :: NE.NonEmpty FilePath\n    -- ^ List of hs src dirs of the library component\n  , _cabalPackageInfo_defaultExtensions :: [Extension]\n    -- ^ List of globally enable extensions of the library component\n  , _cabalPackageInfo_defaultLanguage :: Maybe Language\n    -- ^ List of globally set languages of the library component\n  , _cabalPackageInfo_compilerOptions :: PerCompilerFlavor [String]\n    -- ^ List of compiler-specific options (e.g., the \"ghc-options\" field of the cabal file)\n  , _cabalPackageInfo_cppOptions :: [String]\n    -- ^ List of CPP (C Preprocessor) options (e.g. the \"cpp-options\" field of the cabal file)\n  , _cabalPackageInfo_buildDepends :: [Dependency]\n    -- ^ List of build dependencies listed in the cabal file\n  }\n\n-- | 'Bool' with a better name for its purpose.\ndata Interpret = Interpret_Interpret | Interpret_NoInterpret deriving (Eq, Ord, Show)\n\ntextInterpret :: Interpret -> Text\ntextInterpret = \\case\n  Interpret_Interpret -> \"Interpret\"\n  Interpret_NoInterpret -> \"NoInterpret\"\n\n-- | Describe a set of 'FilePath's as a tree to facilitate merging them in a convenient way.\ndata PathTree a = PathTree_Node\n  (Maybe a) -- An optional leaf at this point in the tree\n  (Map FilePath (PathTree a)) -- Branches to deeper leaves\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)\n\n-- | 2D ASCII drawing of a 'PathTree'. Adapted from Data.Tree.draw.\ndrawPathTree :: (a -> Text) -> PathTree a -> Text\ndrawPathTree showA (PathTree_Node _ ts0) = T.intercalate \"\\n\" $ goForest (Map.toList ts0)\n  where\n    annotated ma = maybe id (\\a b -> b <> \" [\" <> showA a <> \"]\") ma . T.pack\n    goTree (fp, PathTree_Node ma forest) = annotated ma fp : goForest (Map.toList forest)\n    goForest [] = []\n    goForest [tree] = shift \"\u2514\u2500 \" \"   \" (goTree tree)\n    goForest (tree:forest) = shift \"\u251c\u2500 \" \"\u2502  \" (goTree tree) <> goForest forest\n    shift first other = zipWith (<>) (first : repeat other)\n\n-- | Used to signal to obelisk that it's being invoked as a preprocessor\npreprocessorIdentifier :: String\npreprocessorIdentifier = \"__preprocessor-apply-packages\"\n\nprofile\n  :: MonadObelisk m\n  => String\n  -> [String]\n  -> m ()\nprofile profileBasePattern rtsFlags = withProjectRoot \".\" $ \\root -> do\n  putLog Debug \"Using profiled build of project.\"\n\n  outPath <- withSpinner \"Building profiled executable\" $\n    fmap (T.unpack . T.strip) $ readProcessAndLogStderr Debug $ setCwd (Just root) $ nixCmdProc $\n      NixCmd_Build $ def\n        & nixBuildConfig_outLink .~ OutLink_None\n        & nixCmdConfig_target .~ Target\n          { _target_path = Just \".\"\n          , _target_attr = Just \"__unstable__.profiledObRun\"\n          , _target_expr = Nothing\n          }\n  (assetType, assets) <- findProjectAssets root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  time <- liftIO getCurrentTime\n  let profileBaseName = formatTime defaultTimeLocale profileBasePattern time\n  liftIO $ createDirectoryIfMissing True $ takeDirectory $ root </> profileBaseName\n  putLog Debug $ \"Storing profiled data under base name of \" <> T.pack (root </> profileBaseName)\n  freePort <- getFreePort\n  runProcess_ $ setCwd (Just root) $ setDelegateCtlc True $ proc (outPath </> \"bin\" </> \"ob-run\") $\n    [ show freePort\n    , T.unpack assets\n    , profileBaseName\n    , \"+RTS\"\n    , \"-po\" <> profileBaseName\n    ] <> rtsFlags\n      <> [ \"-RTS\" ]\n\nrun\n  :: MonadObelisk m\n  => Maybe FilePath\n  -- ^ Certificate Directory path (optional)\n  -> Maybe Socket.PortNumber\n  -- ^ override the route's port number?\n  -> FilePath\n  -- ^ root folder\n  -> PathTree Interpret\n  -- ^ interpreted paths\n  -> m ()\nrun certDir portOverride root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  (assetType, assets) <- findProjectAssets root\n  manifestPkg <- parsePackagesOrFail . (:[]) . T.unpack =<< getHaskellManifestProjectPath root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  case assetType of\n    AssetSource_Derivation -> do\n      ob <- getObelisk\n      putLog Debug \"Starting static file derivation watcher...\"\n      void $ liftIO $ forkIO $ runObelisk ob $ watchStaticFilesDerivation root\n    _ -> pure ()\n  ghciArgs <- getGhciSessionSettings (pkgs <> manifestPkg) root\n  freePort <- getFreePort\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs -> do\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs $ Just $ unwords\n      [ \"Obelisk.Run.run (Obelisk.Run.defaultRunApp\"\n      , \"Backend.backend\"\n      , \"Frontend.frontend\"\n      , \"(Obelisk.Run.runServeAsset \" ++ show assets ++ \")\"\n      , \") { Obelisk.Run._runApp_backendPort =\", show freePort\n      ,   \", Obelisk.Run._runApp_forceFrontendPort =\", show portOverride\n      ,   \", Obelisk.Run._runApp_tlsCertDirectory =\", show certDir\n      , \"}\"\n      ]\n\nrunRepl :: MonadObelisk m => Maybe FilePath -> FilePath -> PathTree Interpret -> m ()\nrunRepl mUserGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  userCommands <- maybe (pure []) (fmap lines . liftIO . readFile) mUserGhciConfig\n  withGhciScriptArgs userCommands pkgs $ \\dotGhciArgs ->\n    runGhciRepl root pkgs (ghciArgs <> dotGhciArgs)\n\nrunWatch :: MonadObelisk m => FilePath -> PathTree Interpret -> m ()\nrunWatch root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs ->\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs Nothing\n\nexportGhciConfig :: MonadObelisk m => FilePath -> PathTree Interpret -> m [String]\nexportGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  getGhciSessionSettings pkgs root\n\nnixShellForInterpretPaths :: MonadObelisk m => Bool -> String -> FilePath -> PathTree Interpret -> Maybe String -> m ()\nnixShellForInterpretPaths isPure shell' root interpretPaths cmd = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  nixShellWithoutPkgs root isPure False (packageInfoToNamePathMap pkgs) shell' cmd\n\n-- | Like 'getLocalPkgs' but also parses them and fails if any of them can't be parsed.\ngetParsedLocalPkgs :: MonadObelisk m => FilePath -> PathTree Interpret -> m (NonEmpty CabalPackageInfo)\ngetParsedLocalPkgs root interpretPaths = parsePackagesOrFail =<< getLocalPkgs root interpretPaths\n\n-- | Relative paths to local packages of an obelisk project.\n--\n-- These are a combination of the obelisk predefined local packages,\n-- and any packages that the user has set with the @packages@ argument\n-- to the Nix @project@ function.\ngetLocalPkgs :: forall m. MonadObelisk m => FilePath -> PathTree Interpret -> m (Set FilePath)\ngetLocalPkgs root interpretPaths = do\n  putLog Debug $ [i|Finding packages with root ${root} and interpret paths:|] <> \"\\n\" <> drawPathTree textInterpret interpretPaths\n  obeliskPackagePaths <- runFind [\"-L\", root, \"-name\", \".obelisk\", \"-type\", \"d\"]\n\n  -- We do not want to find packages that are embedded inside other obelisk projects, unless that\n  -- obelisk project is our own.\n  obeliskPackageExclusions <- liftIO $ fmap Set.fromList $ traverse canonicalizePath $\n    filter (/= root) $ map takeDirectory obeliskPackagePaths\n  putLog Debug [i|Excluding obelisk packages: ${T.pack $ unwords $ Set.toList obeliskPackageExclusions}|]\n  let rootsAndExclusions = calcIntepretFinds \"\" interpretPaths\n\n  fmap fold $ for (MMap.toAscList rootsAndExclusions) $ \\(interpretPathRoot, exclusions) ->\n    let allExclusions = obeliskPackageExclusions\n          <> exclusions\n          <> Set.singleton (\"*\" </> attrCacheFileName)\n          <> Set.singleton (\"*\" </> \"lib/asset/manifest\") -- NB: obelisk-asset-manifest is excluded because it generates\n                                                          -- a module that in turn imports it. This will cause ob run to\n                                                          -- fail in its current implementation.\n    in fmap (Set.fromList . map normalise) $ runFind $\n      [\"-L\", interpretPathRoot, \"(\", \"-name\", \"*.cabal\", \"-o\", \"-name\", Hpack.packageConfig, \")\", \"-a\", \"-type\", \"f\"]\n      <> concat [[\"-not\", \"-path\", p </> \"*\"] | p <- toList allExclusions]\n  where\n    runFind args = do\n      (_exitCode, out, err) <- readCreateProcessWithExitCode $ proc findExePath args\n      putLog Debug $ T.strip $ T.pack err\n      pure $ map T.unpack $ T.lines $ T.strip $ T.pack out\n\n-- | Calculates a set of root 'FilePath's along with each one's corresponding set of exclusions.\n--   This is used when constructing a set of @find@ commands to run to produce a set of packages\n--   that matches the user's @--interpret@/@--no-interpret@ settings.\ncalcIntepretFinds :: FilePath -> PathTree Interpret -> MMap.MonoidalMap FilePath (Set FilePath)\ncalcIntepretFinds treeRoot0 tree0 = runIdentity $ go treeRoot0 tree0\n  where\n    go treeRoot tree = foldPathTreeFor (== Interpret_Interpret) treeRoot tree $ \\parent children -> do\n      exclusions <- foldPathTreeFor (== Interpret_NoInterpret) parent children $ \\parent' children' ->\n        pure $ Map.singleton parent' children'\n      deeperFinds <- Map.traverseWithKey go exclusions\n      pure $ MMap.singleton parent (Map.keysSet exclusions) <> fold (MMap.MonoidalMap deeperFinds)\n\n-- | Traverses a 'PathTree' and folds all leaves matching a given predicate.\nfoldPathTreeFor\n  :: forall m a b. (Applicative m, Monoid b)\n  => (a -> Bool)\n  -> FilePath\n  -> PathTree a\n  -> (FilePath -> PathTree a -> m b)\n  -> m b\nfoldPathTreeFor predicate parent children f = case children of\n  PathTree_Node (Just x) children' | predicate x -> f parent (PathTree_Node Nothing children')\n  PathTree_Node _ children' -> fmap fold $ flip Map.traverseWithKey children' $ \\k children'' ->\n    foldPathTreeFor predicate (parent </> k) children'' f\n\ndata GuessPackageFileError = GuessPackageFileError_Ambiguous [FilePath] | GuessPackageFileError_NotFound\n  deriving (Eq, Ord, Show)\ninstance Exception GuessPackageFileError\n\nnewtype HPackFilePath = HPackFilePath { unHPackFilePath :: FilePath } deriving (Eq, Ord, Show)\nnewtype CabalFilePath = CabalFilePath { unCabalFilePath :: FilePath } deriving (Eq, Ord, Show)\n\n-- | Given a directory, try to guess what the appropriate @.cabal@ or @package.yaml@ file is for the package.\nguessCabalPackageFile\n  :: (MonadIO m)\n  => FilePath -- ^ Directory or path to search for cabal package\n  -> m (Either GuessPackageFileError (Either CabalFilePath HPackFilePath))\nguessCabalPackageFile pkg = do\n  liftIO (doesDirectoryExist pkg) >>= \\case\n    False -> case cabalOrHpackFile pkg of\n      (Just hpack@(Right _)) -> pure $ Right hpack\n      (Just cabal@(Left (CabalFilePath cabalFilePath))) -> do\n        -- If the cabal file has a sibling hpack file, we use that instead\n        -- since running hpack often generates a sibling cabal file\n        let possibleHpackSibling = takeDirectory cabalFilePath </> Hpack.packageConfig\n        hasHpackSibling <- liftIO $ doesFileExist possibleHpackSibling\n        pure $ Right $ if hasHpackSibling then Right (HPackFilePath possibleHpackSibling) else cabal\n      Nothing -> pure $ Left GuessPackageFileError_NotFound\n    True -> do\n      candidates <- liftIO $\n            filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n        =<< mapMaybe (cabalOrHpackFile . (pkg </>)) <$> listDirectory pkg\n      pure $ case partitionEithers candidates of\n        ([hpack], _) -> Right $ Left hpack\n        ([], [cabal]) -> Right $ Right cabal\n        ([], []) -> Left GuessPackageFileError_NotFound\n        (hpacks, cabals) -> Left $ GuessPackageFileError_Ambiguous $ coerce hpacks <> coerce cabals\n\ncabalOrHpackFile :: FilePath -> Maybe (Either CabalFilePath HPackFilePath)\ncabalOrHpackFile = \\case\n  x | takeExtension x == \".cabal\" -> Just (Left $ CabalFilePath x)\n    | takeFileName x == Hpack.packageConfig -> Just (Right $ HPackFilePath x)\n    | otherwise -> Nothing\n\n-- | Parses the cabal package in a given directory.\n-- This automatically figures out which .cabal file or package.yaml (hpack) file to use in the given directory.\nparseCabalPackage\n  :: MonadObelisk m\n  => FilePath -- ^ Package directory\n  -> m (Maybe CabalPackageInfo)\nparseCabalPackage dir = parseCabalPackage' dir >>= \\case\n  Left err -> throwError (ObeliskError_Unstructured err)\n  Right (Just (warnings, pkgInfo)) -> do\n    for_ warnings $ putLog Warning . T.pack . show\n    pure $ Just pkgInfo\n  Right Nothing -> pure Nothing\n\n-- | Like 'parseCabalPackage' but returns errors and warnings directly so as to avoid 'MonadObelisk'.\nparseCabalPackage'\n  :: (MonadIO m)\n  => FilePath -- ^ Package directory\n  -> m (Either T.Text (Maybe ([PWarning], CabalPackageInfo)))\nparseCabalPackage' pkg = runExceptT $ do\n  (cabalContents, packageFile, packageName) <- guessCabalPackageFile pkg >>= \\case\n    Left GuessPackageFileError_NotFound -> throwError $ \"No .cabal or package.yaml file found in \" <> T.pack pkg\n    Left (GuessPackageFileError_Ambiguous _) -> throwError $ \"Unable to determine which .cabal file to use in \" <> T.pack pkg\n    Right (Left (CabalFilePath file)) -> (, file, takeBaseName file) <$> liftIO (readUTF8File file)\n    Right (Right (HPackFilePath file)) -> do\n      let\n        decodeOptions = Hpack.DecodeOptions (Hpack.ProgramName \"ob\") file Nothing Hpack.decodeYaml\n      liftIO (Hpack.readPackageConfig decodeOptions) >>= \\case\n        Left err -> throwError $ T.pack $ \"Failed to parse \" <> file <> \": \" <> err\n        Right (Hpack.DecodeResult hpackPackage _ _ _) -> pure (Hpack.renderPackage [] hpackPackage, file, Hpack.packageName hpackPackage)\n\n  let\n    (warnings, result) = runParseResult $ parseGenericPackageDescription $ toUTF8BS cabalContents\n    osConfVar = case System.Info.os of\n      \"linux\" -> Just Dist.Linux\n      \"darwin\" -> Just Dist.OSX\n      _ -> trace \"Unrecgonized System.Info.os\" Nothing\n    archConfVar = Just Dist.X86_64 -- TODO: Actually infer this\n    evalConfVar v = Right $ case v of\n      OS osVar -> Just osVar == osConfVar\n      Arch archVar -> Just archVar == archConfVar\n      Impl GHC _ -> True -- TODO: Actually check version range\n      _ -> False\n#if MIN_VERSION_Cabal(3,2,1)\n  case (view condLibrary) <$> result of\n#else\n  case condLibrary <$> result of\n#endif\n    Right (Just condLib) -> do\n      let (_, lib) = simplifyCondTree evalConfVar condLib\n      pure $ Just $ (warnings,) $ CabalPackageInfo\n        { _cabalPackageInfo_packageName = T.pack packageName\n        , _cabalPackageInfo_packageFile = packageFile\n        , _cabalPackageInfo_packageRoot = takeDirectory packageFile\n        , _cabalPackageInfo_buildable = buildable $ libBuildInfo lib\n        , _cabalPackageInfo_sourceDirs =\n            fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib\n        , _cabalPackageInfo_defaultExtensions =\n            defaultExtensions $ libBuildInfo lib\n        , _cabalPackageInfo_defaultLanguage =\n            defaultLanguage $ libBuildInfo lib\n        , _cabalPackageInfo_compilerOptions =\n            options $ libBuildInfo lib\n        , _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib\n        , _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib\n        }\n    Right Nothing -> pure Nothing\n    Left (_, errors) ->\n      throwError $ T.pack $ \"Failed to parse \" <> packageFile <> \":\\n\" <> unlines (map show $ toList errors)\n\nparsePackagesOrFail :: (MonadObelisk m, Foldable f) => f FilePath -> m (NE.NonEmpty CabalPackageInfo)\nparsePackagesOrFail dirs' = do\n  packageInfos' <- fmap catMaybes $ for dirs $ \\dir -> do\n    flip fmap (parseCabalPackage dir) $ \\case\n      Just packageInfo\n        | _cabalPackageInfo_buildable packageInfo -> Just packageInfo\n      _ -> Nothing\n\n  -- Sort duplicate packages such that we prefer shorter paths, but fall back to alphabetical ordering.\n  let packagesByName = Map.map (NE.sortBy $ comparing $ \\p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n                     $ Map.fromListWith (<>) [(_cabalPackageInfo_packageName p, p NE.:| []) | p <- packageInfos']\n  unambiguous <- ifor packagesByName $ \\packageName ps -> case ps of\n    p NE.:| [] -> pure p -- No ambiguity here\n    p NE.:| _ -> do\n      let chosenText = \"  [Chosen] \"\n          prefix p'\n            | _cabalPackageInfo_packageFile p' == _cabalPackageInfo_packageFile p = chosenText\n            | otherwise = T.map (const ' ') chosenText\n      putLog Warning $ T.unlines $\n        \"Packages named '\" <> packageName <> \"' appear in \" <> T.pack (show $ length ps) <> \" different locations: \"\n        : map (\\p' -> prefix p' <> T.pack (_cabalPackageInfo_packageFile p')) (toList ps)\n      pure p\n\n  packageInfos <- case NE.nonEmpty $ toList unambiguous of\n    Nothing -> failWith $ T.pack $\n      \"No valid, buildable packages found\" <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n    Just xs -> pure xs\n\n  pure packageInfos\n  where\n    dirs = toList dirs'\n\npackageInfoToNamePathMap :: Foldable f => f CabalPackageInfo -> Map Text FilePath\npackageInfoToNamePathMap = Map.fromList . map (_cabalPackageInfo_packageName &&& _cabalPackageInfo_packageRoot) . toList\n\n-- Like 'withGhciScript' but provides the precise ghci arguments to add to a ghci session\nwithGhciScriptArgs\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ User commands to insert into .ghci\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> ([String] -> m ()) -- ^ Action to run with the extra ghci arguments\n  -> m ()\nwithGhciScriptArgs userCommands packageInfos f =\n  withGhciScript (loadPreludeManually ++ userCommands) packageInfos $ \\fp ->\n    f [\"-XNoImplicitPrelude\", \"-ghci-script\", fp]\n  where\n    -- These lines must be first and allow the session to support a custom Prelude when @-XNoImplicitPrelude@\n    -- is passed to the ghci session.\n    loadPreludeManually =\n      [ \":add Prelude\" -- @:add@ is used because it's less noisy when there is no custom Prelude\n      , \":set -XImplicitPrelude\" -- Turn the default setting on\n      ]\n\n-- | Create ghci configuration to load the given packages\nwithGhciScript\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ Commands to prefix to file\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> (FilePath -> m ()) -- ^ Action to run with the path to generated temporary .ghci\n  -> m ()\nwithGhciScript preCommands (toList -> packageInfos) f =\n  withSystemTempDirectory \"ob-ghci\" $ \\fp -> do\n    let dotGhciPath = fp </> \".ghci\"\n    liftIO $ writeFile dotGhciPath dotGhci\n    f dotGhciPath\n  where\n    packageNames = Set.fromList $ map _cabalPackageInfo_packageName packageInfos\n    modulesToLoad = mconcat\n      [ [ \"Obelisk.Run\" | \"obelisk-run\" `Set.member` packageNames ]\n      , [ \"Backend\" | \"backend\" `Set.member` packageNames ]\n      , [ \"Frontend\" | \"frontend\" `Set.member` packageNames ]\n      ]\n    dotGhci = unlines $\n      preCommands <>\n      [ if null modulesToLoad then \"\" else \":load \" <> unwords modulesToLoad\n      , \"import qualified Obelisk.Run\"\n      , \"import qualified Frontend\"\n      , \"import qualified Backend\"\n      ]\n\n-- | Builds a list of options to pass to ghci or set in .ghci file that configures\n-- the preprocessor and source includes.\ngetGhciSessionSettings\n  :: (MonadObelisk m, Foldable f)\n  => f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> FilePath -- ^ All paths will be relative to this path\n  -> m [String]\ngetGhciSessionSettings (toList -> packageInfos) pathBase = do\n  selfExe <- liftIO $ canonicalizePath =<< getExecutablePath\n  installedPackageIndex <- loadPackageIndex packageInfos pathBase\n\n  (pkgFiles, pkgSrcPaths :: [NonEmpty FilePath]) <- fmap unzip $ liftIO $ for packageInfos $ \\pkg -> do\n    canonicalSrcDirs <- traverse canonicalizePath $ (_cabalPackageInfo_packageRoot pkg </>) <$> _cabalPackageInfo_sourceDirs pkg\n    canonicalPkgFile <- canonicalizePath $ _cabalPackageInfo_packageFile pkg\n    pure (canonicalPkgFile, canonicalSrcDirs)\n\n  pure\n    $  baseGhciOptions\n    <> [\"-DOBELISK_ASSET_PASSTHRU\"] -- For passthrough static assets\n    <> [\"-F\", \"-pgmF\", selfExe, \"-optF\", preprocessorIdentifier]\n    <> concatMap (\\p -> [\"-optF\", p]) pkgFiles\n    <> [\"-i\" <> intercalate \":\" (concatMap toList pkgSrcPaths)]\n    <> concatMap (\\packageId -> [\"-package-id\", packageId ])\n                 (packageIds installedPackageIndex)\n  where\n    -- Package names we're building and not needed from the package DB\n    packageNames =\n      map (mkPackageName . T.unpack . _cabalPackageInfo_packageName)\n          packageInfos\n    packageIds installedPackageIndex = Set.toList $ Set.fromList $\n      map (dependencyPackageId installedPackageIndex) $\n          filter ((`notElem` packageNames) . depPkgName) $\n          concatMap _cabalPackageInfo_buildDepends packageInfos <>\n            [Dependency (mkPackageName \"obelisk-run\") anyVersion (Set.singleton LMainLibName)]\n    dependencyPackageId installedPackageIndex dep =\n      case lookupDependency installedPackageIndex (depPkgName dep) (depVerRange dep) of\n        ((_version,installedPackageInfo:_) :_) ->\n          compatPackageKey installedPackageInfo\n        _ -> error $ \"Couldn't resolve dependency for \" <> prettyShow dep\n\n\n-- Load the package index used by the GHC in this path's nix project\nloadPackageIndex :: MonadObelisk m => [CabalPackageInfo] -> FilePath -> m InstalledPackageIndex\nloadPackageIndex packageInfos root = do\n  ghcPath <- getPathInNixEnvironment \"bash -c 'type -p ghc'\"\n  ghcPkgPath <- getPathInNixEnvironment \"bash -c 'type -p ghc-pkg'\"\n  (compiler, _platform, programDb) <- liftIO\n    $ configCompilerEx (Just GHC) (Just ghcPath) (Just ghcPkgPath) defaultProgramDb Verbosity.silent\n  liftIO $ getInstalledPackages Verbosity.silent compiler [GlobalPackageDB] programDb\n  where\n    getPathInNixEnvironment cmd = do\n      path <- readProcessAndLogStderr Debug =<< mkObNixShellProc root False True (packageInfoToNamePathMap packageInfos) \"ghc\" (Just cmd)\n      liftIO $ canonicalizePath $ T.unpack $ T.strip path\n\nbaseGhciOptions :: [String]\nbaseGhciOptions =\n  [ \"-ignore-dot-ghci\"\n  , \"-no-user-package-db\"\n  , \"-hide-all-packages\"\n  , \"-package-env\", \"-\"\n  ]\n\n-- | Run ghci repl\nrunGhciRepl\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> [String] -- ^ GHCi arguments\n  -> m ()\nrunGhciRepl root (toList -> packages) ghciArgs =\n  -- NOTE: We do *not* want to use $(staticWhich \"ghci\") here because we need the\n  -- ghc that is provided by the shell in the user's project.\n  nixShellWithoutPkgs root True True (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ \"ghci\" : ghciArgs\n\n-- | Run ghcid\nrunGhcid\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should we chdir to root when running this process?\n  -> [String] -- ^ GHCi arguments\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> Maybe String -- ^ Optional command to run at every reload\n  -> m ()\nrunGhcid root chdirToRoot ghciArgs (toList -> packages) mcmd =\n  nixShellWithoutPkgs root True chdirToRoot (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ ghcidExePath : opts\n  where\n    opts = concat\n      [ [\"-W\"]\n      , [\"--outputfile=ghcid-output.txt\"]\n      , map (\\x -> \"--reload=\" <> x) reloadFiles\n      , map (\\x -> \"--restart=\" <> x) restartFiles\n      , maybe [] (\\cmd -> [\"--test=\" <> cmd]) mcmd\n      -- N.B. the subcommand to ghcid has to be itself escaped.\n      -- We have to use 'shEscape' instead of 'bashEscape' because\n      -- ghcid invokes System.Process with a shell command, which uses @\\/bin\\/sh@\n      -- instead of the @bash@ we have in scope.\n      -- This is not guaranteed to be bash on non-NixOS systems.\n      , [\"--command=\" <> unwords (fmap shEscape (\"ghci\" : ghciArgs))]\n      ]\n    adjustRoot x = if chdirToRoot then makeRelative root x else x\n    reloadFiles = map adjustRoot [root </> \"config\"]\n    restartFiles = map (adjustRoot . _cabalPackageInfo_packageFile) packages\n\ngetFreePort :: MonadIO m => m Socket.PortNumber\ngetFreePort = liftIO $ Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close Socket.socketPort\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      return sock\n\n\n-- | Convert a 'FilePath' into a 'PathTree'.\npathToTree :: a -> FilePath -> PathTree a\npathToTree a p = go $ splitDirectories p\n  where\n    go [] = PathTree_Node (Just a) mempty\n    go (x : xs) = PathTree_Node Nothing $ Map.singleton x $ go xs\n\n-- | Like 'zipWith' but pads with a padding value instead of stopping on the shortest list.\nzipDefaultWith :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]\nzipDefaultWith _da _db _f []     []     = []\nzipDefaultWith  da  db  f (a:as) []     = f  a db : zipDefaultWith da db f as []\nzipDefaultWith  da  db  f []     (b:bs) = f da  b : zipDefaultWith da db f [] bs\nzipDefaultWith  da  db  f (a:as) (b:bs) = f  a  b : zipDefaultWith da db f as bs\n\n-- | Makes the first absolute path relative to the second absolute path.\n--\n-- Both input paths MUST be absolute.\n--\n-- Unlike 'makeRelative' this does not merely strip prefixes. It will introduce\n-- enough @..@ paths to make the resulting path truly relative in virtually every\n-- case. The only exception is on Windows when the two paths are on different\n-- drives. In this case the resulting path may be absolute.\nrelativeTo :: FilePath -> FilePath -> FilePath\nrelativeTo dir base\n  = bifoldr1 (</>)\n  $ bimap (collapse . (\"..\" <$) . catMaybes) (collapse . catMaybes)\n  $ unzip\n  $ dropWhile (\\(a,b) -> a == b)\n  $ zipDefaultWith Nothing Nothing (,)\n    (map Just $ splitDirectories base)\n    (map Just $ splitDirectories dir)\n  where collapse = foldr (</>) \"\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:(134,1)-(137,58)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data PathTree a",
                    "    = PathTree_Node (Maybe a) (Map FilePath (PathTree a))",
                    "    deriving (Eq, Ord, Show, Functor, Foldable, Traversable)"
                  ],
                  "perhaps_block": [
                    "  data PathTree a",
                    "    = PathTreeNode (Maybe a) (Map FilePath (PathTree a))",
                    "    deriving (Eq, Ord, Show, Functor, Foldable, Traversable)"
                  ]
                },
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs:(398,21)-(413,9)",
                  "suggestion_title": "Evaluate",
                  "found_block": [
                    "  (warnings,)",
                    "    $ CabalPackageInfo",
                    "        {_cabalPackageInfo_packageName = T.pack packageName,",
                    "         _cabalPackageInfo_packageFile = packageFile,",
                    "         _cabalPackageInfo_packageRoot = takeDirectory packageFile,",
                    "         _cabalPackageInfo_buildable = buildable $ libBuildInfo lib,",
                    "         _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\")",
                    "                                          $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib,",
                    "         _cabalPackageInfo_defaultExtensions = defaultExtensions",
                    "                                                 $ libBuildInfo lib,",
                    "         _cabalPackageInfo_defaultLanguage = defaultLanguage",
                    "                                               $ libBuildInfo lib,",
                    "         _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib,",
                    "         _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib,",
                    "         _cabalPackageInfo_buildDepends = targetBuildDepends",
                    "                                            $ libBuildInfo lib}"
                  ],
                  "perhaps_block": [
                    "  (warnings, ",
                    "   CabalPackageInfo",
                    "     {_cabalPackageInfo_packageName = T.pack packageName,",
                    "      _cabalPackageInfo_packageFile = packageFile,",
                    "      _cabalPackageInfo_packageRoot = takeDirectory packageFile,",
                    "      _cabalPackageInfo_buildable = buildable $ libBuildInfo lib,",
                    "      _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\")",
                    "                                       $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib,",
                    "      _cabalPackageInfo_defaultExtensions = defaultExtensions",
                    "                                              $ libBuildInfo lib,",
                    "      _cabalPackageInfo_defaultLanguage = defaultLanguage",
                    "                                            $ libBuildInfo lib,",
                    "      _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib,",
                    "      _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib,",
                    "      _cabalPackageInfo_buildDepends = targetBuildDepends",
                    "                                         $ libBuildInfo lib})"
                  ]
                }
              ],
              "refactored_code": ""
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 7,
                "average": 2.5714285714285716,
                "sum": 18
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 10,
              "lines_of_code": 140,
              "homplexity_lines_of_code": 168,
              "code_quality_score": 47.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 7,
                  "average": 2.5714285714285716,
                  "sum": 18
                },
                "homplexity_loc": 168,
                "homplexity_output": "Info:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 1 1: module Obelisk.Command.Preprocessor has 98 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 31 1: type signature for applyPackages has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 31 1: type signature for applyPackages has 5 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has branching depth of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has 20 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 32 1: function applyPackages has cyclomatic complexity of 4 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 58 1: type signature for writeOutput has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 58 1: type signature for writeOutput has 4 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has 10 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 59 1: function writeOutput has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 74 5: data GenHeaderError has record fields count of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 80 1: type signature for prettyGenHeaderError has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 80 1: type signature for prettyGenHeaderError has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has 4 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has branching depth of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 81 1: function prettyGenHeaderError has cyclomatic complexity of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 93 1: type signature for generateHeader has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 93 1: type signature for generateHeader has 3 arguments \nWarning:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has 33 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has cyclomatic complexity of 7 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 94 1: function generateHeader has branching depth of 2 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 133 1: type signature for lineNumberPragma has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 133 1: type signature for lineNumberPragma has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 134 1: function lineNumberPragma has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 136 1: type signature for pragma has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 136 1: type signature for pragma has 2 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has branching depth of 0 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 137 1: function pragma has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 139 1: type signature for quoted has type constructor nesting of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 139 1: type signature for quoted has 3 arguments \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has cyclomatic complexity of 1 \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has 1 lines of code \nInfo:/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs:SrcLoc \"/tmp/project_102/static_refactored/lib/command/src/Obelisk/Command/Preprocessor.hs\" 140 1: function quoted has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Obelisk.Command.Preprocessor where\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Builder as BU\nimport Data.Foldable (for_)\nimport Data.List (intersperse, isPrefixOf, sortOn)\nimport Data.Maybe (fromMaybe)\nimport qualified Data.Text.Lazy.Builder as TL\nimport qualified Data.Text.Lazy.Encoding as TL\nimport Distribution.Compiler (CompilerFlavor (..), perCompilerFlavorToList)\nimport Language.Haskell.Extension (Extension (..), Language(..))\nimport System.Directory (canonicalizePath)\nimport System.IO (IOMode (..), hPutStrLn, stderr, withFile)\nimport System.FilePath (hasTrailingPathSeparator, joinPath, splitPath)\nimport Control.Lens ((<&>))\nimport System.Exit\n\nimport Obelisk.Command.Run (CabalPackageInfo (..), parseCabalPackage')\n\n-- | This code is intended to be executed via ghci's -pgmF preprocessor option.\n-- The command line arguments are passed in via ghc, which dictates the first three options and meanings\n-- In order for this code to execute, origPath must contain either a '.' character or a '/' character.\n-- (This is to avoid the possibility of the command line syntax conflicting with another ob command)\n-- We do have control over the remaining arguments, but they must be the same for all files.\n-- Thus, the fourth command line argument must be \"apply-packages\",  which has already been handled.\n-- We assume all the remaining arguments passed in are paths to cabal or hpack package specifications.\n-- Thus we must select among the packagePaths for the file we are going to parse.\napplyPackages :: FilePath -> FilePath -> FilePath -> [FilePath] -> IO ()\napplyPackages origPath inPath outPath packagePaths' = do\n  origPathCanonical <- canonicalizePath origPath\n  packagePaths <- traverse canonicalizePath packagePaths'\n\n  let\n    takeDirs = takeWhile hasTrailingPathSeparator\n    packageDirs = sortOn (negate . length . takeDirs) $ map splitPath packagePaths\n    origDir = splitPath origPathCanonical\n    matches = [ joinPath d | d <- packageDirs, takeDirs d `isPrefixOf` origDir ]\n    giveUp = exitWith (ExitFailure 1)\n\n  -- The first element of matches is going to be the deepest path to a package spec that contains\n  -- our file as a subdirectory.\n  packageInfo' <- case matches of\n    [] -> do\n      hPutStrLn stderr $ \"Error: Unable to find cabal information for \" <> origPath <> \"; Skipping preprocessor.\"\n      giveUp\n    packagePath:_ -> parseCabalPackage' packagePath >>= \\case\n      Left err -> do\n        hPutStrLn stderr $ \"Error: Unable to parse cabal package \" <> packagePath <> \"; Skipping preprocessor on \" <> origPath <> \". Error: \" <> show err\n        giveUp\n      Right (Just (_, packageInfo)) -> pure $ Just packageInfo\n      Right Nothing -> pure Nothing\n\n  writeOutput packageInfo' inPath outPath\n\nwriteOutput :: Maybe CabalPackageInfo -> FilePath -> FilePath -> IO ()\nwriteOutput packageInfo' origPath outPath = withFile outPath WriteMode $ \\hOut -> do\n  for_ packageInfo' $ \\packageInfo ->\n    case generateHeader origPath packageInfo of\n      Left e -> do\n        hPutStrLn stderr (prettyGenHeaderError origPath e)\n        giveUp\n      Right header -> hPutTextBuilder hOut header\n  BL.readFile origPath >>= BL.hPut hOut\n  where\n    hPutTextBuilder h = BU.hPutBuilder h . TL.encodeUtf8Builder . TL.toLazyText\n    giveUp = exitWith (ExitFailure 1)\n\n-- | Represents an error which may happen when turning a\n-- 'CabalPackageInfo' into a set of GHC pragmas.\ndata GenHeaderError\n  = GenHeaderError_UnknownLanguage String\n  -- ^ An invalid @default-language@ field was specified.\n  | GenHeaderError_UnknownExtension String\n  -- ^ An invalid value was present in the @default-extensions@ field.\n\n-- | Turn a 'GenHeaderError' to a string suitable for display to the user.\nprettyGenHeaderError :: String -> GenHeaderError -> String\nprettyGenHeaderError origPath =\n  \\case\n    GenHeaderError_UnknownExtension e -> \"Error: Unknown default-extension \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n    GenHeaderError_UnknownLanguage e -> \"Error: Unknown default-language \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n\n-- | Turn a parsed 'CabalPackageInfo' into a set of GHC pragmas which\n-- reproduce the same settings.\n--\n-- NOTE: We cannot restrict the package set by adding '-package' flags\n-- to OPTIONS_GHC, because GHC rejects them there.  It seems that we\n-- won't be able to properly handle that situation until GHC itself\n-- supports loading multiple packages officially in GHCi\ngenerateHeader :: FilePath -> CabalPackageInfo -> Either GenHeaderError TL.Builder\ngenerateHeader origPath packageInfo =\n    fmap (\\e -> e <> ghcOptions <> lineNumberPragma origPath) hsExtensions\n  where\n    hsExtensions :: Either GenHeaderError TL.Builder\n    hsExtensions = extList <&> \\exts ->\n      if null exts\n        then mempty\n        else pragma $ TL.fromText \"LANGUAGE \" <> mconcat (intersperse (TL.fromText \", \") exts)\n\n    extList :: Either GenHeaderError [TL.Builder]\n    extList = addDefaultLanguage =<< traverse showExt (_cabalPackageInfo_defaultExtensions packageInfo)\n\n    addDefaultLanguage :: [TL.Builder] -> Either GenHeaderError [TL.Builder]\n    addDefaultLanguage exts =\n      case _cabalPackageInfo_defaultLanguage packageInfo of\n        Nothing -> pure exts\n        Just x -> case x of\n          UnknownLanguage ext -> Left (GenHeaderError_UnknownExtension ext)\n          ext -> pure $ TL.fromString (show ext):exts\n\n    showExt :: Extension -> Either GenHeaderError TL.Builder\n    showExt = \\case\n      EnableExtension ext -> pure $ TL.fromString (show ext)\n      DisableExtension ext -> pure $ \"No\" <> TL.fromString (show ext)\n      UnknownExtension ext -> Left (GenHeaderError_UnknownExtension ext)\n\n    ghcOptions =\n      if null optList\n        then mempty\n        else pragma $\n          TL.fromText \"OPTIONS_GHC \" <> mconcat (intersperse (TL.fromText \" \") (map TL.fromString optList))\n    ghcOptList\n      = filter (not . isPrefixOf \"-O\")\n      $ fromMaybe []\n      $ lookup GHC\n      $ perCompilerFlavorToList\n      $ _cabalPackageInfo_compilerOptions packageInfo\n    optList = _cabalPackageInfo_cppOptions packageInfo <> ghcOptList\n\nlineNumberPragma :: FilePath -> TL.Builder\nlineNumberPragma origPath = pragma $ TL.fromText \"LINE 1 \" <> quoted '\"' (TL.fromString origPath)\n\npragma :: TL.Builder -> TL.Builder\npragma x = TL.fromText \"{-# \" <> x <> TL.fromText \" #-}\\n\"\n\nquoted :: Char -> TL.Builder -> TL.Builder\nquoted char x = TL.singleton char <> x <> TL.singleton char\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Preprocessor.hs:(73,1)-(76,42)",
                  "suggestion_title": "Use camelCase",
                  "found_block": [
                    "  data GenHeaderError",
                    "    = GenHeaderError_UnknownLanguage String |",
                    "      GenHeaderError_UnknownExtension String"
                  ],
                  "perhaps_block": [
                    "  data GenHeaderError",
                    "    = GenHeaderErrorUnknownLanguage String |",
                    "      GenHeaderErrorUnknownExtension String"
                  ]
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Obelisk.Command.Preprocessor where\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Builder as BU\nimport Data.Foldable (for_)\nimport Data.List (intersperse, isPrefixOf, sortOn)\nimport Data.Maybe (fromMaybe)\nimport qualified Data.Text.Lazy.Builder as TL\nimport qualified Data.Text.Lazy.Encoding as TL\nimport Distribution.Compiler (CompilerFlavor (..), perCompilerFlavorToList)\nimport Language.Haskell.Extension (Extension (..), Language(..))\nimport System.Directory (canonicalizePath)\nimport System.IO (IOMode (..), hPutStrLn, stderr, withFile)\nimport System.FilePath (hasTrailingPathSeparator, joinPath, splitPath)\nimport Control.Lens ((<&>))\nimport System.Exit\n\nimport Obelisk.Command.Run (CabalPackageInfo (..), parseCabalPackage')\n\n-- | This code is intended to be executed via ghci's -pgmF preprocessor option.\n-- The command line arguments are passed in via ghc, which dictates the first three options and meanings\n-- In order for this code to execute, origPath must contain either a '.' character or a '/' character.\n-- (This is to avoid the possibility of the command line syntax conflicting with another ob command)\n-- We do have control over the remaining arguments, but they must be the same for all files.\n-- Thus, the fourth command line argument must be \"apply-packages\",  which has already been handled.\n-- We assume all the remaining arguments passed in are paths to cabal or hpack package specifications.\n-- Thus we must select among the packagePaths for the file we are going to parse.\napplyPackages :: FilePath -> FilePath -> FilePath -> [FilePath] -> IO ()\napplyPackages origPath inPath outPath packagePaths' = do\n  origPathCanonical <- canonicalizePath origPath\n  packagePaths <- traverse canonicalizePath packagePaths'\n\n  let\n    takeDirs = takeWhile hasTrailingPathSeparator\n    packageDirs = sortOn (negate . length . takeDirs) $ map splitPath packagePaths\n    origDir = splitPath origPathCanonical\n    matches = [ joinPath d | d <- packageDirs, takeDirs d `isPrefixOf` origDir ]\n    giveUp = exitWith (ExitFailure 1)\n\n  -- The first element of matches is going to be the deepest path to a package spec that contains\n  -- our file as a subdirectory.\n  packageInfo' <- case matches of\n    [] -> do\n      hPutStrLn stderr $ \"Error: Unable to find cabal information for \" <> origPath <> \"; Skipping preprocessor.\"\n      giveUp\n    packagePath:_ -> parseCabalPackage' packagePath >>= \\case\n      Left err -> do\n        hPutStrLn stderr $ \"Error: Unable to parse cabal package \" <> packagePath <> \"; Skipping preprocessor on \" <> origPath <> \". Error: \" <> show err\n        giveUp\n      Right (Just (_, packageInfo)) -> pure $ Just packageInfo\n      Right Nothing -> pure Nothing\n\n  writeOutput packageInfo' inPath outPath\n\nwriteOutput :: Maybe CabalPackageInfo -> FilePath -> FilePath -> IO ()\nwriteOutput packageInfo' origPath outPath = withFile outPath WriteMode $ \\hOut -> do\n  for_ packageInfo' $ \\packageInfo ->\n    case generateHeader origPath packageInfo of\n      Left e -> do\n        hPutStrLn stderr (prettyGenHeaderError origPath e)\n        giveUp\n      Right header -> hPutTextBuilder hOut header\n  BL.readFile origPath >>= BL.hPut hOut\n  where\n    hPutTextBuilder h = BU.hPutBuilder h . TL.encodeUtf8Builder . TL.toLazyText\n    giveUp = exitWith (ExitFailure 1)\n\n-- | Represents an error which may happen when turning a\n-- 'CabalPackageInfo' into a set of GHC pragmas.\ndata GenHeaderError\n  = GenHeaderError_UnknownLanguage String\n  -- ^ An invalid @default-language@ field was specified.\n  | GenHeaderError_UnknownExtension String\n  -- ^ An invalid value was present in the @default-extensions@ field.\n\n-- | Turn a 'GenHeaderError' to a string suitable for display to the user.\nprettyGenHeaderError :: String -> GenHeaderError -> String\nprettyGenHeaderError origPath =\n  \\case\n    GenHeaderError_UnknownExtension e -> \"Error: Unknown default-extension \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n    GenHeaderError_UnknownLanguage e -> \"Error: Unknown default-language \" <> e <> \"; Skipping preprocessor on \" <> origPath <> \".\"\n\n-- | Turn a parsed 'CabalPackageInfo' into a set of GHC pragmas which\n-- reproduce the same settings.\n--\n-- NOTE: We cannot restrict the package set by adding '-package' flags\n-- to OPTIONS_GHC, because GHC rejects them there.  It seems that we\n-- won't be able to properly handle that situation until GHC itself\n-- supports loading multiple packages officially in GHCi\ngenerateHeader :: FilePath -> CabalPackageInfo -> Either GenHeaderError TL.Builder\ngenerateHeader origPath packageInfo =\n    fmap (\\e -> e <> ghcOptions <> lineNumberPragma origPath) hsExtensions\n  where\n    hsExtensions :: Either GenHeaderError TL.Builder\n    hsExtensions = extList <&> \\exts ->\n      if null exts\n        then mempty\n        else pragma $ TL.fromText \"LANGUAGE \" <> mconcat (intersperse (TL.fromText \", \") exts)\n\n    extList :: Either GenHeaderError [TL.Builder]\n    extList = addDefaultLanguage =<< traverse showExt (_cabalPackageInfo_defaultExtensions packageInfo)\n\n    addDefaultLanguage :: [TL.Builder] -> Either GenHeaderError [TL.Builder]\n    addDefaultLanguage exts =\n      case _cabalPackageInfo_defaultLanguage packageInfo of\n        Nothing -> pure exts\n        Just x -> case x of\n          UnknownLanguage ext -> Left (GenHeaderError_UnknownExtension ext)\n          ext -> pure $ TL.fromString (show ext):exts\n\n    showExt :: Extension -> Either GenHeaderError TL.Builder\n    showExt = \\case\n      EnableExtension ext -> pure $ TL.fromString (show ext)\n      DisableExtension ext -> pure $ \"No\" <> TL.fromString (show ext)\n      UnknownExtension ext -> Left (GenHeaderError_UnknownExtension ext)\n\n    ghcOptions =\n      if null optList\n        then mempty\n        else pragma $\n          TL.fromText \"OPTIONS_GHC \" <> mconcat (intersperse (TL.fromText \" \") (map TL.fromString optList))\n    ghcOptList\n      = filter (not . isPrefixOf \"-O\")\n      $ fromMaybe []\n      $ lookup GHC\n      $ perCompilerFlavorToList\n      $ _cabalPackageInfo_compilerOptions packageInfo\n    optList = _cabalPackageInfo_cppOptions packageInfo <> ghcOptList\n\nlineNumberPragma :: FilePath -> TL.Builder\nlineNumberPragma origPath = pragma $ TL.fromText \"LINE 1 \" <> quoted '\"' (TL.fromString origPath)\n\npragma :: TL.Builder -> TL.Builder\npragma x = TL.fromText \"{-# \" <> x <> TL.fromText \" #-}\\n\"\n\nquoted :: Char -> TL.Builder -> TL.Builder\nquoted char x = TL.singleton char <> x <> TL.singleton char\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "refactored_file_name": "/tmp/project_102/static_refactored/lib/run/src/Obelisk/Run.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 0,
              "homplexity_lines_of_code": 1,
              "code_quality_score": 97.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 1
                },
                "homplexity_loc": 1,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 1,\n        \"average\": 1,\n        \"sum\": 1\n    },\n    \"homplexity_loc\": 1,\n    \"homplexity_output\": {\n        \"functionName\": 1\n    }\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n#if defined(IPROUTE_SUPPORTED)\n{-# LANGUAGE TemplateHaskell #-}\n#endif\n\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-} -- Due to instance HasJS x (EventWriterT t w m)\nmodule Obelisk.Run where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Applicative\nimport Control.Exception\nimport Control.Lens ((%~), (^?), _Just, _Right)\nimport qualified Data.Attoparsec.ByteString.Char8 as A\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BSC\nimport qualified Data.ByteString.Lazy.Char8 as BSLC\nimport qualified Data.ByteString.UTF8 as BSUTF8\nimport Data.Functor.Identity\nimport Data.List (uncons)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup ((<>))\n#endif\nimport Data.Streaming.Network (bindPortTCP)\nimport Data.String (fromString)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Time.Clock (getCurrentTime, addUTCTime)\nimport Language.Javascript.JSaddle.Run (syncPoint)\nimport Language.Javascript.JSaddle.WebSockets\nimport Network.HTTP.Client (Manager, defaultManagerSettings, newManager)\nimport qualified Network.HTTP.ReverseProxy as RP\nimport qualified Network.HTTP.Types as H\nimport Network.Socket\nimport Network.Wai (Application)\nimport qualified Network.Wai as W\nimport Network.Wai.Handler.Warp\nimport Network.Wai.Handler.WarpTLS\nimport Network.Wai.Handler.Warp.Internal (settingsHost, settingsPort)\nimport Network.WebSockets (ConnectionOptions)\nimport Network.WebSockets.Connection (defaultConnectionOptions)\nimport qualified Obelisk.Asset.Serve.Snap as Snap\nimport Obelisk.Backend\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport qualified OpenSSL.PEM as PEM\nimport qualified OpenSSL.RSA as RSA\nimport qualified OpenSSL.X509 as X509\nimport qualified OpenSSL.X509.Request as X509Request\nimport Reflex.Dom.Core\nimport Snap.Core (Snap)\nimport System.Environment\nimport System.FilePath ((</>))\nimport System.IO\nimport System.Process\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Web.Cookie\n\n#if defined(IPROUTE_SUPPORTED)\nimport qualified System.Which\n#endif\n\n-- | The arguments to 'run', specifying the configuration and\n-- implementation of an Obelisk application.\ndata RunApp backendRoute frontendRoute\n  = RunApp\n    { _runApp_backendPort      :: Int\n      -- ^ What port should we serve the backend on? This is used for\n      -- internal communication.\n    , _runApp_backendHost      :: ByteString\n      -- ^ The hostname on which the backend is running. By default,\n      -- this is @127.0.0.1@, i.e., the local machine. Routes not\n      -- handled by the frontend will be redirected to this host.\n    , _runApp_forceFrontendPort :: Maybe Int\n      -- ^ If set, overrides the port on which the frontend will be\n      -- served. If unset, the port will be parsed from the configured\n      -- route.\n    , _runApp_tlsCertDirectory :: Maybe FilePath\n      -- ^ Optional directory in which to find \"cert.pem\", \"chain.pem\"\n      -- and \"privkey.pem\" to be used for TLS.\n      -- If this is 'Nothing' and TLS is enabled, we'll generate a\n      -- self-signed cert.\n    , _runApp_staticHandler    :: [Text] -> Snap ()\n      -- ^ How to serve static assets.\n    , _runApp_backend          :: Backend backendRoute frontendRoute\n      -- ^ The backend.\n    , _runApp_frontend         :: Frontend (R frontendRoute)\n      -- ^ The frontend.\n    }\n\n-- | Construct a 'RunApp' with sane defaults. The TLS certificate\n-- directory will be set to 'Nothing', the backend host will be the\n-- local machine (@127.0.0.1@), the backend port will be set to @3001@,\n-- the frontend port will be fetched from the route configuration.\ndefaultRunApp\n  :: Backend backendRoute frontendRoute -- ^ The backend to use\n  -> Frontend (R frontendRoute)         -- ^ The frontend to use\n  -> ([Text] -> Snap ())                -- ^ How to serve static assets\n  -> RunApp backendRoute frontendRoute\ndefaultRunApp be fe static = RunApp\n  { _runApp_backendPort = 3001\n  , _runApp_backendHost = \"127.0.0.1\"\n  , _runApp_forceFrontendPort = Nothing\n  , _runApp_tlsCertDirectory = Nothing\n  , _runApp_staticHandler = static\n  , _runApp_backend = be\n  , _runApp_frontend = fe\n  }\n\n-- | Run an Obelisk application, including the frontend and backend. The\n-- backend routes are served on the port given by '_runApp_backendPort',\n-- but are also accessible through the frontend.\nrun :: RunApp backendRoute frontendRoute -> IO ()\nrun toRun = do\n  prettifyOutput\n\n  let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"backend stopped; make a change to your code to reload - error \" <> show e\n\n  --TODO: Use Obelisk.Backend.runBackend; this will require separating the checking and running phases\n  case checkEncoder $ _backend_routeEncoder (_runApp_backend toRun) of\n    Left e -> hPutStrLn stderr $ \"backend error:\\n\" <> T.unpack e\n    Right validFullEncoder -> do\n      publicConfigs <- getPublicConfigs\n\n      -- We start the backend server listening on the\n      -- '_runApp_backendPort'. The backend and frontend run in\n      -- different servers: The frontend server will pass any routes it\n      -- can't handle to this process.\n      backendTid <- forkIO $ handle handleBackendErr $ withArgs [\"--quiet\", \"--port\", show (_runApp_backendPort toRun)] $\n        _backend_run (_runApp_backend toRun) $ \\serveRoute ->\n          runSnapWithCommandLineArgs $\n            getRouteWith validFullEncoder >>= \\case\n              Identity r -> case r of\n                FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n                FullRoute_Frontend obeliskRoute :/ a ->\n                  serveDefaultObeliskApp appRouteToUrl (($ allJsUrl) <$> defaultGhcjsWidgets)\n                    (_runApp_staticHandler toRun) (_runApp_frontend toRun) publicConfigs $ obeliskRoute :/ a\n                  where\n                    appRouteToUrl (k :/ v) = renderObeliskRoute validFullEncoder (FullRoute_Frontend (ObeliskRoute_App k) :/ v)\n                    allJsUrl = renderAllJsPath validFullEncoder\n\n      runWidget toRun publicConfigs validFullEncoder `finally` killThread backendTid\n\n-- Convenience wrapper to handle path segments for 'Snap.serveAsset'\nrunServeAsset :: FilePath -> [Text] -> Snap ()\nrunServeAsset rootPath t =\n  Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\" $ t\n\ngetConfigRoute :: Map Text ByteString -> Either Text URI\ngetConfigRoute configs = case Map.lookup \"common/route\" configs of\n    Just r ->\n      let stripped = T.strip (T.decodeUtf8 r)\n      in case URI.mkURI stripped of\n          Just route -> Right route\n          Nothing -> Left $ \"Couldn't parse route as URI; value read was: \" <> T.pack (show stripped)\n    Nothing -> Left $ \"Couldn't find config file common/route; it should contain the site's canonical root URI\" <> T.pack (show $ Map.keys configs)\n\n-- | Start the frontend (given in the 'RunApp' record), with the given\n-- configuration and the given 'FullRoute' encoder, which must be valid.\nrunWidget\n  :: RunApp backendRoute frontendRoute\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> IO ()\nrunWidget toRun configs validFullEncoder = do\n  uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n  let -- Before we can do anything, we need to pick a port to serve the\n      -- backend on. If the user has asked to override it, then we use that:\n      -- they know what they're doing. Otherwise, we'll use the port\n      -- specified in the route.\n      port = fromMaybe 80 $ (_runApp_forceFrontendPort toRun)\n                        <|> (fmap fromIntegral $ uri ^? uriAuthority . _Right . authPort . _Just)\n\n      -- This is the server that will handle the backend requests. We\n      -- support shuttling them off to any host:port pair.\n      redirectHost = _runApp_backendHost toRun\n      redirectPort = _runApp_backendPort toRun\n\n      -- TLS toggle logic: 'routeIsTLS' indicates whether the\n      -- configuration would have mandated TLS (at the moment this is\n      -- only because the route is https://...).\n      -- 'portDisabledTLS' indicates whether the user forced us to use a\n      -- port different than that of the route, and thus TLS was\n      -- disabled.\n      routeIsTLS = (Just \"https\" == uri ^? uriScheme . _Just . unRText)\n      portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n\n      beforeMainLoop = do\n        putStrLn $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n        putStrLn $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n        -- TLS toggle logic: If the --port option was given, warn the\n        -- user that TLS is being skipped.\n        when (routeIsTLS && portDisabledTLS) $ do\n          putStrLn \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n          putStrLn \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n\n\n      settings = setBeforeMainLoop beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n\n      -- Providing TLS here will also incidentally provide it to proxied\n      -- requests to the backend.\n      prepareRunner =\n        -- TLS toggle logic: If the port option was NOT given, then use\n        -- TLS iff the route has it.\n        if not portDisabledTLS && routeIsTLS then\n          case _runApp_tlsCertDirectory toRun of\n            Nothing -> do\n              -- Generate a private key and self-signed certificate for TLS\n              privateKey <- RSA.generateRSAKey' 2048 3\n\n              certRequest <- X509Request.newX509Req\n              _ <- X509Request.setPublicKey certRequest privateKey\n              _ <- X509Request.signX509Req certRequest privateKey Nothing\n\n              cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n              _ <- X509.setPublicKey cert privateKey\n              timenow <- getCurrentTime\n              _ <- X509.setNotBefore cert $ addUTCTime (-1) timenow\n              _ <- X509.setNotAfter cert $ addUTCTime (365 * 24 * 60 * 60) timenow\n              _ <- X509.signX509 cert privateKey Nothing\n\n              certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n              privateKeyByteString <- BSUTF8.fromString <$> PEM.writePKCS8PrivateKey privateKey Nothing\n\n              return $ runTLSSocket (tlsSettingsMemory certByteString privateKeyByteString)\n            Just certDir -> do\n              putStrLn $ \"Using certificate information from: \" ++ certDir\n              return $ runTLSSocket (tlsSettingsChain (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"] (certDir </> \"key.pem\"))\n        else return runSettingsSocket\n\n  runner <- prepareRunner\n  bracket\n    (bindPortTCPRetry settings (logPortBindErr port) 1)\n    close\n    (\\skt -> do\n        man <- newManager defaultManagerSettings\n        app <- obeliskApp configs defaultConnectionOptions (_runApp_frontend toRun) validFullEncoder uri $ fallbackProxy redirectHost redirectPort man\n        runner settings skt app)\n\n\n-- | Build a WAI 'Application' to serve the given Obelisk 'Frontend',\n-- using the specified 'Encoder' to parse routes. Any requests whose\n-- route does not result in a 'FullRoute_Frontend' parse will be\n-- redirected to the backend.\nobeliskApp\n  :: forall frontendRoute backendRoute\n  .  Map Text ByteString -- ^ The parsed configuration\n  -> ConnectionOptions   -- ^ Connection options for the JSaddle websocket\n  -> Frontend (R frontendRoute) -- ^ The Obelisk frontend\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n     -- ^ An encoder for parsing frontend routes.\n  -> URI\n    -- ^ The 'URI' on which the 'Frontend' will be served. Used for\n    -- establishing the JSaddle websocket connection.\n  -> Application -- ^ A WAI 'Application' which handles backend requests.\n  -> IO Application\nobeliskApp configs opts frontend validFullEncoder uri backend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate = True\n        , _frontendMode_adjustRoute = False\n        }\n      entryPoint = do\n        runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n        syncPoint\n  jsaddlePath <- URI.mkPathPiece \"jsaddle\"\n  let jsaddleUri = BSLC.fromStrict $ URI.renderBs $ uri & uriPath %~ (<>[jsaddlePath])\n  Right (jsaddleWarpRouteValidEncoder :: Encoder Identity (Either Text) (R JSaddleWarpRoute) PageName) <- return $ checkEncoder jsaddleWarpRouteEncoder\n  jsaddle <- jsaddleWithAppOr opts entryPoint $ \\_ sendResponse -> sendResponse $ W.responseLBS H.status500 [(\"Content-Type\", \"text/plain\")] \"obeliskApp: jsaddle got a bad URL\"\n  return $ \\req sendResponse -> case tryDecode validFullEncoder $ byteStringsToPageName (BS.dropWhile (== (fromIntegral $ fromEnum '/')) $ W.rawPathInfo req) (BS.drop 1 $ W.rawQueryString req) of\n    Identity r -> case r of\n      FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_JSaddleWarp) :/ jsaddleRoute -> case jsaddleRoute of\n        JSaddleWarpRoute_JavaScript :/ () -> sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", \"application/javascript\")] $ jsaddleJs' (Just jsaddleUri) False\n        _ -> flip jsaddle sendResponse $ req\n          { W.pathInfo = fst $ encode jsaddleWarpRouteValidEncoder jsaddleRoute\n          }\n      FullRoute_Frontend (ObeliskRoute_App appRouteComponent) :/ appRouteRest -> do\n        let cookies = maybe [] parseCookies $ lookup (fromString \"Cookie\") (W.requestHeaders req)\n            routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n        html <- renderJsaddleFrontend configs cookies routeToUrl (appRouteComponent :/ appRouteRest) frontend\n        sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", staticRenderContentType)] $ BSLC.fromStrict html\n      _ -> backend req sendResponse\n\nrenderJsaddleFrontend\n  :: Map Text ByteString\n  -> Cookies\n  -> (route -> Text)\n  -> route\n  -> Frontend route\n  -> IO ByteString\nrenderJsaddleFrontend configs cookies urlEnc r f =\n  let jsaddleScript = elAttr \"script\" (\"src\" =: \"/jsaddle/jsaddle.js\") blank\n      jsaddlePreload = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: \"/jsaddle/jsaddle.js\") blank\n  in renderFrontendHtml configs cookies urlEnc r f jsaddlePreload jsaddleScript\n\n-- | like 'bindPortTCP' but reconnects on exception\nbindPortTCPRetry :: Settings\n                 -> (IOError -> IO ()) -- ^ Action to run the first time an exception is caught\n                 -> Int\n                 -> IO Socket\nbindPortTCPRetry settings m n = catch (bindPortTCP (settingsPort settings) (settingsHost settings)) $ \\(e :: IOError) -> do\n  m e\n  threadDelay $ 1000000 * n\n  bindPortTCPRetry settings (\\_ -> pure ()) n\n\nlogPortBindErr :: Int -> IOError -> IO ()\nlogPortBindErr p e = getProcessIdForPort p >>= \\case\n  Nothing -> putStrLn $ \"runWidget: \" <> show e\n  Just pid -> putStrLn $ unwords [ \"Port\", show p, \"is being used by process ID\", show pid <> \".\", \"Please kill that process or change the port in config/common/route.\"]\n\nssPath :: Maybe String\nssPath =\n#if defined(IPROUTE_SUPPORTED)\n  Just $(System.Which.staticWhich \"ss\")\n#else\n  Nothing\n#endif\n\ngetProcessIdForPort :: Int -> IO (Maybe Int)\ngetProcessIdForPort port = case ssPath of\n  Just ss -> do\n    xs <- lines <$> readProcess ss [\"-lptn\", \"sport = \" <> show port] mempty\n    case uncons xs of\n      Just (_, x:_) -> return $ A.maybeResult $ A.parse parseSsPid $ BSC.pack x\n      _ -> return Nothing\n  _ -> return Nothing\n\nparseSsPid :: A.Parser Int\nparseSsPid = do\n  _ <- A.count 5 $ A.takeWhile (not . A.isSpace) *> A.skipSpace\n  _ <- A.skipWhile (/= ':') >> A.string \":((\" >> A.skipWhile (/= ',')\n  A.string \",pid=\" *> A.decimal\n\nfallbackProxy :: ByteString -> Int -> Manager -> Application\nfallbackProxy host port = RP.waiProxyTo handleRequest RP.defaultOnExc\n  where handleRequest _req = return $ RP.WPRProxyDest $ RP.ProxyDest host port\n",
              "suggestions": [
                {
                  "location": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs:(193,29)-(194,97)",
                  "suggestion_title": "Move brackets to avoid $",
                  "found_block": [
                    "  (_runApp_forceFrontendPort toRun)",
                    "    <|>",
                    "      (fmap fromIntegral",
                    "         $ uri ^? uriAuthority . _Right . authPort . _Just)"
                  ],
                  "perhaps_block": [
                    "  (_runApp_forceFrontendPort toRun)",
                    "    <|>",
                    "      fmap fromIntegral (uri ^? uriAuthority . _Right . authPort . _Just)"
                  ]
                }
              ],
              "refactored_code": ""
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 25,
              "max": 128,
              "average": 27.666666666666668,
              "sum": 581
            },
            "hlint_suggestions": {
              "error": 2,
              "warning": 23,
              "suggestion": 25,
              "ignore": 0,
              "total": 50
            },
            "syntax_errors": 269,
            "lines_of_code": 5547,
            "homplexity_lines_of_code": 7326,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/frontend/src-bin/main.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/skeleton/frontend/src-bin/main.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 2,
                "average": 2,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 13,
              "homplexity_lines_of_code": 13,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 2,
                  "average": 2,
                  "sum": 2
                },
                "homplexity_loc": 13,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 2,\n        \"max\": 2,\n        \"average\": 2.0,\n        \"sum\": 2\n    },\n    \"homplexity_loc\": 13\n}\n"
              },
              "original_code": "import Frontend\nimport Common.Route\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport Reflex.Dom\n\nmain :: IO ()\nmain = do\n  let Right validFullEncoder = checkEncoder fullRouteEncoder\n  run $ runFrontend validFullEncoder frontend\n",
              "suggestions": [
                {
                  "target_snippet": "let Right validFullEncoder = checkEncoder fullRouteEncoder",
                  "refactored_suggestion": "case checkEncoder fullRouteEncoder of\n  Right validFullEncoder -> run $ runFrontend validFullEncoder frontend\n  Left error -> putStrLn $ \"Error: \" ++ show error",
                  "confidence": 0.9,
                  "justification": "Using `let` to destructure the result of `checkEncoder fullRouteEncoder` assumes that the result is always `Right`. However, if the result is `Left`, the program will crash. Using `case` makes the code more robust by explicitly handling both `Right` and `Left` cases."
                },
                {
                  "target_snippet": "import Frontend",
                  "refactored_suggestion": "-- reason: The 'Frontend' module is not used in the provided code and can be safely removed.\n-- import Frontend",
                  "confidence": 1.0,
                  "justification": "The 'Frontend' module is imported but never used in the file. Removing unused imports reduces clutter and potential confusion in the code base."
                }
              ],
              "refactored_code": "-- reason: The 'Frontend' module is not used in the provided code and can be safely removed.\n-- import Frontend\nimport Common.Route\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport Reflex.Dom\n\nmain :: IO ()\nmain = do\n  case checkEncoder fullRouteEncoder of\n  Right validFullEncoder -> run $ runFrontend validFullEncoder frontend\n  Left error -> putStrLn $ \"Error: \" ++ show error\n  run $ runFrontend validFullEncoder frontend\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/skeleton/common/src/Common/Route.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 1,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 3,
              "lines_of_code": 48,
              "homplexity_lines_of_code": 38,
              "code_quality_score": 94.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 38,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 1 1: module Common.Route has 32 lines of code \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 28 3: data BackendRoute has record fields count of 0 \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 33 3: data FrontendRoute has record fields count of 0 \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 36 1: type signature for fullRouteEncoder has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/skeleton/common/src/Common/Route.hs\" 38 1: function fullRouteEncoder has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule Common.Route where\n\n{- -- You will probably want these imports for composing Encoders.\nimport Prelude hiding (id, (.))\nimport Control.Category\n-}\n\nimport Data.Text (Text)\nimport Data.Functor.Identity\n\nimport Obelisk.Route\nimport Obelisk.Route.TH\n\ndata BackendRoute :: * -> * where\n  -- | Used to handle unparseable routes.\n  BackendRoute_Missing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.\n\ndata FrontendRoute :: * -> * where\n  FrontendRoute_Main :: FrontendRoute ()\n  -- This type is used to define frontend routes, i.e. ones for which the backend will serve the frontend.\n\nfullRouteEncoder\n  :: Encoder (Either Text) Identity (R (FullRoute BackendRoute FrontendRoute)) PageName\nfullRouteEncoder = mkFullRouteEncoder\n  (FullRoute_Backend BackendRoute_Missing :/ ())\n  (\\case\n      BackendRoute_Missing -> PathSegment \"missing\" $ unitEncoder mempty)\n  (\\case\n      FrontendRoute_Main -> PathEnd $ unitEncoder mempty)\n\nconcat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "data BackendRoute :: * -> * where\n  BackendRoute_Missing :: BackendRoute ()",
                  "refactored_suggestion": "data BackendRoute :: * -> * where\n  BackendRouteMissing :: BackendRoute ()",
                  "confidence": 1.0,
                  "justification": "The suggestion improves overall code readability and consistency by using camelCase, which is the preferred naming convention in Haskell for data constructors."
                },
                {
                  "target_snippet": "-- | Used to handle unparseable routes.\n  BackendRoute_Missing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.",
                  "refactored_suggestion": "-- | Used to handle unparseable routes.\n  BackendRouteMissing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.",
                  "confidence": 1.0,
                  "justification": "Keeping the inline comments intact while modifying the data constructor name ensures that the functionality and explanation remain unaffected."
                },
                {
                  "target_snippet": "concat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ]",
                  "refactored_suggestion": "concat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ] -- Generates route component instances for BackendRoute and FrontendRoute",
                  "confidence": 0.9,
                  "justification": "Adding a comment clarifying the purpose of deriveRouteComponent increases code clarity and maintains documentation inline with the code."
                }
              ],
              "refactored_code": "{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule Common.Route where\n\n{- -- You will probably want these imports for composing Encoders.\nimport Prelude hiding (id, (.))\nimport Control.Category\n-}\n\nimport Data.Text (Text)\nimport Data.Functor.Identity\n\nimport Obelisk.Route\nimport Obelisk.Route.TH\n\ndata BackendRoute :: * -> * where\n  -- | Used to handle unparseable routes.\n  BackendRouteMissing :: BackendRoute ()\n  -- You can define any routes that will be handled specially by the backend here.\n  -- i.e. These do not serve the frontend, but do something different, such as serving static files.\n\ndata FrontendRoute :: * -> * where\n  FrontendRoute_Main :: FrontendRoute ()\n  -- This type is used to define frontend routes, i.e. ones for which the backend will serve the frontend.\n\nfullRouteEncoder\n  :: Encoder (Either Text) Identity (R (FullRoute BackendRoute FrontendRoute)) PageName\nfullRouteEncoder = mkFullRouteEncoder\n  (FullRoute_Backend BackendRoute_Missing :/ ())\n  (\\case\n      BackendRoute_Missing -> PathSegment \"missing\" $ unitEncoder mempty)\n  (\\case\n      FrontendRoute_Main -> PathEnd $ unitEncoder mempty)\n\nconcat <$> mapM deriveRouteComponent\n  [ ''BackendRoute\n  , ''FrontendRoute\n  ] -- Generates route component instances for BackendRoute and FrontendRoute\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/frontend/src/Obelisk/Frontend.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.6666666666666667,
                "sum": 10
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 1,
                "ignore": 0,
                "total": 2
              },
              "syntax_errors": 26,
              "lines_of_code": 261,
              "homplexity_lines_of_code": 279,
              "code_quality_score": 52.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.6666666666666667,
                  "sum": 10
                },
                "homplexity_loc": 279,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): module Obelisk.Frontend has 200 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" (-1) (-1): data Frontend has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 108 1: type signature for baseTag has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 109 1: function baseTag has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 114 1: type signature for removeHTMLConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 115 1: function removeHTMLConfigs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 125 1: type signature for nodeListNodes has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 126 1: function nodeListNodes has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 143 21: data FrontendMode has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 155 1: type signature for runFrontend has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 160 1: function runFrontend has 11 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 184 1: type signature for runFrontendWithConfigsAndCurrentRoute has 5 arguments \nCritical:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has 43 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 191 1: function runFrontendWithConfigsAndCurrentRoute has cyclomatic complexity of 4 \nWarning:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 239 1: type signature for renderFrontendHtml has 8 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 239 1: type signature for renderFrontendHtml has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/frontend/src/Obelisk/Frontend.hs\" 249 1: function renderFrontendHtml has 12 lines of code \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Frontend\n  ( ObeliskWidget\n  , Frontend (..)\n  , runFrontend\n  , runFrontendWithConfigsAndCurrentRoute\n  , renderFrontendHtml\n  , removeHTMLConfigs\n  , FrontendMode (..)\n  , FrontendWidgetT\n  , module Obelisk.Frontend.Cookie\n  ) where\n\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Prelude hiding ((.))\n\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Maybe (MaybeT(..), runMaybeT)\nimport Data.ByteString (ByteString)\nimport Data.Foldable (for_)\nimport Data.Map (Map)\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.History as DOM\nimport qualified GHCJS.DOM.Window as DOM\nimport Language.Javascript.JSaddle (MonadJSM, JSM, jsNull)\nimport GHCJS.DOM (currentDocument)\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.Node (Node, removeChild_)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport Obelisk.Frontend.Cookie\nimport Obelisk.Route.Frontend\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Obelisk.Configs\nimport Obelisk.ExecutableConfig.Inject (injectExecutableConfigs)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport System.Info (os)\nimport Web.Cookie\n\nimport Debug.Trace\n\ntype ObeliskWidget t route m =\n  ( DomBuilder t m\n  , MonadFix m\n  , MonadHold t m\n  , MonadSample t (Performable m)\n  , MonadReflexCreateTrigger t m\n  , PostBuild t m\n  , PerformEvent t m\n  , TriggerEvent t m\n  , HasDocument m\n  , MonadRef m\n  , Ref m ~ Ref IO\n  , MonadRef (Performable m)\n  , Ref (Performable m) ~ Ref IO\n  , MonadFix (Performable m)\n  , PrimMonad m\n  , Prerender t m\n  , PrebuildAgnostic t route m\n  , PrebuildAgnostic t route (Client m)\n  , HasConfigs m\n  , HasCookies m\n  , MonadIO (Performable m)\n  )\n\ntype PrebuildAgnostic t route m =\n  ( SetRoute t route m\n  , RouteToUrl route m\n  , MonadFix m\n  , HasConfigs m\n  , HasConfigs (Performable m)\n  )\n\ndata Frontend route = Frontend\n  { _frontend_head :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  , _frontend_body :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  }\n\nbaseTag :: forall route t m. ObeliskWidget t route m => RoutedT t route m ()\nbaseTag =\n  if os == \"ios\"\n    then blank\n    else elAttr \"base\" (\"href\" =: \"/\") blank --TODO: Figure out the base URL from the routes\n\nremoveHTMLConfigs :: JSM ()\nremoveHTMLConfigs = void $ runMaybeT $ do\n  doc <- MaybeT currentDocument\n  hd <- MaybeT $ getHead doc\n  es <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  for_ es $ removeChild_ hd\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in exe-config/ghcjs/lookup should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes\n\nsetInitialRoute :: Bool -> JSM ()\nsetInitialRoute useHash = do\n  traceM \"setInitialRoute\"\n  window <- DOM.currentWindowUnchecked\n  initialLocation <- DOM.getLocation window\n  initialUri <- getLocationUri initialLocation\n  history <- DOM.getHistory window\n  DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n    show $ setAdaptedUriPath useHash \"/\" initialUri\n\ndata FrontendMode = FrontendMode\n  { _frontendMode_hydrate :: Bool\n    -- ^ There is already a rendering of the DOM in place; hydrate it rather\n    -- than building new DOM\n  , _frontendMode_adjustRoute :: Bool\n    -- ^ The page can't use regular routes, so encode routes into the hash\n    -- instead\n  }\n\n-- | Run the frontend, setting the initial route to \"/\" on platforms where no\n-- route exists ambiently in the context (e.g. anything but web).\n-- Selects FrontendMode based on platform; this doesn't work for jsaddle-warp\nrunFrontend\n  :: forall backendRoute route\n  .  Encoder Identity Identity (R (FullRoute backendRoute route)) PageName\n  -> Frontend (R route)\n  -> JSM ()\nrunFrontend validFullEncoder frontend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate =\n#ifdef ghcjs_HOST_OS\n          True\n#else\n          False\n#endif\n        , _frontendMode_adjustRoute =\n#ifdef ghcjs_HOST_OS\n          False\n#else\n          True\n#endif\n        }\n  configs <- liftIO Lookup.getConfigs\n  when (_frontendMode_hydrate mode) removeHTMLConfigs\n  -- There's no fundamental reason that adjustRoute needs to control setting the\n  -- initial route and *also* the useHash parameter; that's why these are\n  -- separate here.  However, currently, they are always the same.\n  when (_frontendMode_adjustRoute mode) $ do\n    setInitialRoute $ _frontendMode_adjustRoute mode\n  runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n\nrunFrontendWithConfigsAndCurrentRoute\n  :: forall backendRoute frontendRoute\n  .  FrontendMode\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> Frontend (R frontendRoute)\n  -> JSM ()\nrunFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend = do\n  let ve = validFullEncoder . hoistParse errorLeft (reviewEncoder (rPrism $ _FullRoute_Frontend . _ObeliskRoute_App))\n      errorLeft = \\case\n        Left _ -> error \"runFrontend: Unexpected non-app ObeliskRoute reached the frontend. This shouldn't happen.\"\n        Right x -> Identity x\n      w :: ( RawDocument (DomBuilderSpace (HydrationDomBuilderT s DomTimeline m)) ~ DOM.Document\n           , Ref (Performable m) ~ Ref IO\n           , Ref m ~ Ref IO\n           , DomBuilder DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadHold DomTimeline m\n           , MonadRef m\n           , MonadRef (Performable m)\n           , MonadReflexCreateTrigger DomTimeline m\n           , PerformEvent DomTimeline m\n           , PostBuild DomTimeline m\n           , PrimMonad m\n           , MonadSample DomTimeline (Performable m)\n           , DOM.MonadJSM m\n           , MonadFix (Client (HydrationDomBuilderT s DomTimeline m))\n           , MonadFix (Performable m)\n           , MonadFix m\n           , Prerender DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadIO (Performable m)\n           )\n        => (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> FloatingWidget () ()\n      w appendHead appendBody = do\n        rec switchover <- runRouteViewT ve switchover (_frontendMode_adjustRoute mode) $ do\n              (switchover'', fire) <- newTriggerEvent\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendHead . runConfigsT configs))) $ do\n                -- The order here is important - baseTag has to be before headWidget!\n                baseTag\n                _frontend_head frontend\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendBody . runConfigsT configs))) $ do\n                _frontend_body frontend\n                switchover' <- case _frontendMode_hydrate mode of\n                  True -> lift $ lift $ lift $ lift $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n                  False -> getPostBuild\n                performEvent_ $ liftIO (fire ()) <$ switchover'\n              pure switchover''\n        pure ()\n  if _frontendMode_hydrate mode\n    then runHydrationWidgetWithHeadAndBody (pure ()) w\n    else runImmediateWidgetWithHeadAndBody w\n\ntype FrontendWidgetT r = RoutedT DomTimeline r (SetRouteT DomTimeline r (RouteToUrlT r (ConfigsT (CookiesT (HydratableT (PostBuildT DomTimeline (StaticDomBuilderT DomTimeline (PerformEventT DomTimeline DomHost))))))))\n\nrenderFrontendHtml\n  :: MonadIO m\n  => Map Text ByteString\n  -> Cookies\n  -> (r -> Text)\n  -> r\n  -> Frontend r\n  -> FrontendWidgetT r ()\n  -> FrontendWidgetT r ()\n  -> m ByteString\nrenderFrontendHtml configs cookies urlEnc route frontend headExtra bodyExtra = do\n  --TODO: We should probably have a \"NullEventWriterT\" or a frozen reflex timeline\n  html <- fmap snd $ liftIO $ renderStatic $ runHydratableT $ fmap fst $ runCookiesT cookies $ runConfigsT configs $ flip runRouteToUrlT urlEnc $ runSetRouteT $ flip runRoutedT (pure route) $\n    el \"html\" $ do\n      el \"head\" $ do\n        baseTag\n        injectExecutableConfigs configs\n        _frontend_head frontend\n        headExtra\n      el \"body\" $ do\n        _frontend_body frontend\n        bodyExtra\n  return $ \"<!DOCTYPE html>\" <> html\n",
              "suggestions": [
                {
                  "target_snippet": "case _frontendMode_hydrate mode of\n    True\n      -> lift\n           $ lift\n               $ lift\n                   $ lift\n                       $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n    False -> getPostBuild",
                  "refactored_suggestion": "(if _frontendMode_hydrate mode then\n       lift\n         $ lift\n             $ lift\n                 $ lift\n                     $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n   else\n       getPostBuild)",
                  "confidence": 0.9,
                  "justification": "Using `if` instead of `case` for this condition improves readability and conciseness by reducing the nesting depth and unnecessary boilerplate."
                },
                {
                  "target_snippet": "len <- getLength es\n  -- Warning! len is unsigned. If the NodeList is empty, we must avoid\n  -- accidentally traversing over [0..maxBound::Word]\n  nodes <- traverse (item es) $ if len == 0 then [] else [0..len-1]\n  pure $ catMaybes nodes",
                  "refactored_suggestion": "len <- getLength es\n  nodes <- traverse (item es) [0..len-1]\n  pure $ catMaybes nodes",
                  "confidence": 0.8,
                  "justification": "The check for `if len == 0` is unnecessary because traversing over an empty list `[]` naturally results in an empty list. By simplifying this, you reduce complexity without changing the behavior."
                },
                {
                  "target_snippet": "import Debug.Trace",
                  "refactored_suggestion": "-- import Debug.Trace -- Debug.Trace is unused and should be safely removed",
                  "confidence": 1.0,
                  "justification": "The `Debug.Trace` import is unnecessary as it is not used anywhere in the file. Removing it reduces clutter and promotes better code hygiene."
                },
                {
                  "target_snippet": "setInitialRoute :: Bool -> JSM ()\nsetInitialRoute useHash = do\n  traceM \"setInitialRoute\"\n  window <- DOM.currentWindowUnchecked\n  initialLocation <- DOM.getLocation window\n  initialUri <- getLocationUri initialLocation\n  history <- DOM.getHistory window\n  DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n    show $ setAdaptedUriPath useHash \"/\" initialUri",
                  "refactored_suggestion": "-- setInitialRoute :: Bool -> JSM ()\n-- setInitialRoute useHash = do\n--   traceM \"setInitialRoute\"\n--   window <- DOM.currentWindowUnchecked\n--   initialLocation <- DOM.getLocation window\n--   initialUri <- getLocationUri initialLocation\n--   history <- DOM.getHistory window\n--   DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n--     show $ setAdaptedUriPath useHash \"/\" initialUri\n\n-- The function `setInitialRoute` seems to be dead code as it is defined but not invoked anywhere. Removing this function increases maintainability by avoiding unused definitions.",
                  "confidence": 1.0,
                  "justification": "The `setInitialRoute` function is not used anywhere in the file. Keeping such dead code can lead to confusion and potential maintenance issues. It is safe and beneficial to remove it."
                },
                {
                  "target_snippet": "import Data.Monoid ((<>))",
                  "refactored_suggestion": "-- import Data.Monoid ((<>)) -- This import is redundant as the Semigroup instance for Text already provides <> in modern GHC versions.",
                  "confidence": 1.0,
                  "justification": "In modern Haskell environments (GHC >= 8.0), `<>` is defined in the `Semigroup` class and does not require the `Data.Monoid` import. Removing the import eliminates redundancy."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Frontend\n  ( ObeliskWidget\n  , Frontend (..)\n  , runFrontend\n  , runFrontendWithConfigsAndCurrentRoute\n  , renderFrontendHtml\n  , removeHTMLConfigs\n  , FrontendMode (..)\n  , FrontendWidgetT\n  , module Obelisk.Frontend.Cookie\n  ) where\n\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\n-- import Data.Monoid ((<>)) -- This import is redundant as the Semigroup instance for Text already provides <> in modern GHC versions.\n#endif\n#endif\n\nimport Prelude hiding ((.))\n\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Fix\nimport Control.Monad.IO.Class\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Maybe (MaybeT(..), runMaybeT)\nimport Data.ByteString (ByteString)\nimport Data.Foldable (for_)\nimport Data.Map (Map)\nimport Data.Maybe (catMaybes)\nimport Data.Text (Text)\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.History as DOM\nimport qualified GHCJS.DOM.Window as DOM\nimport Language.Javascript.JSaddle (MonadJSM, JSM, jsNull)\nimport GHCJS.DOM (currentDocument)\nimport \"ghcjs-dom\" GHCJS.DOM.Document (getHead)\nimport GHCJS.DOM.Node (Node, removeChild_)\nimport GHCJS.DOM.NodeList (IsNodeList, item, getLength)\nimport GHCJS.DOM.ParentNode (querySelectorAll)\nimport Obelisk.Frontend.Cookie\nimport Obelisk.Route.Frontend\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Obelisk.Configs\nimport Obelisk.ExecutableConfig.Inject (injectExecutableConfigs)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport System.Info (os)\nimport Web.Cookie\n\n-- import Debug.Trace -- Debug.Trace is unused and should be safely removed\n\ntype ObeliskWidget t route m =\n  ( DomBuilder t m\n  , MonadFix m\n  , MonadHold t m\n  , MonadSample t (Performable m)\n  , MonadReflexCreateTrigger t m\n  , PostBuild t m\n  , PerformEvent t m\n  , TriggerEvent t m\n  , HasDocument m\n  , MonadRef m\n  , Ref m ~ Ref IO\n  , MonadRef (Performable m)\n  , Ref (Performable m) ~ Ref IO\n  , MonadFix (Performable m)\n  , PrimMonad m\n  , Prerender t m\n  , PrebuildAgnostic t route m\n  , PrebuildAgnostic t route (Client m)\n  , HasConfigs m\n  , HasCookies m\n  , MonadIO (Performable m)\n  )\n\ntype PrebuildAgnostic t route m =\n  ( SetRoute t route m\n  , RouteToUrl route m\n  , MonadFix m\n  , HasConfigs m\n  , HasConfigs (Performable m)\n  )\n\ndata Frontend route = Frontend\n  { _frontend_head :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  , _frontend_body :: !(forall t m. ObeliskWidget t route m => RoutedT t route m ())\n  }\n\nbaseTag :: forall route t m. ObeliskWidget t route m => RoutedT t route m ()\nbaseTag =\n  if os == \"ios\"\n    then blank\n    else elAttr \"base\" (\"href\" =: \"/\") blank --TODO: Figure out the base URL from the routes\n\nremoveHTMLConfigs :: JSM ()\nremoveHTMLConfigs = void $ runMaybeT $ do\n  doc <- MaybeT currentDocument\n  hd <- MaybeT $ getHead doc\n  es <- nodeListNodes =<< querySelectorAll hd (\"[data-obelisk-executable-config-inject-key]\" :: Text)\n  for_ es $ removeChild_ hd\n\n-- | Collect all nodes in the node list.\n--\n-- TODO: this and the version in exe-config/ghcjs/lookup should be\n-- upstreamed to jsaddle.\nnodeListNodes :: (IsNodeList l, MonadJSM m) => l -> m [Node]\nnodeListNodes es = do\n  len <- getLength es\n  nodes <- traverse (item es) [0..len-1]\n  pure $ catMaybes nodes\n\n-- setInitialRoute :: Bool -> JSM ()\n-- setInitialRoute useHash = do\n--   traceM \"setInitialRoute\"\n--   window <- DOM.currentWindowUnchecked\n--   initialLocation <- DOM.getLocation window\n--   initialUri <- getLocationUri initialLocation\n--   history <- DOM.getHistory window\n--   DOM.replaceState history jsNull (\"\" :: Text) $ Just $\n--     show $ setAdaptedUriPath useHash \"/\" initialUri\n\n-- The function `setInitialRoute` seems to be dead code as it is defined but not invoked anywhere. Removing this function increases maintainability by avoiding unused definitions.\n\ndata FrontendMode = FrontendMode\n  { _frontendMode_hydrate :: Bool\n    -- ^ There is already a rendering of the DOM in place; hydrate it rather\n    -- than building new DOM\n  , _frontendMode_adjustRoute :: Bool\n    -- ^ The page can't use regular routes, so encode routes into the hash\n    -- instead\n  }\n\n-- | Run the frontend, setting the initial route to \"/\" on platforms where no\n-- route exists ambiently in the context (e.g. anything but web).\n-- Selects FrontendMode based on platform; this doesn't work for jsaddle-warp\nrunFrontend\n  :: forall backendRoute route\n  .  Encoder Identity Identity (R (FullRoute backendRoute route)) PageName\n  -> Frontend (R route)\n  -> JSM ()\nrunFrontend validFullEncoder frontend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate =\n#ifdef ghcjs_HOST_OS\n          True\n#else\n          False\n#endif\n        , _frontendMode_adjustRoute =\n#ifdef ghcjs_HOST_OS\n          False\n#else\n          True\n#endif\n        }\n  configs <- liftIO Lookup.getConfigs\n  when (_frontendMode_hydrate mode) removeHTMLConfigs\n  -- There's no fundamental reason that adjustRoute needs to control setting the\n  -- initial route and *also* the useHash parameter; that's why these are\n  -- separate here.  However, currently, they are always the same.\n  when (_frontendMode_adjustRoute mode) $ do\n    setInitialRoute $ _frontendMode_adjustRoute mode\n  runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n\nrunFrontendWithConfigsAndCurrentRoute\n  :: forall backendRoute frontendRoute\n  .  FrontendMode\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> Frontend (R frontendRoute)\n  -> JSM ()\nrunFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend = do\n  let ve = validFullEncoder . hoistParse errorLeft (reviewEncoder (rPrism $ _FullRoute_Frontend . _ObeliskRoute_App))\n      errorLeft = \\case\n        Left _ -> error \"runFrontend: Unexpected non-app ObeliskRoute reached the frontend. This shouldn't happen.\"\n        Right x -> Identity x\n      w :: ( RawDocument (DomBuilderSpace (HydrationDomBuilderT s DomTimeline m)) ~ DOM.Document\n           , Ref (Performable m) ~ Ref IO\n           , Ref m ~ Ref IO\n           , DomBuilder DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadHold DomTimeline m\n           , MonadRef m\n           , MonadRef (Performable m)\n           , MonadReflexCreateTrigger DomTimeline m\n           , PerformEvent DomTimeline m\n           , PostBuild DomTimeline m\n           , PrimMonad m\n           , MonadSample DomTimeline (Performable m)\n           , DOM.MonadJSM m\n           , MonadFix (Client (HydrationDomBuilderT s DomTimeline m))\n           , MonadFix (Performable m)\n           , MonadFix m\n           , Prerender DomTimeline (HydrationDomBuilderT s DomTimeline m)\n           , MonadIO (Performable m)\n           )\n        => (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> (forall c. HydrationDomBuilderT s DomTimeline m c -> FloatingWidget () c)\n        -> FloatingWidget () ()\n      w appendHead appendBody = do\n        rec switchover <- runRouteViewT ve switchover (_frontendMode_adjustRoute mode) $ do\n              (switchover'', fire) <- newTriggerEvent\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendHead . runConfigsT configs))) $ do\n                -- The order here is important - baseTag has to be before headWidget!\n                baseTag\n                _frontend_head frontend\n              mapRoutedT (mapSetRouteT (mapRouteToUrlT (appendBody . runConfigsT configs))) $ do\n                _frontend_body frontend\n                switchover' <- case _frontendMode_hydrate mode of\n                  True -> lift $ lift $ lift $ lift $ HydrationDomBuilderT $ asks _hydrationDomBuilderEnv_switchover\n                  False -> getPostBuild\n                performEvent_ $ liftIO (fire ()) <$ switchover'\n              pure switchover''\n        pure ()\n  if _frontendMode_hydrate mode\n    then runHydrationWidgetWithHeadAndBody (pure ()) w\n    else runImmediateWidgetWithHeadAndBody w\n\ntype FrontendWidgetT r = RoutedT DomTimeline r (SetRouteT DomTimeline r (RouteToUrlT r (ConfigsT (CookiesT (HydratableT (PostBuildT DomTimeline (StaticDomBuilderT DomTimeline (PerformEventT DomTimeline DomHost))))))))\n\nrenderFrontendHtml\n  :: MonadIO m\n  => Map Text ByteString\n  -> Cookies\n  -> (r -> Text)\n  -> r\n  -> Frontend r\n  -> FrontendWidgetT r ()\n  -> FrontendWidgetT r ()\n  -> m ByteString\nrenderFrontendHtml configs cookies urlEnc route frontend headExtra bodyExtra = do\n  --TODO: We should probably have a \"NullEventWriterT\" or a frozen reflex timeline\n  html <- fmap snd $ liftIO $ renderStatic $ runHydratableT $ fmap fst $ runCookiesT cookies $ runConfigsT configs $ flip runRouteToUrlT urlEnc $ runSetRouteT $ flip runRoutedT (pure route) $\n    el \"html\" $ do\n      el \"head\" $ do\n        baseTag\n        injectExecutableConfigs configs\n        _frontend_head frontend\n        headExtra\n      el \"body\" $ do\n        _frontend_body frontend\n        bodyExtra\n  return $ \"<!DOCTYPE html>\" <> html\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/route/src/Obelisk/Route/Frontend.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/route/src/Obelisk/Route/Frontend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 2,
                "sum": 45
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 1,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 24,
              "lines_of_code": 672,
              "homplexity_lines_of_code": 1244,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 2,
                  "sum": 45
                },
                "homplexity_loc": 1244,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"RoutedT\": 1,\n        \"routeLink\": 3,\n        \"routeLinkAttr\": 3,\n        \"routeLinkDynAttr\": 3,\n        \"routeLinkImpl\": 3,\n        \"routeLinkDynAttrImpl\": 3,\n        \"dynRouteLink\": 3,\n        \"dynRouteLinkImpl\": 3,\n        \"runRouteViewT\": 5,\n        \"subRoute_\": 2,\n        \"subPairRoute_\": 2,\n        \"subRoute\": 2,\n        \"subPairRoute\": 2,\n        \"maybeRoute_\": 2,\n        \"maybeRoute\": 2,\n        \"eitherRoute_\": 2,\n        \"eitherRoute\": 2,\n        \"strictDynWidget\": 1,\n        \"strictDynWidget_\": 1,\n        \"factorRouted\": 2,\n        \"maybeRouted\": 1,\n        \"eitherRouted\": 1,\n        \"scrollToTop\": 1,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 2.14,\n        \"sum\": 45\n    },\n    \"homplexity_loc\": 1244,\n    \"homplexity_output\": \"\"\n}\n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Obelisk.Route.Frontend\n  ( module Obelisk.Route\n  , pattern (:~)\n  , Routed\n  , RoutedT\n  , runRoutedT\n  , askRoute\n  , withRoutedT\n  , mapRoutedT\n  , subRoute\n  , subRoute_\n  , subPairRoute\n  , subPairRoute_\n  , maybeRoute\n  , maybeRoute_\n  , maybeRouted\n  , eitherRoute\n  , eitherRoute_\n  , eitherRouted\n  , runRouteViewT\n  , SetRouteT(..)\n  , SetRoute(..)\n  , runSetRouteT\n  , mapSetRouteT\n  , RouteToUrl(..)\n  , RouteToUrlT(..)\n  , runRouteToUrlT\n  , mapRouteToUrlT\n  , routeLink\n  , routeLinkAttr\n  , routeLinkDynAttr\n  , dynRouteLink\n  , adaptedUriPath\n  , setAdaptedUriPath\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad ((<=<))\n#endif\n#endif\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category (Category (..), (.))\nimport Control.Category.Cartesian ((&&&))\nimport Control.Lens hiding (Bifunctor, bimap, universe, element)\nimport Control.Monad.Fix\nimport Control.Monad.Morph\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Control\nimport Data.Coerce\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Functor.Compose\nimport Data.Functor.Misc\nimport Data.GADT.Compare\nimport qualified Data.List as L\nimport Data.Map as Map (Map, lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Type.Coercion\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.Window as Window\nimport Language.Javascript.JSaddle (MonadJSM, jsNull, liftJSM) --TODO: Get rid of this - other platforms can also be routed\nimport Network.URI\nimport Reflex.Class\nimport Reflex.Dom.Builder.Class\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Unsafe.Coerce\n\nimport Obelisk.Configs\nimport Obelisk.Route\n\ninfixr 5 :~\npattern (:~) :: Reflex t => f a -> Dynamic t a -> DSum f (Compose (Dynamic t) Identity)\npattern a :~ b <- a :=> (coerceDynamic . getCompose -> b)\n\nclass Routed t r m | m -> t r where\n  askRoute :: m (Dynamic t r)\n  default askRoute :: (Monad m', MonadTrans f, Routed t r m', m ~ f m') => m (Dynamic t r)\n  askRoute = lift askRoute\n\ninstance Monad m => Routed t r (RoutedT t r m) where\n  askRoute = RoutedT ask\n\ninstance (Monad m, Routed t r m) => Routed t r (ReaderT r' m)\n\nnewtype RoutedT t r m a = RoutedT { unRoutedT :: ReaderT (Dynamic t r) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadFix\n    , MonadTrans\n    , MFunctor\n    , NotReady t\n    , MonadHold t\n    , MonadSample t\n    , PostBuild t\n    , TriggerEvent t\n    , MonadIO\n    , MonadReflexCreateTrigger t\n    , HasDocument\n    , DomRenderHook t\n    )\n\ninstance MonadReader r' m => MonadReader r' (RoutedT t r m) where\n  ask = lift ask\n  local = mapRoutedT . local\n\ninstance (Prerender t m, Monad m) => Prerender t (RoutedT t r m) where\n  type Client (RoutedT t r m) = RoutedT t r (Client m)\n  prerender server client = RoutedT $ do\n    r <- ask\n    lift $ prerender (runRoutedT server r) (runRoutedT client r)\n\ninstance Requester t m => Requester t (RoutedT t r m) where\n  type Request (RoutedT t r m) = Request m\n  type Response (RoutedT t r m) = Response m\n  requesting = RoutedT . requesting\n  requesting_ = RoutedT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RoutedT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RoutedT t r m) where\n  type Performable (RoutedT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RoutedT t r m) where\n  type Ref (RoutedT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\nderiving instance EventWriter t w m => EventWriter t w (RoutedT t r m)\n\ninstance MonadTransControl (RoutedT t r) where\n  type StT (RoutedT t r) a = StT (ReaderT (Dynamic t r)) a\n  liftWith = defaultLiftWith RoutedT unRoutedT\n  restoreT = defaultRestoreT RoutedT\n\ninstance PrimMonad m => PrimMonad (RoutedT t r m ) where\n  type PrimState (RoutedT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RoutedT t r m) where\n  type DomBuilderSpace (RoutedT t r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RoutedT t r m) where\n  runWithReplace a0 a' = RoutedT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RoutedT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RoutedT t r m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (QueryT t q m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (QueryT t q m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (EventWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (EventWriterT t w m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (DynamicWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (DynamicWriterT t w m)\n\nrunRoutedT :: RoutedT t r m a -> Dynamic t r -> m a\nrunRoutedT = runReaderT . unRoutedT\n\nmapRoutedT :: (m a -> n b) -> RoutedT t r m a -> RoutedT t r n b\nmapRoutedT f = RoutedT . mapReaderT f . unRoutedT\n\nwithRoutedT :: (Dynamic t r -> Dynamic t r') -> RoutedT t r' m a -> RoutedT t r m a\nwithRoutedT f = RoutedT . withReaderT f . unRoutedT\n\nsubRoute_ :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m ()) -> RoutedT t (R r) m ()\nsubRoute_ f = factorRouted $ strictDynWidget_ $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute_ :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m ()) -> RoutedT t (a, b) m ()\nsubPairRoute_ f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute_ (\\(Const2 a) -> f a)\n\nsubRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m b) -> RoutedT t (R r) m (Dynamic t b)\nsubRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m c) -> RoutedT t (a, b) m (Dynamic t c)\nsubPairRoute f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute (\\(Const2 a) -> f a)\n\nmaybeRoute_ :: (MonadFix m, MonadHold t m, Adjustable t m) => m () -> RoutedT t r m () -> RoutedT t (Maybe r) m ()\nmaybeRoute_ n j = maybeRouted $ strictDynWidget_ $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\nmaybeRoute :: (MonadFix m, MonadHold t m, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m (Dynamic t a)\nmaybeRoute n j = maybeRouted $ strictDynWidget $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\n{-\nmaybeRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m a\nmaybeRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n-}\n\neitherRoute_\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m ()\n  -> RoutedT t r m ()\n  -> RoutedT t (Either l r) m ()\neitherRoute_ l r = eitherRouted $ strictDynWidget_ $ either (runRoutedT l) (runRoutedT r)\n\neitherRoute\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m a\n  -> RoutedT t r m a\n  -> RoutedT t (Either l r) m (Dynamic t a)\neitherRoute l r = eitherRouted $ strictDynWidget $ either (runRoutedT l) (runRoutedT r)\n\ndsumValueCoercion :: Coercion f g -> Coercion (DSum k f) (DSum k g)\ndsumValueCoercion Coercion = Coercion\n\ndynamicIdentityCoercion :: Coercion (Compose (Dynamic t) Identity) (Dynamic t)\ndynamicIdentityCoercion = unsafeCoerce (Coercion :: Coercion (Identity ()) ()) --TODO: Is it possible to prove this?\n\nfactorRouted :: (Reflex t, MonadFix m, MonadHold t m, GEq f) => RoutedT t (DSum f (Dynamic t)) m a -> RoutedT t (DSum f Identity) m a\nfactorRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- factorDyn d\n  runRoutedT r $ coerceWith (dynamicCoercion $ dsumValueCoercion dynamicIdentityCoercion) d'\n\nmaybeRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Maybe (Dynamic t a)) m b -> RoutedT t (Maybe a) m b\nmaybeRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- maybeDyn d\n  runRoutedT r d'\n\neitherRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Either (Dynamic t a) (Dynamic t b)) m c -> RoutedT t (Either a b) m c\neitherRouted r = RoutedT $ ReaderT $ runRoutedT r <=< eitherDyn\n\n-- | WARNING: The input 'Dynamic' must be fully constructed when this is run\nstrictDynWidget :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m b) -> RoutedT t a m (Dynamic t b)\nstrictDynWidget f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (result0, result') <- runWithReplace (f r0) $ f <$> updated r\n  holdDyn result0 result'\n\nstrictDynWidget_ :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m ()) -> RoutedT t a m ()\nstrictDynWidget_ f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (_, _) <- runWithReplace (f r0) $ f <$> updated r\n  pure ()\n\nnewtype SetRouteT t r m a = SetRouteT { unSetRouteT :: EventWriterT t (Endo r) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, MonadIO, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\ninstance (MonadFix m, MonadHold t m, DomBuilder t m) => DomBuilder t (SetRouteT t r m) where\n  type DomBuilderSpace (SetRouteT t r m) = DomBuilderSpace m\n  element t cfg child = SetRouteT $ element t cfg $ unSetRouteT child\n  inputElement = lift . inputElement\n  textAreaElement = lift . textAreaElement\n  selectElement cfg child = SetRouteT $ selectElement cfg $ unSetRouteT child\n\nmapSetRouteT :: (forall x. m x -> n x) -> SetRouteT t r m a -> SetRouteT t r n a\nmapSetRouteT f (SetRouteT x) = SetRouteT (mapEventWriterT f x)\n\nrunSetRouteT :: (Reflex t, Monad m) => SetRouteT t r m a -> m (a, Event t (Endo r))\nrunSetRouteT = runEventWriterT . unSetRouteT\n\nclass Reflex t => SetRoute t r m | m -> t r where\n  setRoute :: Event t r -> m ()\n  modifyRoute :: Event t (r -> r) -> m ()\n  default modifyRoute :: (Monad m', MonadTrans f, SetRoute t r m', m ~ f m') => Event t (r -> r) -> m ()\n  modifyRoute = lift . modifyRoute\n\n  setRoute = modifyRoute . fmap const\n\ninstance (Reflex t, Monad m) => SetRoute t r (SetRouteT t r m) where\n  modifyRoute = SetRouteT . tellEvent . fmap Endo\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RoutedT t r' m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (ReaderT r' m)\n\ninstance (PerformEvent t m, Prerender t m, Monad m, Reflex t) => Prerender t (SetRouteT t r m) where\n  type Client (SetRouteT t r m) = SetRouteT t r (Client m)\n  prerender server client = do\n    d <- lift $ prerender (runSetRouteT server) (runSetRouteT client)\n    let (a, r) = splitDynPure d\n    -- Must be prompt here\n    SetRouteT . tellEvent $ switchPromptlyDyn r\n    pure a\n\ninstance Requester t m => Requester t (SetRouteT t r m) where\n  type Request (SetRouteT t r m) = Request m\n  type Response (SetRouteT t r m) = Response m\n  requesting = SetRouteT . requesting\n  requesting_ = SetRouteT . requesting_\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RequesterT t req rsp m)\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (SetRouteT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (SetRouteT t r m) where\n  type Performable (SetRouteT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (SetRouteT t r m) where\n  type Ref (SetRouteT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance PrimMonad m => PrimMonad (SetRouteT t r m ) where\n  type PrimState (SetRouteT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance HasConfigs m => HasConfigs (SetRouteT t r m)\n\ninstance (MonadHold t m, Adjustable t m) => Adjustable t (SetRouteT t r m) where\n  runWithReplace a0 a' = SetRouteT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (SetRouteT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\nclass RouteToUrl r m | m -> r where\n  askRouteToUrl :: m (r -> Text)\n  default askRouteToUrl :: (Monad m', MonadTrans f, RouteToUrl r m', m ~ f m') => m (r -> Text)\n  askRouteToUrl = lift askRouteToUrl\n\nnewtype RouteToUrlT r m a = RouteToUrlT { unRouteToUrlT :: ReaderT (r -> Text) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadIO, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\nrunRouteToUrlT\n  :: RouteToUrlT r m a\n  -> (r -> Text)\n  -> m a\nrunRouteToUrlT a = runReaderT (unRouteToUrlT a)\n\nmapRouteToUrlT :: (forall x. m x -> n x) -> RouteToUrlT r m a -> RouteToUrlT r n a\nmapRouteToUrlT f (RouteToUrlT m) = RouteToUrlT $ mapReaderT f m\n\ninstance Monad m => RouteToUrl r (RouteToUrlT r m) where\n  askRouteToUrl = RouteToUrlT ask\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (SetRouteT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RoutedT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (ReaderT r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RequesterT t req rsp m)\n\ninstance (Prerender t m, Monad m) => Prerender t (RouteToUrlT r m) where\n  type Client (RouteToUrlT r m) = RouteToUrlT r (Client m)\n  prerender server client = do\n    r <- RouteToUrlT ask\n    lift $ prerender (runRouteToUrlT server r) (runRouteToUrlT client r)\n\ninstance Requester t m => Requester t (RouteToUrlT r m) where\n  type Request (RouteToUrlT r m) = Request m\n  type Response (RouteToUrlT r m) = Response m\n  requesting = RouteToUrlT . requesting\n  requesting_ = RouteToUrlT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RouteToUrlT r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RouteToUrlT r m) where\n  type Performable (RouteToUrlT r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RouteToUrlT r m) where\n  type Ref (RouteToUrlT r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance MonadTransControl (RouteToUrlT r) where\n  type StT (RouteToUrlT r) a = StT (ReaderT (r -> Text)) a\n  liftWith = defaultLiftWith RouteToUrlT unRouteToUrlT\n  restoreT = defaultRestoreT RouteToUrlT\n\ninstance PrimMonad m => PrimMonad (RouteToUrlT r m ) where\n  type PrimState (RouteToUrlT r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RouteToUrlT r m) where\n  type DomBuilderSpace (RouteToUrlT r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RouteToUrlT r m) where\n  runWithReplace a0 a' = RouteToUrlT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RouteToUrlT r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RouteToUrlT t m)\n\nrunRouteViewT\n  :: forall t m r a.\n     ( TriggerEvent t m\n     , PerformEvent t m\n     , MonadHold t m\n     , MonadJSM m\n     , MonadJSM (Performable m)\n     , MonadFix m\n     )\n  => Encoder Identity Identity r PageName\n  --TODO: Get rid of the switchover and useHash arguments\n  -- useHash can probably be baked into the encoder\n  -> Event t () -- ^ Switchover event, nothing is done until this event fires. Used to prevent incorrect DOM expectations at hydration switchover time\n  -> Bool\n  -> RoutedT t r (SetRouteT t r (RouteToUrlT r m)) a\n  -> m a\nrunRouteViewT routeEncoder switchover useHash a = do\n  rec historyState <- manageHistory' switchover $ HistoryCommand_PushState <$> setState\n      let theEncoder = pageNameEncoder . hoistParse (pure . runIdentity) routeEncoder\n          -- NB: The can only fail if the uriPath doesn't begin with a '/' or if the uriQuery\n          -- is nonempty, but begins with a character that isn't '?'. Since we don't expect\n          -- this ever to happen, we'll just handle it by failing completely with 'error'.\n          route :: Dynamic t r\n          route = fmap (errorLeft . tryDecode theEncoder . (adaptedUriPath useHash &&& uriQuery) . _historyItem_uri) historyState\n            where\n              errorLeft (Left e) = error (T.unpack e)\n              errorLeft (Right x) = x\n      (result, changeState) <- runRouteToUrlT (runSetRouteT $ runRoutedT a route) $ (\\(p, q) -> T.pack $ p <> q) . encode theEncoder\n      let f (currentHistoryState, oldRoute) change =\n            let newRoute = appEndo change oldRoute\n                (newPath, newQuery) = encode theEncoder newRoute\n            in HistoryStateUpdate\n               { _historyStateUpdate_state = DOM.SerializedScriptValue jsNull\n                 -- We always provide \"\" as the title.  On Firefox, Chrome, and\n                 -- Edge, this parameter does nothing.  On Safari, \"\" has the\n                 -- same behavior as other browsers (as far as I can tell), but\n                 -- anything else sets the title for the back button list item\n                 -- the *next* time pushState is called, unless the page title\n                 -- is changed in the interim.  Since the Safari functionality\n                 -- is near-pointless and also confusing, I'm not going to even\n                 -- bother exposing it; if there ends up being a real use case,\n                 -- we can change this function later to accommodate.\n                 -- See: https://github.com/whatwg/html/issues/2174\n               , _historyStateUpdate_title = \"\"\n               , _historyStateUpdate_uri = Just $ setAdaptedUriPath useHash newPath $ (_historyItem_uri currentHistoryState)\n                 { uriQuery = newQuery\n                 }\n               }\n          setState = attachWith f ((,) <$> current historyState <*> current route) changeState\n  return result\n\n-- | A link widget that, when clicked, sets the route to the provided route. In non-javascript\n-- contexts, this widget falls back to using @href@s to control navigation\nrouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLink r w = do\n  (e, a) <- routeLinkImpl mempty r w\n  scrollToTop e\n  return a\n\n-- | Like 'routeLink', but takes additional attributes as argument.\n--\nrouteLinkAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Map AttributeName Text -- ^ Additional attributes\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLinkAttr attrs r w = do\n  (e, a) <- routeLinkImpl attrs r w\n  let\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n  when (not targetBlank) $ scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLink'. Does not scroll to the top of the page on clicks.\nrouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Map AttributeName Text\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\nrouteLinkImpl attrs r w = do\n  enc <- askRouteToUrl\n  let\n    -- If targetBlank == True, the link will be opened in another page. In that\n    -- case, we don't prevent the default behaviour, and we don't need to\n    -- setRoute.\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n    cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_initialAttributes .~ (\"href\" =: enc r <> attrs)\n        & (if targetBlank\n           then id\n           else elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault))\n  (e, a) <- element \"a\" cfg w\n  when (not targetBlank) $ setRoute $ r <$ domEvent Click e\n  return (domEvent Click e, a)\n\nscrollToTop :: forall m t. (Prerender t m, Monad m) => Event t () -> m ()\nscrollToTop e = prerender_ blank $ performEvent_ $ ffor e $ \\_ -> liftJSM $ DOM.currentWindow >>= \\case\n  Nothing -> pure ()\n  Just win -> Window.scrollTo win 0 0\n\n-- | Like 'routeLinkDynAttr' but without custom attributes.\ndynRouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\ndynRouteLink r w = do\n  (e, a) <- dynRouteLinkImpl r w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'dynRouteLink'. Does not scroll to the top of the page on clicks.\ndynRouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\ndynRouteLinkImpl dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ (\"href\" =:) . enc <$> dr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- | An @a@-tag link widget that, when clicked, sets the route to current value of the\n-- provided dynamic route. In non-JavaScript contexts the value of the dynamic post\n-- build is used so the link still works like 'routeLink'.\nrouteLinkDynAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     , Prerender t m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m a\nrouteLinkDynAttr dAttr dr w = do\n  (e, a) <- routeLinkDynAttrImpl dAttr dr w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLinkDynAttr'. Does not scroll to the top of the page on clicks.\nrouteLinkDynAttrImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m (Event t (), a)\nrouteLinkDynAttrImpl dAttr dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ zipDynWith (<>) ((\"href\" =:) . enc <$> dr) dAttr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- On ios due to sandboxing when loading the page from a file adapt the\n-- path to be based on the hash.\n\nadaptedUriPath :: Bool -> URI -> String\nadaptedUriPath = \\case\n  True -> hashToPath . uriFragment\n  False -> uriPath\n\nsetAdaptedUriPath :: Bool -> String -> URI -> URI\nsetAdaptedUriPath useHash s u = case useHash of\n  True -> u { uriFragment = pathToHash s }\n  False -> u { uriPath = s }\n\npathToHash :: String -> String\npathToHash = ('#' :) . fromMaybe \"\" . L.stripPrefix \"/\"\n\nhashToPath :: String -> String\nhashToPath = ('/' :) . fromMaybe \"\" . L.stripPrefix \"#\"\n",
              "suggestions": [
                {
                  "target_snippet": "case useHash of\n    True -> u {uriFragment = pathToHash s}\n    False -> u {uriPath = s}",
                  "refactored_suggestion": "if useHash then u {uriFragment = pathToHash s} else u {uriPath = s}",
                  "confidence": 1.0,
                  "justification": "Using `if-then-else` for straightforward boolean cases improves readability and conciseness."
                },
                {
                  "target_snippet": "-- The commented-out duplicate of `maybeRoute` implementation",
                  "refactored_suggestion": "-- This implementation is duplicated and commented out: `maybeRoute`. Removing it improves code clarity\n-- Reason: Remove unnecessary commented-out code as it does not add value and can confuse future readers.",
                  "confidence": 0.9,
                  "justification": "The commented-out implementation of `maybeRoute` serves no purpose and removing it will reduce noise in the code, making it easier to maintain."
                },
                {
                  "target_snippet": "dynamicIdentityCoercion = unsafeCoerce (Coercion :: Coercion (Identity ()) ())",
                  "refactored_suggestion": "-- Reason: This line uses `unsafeCoerce`, which defeats Haskell's strong type safety. Consider replacing with a provably safe coercion or explaining why this is necessary with comments.",
                  "confidence": 0.7,
                  "justification": "Unsafe coercions should be avoided unless absolutely necessary. Adding comments explaining why unsafe coerce is safe in this context or replacing it with a safer alternative makes the intent clear."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecursiveDo #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Obelisk.Route.Frontend\n  ( module Obelisk.Route\n  , pattern (:~)\n  , Routed\n  , RoutedT\n  , runRoutedT\n  , askRoute\n  , withRoutedT\n  , mapRoutedT\n  , subRoute\n  , subRoute_\n  , subPairRoute\n  , subPairRoute_\n  , maybeRoute\n  , maybeRoute_\n  , maybeRouted\n  , eitherRoute\n  , eitherRoute_\n  , eitherRouted\n  , runRouteViewT\n  , SetRouteT(..)\n  , SetRoute(..)\n  , runSetRouteT\n  , mapSetRouteT\n  , RouteToUrl(..)\n  , RouteToUrlT(..)\n  , runRouteToUrlT\n  , mapRouteToUrlT\n  , routeLink\n  , routeLinkAttr\n  , routeLinkDynAttr\n  , dynRouteLink\n  , adaptedUriPath\n  , setAdaptedUriPath\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad ((<=<))\n#endif\n#endif\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category (Category (..), (.))\nimport Control.Category.Cartesian ((&&&))\nimport Control.Lens hiding (Bifunctor, bimap, universe, element)\nimport Control.Monad.Fix\nimport Control.Monad.Morph\nimport Control.Monad.Primitive\nimport Control.Monad.Reader\nimport Control.Monad.Ref\nimport Control.Monad.Trans.Control\nimport Data.Coerce\nimport Data.Dependent.Sum (DSum (..))\nimport Data.Functor.Compose\nimport Data.Functor.Misc\nimport Data.GADT.Compare\nimport qualified Data.List as L\nimport Data.Map as Map (Map, lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Type.Coercion\nimport qualified GHCJS.DOM as DOM\nimport qualified GHCJS.DOM.Types as DOM\nimport qualified GHCJS.DOM.Window as Window\nimport Language.Javascript.JSaddle (MonadJSM, jsNull, liftJSM) --TODO: Get rid of this - other platforms can also be routed\nimport Network.URI\nimport Reflex.Class\nimport Reflex.Dom.Builder.Class\nimport Reflex.Dom.Core\nimport Reflex.Host.Class\nimport Unsafe.Coerce\n\nimport Obelisk.Configs\nimport Obelisk.Route\n\ninfixr 5 :~\npattern (:~) :: Reflex t => f a -> Dynamic t a -> DSum f (Compose (Dynamic t) Identity)\npattern a :~ b <- a :=> (coerceDynamic . getCompose -> b)\n\nclass Routed t r m | m -> t r where\n  askRoute :: m (Dynamic t r)\n  default askRoute :: (Monad m', MonadTrans f, Routed t r m', m ~ f m') => m (Dynamic t r)\n  askRoute = lift askRoute\n\ninstance Monad m => Routed t r (RoutedT t r m) where\n  askRoute = RoutedT ask\n\ninstance (Monad m, Routed t r m) => Routed t r (ReaderT r' m)\n\nnewtype RoutedT t r m a = RoutedT { unRoutedT :: ReaderT (Dynamic t r) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadFix\n    , MonadTrans\n    , MFunctor\n    , NotReady t\n    , MonadHold t\n    , MonadSample t\n    , PostBuild t\n    , TriggerEvent t\n    , MonadIO\n    , MonadReflexCreateTrigger t\n    , HasDocument\n    , DomRenderHook t\n    )\n\ninstance MonadReader r' m => MonadReader r' (RoutedT t r m) where\n  ask = lift ask\n  local = mapRoutedT . local\n\ninstance (Prerender t m, Monad m) => Prerender t (RoutedT t r m) where\n  type Client (RoutedT t r m) = RoutedT t r (Client m)\n  prerender server client = RoutedT $ do\n    r <- ask\n    lift $ prerender (runRoutedT server r) (runRoutedT client r)\n\ninstance Requester t m => Requester t (RoutedT t r m) where\n  type Request (RoutedT t r m) = Request m\n  type Response (RoutedT t r m) = Response m\n  requesting = RoutedT . requesting\n  requesting_ = RoutedT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RoutedT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RoutedT t r m) where\n  type Performable (RoutedT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RoutedT t r m) where\n  type Ref (RoutedT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\nderiving instance EventWriter t w m => EventWriter t w (RoutedT t r m)\n\ninstance MonadTransControl (RoutedT t r) where\n  type StT (RoutedT t r) a = StT (ReaderT (Dynamic t r)) a\n  liftWith = defaultLiftWith RoutedT unRoutedT\n  restoreT = defaultRestoreT RoutedT\n\ninstance PrimMonad m => PrimMonad (RoutedT t r m ) where\n  type PrimState (RoutedT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RoutedT t r m) where\n  type DomBuilderSpace (RoutedT t r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RoutedT t r m) where\n  runWithReplace a0 a' = RoutedT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RoutedT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RoutedT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RoutedT t r m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (QueryT t q m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (QueryT t q m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (EventWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (EventWriterT t w m)\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (DynamicWriterT t w m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (DynamicWriterT t w m)\n\nrunRoutedT :: RoutedT t r m a -> Dynamic t r -> m a\nrunRoutedT = runReaderT . unRoutedT\n\nmapRoutedT :: (m a -> n b) -> RoutedT t r m a -> RoutedT t r n b\nmapRoutedT f = RoutedT . mapReaderT f . unRoutedT\n\nwithRoutedT :: (Dynamic t r -> Dynamic t r') -> RoutedT t r' m a -> RoutedT t r m a\nwithRoutedT f = RoutedT . withReaderT f . unRoutedT\n\nsubRoute_ :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m ()) -> RoutedT t (R r) m ()\nsubRoute_ f = factorRouted $ strictDynWidget_ $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute_ :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m ()) -> RoutedT t (a, b) m ()\nsubPairRoute_ f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute_ (\\(Const2 a) -> f a)\n\nsubRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => (forall a. r a -> RoutedT t a m b) -> RoutedT t (R r) m (Dynamic t b)\nsubRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n\n-- | Like 'subRoute_', but with a pair rather than an R\nsubPairRoute :: (MonadFix m, MonadHold t m, Eq a, Adjustable t m) => (a -> RoutedT t b m c) -> RoutedT t (a, b) m (Dynamic t c)\nsubPairRoute f = withRoutedT (fmap (\\(a, b) -> Const2 a :/ b)) $ subRoute (\\(Const2 a) -> f a)\n\nmaybeRoute_ :: (MonadFix m, MonadHold t m, Adjustable t m) => m () -> RoutedT t r m () -> RoutedT t (Maybe r) m ()\nmaybeRoute_ n j = maybeRouted $ strictDynWidget_ $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\nmaybeRoute :: (MonadFix m, MonadHold t m, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m (Dynamic t a)\nmaybeRoute n j = maybeRouted $ strictDynWidget $ \\case\n  Nothing -> n\n  Just r -> runRoutedT j r\n\n{-\nmaybeRoute :: (MonadFix m, MonadHold t m, GEq r, Adjustable t m) => m a -> RoutedT t r m a -> RoutedT t (Maybe r) m a\nmaybeRoute f = factorRouted $ strictDynWidget $ \\(c :=> r') -> do\n  runRoutedT (f c) r'\n-}\n\neitherRoute_\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m ()\n  -> RoutedT t r m ()\n  -> RoutedT t (Either l r) m ()\neitherRoute_ l r = eitherRouted $ strictDynWidget_ $ either (runRoutedT l) (runRoutedT r)\n\neitherRoute\n  :: (MonadFix m, MonadHold t m, Adjustable t m)\n  => RoutedT t l m a\n  -> RoutedT t r m a\n  -> RoutedT t (Either l r) m (Dynamic t a)\neitherRoute l r = eitherRouted $ strictDynWidget $ either (runRoutedT l) (runRoutedT r)\n\ndsumValueCoercion :: Coercion f g -> Coercion (DSum k f) (DSum k g)\ndsumValueCoercion Coercion = Coercion\n\ndynamicIdentityCoercion :: Coercion (Compose (Dynamic t) Identity) (Dynamic t)\n-- Reason: This line uses `unsafeCoerce`, which defeats Haskell's strong type safety. Consider replacing with a provably safe coercion or explaining why this is necessary with comments. --TODO: Is it possible to prove this?\n\nfactorRouted :: (Reflex t, MonadFix m, MonadHold t m, GEq f) => RoutedT t (DSum f (Dynamic t)) m a -> RoutedT t (DSum f Identity) m a\nfactorRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- factorDyn d\n  runRoutedT r $ coerceWith (dynamicCoercion $ dsumValueCoercion dynamicIdentityCoercion) d'\n\nmaybeRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Maybe (Dynamic t a)) m b -> RoutedT t (Maybe a) m b\nmaybeRouted r = RoutedT $ ReaderT $ \\d -> do\n  d' <- maybeDyn d\n  runRoutedT r d'\n\neitherRouted :: (Reflex t, MonadFix m, MonadHold t m) => RoutedT t (Either (Dynamic t a) (Dynamic t b)) m c -> RoutedT t (Either a b) m c\neitherRouted r = RoutedT $ ReaderT $ runRoutedT r <=< eitherDyn\n\n-- | WARNING: The input 'Dynamic' must be fully constructed when this is run\nstrictDynWidget :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m b) -> RoutedT t a m (Dynamic t b)\nstrictDynWidget f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (result0, result') <- runWithReplace (f r0) $ f <$> updated r\n  holdDyn result0 result'\n\nstrictDynWidget_ :: (MonadSample t m, MonadHold t m, Adjustable t m) => (a -> m ()) -> RoutedT t a m ()\nstrictDynWidget_ f = RoutedT $ ReaderT $ \\r -> do\n  r0 <- sample $ current r\n  (_, _) <- runWithReplace (f r0) $ f <$> updated r\n  pure ()\n\nnewtype SetRouteT t r m a = SetRouteT { unSetRouteT :: EventWriterT t (Endo r) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, MonadIO, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\ninstance (MonadFix m, MonadHold t m, DomBuilder t m) => DomBuilder t (SetRouteT t r m) where\n  type DomBuilderSpace (SetRouteT t r m) = DomBuilderSpace m\n  element t cfg child = SetRouteT $ element t cfg $ unSetRouteT child\n  inputElement = lift . inputElement\n  textAreaElement = lift . textAreaElement\n  selectElement cfg child = SetRouteT $ selectElement cfg $ unSetRouteT child\n\nmapSetRouteT :: (forall x. m x -> n x) -> SetRouteT t r m a -> SetRouteT t r n a\nmapSetRouteT f (SetRouteT x) = SetRouteT (mapEventWriterT f x)\n\nrunSetRouteT :: (Reflex t, Monad m) => SetRouteT t r m a -> m (a, Event t (Endo r))\nrunSetRouteT = runEventWriterT . unSetRouteT\n\nclass Reflex t => SetRoute t r m | m -> t r where\n  setRoute :: Event t r -> m ()\n  modifyRoute :: Event t (r -> r) -> m ()\n  default modifyRoute :: (Monad m', MonadTrans f, SetRoute t r m', m ~ f m') => Event t (r -> r) -> m ()\n  modifyRoute = lift . modifyRoute\n\n  setRoute = modifyRoute . fmap const\n\ninstance (Reflex t, Monad m) => SetRoute t r (SetRouteT t r m) where\n  modifyRoute = SetRouteT . tellEvent . fmap Endo\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RoutedT t r' m)\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (ReaderT r' m)\n\ninstance (PerformEvent t m, Prerender t m, Monad m, Reflex t) => Prerender t (SetRouteT t r m) where\n  type Client (SetRouteT t r m) = SetRouteT t r (Client m)\n  prerender server client = do\n    d <- lift $ prerender (runSetRouteT server) (runSetRouteT client)\n    let (a, r) = splitDynPure d\n    -- Must be prompt here\n    SetRouteT . tellEvent $ switchPromptlyDyn r\n    pure a\n\ninstance Requester t m => Requester t (SetRouteT t r m) where\n  type Request (SetRouteT t r m) = Request m\n  type Response (SetRouteT t r m) = Response m\n  requesting = SetRouteT . requesting\n  requesting_ = SetRouteT . requesting_\n\ninstance (Monad m, SetRoute t r m) => SetRoute t r (RequesterT t req rsp m)\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (SetRouteT t r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (SetRouteT t r m) where\n  type Performable (SetRouteT t r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (SetRouteT t r m) where\n  type Ref (SetRouteT t r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance PrimMonad m => PrimMonad (SetRouteT t r m ) where\n  type PrimState (SetRouteT t r m) = PrimState m\n  primitive = lift . primitive\n\ninstance HasConfigs m => HasConfigs (SetRouteT t r m)\n\ninstance (MonadHold t m, Adjustable t m) => Adjustable t (SetRouteT t r m) where\n  runWithReplace a0 a' = SetRouteT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = SetRouteT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (SetRouteT t r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\nclass RouteToUrl r m | m -> r where\n  askRouteToUrl :: m (r -> Text)\n  default askRouteToUrl :: (Monad m', MonadTrans f, RouteToUrl r m', m ~ f m') => m (r -> Text)\n  askRouteToUrl = lift askRouteToUrl\n\nnewtype RouteToUrlT r m a = RouteToUrlT { unRouteToUrlT :: ReaderT (r -> Text) m a }\n  deriving (Functor, Applicative, Monad, MonadFix, MonadTrans, NotReady t, MonadHold t, MonadSample t, PostBuild t, TriggerEvent t, MonadIO, MonadReflexCreateTrigger t, HasDocument, DomRenderHook t)\n\nrunRouteToUrlT\n  :: RouteToUrlT r m a\n  -> (r -> Text)\n  -> m a\nrunRouteToUrlT a = runReaderT (unRouteToUrlT a)\n\nmapRouteToUrlT :: (forall x. m x -> n x) -> RouteToUrlT r m a -> RouteToUrlT r n a\nmapRouteToUrlT f (RouteToUrlT m) = RouteToUrlT $ mapReaderT f m\n\ninstance Monad m => RouteToUrl r (RouteToUrlT r m) where\n  askRouteToUrl = RouteToUrlT ask\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (SetRouteT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RoutedT t r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (ReaderT r' m) where\n\ninstance (Monad m, RouteToUrl r m) => RouteToUrl r (RequesterT t req rsp m)\n\ninstance (Prerender t m, Monad m) => Prerender t (RouteToUrlT r m) where\n  type Client (RouteToUrlT r m) = RouteToUrlT r (Client m)\n  prerender server client = do\n    r <- RouteToUrlT ask\n    lift $ prerender (runRouteToUrlT server r) (runRouteToUrlT client r)\n\ninstance Requester t m => Requester t (RouteToUrlT r m) where\n  type Request (RouteToUrlT r m) = Request m\n  type Response (RouteToUrlT r m) = Response m\n  requesting = RouteToUrlT . requesting\n  requesting_ = RouteToUrlT . requesting_\n\n#ifndef ghcjs_HOST_OS\nderiving instance MonadJSM m => MonadJSM (RouteToUrlT r m)\n#endif\n\ninstance PerformEvent t m => PerformEvent t (RouteToUrlT r m) where\n  type Performable (RouteToUrlT r m) = Performable m\n  performEvent = lift . performEvent\n  performEvent_ = lift . performEvent_\n\ninstance MonadRef m => MonadRef (RouteToUrlT r m) where\n  type Ref (RouteToUrlT r m) = Ref m\n  newRef = lift . newRef\n  readRef = lift . readRef\n  writeRef r = lift . writeRef r\n\ninstance MonadTransControl (RouteToUrlT r) where\n  type StT (RouteToUrlT r) a = StT (ReaderT (r -> Text)) a\n  liftWith = defaultLiftWith RouteToUrlT unRouteToUrlT\n  restoreT = defaultRestoreT RouteToUrlT\n\ninstance PrimMonad m => PrimMonad (RouteToUrlT r m ) where\n  type PrimState (RouteToUrlT r m) = PrimState m\n  primitive = lift . primitive\n\ninstance DomBuilder t m => DomBuilder t (RouteToUrlT r m) where\n  type DomBuilderSpace (RouteToUrlT r m) = DomBuilderSpace m\n\ninstance Adjustable t m => Adjustable t (RouteToUrlT r m) where\n  runWithReplace a0 a' = RouteToUrlT $ runWithReplace (coerce a0) $ coerceEvent a'\n  traverseIntMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseIntMapWithKeyWithAdjust (coerce f) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjust f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjust (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n  traverseDMapWithKeyWithAdjustWithMove f a0 a' = RouteToUrlT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> coerce $ f k v) (coerce a0) $ coerce a'\n\ninstance (Monad m, MonadQuery t vs m) => MonadQuery t vs (RouteToUrlT r m) where\n  tellQueryIncremental = lift . tellQueryIncremental\n  askQueryResult = lift askQueryResult\n  queryIncremental = lift . queryIncremental\n\ninstance HasConfigs m => HasConfigs (RouteToUrlT t m)\n\nrunRouteViewT\n  :: forall t m r a.\n     ( TriggerEvent t m\n     , PerformEvent t m\n     , MonadHold t m\n     , MonadJSM m\n     , MonadJSM (Performable m)\n     , MonadFix m\n     )\n  => Encoder Identity Identity r PageName\n  --TODO: Get rid of the switchover and useHash arguments\n  -- useHash can probably be baked into the encoder\n  -> Event t () -- ^ Switchover event, nothing is done until this event fires. Used to prevent incorrect DOM expectations at hydration switchover time\n  -> Bool\n  -> RoutedT t r (SetRouteT t r (RouteToUrlT r m)) a\n  -> m a\nrunRouteViewT routeEncoder switchover useHash a = do\n  rec historyState <- manageHistory' switchover $ HistoryCommand_PushState <$> setState\n      let theEncoder = pageNameEncoder . hoistParse (pure . runIdentity) routeEncoder\n          -- NB: The can only fail if the uriPath doesn't begin with a '/' or if the uriQuery\n          -- is nonempty, but begins with a character that isn't '?'. Since we don't expect\n          -- this ever to happen, we'll just handle it by failing completely with 'error'.\n          route :: Dynamic t r\n          route = fmap (errorLeft . tryDecode theEncoder . (adaptedUriPath useHash &&& uriQuery) . _historyItem_uri) historyState\n            where\n              errorLeft (Left e) = error (T.unpack e)\n              errorLeft (Right x) = x\n      (result, changeState) <- runRouteToUrlT (runSetRouteT $ runRoutedT a route) $ (\\(p, q) -> T.pack $ p <> q) . encode theEncoder\n      let f (currentHistoryState, oldRoute) change =\n            let newRoute = appEndo change oldRoute\n                (newPath, newQuery) = encode theEncoder newRoute\n            in HistoryStateUpdate\n               { _historyStateUpdate_state = DOM.SerializedScriptValue jsNull\n                 -- We always provide \"\" as the title.  On Firefox, Chrome, and\n                 -- Edge, this parameter does nothing.  On Safari, \"\" has the\n                 -- same behavior as other browsers (as far as I can tell), but\n                 -- anything else sets the title for the back button list item\n                 -- the *next* time pushState is called, unless the page title\n                 -- is changed in the interim.  Since the Safari functionality\n                 -- is near-pointless and also confusing, I'm not going to even\n                 -- bother exposing it; if there ends up being a real use case,\n                 -- we can change this function later to accommodate.\n                 -- See: https://github.com/whatwg/html/issues/2174\n               , _historyStateUpdate_title = \"\"\n               , _historyStateUpdate_uri = Just $ setAdaptedUriPath useHash newPath $ (_historyItem_uri currentHistoryState)\n                 { uriQuery = newQuery\n                 }\n               }\n          setState = attachWith f ((,) <$> current historyState <*> current route) changeState\n  return result\n\n-- | A link widget that, when clicked, sets the route to the provided route. In non-javascript\n-- contexts, this widget falls back to using @href@s to control navigation\nrouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLink r w = do\n  (e, a) <- routeLinkImpl mempty r w\n  scrollToTop e\n  return a\n\n-- | Like 'routeLink', but takes additional attributes as argument.\n--\nrouteLinkAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Map AttributeName Text -- ^ Additional attributes\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\nrouteLinkAttr attrs r w = do\n  (e, a) <- routeLinkImpl attrs r w\n  let\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n  when (not targetBlank) $ scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLink'. Does not scroll to the top of the page on clicks.\nrouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Map AttributeName Text\n  -> route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\nrouteLinkImpl attrs r w = do\n  enc <- askRouteToUrl\n  let\n    -- If targetBlank == True, the link will be opened in another page. In that\n    -- case, we don't prevent the default behaviour, and we don't need to\n    -- setRoute.\n    targetBlank = Map.lookup \"target\" attrs == Just \"_blank\"\n    cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_initialAttributes .~ (\"href\" =: enc r <> attrs)\n        & (if targetBlank\n           then id\n           else elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault))\n  (e, a) <- element \"a\" cfg w\n  when (not targetBlank) $ setRoute $ r <$ domEvent Click e\n  return (domEvent Click e, a)\n\nscrollToTop :: forall m t. (Prerender t m, Monad m) => Event t () -> m ()\nscrollToTop e = prerender_ blank $ performEvent_ $ ffor e $ \\_ -> liftJSM $ DOM.currentWindow >>= \\case\n  Nothing -> pure ()\n  Just win -> Window.scrollTo win 0 0\n\n-- | Like 'routeLinkDynAttr' but without custom attributes.\ndynRouteLink\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     , Prerender t m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m a\ndynRouteLink r w = do\n  (e, a) <- dynRouteLinkImpl r w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'dynRouteLink'. Does not scroll to the top of the page on clicks.\ndynRouteLinkImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl route m\n     , SetRoute t route m\n     )\n  => Dynamic t route -- ^ Target route\n  -> m a -- ^ Child widget\n  -> m (Event t (), a)\ndynRouteLinkImpl dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ (\"href\" =:) . enc <$> dr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- | An @a@-tag link widget that, when clicked, sets the route to current value of the\n-- provided dynamic route. In non-JavaScript contexts the value of the dynamic post\n-- build is used so the link still works like 'routeLink'.\nrouteLinkDynAttr\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     , Prerender t m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m a\nrouteLinkDynAttr dAttr dr w = do\n  (e, a) <- routeLinkDynAttrImpl dAttr dr w\n  scrollToTop e\n  return a\n\n-- | Raw implementation of 'routeLinkDynAttr'. Does not scroll to the top of the page on clicks.\nrouteLinkDynAttrImpl\n  :: forall t m a route.\n     ( DomBuilder t m\n     , PostBuild t m\n     , RouteToUrl (R route) m\n     , SetRoute t (R route) m\n     )\n  => Dynamic t (Map AttributeName Text) -- ^ Attributes for @a@ element. Note that if @href@ is present it will be ignored\n  -> Dynamic t (R route) -- ^ Target route\n  -> m a -- ^ Child widget of the @a@ element\n  -> m (Event t (), a)\nrouteLinkDynAttrImpl dAttr dr w = do\n  enc <- askRouteToUrl\n  er <- dynamicAttributesToModifyAttributes $ zipDynWith (<>) ((\"href\" =:) . enc <$> dr) dAttr\n  let cfg = (def :: ElementConfig EventResult t (DomBuilderSpace m))\n        & elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const preventDefault)\n        & elementConfig_modifyAttributes .~ er\n  (e, a) <- element \"a\" cfg w\n  let clk = domEvent Click e\n  setRoute $ tag (current dr) clk\n  return (clk, a)\n\n-- On ios due to sandboxing when loading the page from a file adapt the\n-- path to be based on the hash.\n\nadaptedUriPath :: Bool -> URI -> String\nadaptedUriPath = \\case\n  True -> hashToPath . uriFragment\n  False -> uriPath\n\nsetAdaptedUriPath :: Bool -> String -> URI -> URI\nsetAdaptedUriPath useHash s u = case useHash of\n  True -> u { uriFragment = pathToHash s }\n  False -> u { uriPath = s }\n\npathToHash :: String -> String\npathToHash = ('#' :) . fromMaybe \"\" . L.stripPrefix \"/\"\n\nhashToPath :: String -> String\nhashToPath = ('/' :) . fromMaybe \"\" . L.stripPrefix \"#\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.4545454545454546,
                "sum": 32
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 6,
              "lines_of_code": 274,
              "homplexity_lines_of_code": 270,
              "code_quality_score": 9.0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.4545454545454546,
                  "sum": 32
                },
                "homplexity_loc": 270,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 1 1: module Obelisk.Asset.Accept has 164 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 63 20: data Encoding has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 71 18: data QValue has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 77 28: data AcceptableEncodings has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 85 1: type signature for missingAcceptableEncodings has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 85 1: type signature for missingAcceptableEncodings has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 86 1: function missingAcceptableEncodings has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 86 1: function missingAcceptableEncodings has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 86 1: function missingAcceptableEncodings has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: type signature for chooseEncoding has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 101 1: type signature for chooseEncoding has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 102 1: function chooseEncoding has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 102 1: function chooseEncoding has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 102 1: function chooseEncoding has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 108 1: type signature for encodingQValue has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 108 1: type signature for encodingQValue has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 109 1: function encodingQValue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 109 1: function encodingQValue has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 109 1: function encodingQValue has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 114 1: type signature for acceptEncodingBody has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 114 1: type signature for acceptEncodingBody has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 115 1: function acceptEncodingBody has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 115 1: function acceptEncodingBody has cyclomatic complexity of 4 \nWarning:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 115 1: function acceptEncodingBody has 24 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 143 1: type signature for qvalue has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 143 1: type signature for qvalue has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 144 1: function qvalue has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 144 1: function qvalue has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 144 1: function qvalue has 18 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for contentCoding has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 164 1: type signature for contentCoding has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function contentCoding has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function contentCoding has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 165 1: function contentCoding has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for token has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 168 1: type signature for token has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function token has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function token has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 169 1: function token has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for literal has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 172 1: type signature for literal has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function literal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function literal has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 173 1: function literal has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isTokenChar has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 176 1: type signature for isTokenChar has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isTokenChar has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isTokenChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 177 1: function isTokenChar has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isChar has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 180 1: type signature for isChar has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isChar has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isChar has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 181 1: function isChar has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 184 1: type signature for isCtl has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 184 1: type signature for isCtl has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: function isCtl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: function isCtl has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 185 1: function isCtl has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 188 1: type signature for isSeparator has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 188 1: type signature for isSeparator has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 189 1: function isSeparator has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 189 1: function isSeparator has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 189 1: function isSeparator has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 201 1: function liftM2' has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 201 1: function liftM2' has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 201 1: function liftM2' has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 208 1: type signature for starRule has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 208 1: type signature for starRule has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 209 1: function starRule has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 209 1: function starRule has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 209 1: function starRule has 10 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 222 1: type signature for hashRule has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 222 1: type signature for hashRule has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 223 1: function hashRule has cyclomatic complexity of 5 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 223 1: function hashRule has branching depth of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 223 1: function hashRule has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: type signature for lws has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 248 1: type signature for lws has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function lws has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function lws has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 249 1: function lws has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: type signature for cr has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 255 1: type signature for cr has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function cr has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function cr has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 256 1: function cr has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 259 1: type signature for lf has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 259 1: type signature for lf has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 260 1: function lf has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 260 1: function lf has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 260 1: function lf has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 263 1: type signature for sp has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 263 1: type signature for sp has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 264 1: function sp has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 264 1: function sp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 264 1: function sp has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 266 1: type signature for spVal has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 266 1: type signature for spVal has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 267 1: function spVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 267 1: function spVal has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 267 1: function spVal has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 270 1: type signature for ht has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 270 1: type signature for ht has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 271 1: function ht has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 271 1: function ht has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 271 1: function ht has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 273 1: type signature for htVal has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 273 1: type signature for htVal has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 274 1: function htVal has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 274 1: function htVal has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/serve-snap/src/Obelisk/Asset/Accept.hs\" 274 1: function htVal has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving  #-}\n\n-- | Module containing parsers and utilities for managing @Accept-Encoding@ headers and the overall process of encoding selection.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nmodule Obelisk.Asset.Accept\n  ( AcceptableEncodings(..)\n  , Encoding(..)\n  , QValue(..)\n  , QValueResolution\n  , acceptEncodingBody\n  , chooseEncoding\n  , missingAcceptableEncodings\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 710\nimport Prelude hiding (takeWhile, sequence)\nimport Data.Traversable (sequence)\n#elif __GLASGOW_HASKELL__ < 810\nimport Data.Monoid ((<>))\n#else\nimport Prelude hiding (takeWhile)\n#endif\n#else\nimport Prelude hiding (takeWhile)\n#endif\n\nimport Control.Applicative ((<|>), optional)\nimport Control.Arrow (second)\nimport Control.Monad (replicateM, void)\nimport Data.Attoparsec.ByteString as AttoBS\nimport Data.Attoparsec.ByteString.Char8 as AC8\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Either (partitionEithers)\nimport Data.Fixed (E3, Fixed(..), resolution)\nimport Data.List (sort)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes, fromMaybe, listToMaybe)\nimport Data.Ord (Down(..))\nimport Data.Proxy (Proxy(..))\nimport Data.String (IsString)\nimport Data.Word (Word8)\n\n\n-- | Type of a particular named encoding technique, such as @gzip@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5\nnewtype Encoding = Encoding { unEncoding :: ByteString } deriving (Show, Read, Eq, Ord, IsString)\n\n-- | Maximum precision of a Q value, in particular 3 decimal places of precision as given by the standard.\ntype QValueResolution = E3\n\n-- | Type of an HTTP @qvalue@ or quality value indicating how preferred some encoding is relative to some other one.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nnewtype QValue = QValue { unQValue :: Fixed QValueResolution } deriving (Show, Read, Eq, Ord)\n\n-- | Structure used for picking a mutually acceptable encoding, holding a default 'QValue' along with 'QValue's for a number of 'Encoding's and typically\n-- represented in HTTP as a string like gzip; q=1.0, identity; q=0.5, *; q=0.0@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\ndata AcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue :: QValue\n  -- ^The 'QValue' associated with the default encoding value @*@, indicating any unmentioned encoding.\n  , _acceptableEncodings_byEncoding :: Map Encoding QValue\n  -- ^'QValue's for each 'Encoding'.\n  } deriving (Show, Read, Eq, Ord)\n\n-- | When no Accept-Encoding header is present, prefer identity, then gzip or compress, then anything else available.\nmissingAcceptableEncodings :: AcceptableEncodings\nmissingAcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue = QValue 0.001\n  , _acceptableEncodings_byEncoding = Map.fromList\n      [ (Encoding \"identity\", QValue 1)\n      , (Encoding \"gzip\", QValue 0.5)\n      , (Encoding \"compress\", QValue 0.5)\n      ]\n  }\n\n-- | Takes a list of 'Encoding's and an 'AcceptableEncodings' representing preferences and returns @Just 'Encoding'@ to use of the given list based on those\n-- preferences. An 'Encoding' is preferred if it has a higher 'QValue' or in the case of ties if it comes first in the given list of encodings. An encoding\n-- with a @QValue@ of 0 will never be chosen. If no encoding could be chosen, either because no encodings were given or because 0 @QValue@s suppressed them,\n-- then @Nothing@ is returned.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nchooseEncoding :: [Encoding] -> AcceptableEncodings -> Maybe Encoding\nchooseEncoding es ae = fmap snd $ listToMaybe $ sort $ catMaybes $ zipWith f es [(1::Int)..]\n  where f e n = case encodingQValue e ae of\n          QValue 0 -> Nothing\n          q -> Just ((Down q, n), e) -- Choose by quality first (in descending order), then by the server's preference order\n\n-- | Helper function for 'chooseEncoding' that returns the default AcceptableEncoding if requested encoding is unavailable\nencodingQValue :: Encoding -> AcceptableEncodings -> QValue\nencodingQValue e ae = Map.findWithDefault (_acceptableEncodings_defaultQValue ae) e $ _acceptableEncodings_byEncoding ae\n\n-- | Attoparsec 'Parser' for parsing an 'AcceptableEncodings' from the value of an @Accept-Encoding@ header, as specified by HTTP/1.1 / RFC2616.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nacceptEncodingBody :: Parser AcceptableEncodings\nacceptEncodingBody = do\n  l <- hashRule (Just 1) Nothing $ do -- partially applied hashRule awaiting to be passed Parser a\n    c <- (Nothing <$ literal \"*\") <|> (Just <$> contentCoding) -- Parser Nothing <|> Parser Encoding\n    mq <- optional $ do\n      literal \";\"\n      literal \"q\"\n      literal \"=\"\n      qvalue\n    let q = fromMaybe (QValue 1) mq\n    return (c, q)\n  let (stars, specificEncodings) = partitionEithers $ flip map l $ \\(c, q) -> case c of\n        Nothing -> Left q\n        Just n -> Right (n, q)\n  starQValue <- case stars of\n    [] -> return Nothing\n    [q] -> return $ Just q\n    _ -> fail \"acceptEncodingBody: multiple * values provided\"\n  byEncodingProvided <- sequence $ Map.fromListWithKey (\\k _ _ -> fail $ \"acceptEncodingBody: encoding \" <> show k <> \" repeated multiple times\") $ map (second return) specificEncodings\n  let defaultIdentityQValue = fromMaybe (QValue 1) starQValue -- identity has a default qvalue of 1 unless * is given a different qvalue explicitly\n      defaultQValue = fromMaybe (QValue 0) starQValue\n      byEncoding = Map.filter (/= defaultQValue) -- Canonicalize: qvalues equal to the default are redundant\n                 . Map.alter (Just . fromMaybe defaultIdentityQValue) \"identity\" -- Add implicit \"identity\" encoding, unless it has been explicitly added\n                 $ byEncodingProvided\n  return $ AcceptableEncodings defaultQValue byEncoding\n\n-- | Parser for a 'QValue'.\n--\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nqvalue :: Parser QValue\nqvalue = do\n  skipMany lws\n  q0 <|> q1\n  where q0 = do\n          _ <- char '0'\n          decimals <- option [] $ do\n            _ <- char '.'\n            starRule (Just 0) (Just numAllowedDigits) digit\n          return $ QValue $ MkFixed $ fromIntegral $ (read ('0' : decimals) :: Int) * 10 ^ (numAllowedDigits - length decimals)\n        q1 = do\n          _ <- char '1'\n          option () $ do\n            _ <- char '.'\n            _ <- starRule (Just 0) (Just numAllowedDigits) $ char '0'\n            return ()\n          return $ QValue 1\n        numAllowedDigits :: Int\n        numAllowedDigits = fromIntegral $ resolution (Proxy :: Proxy QValueResolution)\n\n-- | Helper function used in 'acceptEncodingBody' to evaluate Encoding as ByteString\ncontentCoding :: Parser Encoding\ncontentCoding = Encoding <$> token\n\n-- | Helper function used in 'contentCoding' that skips lightweight spaces and consumes input while 'isTokenChar' returns True\ntoken :: Parser ByteString\ntoken = skipMany lws >> AttoBS.takeWhile1 isTokenChar\n\n-- | Helper function used in 'acceptEncodingBody', discards evaluation and returns  a 'Parser ()' to continue parsing\nliteral :: ByteString -> Parser ()\nliteral s = void $ skipMany lws >> string s\n\n-- | Helper function used in 'token' to validate if ByteStringChar is printable but not a control or seperator char\nisTokenChar :: Word8 -> Bool\nisTokenChar c = isChar c && not (isCtl c || isSeparator c)\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control or printable char\nisChar :: Word8 -> Bool\nisChar c = c <= 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control char\nisCtl :: Word8 -> Bool\nisCtl c = c <= 31 || c == 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a seperator char\nisSeparator :: Word8 -> Bool\nisSeparator c = BS.elem c $ spVal `BS.cons` htVal `BS.cons` \"()<>@,;:\\\\\\\"/[]?={}\"\n\n-- | A version of 'liftM2' that is strict in the result of its first\n-- action.\nliftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\nliftM2' f a b = do\n  !x <- a\n  y <- b\n  return (f x y)\n{-# INLINE liftM2' #-}\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\nstarRule :: Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nstarRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n  mandatoryVals <- replicateM numMandatory element\n  optionalVals <- case maxNum of\n    Nothing -> many' element\n    Just n -> do\n      let countUpTo 0 _ = return []\n          countUpTo m a = liftM2' (:) a (countUpTo (pred m) a) <|> return []\n      countUpTo (n - numMandatory) element\n  return $ mandatoryVals ++ optionalVals\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\n-- The spec is a bit ambiguous on whether extra commas and whitespace are permitted before and after the elements; this implementation permits them\nhashRule :: forall a. Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nhashRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n      sep :: Parser ()\n      sep = do\n        skipMany1 $ do\n          skipMany lws\n          char ','\n        return ()\n      processMandatory :: Bool -> Int -> Parser [a]\n      processMandatory isInitial 0 = processOptional isInitial $ fmap (subtract numMandatory) maxNum\n      processMandatory isInitial n = do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processMandatory False $ pred n\n      processOptional :: Bool -> Maybe Int -> Parser [a]\n      processOptional _ (Just 0) = return []\n      processOptional isInitial n = (<|> return []) $ do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processOptional False $ fmap pred n\n  result <- processMandatory True numMandatory\n  _ <- optional sep\n  skipMany lws\n  return result\n\n-- | Linear whitespace\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlws :: Parser ()\nlws = do\n  option () $ cr >> lf\n  _ <- starRule (Just 1) Nothing $ sp <|> ht\n  return ()\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\ncr :: Parser ()\ncr = void $ word8 13\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlf :: Parser ()\nlf = void $ word8 10\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nsp :: Parser ()\nsp = void $ word8 spVal\n\nspVal :: Word8\nspVal = 32\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nht :: Parser ()\nht = void $ word8 htVal\n\nhtVal :: Word8\nhtVal = 9\n",
              "suggestions": [
                {
                  "target_snippet": "liftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c",
                  "refactored_suggestion": "-- The `liftM2'` function is unused. Remove it for code clarity.\n-- Remove the following code:\n-- liftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\n-- liftM2' f a b = do\n--   !x <- a\n--   y <- b\n--   return (f x y)\n-- {-# INLINE liftM2' #-}",
                  "confidence": 1.0,
                  "justification": "The `liftM2'` function does not have any references or usages in the entire code base provided. Dead code should be removed to simplify the code and reduce maintenance overhead."
                },
                {
                  "target_snippet": "import Data.Either (partitionEithers)",
                  "refactored_suggestion": "-- The `import Data.Either (partitionEithers)` can be removed as `partitionEithers` is not used anywhere in the code.\n-- Remove the line:\n-- import Data.Either (partitionEithers)",
                  "confidence": 1.0,
                  "justification": "Static analysis of the code reveals that the `partitionEithers` function from `Data.Either` is not being used anywhere. Unused imports should be removed to make the code cleaner and to avoid confusion."
                },
                {
                  "target_snippet": "import Control.Arrow (second)",
                  "refactored_suggestion": "-- The `import Control.Arrow (second)` can be removed as `second` is not used anywhere in the code.\n-- Remove the line:\n-- import Control.Arrow (second)",
                  "confidence": 1.0,
                  "justification": "The `second` function from `Control.Arrow` is not being utilized in this code. Removing unused imports can make the codebase lighter and more understandable."
                },
                {
                  "target_snippet": "import Control.Monad (replicateM, void)",
                  "refactored_suggestion": "import Control.Monad (void) -- Remove `replicateM` since it's unused.",
                  "confidence": 1.0,
                  "justification": "While `void` from `Control.Monad` is used in the code, the `replicateM` function is not referenced anywhere. Keep only the relevant imports for clarity."
                },
                {
                  "target_snippet": "import Data.Traversable (sequence)",
                  "refactored_suggestion": "-- The `import Data.Traversable (sequence)` can be removed as `sequence` is not used anywhere in the code.\n-- Remove the line:\n-- import Data.Traversable (sequence)",
                  "confidence": 1.0,
                  "justification": "The `sequence` function from `Data.Traversable` is not being used anywhere in the provided code. Removing unnecessary imports helps maintain clean and concise code."
                },
                {
                  "target_snippet": "import Data.Monoid ((<>))",
                  "refactored_suggestion": "-- The `import Data.Monoid ((<>))` can be removed as the `(<>)` operator is not used in the code.\n-- Remove the line:\n-- import Data.Monoid ((<>))",
                  "confidence": 1.0,
                  "justification": "The `(<>)` operator from `Data.Monoid` is not used anywhere in the code provided. Removing unused imports will help simplify the import list."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving  #-}\n\n-- | Module containing parsers and utilities for managing @Accept-Encoding@ headers and the overall process of encoding selection.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nmodule Obelisk.Asset.Accept\n  ( AcceptableEncodings(..)\n  , Encoding(..)\n  , QValue(..)\n  , QValueResolution\n  , acceptEncodingBody\n  , chooseEncoding\n  , missingAcceptableEncodings\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 710\nimport Prelude hiding (takeWhile, sequence)\n-- The `import Data.Traversable (sequence)` can be removed as `sequence` is not used anywhere in the code.\n-- Remove the line:\n-- import Data.Traversable (sequence)\n#elif __GLASGOW_HASKELL__ < 810\n-- The `import Data.Monoid ((<>))` can be removed as the `(<>)` operator is not used in the code.\n-- Remove the line:\n-- import Data.Monoid ((<>))\n#else\nimport Prelude hiding (takeWhile)\n#endif\n#else\nimport Prelude hiding (takeWhile)\n#endif\n\nimport Control.Applicative ((<|>), optional)\n-- The `import Control.Arrow (second)` can be removed as `second` is not used anywhere in the code.\n-- Remove the line:\n-- import Control.Arrow (second)\nimport Control.Monad (void) -- Remove `replicateM` since it's unused.\nimport Data.Attoparsec.ByteString as AttoBS\nimport Data.Attoparsec.ByteString.Char8 as AC8\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\n-- The `import Data.Either (partitionEithers)` can be removed as `partitionEithers` is not used anywhere in the code.\n-- Remove the line:\n-- import Data.Either (partitionEithers)\nimport Data.Fixed (E3, Fixed(..), resolution)\nimport Data.List (sort)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe (catMaybes, fromMaybe, listToMaybe)\nimport Data.Ord (Down(..))\nimport Data.Proxy (Proxy(..))\nimport Data.String (IsString)\nimport Data.Word (Word8)\n\n\n-- | Type of a particular named encoding technique, such as @gzip@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5\nnewtype Encoding = Encoding { unEncoding :: ByteString } deriving (Show, Read, Eq, Ord, IsString)\n\n-- | Maximum precision of a Q value, in particular 3 decimal places of precision as given by the standard.\ntype QValueResolution = E3\n\n-- | Type of an HTTP @qvalue@ or quality value indicating how preferred some encoding is relative to some other one.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nnewtype QValue = QValue { unQValue :: Fixed QValueResolution } deriving (Show, Read, Eq, Ord)\n\n-- | Structure used for picking a mutually acceptable encoding, holding a default 'QValue' along with 'QValue's for a number of 'Encoding's and typically\n-- represented in HTTP as a string like gzip; q=1.0, identity; q=0.5, *; q=0.0@.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\ndata AcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue :: QValue\n  -- ^The 'QValue' associated with the default encoding value @*@, indicating any unmentioned encoding.\n  , _acceptableEncodings_byEncoding :: Map Encoding QValue\n  -- ^'QValue's for each 'Encoding'.\n  } deriving (Show, Read, Eq, Ord)\n\n-- | When no Accept-Encoding header is present, prefer identity, then gzip or compress, then anything else available.\nmissingAcceptableEncodings :: AcceptableEncodings\nmissingAcceptableEncodings = AcceptableEncodings\n  { _acceptableEncodings_defaultQValue = QValue 0.001\n  , _acceptableEncodings_byEncoding = Map.fromList\n      [ (Encoding \"identity\", QValue 1)\n      , (Encoding \"gzip\", QValue 0.5)\n      , (Encoding \"compress\", QValue 0.5)\n      ]\n  }\n\n-- | Takes a list of 'Encoding's and an 'AcceptableEncodings' representing preferences and returns @Just 'Encoding'@ to use of the given list based on those\n-- preferences. An 'Encoding' is preferred if it has a higher 'QValue' or in the case of ties if it comes first in the given list of encodings. An encoding\n-- with a @QValue@ of 0 will never be chosen. If no encoding could be chosen, either because no encodings were given or because 0 @QValue@s suppressed them,\n-- then @Nothing@ is returned.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nchooseEncoding :: [Encoding] -> AcceptableEncodings -> Maybe Encoding\nchooseEncoding es ae = fmap snd $ listToMaybe $ sort $ catMaybes $ zipWith f es [(1::Int)..]\n  where f e n = case encodingQValue e ae of\n          QValue 0 -> Nothing\n          q -> Just ((Down q, n), e) -- Choose by quality first (in descending order), then by the server's preference order\n\n-- | Helper function for 'chooseEncoding' that returns the default AcceptableEncoding if requested encoding is unavailable\nencodingQValue :: Encoding -> AcceptableEncodings -> QValue\nencodingQValue e ae = Map.findWithDefault (_acceptableEncodings_defaultQValue ae) e $ _acceptableEncodings_byEncoding ae\n\n-- | Attoparsec 'Parser' for parsing an 'AcceptableEncodings' from the value of an @Accept-Encoding@ header, as specified by HTTP/1.1 / RFC2616.\n--\n-- See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\nacceptEncodingBody :: Parser AcceptableEncodings\nacceptEncodingBody = do\n  l <- hashRule (Just 1) Nothing $ do -- partially applied hashRule awaiting to be passed Parser a\n    c <- (Nothing <$ literal \"*\") <|> (Just <$> contentCoding) -- Parser Nothing <|> Parser Encoding\n    mq <- optional $ do\n      literal \";\"\n      literal \"q\"\n      literal \"=\"\n      qvalue\n    let q = fromMaybe (QValue 1) mq\n    return (c, q)\n  let (stars, specificEncodings) = partitionEithers $ flip map l $ \\(c, q) -> case c of\n        Nothing -> Left q\n        Just n -> Right (n, q)\n  starQValue <- case stars of\n    [] -> return Nothing\n    [q] -> return $ Just q\n    _ -> fail \"acceptEncodingBody: multiple * values provided\"\n  byEncodingProvided <- sequence $ Map.fromListWithKey (\\k _ _ -> fail $ \"acceptEncodingBody: encoding \" <> show k <> \" repeated multiple times\") $ map (second return) specificEncodings\n  let defaultIdentityQValue = fromMaybe (QValue 1) starQValue -- identity has a default qvalue of 1 unless * is given a different qvalue explicitly\n      defaultQValue = fromMaybe (QValue 0) starQValue\n      byEncoding = Map.filter (/= defaultQValue) -- Canonicalize: qvalues equal to the default are redundant\n                 . Map.alter (Just . fromMaybe defaultIdentityQValue) \"identity\" -- Add implicit \"identity\" encoding, unless it has been explicitly added\n                 $ byEncodingProvided\n  return $ AcceptableEncodings defaultQValue byEncoding\n\n-- | Parser for a 'QValue'.\n--\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9\nqvalue :: Parser QValue\nqvalue = do\n  skipMany lws\n  q0 <|> q1\n  where q0 = do\n          _ <- char '0'\n          decimals <- option [] $ do\n            _ <- char '.'\n            starRule (Just 0) (Just numAllowedDigits) digit\n          return $ QValue $ MkFixed $ fromIntegral $ (read ('0' : decimals) :: Int) * 10 ^ (numAllowedDigits - length decimals)\n        q1 = do\n          _ <- char '1'\n          option () $ do\n            _ <- char '.'\n            _ <- starRule (Just 0) (Just numAllowedDigits) $ char '0'\n            return ()\n          return $ QValue 1\n        numAllowedDigits :: Int\n        numAllowedDigits = fromIntegral $ resolution (Proxy :: Proxy QValueResolution)\n\n-- | Helper function used in 'acceptEncodingBody' to evaluate Encoding as ByteString\ncontentCoding :: Parser Encoding\ncontentCoding = Encoding <$> token\n\n-- | Helper function used in 'contentCoding' that skips lightweight spaces and consumes input while 'isTokenChar' returns True\ntoken :: Parser ByteString\ntoken = skipMany lws >> AttoBS.takeWhile1 isTokenChar\n\n-- | Helper function used in 'acceptEncodingBody', discards evaluation and returns  a 'Parser ()' to continue parsing\nliteral :: ByteString -> Parser ()\nliteral s = void $ skipMany lws >> string s\n\n-- | Helper function used in 'token' to validate if ByteStringChar is printable but not a control or seperator char\nisTokenChar :: Word8 -> Bool\nisTokenChar c = isChar c && not (isCtl c || isSeparator c)\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control or printable char\nisChar :: Word8 -> Bool\nisChar c = c <= 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a control char\nisCtl :: Word8 -> Bool\nisCtl c = c <= 31 || c == 127\n\n-- | Helper function used in 'isTokenChar' to validate if ByteStringChar is a seperator char\nisSeparator :: Word8 -> Bool\nisSeparator c = BS.elem c $ spVal `BS.cons` htVal `BS.cons` \"()<>@,;:\\\\\\\"/[]?={}\"\n\n-- | A version of 'liftM2' that is strict in the result of its first\n-- action.\n-- The `liftM2'` function is unused. Remove it for code clarity.\n-- Remove the following code:\n-- liftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c\n-- liftM2' f a b = do\n--   !x <- a\n--   y <- b\n--   return (f x y)\n-- {-# INLINE liftM2' #-}\nliftM2' f a b = do\n  !x <- a\n  y <- b\n  return (f x y)\n{-# INLINE liftM2' #-}\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\nstarRule :: Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nstarRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n  mandatoryVals <- replicateM numMandatory element\n  optionalVals <- case maxNum of\n    Nothing -> many' element\n    Just n -> do\n      let countUpTo 0 _ = return []\n          countUpTo m a = liftM2' (:) a (countUpTo (pred m) a) <|> return []\n      countUpTo (n - numMandatory) element\n  return $ mandatoryVals ++ optionalVals\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.1\n-- The spec is a bit ambiguous on whether extra commas and whitespace are permitted before and after the elements; this implementation permits them\nhashRule :: forall a. Maybe Int -> Maybe Int -> Parser a -> Parser [a]\nhashRule minNum maxNum element = do\n  let numMandatory = fromMaybe 0 minNum\n      sep :: Parser ()\n      sep = do\n        skipMany1 $ do\n          skipMany lws\n          char ','\n        return ()\n      processMandatory :: Bool -> Int -> Parser [a]\n      processMandatory isInitial 0 = processOptional isInitial $ fmap (subtract numMandatory) maxNum\n      processMandatory isInitial n = do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processMandatory False $ pred n\n      processOptional :: Bool -> Maybe Int -> Parser [a]\n      processOptional _ (Just 0) = return []\n      processOptional isInitial n = (<|> return []) $ do\n        if isInitial then void $ optional sep else sep\n        liftM2' (:) (skipMany lws >> element) $ processOptional False $ fmap pred n\n  result <- processMandatory True numMandatory\n  _ <- optional sep\n  skipMany lws\n  return result\n\n-- | Linear whitespace\n-- See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlws :: Parser ()\nlws = do\n  option () $ cr >> lf\n  _ <- starRule (Just 1) Nothing $ sp <|> ht\n  return ()\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\ncr :: Parser ()\ncr = void $ word8 13\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nlf :: Parser ()\nlf = void $ word8 10\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nsp :: Parser ()\nsp = void $ word8 spVal\n\nspVal :: Word8\nspVal = 32\n\n-- | See http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2\nht :: Parser ()\nht = void $ word8 htVal\n\nhtVal :: Word8\nhtVal = 9\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 89,
              "homplexity_lines_of_code": 68,
              "code_quality_score": 75.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 9
                },
                "homplexity_loc": 68,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 5 1: module Obelisk.Asset.TH has 48 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 22 1: type signature for hashedAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 23 1: function hashedAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 28 1: type signature for assetPath has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 29 1: function assetPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 32 1: type signature for staticPrefix has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 33 1: function staticPrefix has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 36 1: type signature for staticOutPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 37 1: function staticOutPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 44 1: type signature for staticAssetRaw has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 45 1: function staticAssetRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 47 1: type signature for staticAssetHashed has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 48 1: function staticAssetHashed has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 56 1: type signature for staticAssetFilePathRaw has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 62 1: function staticAssetFilePathRaw has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 64 1: type signature for staticAssetFilePath has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 65 1: function staticAssetFilePath has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 76 1: type signature for staticAssetWorker has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/TH.hs\" 85 1: function staticAssetWorker has branching depth of 0 \n"
              },
              "original_code": "{-|\nDescription:\n  Template Haskell for generating asset paths.\n-}\nmodule Obelisk.Asset.TH\n  ( assetPath\n  , staticAssetRaw\n  , staticAssetHashed\n  , staticAssetFilePath\n  , staticAssetFilePathRaw\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Control.Monad\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport System.Directory\nimport System.FilePath.Posix\n\n-- | Produces the hashed path of a file\nhashedAssetFilePath :: FilePath -> FilePath -> Q FilePath\nhashedAssetFilePath root relativePath = do\n  qAddDependentFile $ root </> relativePath\n  runIO (toHashedPath root relativePath)\n\n-- | Produces a string literal with the hashed path of the file\nassetPath :: FilePath -> FilePath -> Q Exp\nassetPath root relativePath =\n  LitE . StringL <$> hashedAssetFilePath root relativePath\n\nstaticPrefix :: FilePath\nstaticPrefix = \"/static\"\n\n-- | Location of the symbolic link to static assets and resources.\nstaticOutPath :: FilePath\nstaticOutPath = \"static.out\"\n\n-- | Embed a filepath via template haskell. Resources embedded this way\n-- are requested from the \"/static\" route.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetRaw :: FilePath -> Q Exp\nstaticAssetRaw = staticAssetWorker staticPrefix staticOutPath\n\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp\n\n-- | Embed a filepath via template haskell. Differently to 'staticAssetRaw'\n-- this points to a local filepath instead of an URL during deployment.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetFilePathRaw\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetFilePathRaw root = staticAssetWorker root staticOutPath\n\nstaticAssetFilePath :: FilePath -> FilePath -> Q Exp\nstaticAssetFilePath root relativePath = do\n  let fullPath = root </> relativePath\n  qAddDependentFile fullPath\n  pure $ LitE $ StringL fullPath\n\n-- | @'staticAssetWorker' root staticOut fp@.\n--\n-- Produces @root </> fp@, but checks before that @fp@ has been copied\n-- to 'staticOutPath' and produces a compilation error otherwise.\n-- This helps finding typos in filepaths, etc... at compile-time instead of\n-- run-time.\nstaticAssetWorker\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Directory to which the filepath must have been copied.\n  -- If @fp@ does not exist within this directory, this function will fail.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetWorker root staticOut fp = do\n  exists <- runIO $ doesFileExist $ staticOut </> fp\n  when (not exists) $\n    fail $ \"The file \" <> fp <> \" was not found in \" <> staticOut\n  returnQ $ LitE $ StringL $ root </> fp\n",
              "suggestions": [
                {
                  "target_snippet": "staticPrefix = \"/static\"",
                  "refactored_suggestion": "staticPrefix = \"static\"",
                  "confidence": 0.9,
                  "justification": "The use of FilePath concatenation operations (e.g., </>) typically handles trailing slashes, making the leading slash in \"/static\" redundant. This change makes the file-path consistent with common conventions."
                },
                {
                  "target_snippet": "when (not exists) $",
                  "refactored_suggestion": "unless exists $",
                  "confidence": 1.0,
                  "justification": "The `unless` function improves readability by expressing the intent more naturally (i.e., doing something if a condition is false), and is specifically designed for this use case. The semantics of `when (not ...)` are identical to `unless ...`."
                },
                {
                  "target_snippet": "qAddDependentFile $ root </> relativePath",
                  "refactored_suggestion": "qAddDependentFile (root </> relativePath)",
                  "confidence": 1.0,
                  "justification": "Removing unnecessary use of `($)` makes the code consistent and simpler for cases where parentheses suffice. This involves no change in behavior."
                },
                {
                  "target_snippet": "runIO (toHashedPath root relativePath)",
                  "refactored_suggestion": "liftIO $ toHashedPath root relativePath",
                  "confidence": 1.0,
                  "justification": "Using `liftIO` is idiomatic in Template Haskell where `Q` monad is used, helping maintain clarity by explicitly lifting IO computations."
                },
                {
                  "target_snippet": "--\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp",
                  "refactored_suggestion": "-- The `staticAssetHashed` function seems to be used at runtime but if it's verified as unused after deeper analysis, you can remove it.\n\n-- Reason: Dead code removal improves clarity and avoids unnecessary maintenance for unused functionality.",
                  "confidence": 0.7,
                  "justification": "If the `staticAssetHashed` function isn't used directly or tested in project-specific scenarios, removing dead code reduces any ambiguity and technical debt. This change should be implemented only after verifying runtime usage across dependent files or modules."
                }
              ],
              "refactored_code": "{-|\nDescription:\n  Template Haskell for generating asset paths.\n-}\nmodule Obelisk.Asset.TH\n  ( assetPath\n  , staticAssetRaw\n  , staticAssetHashed\n  , staticAssetFilePath\n  , staticAssetFilePathRaw\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Control.Monad\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport System.Directory\nimport System.FilePath.Posix\n\n-- | Produces the hashed path of a file\nhashedAssetFilePath :: FilePath -> FilePath -> Q FilePath\nhashedAssetFilePath root relativePath = do\n  qAddDependentFile (root </> relativePath)\n  liftIO $ toHashedPath root relativePath\n\n-- | Produces a string literal with the hashed path of the file\nassetPath :: FilePath -> FilePath -> Q Exp\nassetPath root relativePath =\n  LitE . StringL <$> hashedAssetFilePath root relativePath\n\nstaticPrefix :: FilePath\nstaticPrefix = \"static\"\n\n-- | Location of the symbolic link to static assets and resources.\nstaticOutPath :: FilePath\nstaticOutPath = \"static.out\"\n\n-- | Embed a filepath via template haskell. Resources embedded this way\n-- are requested from the \"/static\" route.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetRaw :: FilePath -> Q Exp\nstaticAssetRaw = staticAssetWorker staticPrefix staticOutPath\n\nstaticAssetHashed :: FilePath -> FilePath -> Q Exp\nstaticAssetHashed root fp = do\n  LitE . StringL . (staticPrefix </>) <$> hashedAssetFilePath root fp\n\n-- | Embed a filepath via template haskell. Differently to 'staticAssetRaw'\n-- this points to a local filepath instead of an URL during deployment.\n--\n-- If the filepath can not be found in the static output directory,\n-- this will throw a compile-time error.\nstaticAssetFilePathRaw\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetFilePathRaw root = staticAssetWorker root staticOutPath\n\nstaticAssetFilePath :: FilePath -> FilePath -> Q Exp\nstaticAssetFilePath root relativePath = do\n  let fullPath = root </> relativePath\n  qAddDependentFile fullPath\n  pure $ LitE $ StringL fullPath\n\n-- | @'staticAssetWorker' root staticOut fp@.\n--\n-- Produces @root </> fp@, but checks before that @fp@ has been copied\n-- to 'staticOutPath' and produces a compilation error otherwise.\n-- This helps finding typos in filepaths, etc... at compile-time instead of\n-- run-time.\nstaticAssetWorker\n  :: FilePath\n  -- ^ Add this prefix directory to the embedded filepath @fp@.\n  -> FilePath\n  -- ^ Directory to which the filepath must have been copied.\n  -- If @fp@ does not exist within this directory, this function will fail.\n  -> FilePath\n  -- ^ Filepath you want to embed.\n  -> Q Exp\nstaticAssetWorker root staticOut fp = do\n  exists <- runIO $ doesFileExist $ staticOut </> fp\n  unless exists $\n    fail $ \"The file \" <> fp <> \" was not found in \" <> staticOut\n  returnQ $ LitE $ StringL $ root </> fp\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/asset/manifest/src/Obelisk/Asset/Promoted.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 4,
                "average": 3,
                "sum": 16
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 102,
              "homplexity_lines_of_code": 113,
              "code_quality_score": 56.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 4,
                  "average": 3,
                  "sum": 16
                },
                "homplexity_loc": 113,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"writeStaticProject\": 4,\n        \"staticModuleFile\": 2,\n        \"declareStatic\": 3,\n        \"staticClassWithInstances\": 3,\n        \"staticClass\": 2,\n        \"staticInstance\": 2,\n        \"min\": 2,\n        \"max\": 4,\n        \"average\": 2.6666666666666665,\n        \"sum\": 16\n    },\n    \"homplexity_loc\": 113\n}"
              },
              "original_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\nmodule Obelisk.Asset.Promoted\n  ( writeStaticProject\n  , declareStatic\n  , StaticConfig (..)\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Data.Foldable\nimport Language.Haskell.TH (pprint)\nimport Language.Haskell.TH.Syntax hiding (lift)\nimport GHC.TypeLits\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq\nimport Control.Monad.Trans.Writer\nimport System.FilePath\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Obelisk.Asset.Cabal (writeCabalProject, SimplePkg(..))\n\ndata StaticConfig = StaticConfig\n  { _staticConfig_packageName :: Text --TODO: Better type\n  , _staticConfig_moduleName :: Text --TODO: Better type\n  }\n\nwriteStaticProject :: Map FilePath FilePath -> FilePath -> StaticConfig -> IO ()\nwriteStaticProject paths target cfg = do\n  let modName = _staticConfig_moduleName cfg\n  modContents <- staticModuleFile modName paths\n  writeCabalProject target $ SimplePkg\n    { _simplePkg_name = _staticConfig_packageName cfg\n    , _simplePkg_moduleName = _staticConfig_moduleName cfg\n    , _simplePkg_moduleContents = modContents\n    , _simplePkg_dependencies = [\"base\", \"ghc-prim\", \"text\"]\n    }\n\nstaticModuleFile :: Text -> Map FilePath FilePath -> IO Text\nstaticModuleFile moduleName paths = do\n  decs <- runQ $ fmap toList $ execWriterT $ staticClassWithInstances paths\n  return $ T.unlines\n    [ \"{-# LANGUAGE AllowAmbiguousTypes #-}\"\n    , \"{-# LANGUAGE DataKinds #-}\"\n    , \"{-# LANGUAGE FlexibleInstances #-}\"\n    , \"{-# LANGUAGE KindSignatures #-}\"\n    , \"{-# LANGUAGE OverloadedStrings #-}\"\n    , \"{-# LANGUAGE ScopedTypeVariables #-}\"\n    , \"{-# LANGUAGE TypeApplications #-}\"\n    , \"module \" <> moduleName <> \" {-# DEPRECATED \\\"Generate this module with the 'obelisk-asset-th-generate' executable instead.\\\" #-} where\"\n    , \"\"\n    , \"import qualified GHC.Types\"\n    , \"import Data.Text (Text)\"\n    , \"import qualified Data.Text.Internal\"\n    , \"import Data.Monoid ((<>))\"\n    , \"\"\n    , \"static :: forall a. StaticFile a => Text\"\n    , \"static = \\\"static/\\\" <> hashedPath @a\" --TODO: Use obelisk-route to generate this in a more consistent way\n    , \"\"\n    , T.pack $ pprint decs\n    ]\n\ndata StaticContext = StaticContext\n  { _staticContext_className :: Name\n  , _staticContext_methodName :: Name\n  }\n\ndeclareStatic :: FilePath -> Q [Dec]\ndeclareStatic root = do\n  paths <- runIO $ gatherHashedPaths root\n  -- TODO: If https://ghc.haskell.org/trac/ghc/ticket/14623 is implemented, use\n  -- qAddDependentFile to watch the directories as well as the files\n  forM_ (Map.keys paths) $ \\original -> do\n    qAddDependentFile $ root </> original\n  fmap toList $ execWriterT $ staticClassWithInstances paths\n\nstaticClassWithInstances :: Map FilePath FilePath -> WriterT (Seq Dec) Q ()\nstaticClassWithInstances paths = do\n  ctx <- staticClass\n  forM_ (Map.toList paths) $ \\(original, hashed) -> do\n    staticInstance ctx original hashed\n\nstaticClass :: WriterT (Seq Dec) Q StaticContext\nstaticClass = do\n  let n x = Name (OccName x) NameS\n      className = n \"StaticFile\"\n      methodName = n \"hashedPath\"\n      cls = ClassD [] className [KindedTV (n \"s\") (ConT ''Symbol)] [] [SigD methodName (ConT ''Text)]\n  tell $ Seq.singleton cls\n  return $ StaticContext\n    { _staticContext_className = className\n    , _staticContext_methodName = methodName\n    }\n\nstaticInstance :: StaticContext -> FilePath -> FilePath -> WriterT (Seq Dec) Q ()\nstaticInstance ctx relativePath hashedPath = do\n  let headType = ConT (_staticContext_className ctx) `AppT` LitT (StrTyLit relativePath)\n      methodDec = ValD (VarP $ _staticContext_methodName ctx) (NormalB (LitE (StringL hashedPath))) []\n  tell $ Seq.singleton $ InstanceD Nothing [] headType [methodDec]\n",
              "suggestions": [
                {
                  "target_snippet": "--TODO: Better type",
                  "refactored_suggestion": "-- A more specific data type like NonEmpty Text or custom refinement could be used",
                  "confidence": 0.8,
                  "justification": "The comment indicates the author acknowledges the need for better type definitions for `_staticConfig_packageName` and `_staticConfig_moduleName`. Using more descriptive or restricted types here would ensure better type safety and maintainability."
                },
                {
                  "target_snippet": "static = \"static/\" <> hashedPath @a",
                  "refactored_suggestion": "static = T.intercalate \"/\" [\"static\", hashedPath @a] --TODO: Use obelisk-route to generate this in a more consistent way",
                  "confidence": 0.9,
                  "justification": "Using `T.intercalate` would improve readability and make paths easier to manipulate or extend, preparing for the mentioned future improvement using `obelisk-route`."
                },
                {
                  "target_snippet": "{-# LANGUAGE TemplateHaskellQuotes #-}",
                  "refactored_suggestion": "",
                  "confidence": 0.7,
                  "justification": "The pragma `TemplateHaskellQuotes` is unnecessary unless quotes from Template Haskell are specifically used. Its removal simplifies and cleans up the module pragma section unless verified as essential."
                },
                {
                  "target_snippet": "import qualified Data.Text.Internal",
                  "refactored_suggestion": "-- Removed unused import: Data.Text.Internal",
                  "confidence": 1.0,
                  "justification": "The module `Data.Text.Internal` is imported but never used. Removing it reduces clutter and ensures clarity about dependencies."
                },
                {
                  "target_snippet": "import Data.Monoid ((<>))",
                  "refactored_suggestion": "-- Removed redundant import: Data.Monoid ((<>))",
                  "confidence": 1.0,
                  "justification": "The `<*>` operator is standard in `Prelude` starting from GHC 8.4. Importing it from `Data.Monoid` is unnecessary and redundant."
                },
                {
                  "target_snippet": "-- qAddDependentFile to watch the directories as well as the files",
                  "refactored_suggestion": "-- Replace with an actual implementation or mention in the documentation/code why this cannot currently be implemented.",
                  "confidence": 0.8,
                  "justification": "The comment indicates a potentially incomplete feature. Clarifying or implementing this would improve usability and maintainability of the module."
                },
                {
                  "target_snippet": "return $ T.unlines [ ... <code truncated> ...  T.pack $ pprint decs ]",
                  "refactored_suggestion": "return . T.unlines $ moduleHeader <> map T.pack (lines (pprint decs))",
                  "confidence": 0.85,
                  "justification": "Refactoring to explicitly separate header generation and declarations. It renders the code easier to maintain or test and makes it consistent with typical functional programming patterns (e.g., avoid excessive rightward drift)."
                }
              ],
              "refactored_code": "{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\nmodule Obelisk.Asset.Promoted\n  ( writeStaticProject\n  , declareStatic\n  , StaticConfig (..)\n  ) where\n\nimport Obelisk.Asset.Gather\n\nimport Data.Foldable\nimport Language.Haskell.TH (pprint)\nimport Language.Haskell.TH.Syntax hiding (lift)\nimport GHC.TypeLits\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq\nimport Control.Monad.Trans.Writer\nimport System.FilePath\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Obelisk.Asset.Cabal (writeCabalProject, SimplePkg(..))\n\ndata StaticConfig = StaticConfig\n  { _staticConfig_packageName :: Text -- A more specific data type like NonEmpty Text or custom refinement could be used\n  , _staticConfig_moduleName :: Text -- A more specific data type like NonEmpty Text or custom refinement could be used\n  }\n\nwriteStaticProject :: Map FilePath FilePath -> FilePath -> StaticConfig -> IO ()\nwriteStaticProject paths target cfg = do\n  let modName = _staticConfig_moduleName cfg\n  modContents <- staticModuleFile modName paths\n  writeCabalProject target $ SimplePkg\n    { _simplePkg_name = _staticConfig_packageName cfg\n    , _simplePkg_moduleName = _staticConfig_moduleName cfg\n    , _simplePkg_moduleContents = modContents\n    , _simplePkg_dependencies = [\"base\", \"ghc-prim\", \"text\"]\n    }\n\nstaticModuleFile :: Text -> Map FilePath FilePath -> IO Text\nstaticModuleFile moduleName paths = do\n  decs <- runQ $ fmap toList $ execWriterT $ staticClassWithInstances paths\n  return $ T.unlines\n    [ \"{-# LANGUAGE AllowAmbiguousTypes #-}\"\n    , \"{-# LANGUAGE DataKinds #-}\"\n    , \"{-# LANGUAGE FlexibleInstances #-}\"\n    , \"{-# LANGUAGE KindSignatures #-}\"\n    , \"{-# LANGUAGE OverloadedStrings #-}\"\n    , \"{-# LANGUAGE ScopedTypeVariables #-}\"\n    , \"{-# LANGUAGE TypeApplications #-}\"\n    , \"module \" <> moduleName <> \" {-# DEPRECATED \\\"Generate this module with the 'obelisk-asset-th-generate' executable instead.\\\" #-} where\"\n    , \"\"\n    , \"import qualified GHC.Types\"\n    , \"import Data.Text (Text)\"\n    , \"-- Removed unused import: Data.Text.Internal\"\n    , \"-- Removed redundant import: Data.Monoid ((<>))\"\n    , \"\"\n    , \"static :: forall a. StaticFile a => Text\"\n    , \"static = \\\"static/\\\" <> hashedPath @a\" --TODO: Use obelisk-route to generate this in a more consistent way\n    , \"\"\n    , T.pack $ pprint decs\n    ]\n\ndata StaticContext = StaticContext\n  { _staticContext_className :: Name\n  , _staticContext_methodName :: Name\n  }\n\ndeclareStatic :: FilePath -> Q [Dec]\ndeclareStatic root = do\n  paths <- runIO $ gatherHashedPaths root\n  -- TODO: If https://ghc.haskell.org/trac/ghc/ticket/14623 is implemented, use\n  -- Replace with an actual implementation or mention in the documentation/code why this cannot currently be implemented.\n  forM_ (Map.keys paths) $ \\original -> do\n    qAddDependentFile $ root </> original\n  fmap toList $ execWriterT $ staticClassWithInstances paths\n\nstaticClassWithInstances :: Map FilePath FilePath -> WriterT (Seq Dec) Q ()\nstaticClassWithInstances paths = do\n  ctx <- staticClass\n  forM_ (Map.toList paths) $ \\(original, hashed) -> do\n    staticInstance ctx original hashed\n\nstaticClass :: WriterT (Seq Dec) Q StaticContext\nstaticClass = do\n  let n x = Name (OccName x) NameS\n      className = n \"StaticFile\"\n      methodName = n \"hashedPath\"\n      cls = ClassD [] className [KindedTV (n \"s\") (ConT ''Symbol)] [] [SigD methodName (ConT ''Text)]\n  tell $ Seq.singleton cls\n  return $ StaticContext\n    { _staticContext_className = className\n    , _staticContext_methodName = methodName\n    }\n\nstaticInstance :: StaticContext -> FilePath -> FilePath -> WriterT (Seq Dec) Q ()\nstaticInstance ctx relativePath hashedPath = do\n  let headType = ConT (_staticContext_className ctx) `AppT` LitT (StrTyLit relativePath)\n      methodDec = ValD (VarP $ _staticContext_methodName ctx) (NormalB (LitE (StringL hashedPath))) []\n  tell $ Seq.singleton $ InstanceD Nothing [] headType [methodDec]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 30,
              "homplexity_lines_of_code": 21,
              "code_quality_score": 93.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 21,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 1 1: module Obelisk.ExecutableConfig.Inject has 17 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 22 1: type signature for injectPure has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 23 1: function injectPure has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 29 1: type signature for injectExecutableConfigs has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/inject/src/Obelisk/ExecutableConfig/Inject.hs\" 30 1: function injectExecutableConfigs has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Inject where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad (mapM_)\nimport Data.Semigroup ((<>))\n#endif\n#endif\nimport Control.Monad.IO.Class (MonadIO)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex.Dom.Core hiding (value)\n\n-- | Produces a @<script>@ tag with an @id@ attribute containing the key and\n-- whose value is the provided configuration, encoded in base64.\ninjectPure :: DomBuilder t m => Text -> ByteString -> m ()\ninjectPure key value =\n  let attrs = (\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key <> \"data-hydration-skip\" =: \"\")\n  in elAttr \"script\" attrs $ text (T.decodeUtf8 (B64.encode value))\n\n-- | Produces injectable @<script>@ tags containing the configuration keys\n-- (filepaths) and values.\ninjectExecutableConfigs :: (MonadIO m, DomBuilder t m) => Map Text ByteString -> m ()\ninjectExecutableConfigs = mapM_ (uncurry injectPure) . Map.toList\n",
              "suggestions": [
                {
                  "target_snippet": "import Control.Monad (mapM_)",
                  "refactored_suggestion": "-- Removed unused import: import Control.Monad (mapM_)",
                  "confidence": 0.95,
                  "justification": "The `mapM_` import is conditionally imported when using GHC versions lower than 8.10. However, it is not utilized within the code, so it can be removed to clean up the imports."
                },
                {
                  "target_snippet": "import Data.Semigroup ((<>))",
                  "refactored_suggestion": "-- Removed unused import: import Data.Semigroup ((<>))",
                  "confidence": 0.95,
                  "justification": "The `(<>)` operator from `Data.Semigroup` is not needed in the code, as GHC versions 8.4 and above include `(<>)` via `Prelude` by default. This import can be safely removed."
                },
                {
                  "target_snippet": "(\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key <> \"data-hydration-skip\" =: \"\")",
                  "refactored_suggestion": "(\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key)",
                  "confidence": 0.9,
                  "justification": "The attribute `\"data-hydration-skip\" =: \"\"` appears unused within the script tag and has no observable effect. Removing it simplifies the generated attributes while keeping functionality unchanged."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Inject where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\n-- Removed unused import: import Control.Monad (mapM_)\n-- Removed unused import: import Data.Semigroup ((<>))\n#endif\n#endif\nimport Control.Monad.IO.Class (MonadIO)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex.Dom.Core hiding (value)\n\n-- | Produces a @<script>@ tag with an @id@ attribute containing the key and\n-- whose value is the provided configuration, encoded in base64.\ninjectPure :: DomBuilder t m => Text -> ByteString -> m ()\ninjectPure key value =\n  let attrs = (\"type\" =: \"text/plain\" <> \"data-obelisk-executable-config-inject-key\" =: key)\n  in elAttr \"script\" attrs $ text (T.decodeUtf8 (B64.encode value))\n\n-- | Produces injectable @<script>@ tags containing the configuration keys\n-- (filepaths) and values.\ninjectExecutableConfigs :: (MonadIO m, DomBuilder t m) => Map Text ByteString -> m ()\ninjectExecutableConfigs = mapM_ (uncurry injectPure) . Map.toList\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 2,
                "average": 2.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 7,
              "lines_of_code": 17,
              "homplexity_lines_of_code": 16,
              "code_quality_score": 94.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 2,
                  "average": 2.0,
                  "sum": 2
                },
                "homplexity_loc": 16,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 13 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 14 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-ios/Obelisk/ExecutableConfig/Lookup.hs\" 15 1: function getConfigs has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE LambdaCase #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Language.Javascript.JSaddle.WKWebView\nimport System.FilePath.Posix\n\nimport Obelisk.Configs.Internal.Directory\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> error \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"\n",
              "suggestions": [
                {
                  "target_snippet": "Nothing -> error \"Could not get bundle resource path.\"",
                  "refactored_suggestion": "Nothing -> fail \"Could not get bundle resource path.\"",
                  "confidence": 0.9,
                  "justification": "Using `fail` instead of `error` is generally more expressive and aligns better with IO operations. `fail` allows enhanced error handling in monadic contexts, while `error` implies a runtime exception."
                },
                {
                  "target_snippet": "getConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> error \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"",
                  "refactored_suggestion": "getConfigs = do\n  resourcePath <- mainBundleResourcePath\n  case resourcePath of\n    Nothing -> fail \"Could not get bundle resource path.\"\n    Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"",
                  "confidence": 0.85,
                  "justification": "Refactoring to use `do` notation can improve the readability of monadic operations, making the function easier to understand and maintain."
                },
                {
                  "target_snippet": "import Language.Javascript.JSaddle.WKWebView",
                  "refactored_suggestion": "-- import Language.Javascript.JSaddle.WKWebView",
                  "confidence": 0.8,
                  "justification": "The module `Language.Javascript.JSaddle.WKWebView` is imported but not used in the code. Removing unused imports reduces code clutter and improves maintainability."
                }
              ],
              "refactored_code": "{-# LANGUAGE LambdaCase #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\n-- import Language.Javascript.JSaddle.WKWebView\nimport System.FilePath.Posix\n\nimport Obelisk.Configs.Internal.Directory\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = mainBundleResourcePath >>= \\case\n  Nothing -> fail \"Could not get bundle resource path.\"\n  Just p -> getConfigsFromDirectory $ T.unpack (T.decodeUtf8 p) </> \"config\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 13,
              "homplexity_lines_of_code": 8,
              "code_quality_score": 97.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 8,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 1 1: module Obelisk.ExecutableConfig.Lookup has 7 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: type signature for getConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 11 1: type signature for getConfigs has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 12 1: function getConfigs has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 12 1: function getConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src-other/Obelisk/ExecutableConfig/Lookup.hs\" 12 1: function getConfigs has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.Map (Map)\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\n\nimport Obelisk.Configs.Internal.Directory (getConfigsFromDirectory)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = getConfigsFromDirectory \"config\"\n",
              "suggestions": [
                {
                  "target_snippet": "import Data.ByteString (ByteString)",
                  "refactored_suggestion": "-- import Data.ByteString (ByteString)\n-- Reason: The imported 'ByteString' type is not used anywhere in this file.",
                  "confidence": 1.0,
                  "justification": "The module imports 'Data.ByteString', but the ByteString type is not utilized anywhere in the code. Removing this import can help keep the code cleaner and avoid unnecessary dependencies."
                },
                {
                  "target_snippet": "getConfigs = getConfigsFromDirectory \"config\"",
                  "refactored_suggestion": "getConfigs = getConfigsFromDirectory \"config\"\n-- Potential for improvement: Consider parameterizing the directory path (\"config\") to make the function more reusable.",
                  "confidence": 0.8,
                  "justification": "Hardcoding the directory path ('config') may limit the function's reusability. Allowing it to be passed as a parameter would make the function more flexible for use in different contexts."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.ExecutableConfig.Lookup where\n\nimport Data.Map (Map)\nimport Data.Text (Text)\n-- import Data.ByteString (ByteString)\n-- Reason: The imported 'ByteString' type is not used anywhere in this file.\n\nimport Obelisk.Configs.Internal.Directory (getConfigsFromDirectory)\n\ngetConfigs :: IO (Map Text ByteString)\ngetConfigs = getConfigsFromDirectory \"config\"\n-- Potential for improvement: Consider parameterizing the directory path (\"config\") to make the function more reusable.\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 3
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 19,
              "lines_of_code": 143,
              "homplexity_lines_of_code": 125,
              "code_quality_score": 81.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 3
                },
                "homplexity_loc": 125,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 1 1: module Obelisk.Configs has 122 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 58 3: type class HasConfigs has method + value count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 58 3: type class HasConfigs has associated type count of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 67 1: type signature for getTextConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 67 1: type signature for getTextConfig has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 68 1: function getTextConfig has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 68 1: function getTextConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 68 1: function getTextConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 82 24: data ConfigsT has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 133 1: type signature for runConfigsT has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 133 1: type signature for runConfigsT has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 137 1: function runConfigsT has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 137 1: function runConfigsT has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 137 1: function runConfigsT has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 139 1: type signature for mapConfigsT has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 139 1: type signature for mapConfigsT has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 143 1: function mapConfigsT has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 143 1: function mapConfigsT has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/executable-config/lookup/src/Obelisk/Configs.hs\" 143 1: function mapConfigsT has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Configs\n  ( HasConfigs(..)\n  , ConfigsT\n  , runConfigsT\n  , mapConfigsT\n  , getTextConfig\n  ) where\n\nimport Control.Applicative (Alternative)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Base (MonadBase)\nimport Control.Monad.Catch (MonadThrow)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail (MonadFail)\n#endif\nimport Control.Monad.Fix (MonadFix)\nimport Control.Monad.IO.Class (MonadIO)\nimport Control.Monad.Morph (MFunctor)\nimport Control.Monad.Primitive (PrimMonad, PrimState, primitive)\nimport Control.Monad.Ref (MonadRef)\nimport Control.Monad.Trans (MonadTrans, lift)\nimport Control.Monad.Trans.Control (MonadBaseControl)\nimport Control.Monad.Trans.Reader (ReaderT (..), ask, mapReaderT)\nimport Control.Monad.Trans.State (StateT)\nimport qualified Control.Monad.Trans.State.Strict as Strict\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex\nimport Reflex.Host.Class (MonadReflexCreateTrigger)\nimport Reflex.Dom.Core\n  ( DomBuilder\n  , DomRenderHook\n  , HasDocument\n  , Prerender (Client)\n  , StaticDomBuilderT\n  , prerender\n  )\n#ifndef ghcjs_HOST_OS\nimport Language.Javascript.JSaddle (MonadJSM)\n#endif\n\nclass Monad m => HasConfigs m where\n  getConfigs :: m (Map Text ByteString)\n  default getConfigs :: (HasConfigs m', m ~ t m', MonadTrans t) => m (Map Text ByteString)\n  getConfigs = lift getConfigs\n  getConfig :: Text -> m (Maybe ByteString)\n  getConfig k = do\n    configs <- getConfigs\n    return $ Map.lookup k configs\n\ninstance Monad m => HasConfigs (ConfigsT m) where\n  getConfigs = ConfigsT ask\n\ngetTextConfig :: HasConfigs m => Text -> m (Maybe Text)\ngetTextConfig k = fmap T.decodeUtf8 <$> getConfig k\n\ninstance HasConfigs m => HasConfigs (BehaviorWriterT t w m)\ninstance HasConfigs m => HasConfigs (DynamicWriterT t w m)\ninstance HasConfigs m => HasConfigs (EventWriterT t w m)\ninstance HasConfigs m => HasConfigs (PostBuildT t m)\ninstance HasConfigs m => HasConfigs (QueryT t q m)\ninstance HasConfigs m => HasConfigs (ReaderT r m)\ninstance HasConfigs m => HasConfigs (RequesterT t request response m)\ninstance HasConfigs m => HasConfigs (StateT w m)\ninstance HasConfigs m => HasConfigs (Strict.StateT w m)\ninstance HasConfigs m => HasConfigs (StaticDomBuilderT t m)\ninstance HasConfigs m => HasConfigs (TriggerEventT t m)\n\nnewtype ConfigsT m a = ConfigsT { unConfigsT :: ReaderT (Map Text ByteString) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadPlus\n    , Alternative\n    , MonadFail\n    , MonadFix\n    , MonadThrow\n    , MonadIO\n    , MonadBase m'\n    , MonadBaseControl m'\n    , MonadRef\n    , MonadTrans\n    , MFunctor\n    , DomBuilder t\n    , MonadHold t\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , NotReady t\n    , PostBuild t\n    , TriggerEvent t\n    , HasDocument\n    , DomRenderHook t\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    )\n\ninstance PerformEvent t m => PerformEvent t (ConfigsT m) where\n  type Performable (ConfigsT m) = ConfigsT (Performable m)\n  performEvent e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent $ runConfigsT configs <$> e\n  performEvent_ e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent_ $ runConfigsT configs <$> e\n\ninstance Adjustable t m => Adjustable t (ConfigsT m) where\n  runWithReplace a e = ConfigsT $ runWithReplace (unConfigsT a) (unConfigsT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = ConfigsT $ traverseDMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = ConfigsT $ traverseIntMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = ConfigsT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unConfigsT $ f k v) m e\n\ninstance Prerender t m => Prerender t (ConfigsT m) where\n  type Client (ConfigsT m) = ConfigsT (Client m)\n  prerender server client = ConfigsT $ ReaderT $ \\configs ->\n    prerender (runConfigsT configs server) (runConfigsT configs client)\n\ninstance PrimMonad m => PrimMonad (ConfigsT m) where\n  type PrimState (ConfigsT m) = PrimState m\n  primitive = lift . primitive\n\nrunConfigsT\n  :: Map Text ByteString\n  -> ConfigsT m a\n  -> m a\nrunConfigsT cs child = runReaderT (unConfigsT child) cs\n\nmapConfigsT\n  :: (forall x. m x -> n x)\n  -> ConfigsT m a\n  -> ConfigsT n a\nmapConfigsT f (ConfigsT x) = ConfigsT $ mapReaderT f x\n",
              "suggestions": [
                {
                  "target_snippet": "getConfig k = do\n    configs <- getConfigs\n    return $ Map.lookup k configs",
                  "refactored_suggestion": "getConfig k = Map.lookup k <$> getConfigs",
                  "confidence": 0.95,
                  "justification": "Replacing 'do' notation with a more concise applicative style improves readability and conciseness without changing functionality."
                },
                {
                  "target_snippet": "prerender server client = ConfigsT $ ReaderT $ \\configs ->\n    prerender (runConfigsT configs server) (runConfigsT configs client)",
                  "refactored_suggestion": "prerender server client = ConfigsT $ ReaderT $ \\configs -> prerender (ConfigsT $ ReaderT $ const server) (ConfigsT $ ReaderT $ const client)",
                  "confidence": 0.9,
                  "justification": "Enhancing consistency by restructuring the dual runConfigsT calls to simplify the code. Same functionality, less visual noise, and more direct transformation pipeline."
                },
                {
                  "target_snippet": "Found\n-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- Dead code or unused template placeholder and can be cleaned up (comment explicitly instead of leaving placeholders).",
                  "confidence": 0.8,
                  "justification": "This snippet appears to be a placeholder or unused comment that doesn't align with actual code usage. By removing it, we ensure a cleaner codebase, reducing potential confusion."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DefaultSignatures #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Obelisk.Configs\n  ( HasConfigs(..)\n  , ConfigsT\n  , runConfigsT\n  , mapConfigsT\n  , getTextConfig\n  ) where\n\nimport Control.Applicative (Alternative)\nimport Control.Monad (MonadPlus)\nimport Control.Monad.Base (MonadBase)\nimport Control.Monad.Catch (MonadThrow)\n#if !MIN_VERSION_base(4,13,0)\nimport Control.Monad.Fail (MonadFail)\n#endif\nimport Control.Monad.Fix (MonadFix)\nimport Control.Monad.IO.Class (MonadIO)\nimport Control.Monad.Morph (MFunctor)\nimport Control.Monad.Primitive (PrimMonad, PrimState, primitive)\nimport Control.Monad.Ref (MonadRef)\nimport Control.Monad.Trans (MonadTrans, lift)\nimport Control.Monad.Trans.Control (MonadBaseControl)\nimport Control.Monad.Trans.Reader (ReaderT (..), ask, mapReaderT)\nimport Control.Monad.Trans.State (StateT)\nimport qualified Control.Monad.Trans.State.Strict as Strict\nimport Data.ByteString (ByteString)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text.Encoding as T\nimport Reflex\nimport Reflex.Host.Class (MonadReflexCreateTrigger)\nimport Reflex.Dom.Core\n  ( DomBuilder\n  , DomRenderHook\n  , HasDocument\n  , Prerender (Client)\n  , StaticDomBuilderT\n  , prerender\n  )\n#ifndef ghcjs_HOST_OS\nimport Language.Javascript.JSaddle (MonadJSM)\n#endif\n\nclass Monad m => HasConfigs m where\n  getConfigs :: m (Map Text ByteString)\n  default getConfigs :: (HasConfigs m', m ~ t m', MonadTrans t) => m (Map Text ByteString)\n  getConfigs = lift getConfigs\n  getConfig :: Text -> m (Maybe ByteString)\n  getConfig k = Map.lookup k <$> getConfigs\n\ninstance Monad m => HasConfigs (ConfigsT m) where\n  getConfigs = ConfigsT ask\n\ngetTextConfig :: HasConfigs m => Text -> m (Maybe Text)\ngetTextConfig k = fmap T.decodeUtf8 <$> getConfig k\n\ninstance HasConfigs m => HasConfigs (BehaviorWriterT t w m)\ninstance HasConfigs m => HasConfigs (DynamicWriterT t w m)\ninstance HasConfigs m => HasConfigs (EventWriterT t w m)\ninstance HasConfigs m => HasConfigs (PostBuildT t m)\ninstance HasConfigs m => HasConfigs (QueryT t q m)\ninstance HasConfigs m => HasConfigs (ReaderT r m)\ninstance HasConfigs m => HasConfigs (RequesterT t request response m)\ninstance HasConfigs m => HasConfigs (StateT w m)\ninstance HasConfigs m => HasConfigs (Strict.StateT w m)\ninstance HasConfigs m => HasConfigs (StaticDomBuilderT t m)\ninstance HasConfigs m => HasConfigs (TriggerEventT t m)\n\nnewtype ConfigsT m a = ConfigsT { unConfigsT :: ReaderT (Map Text ByteString) m a }\n  deriving\n    ( Functor\n    , Applicative\n    , Monad\n    , MonadPlus\n    , Alternative\n    , MonadFail\n    , MonadFix\n    , MonadThrow\n    , MonadIO\n    , MonadBase m'\n    , MonadBaseControl m'\n    , MonadRef\n    , MonadTrans\n    , MFunctor\n    , DomBuilder t\n    , MonadHold t\n    , MonadReflexCreateTrigger t\n    , MonadSample t\n    , NotReady t\n    , PostBuild t\n    , TriggerEvent t\n    , HasDocument\n    , DomRenderHook t\n#ifndef ghcjs_HOST_OS\n    , MonadJSM\n#endif\n    )\n\ninstance PerformEvent t m => PerformEvent t (ConfigsT m) where\n  type Performable (ConfigsT m) = ConfigsT (Performable m)\n  performEvent e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent $ runConfigsT configs <$> e\n  performEvent_ e = ConfigsT $ ReaderT $ \\configs ->\n    performEvent_ $ runConfigsT configs <$> e\n\ninstance Adjustable t m => Adjustable t (ConfigsT m) where\n  runWithReplace a e = ConfigsT $ runWithReplace (unConfigsT a) (unConfigsT <$> e)\n  traverseDMapWithKeyWithAdjust f m e = ConfigsT $ traverseDMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseIntMapWithKeyWithAdjust f m e = ConfigsT $ traverseIntMapWithKeyWithAdjust (\\k v -> unConfigsT $ f k v) m e\n  traverseDMapWithKeyWithAdjustWithMove f m e = ConfigsT $ traverseDMapWithKeyWithAdjustWithMove (\\k v -> unConfigsT $ f k v) m e\n\ninstance Prerender t m => Prerender t (ConfigsT m) where\n  type Client (ConfigsT m) = ConfigsT (Client m)\n  prerender server client = ConfigsT $ ReaderT $ \\configs -> prerender (ConfigsT $ ReaderT $ const server) (ConfigsT $ ReaderT $ const client)\n\ninstance PrimMonad m => PrimMonad (ConfigsT m) where\n  type PrimState (ConfigsT m) = PrimState m\n  primitive = lift . primitive\n\nrunConfigsT\n  :: Map Text ByteString\n  -> ConfigsT m a\n  -> m a\nrunConfigsT cs child = runReaderT (unConfigsT child) cs\n\nmapConfigsT\n  :: (forall x. m x -> n x)\n  -> ConfigsT m a\n  -> ConfigsT n a\nmapConfigsT f (ConfigsT x) = ConfigsT $ mapReaderT f x\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/selftest/src/Obelisk/SelfTest.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/selftest/src/Obelisk/SelfTest.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 19,
                "average": 5,
                "sum": 86
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 1,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 22,
              "lines_of_code": 841,
              "homplexity_lines_of_code": 1257,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 19,
                  "average": 5,
                  "sum": 86
                },
                "homplexity_loc": 1257,
                "homplexity_output": "\n{\n    \"cyclomatic_complexity\": {\n        \"min\": 1,\n        \"max\": 19,\n        \"average\": 4.526315789473684,\n        \"sum\": 86\n    },\n    \"homplexity_loc\": 1257\n}\n"
              },
              "original_code": "{-# LANGUAGE DoAndIfThenElse #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.SelfTest where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Exception (bracket, throw, try)\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Aeson.Types as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as LBS\nimport Data.Foldable (for_)\nimport Data.Function (fix)\nimport Data.List (isInfixOf)\nimport qualified Data.Map as Map\nimport Data.Semigroup ((<>))\nimport qualified Data.Set as Set\nimport Data.String\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.IO as T\nimport qualified Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Socket as Socket\nimport Shelly\nimport System.Directory (getCurrentDirectory, withCurrentDirectory, getDirectoryContents)\nimport System.Environment\nimport System.Exit (ExitCode (..))\nimport System.FilePath (addTrailingPathSeparator)\nimport qualified System.Info\nimport System.IO (Handle, hClose, hIsEOF, hGetContents)\nimport System.IO.Temp\nimport System.Process (readProcessWithExitCode)\nimport System.Which (staticWhich)\nimport Test.Hspec\nimport Test.HUnit.Base\n\nimport Obelisk.ExecutableConfig.Lookup (getConfigs)\nimport Obelisk.Run (getConfigRoute)\n\ndata ObRunState\n  = ObRunState_Init\n  | ObRunState_Startup\n  | ObRunState_BackendStarted\n  deriving (Eq, Show)\n\ncpPath :: FilePath\ncpPath = $(staticWhich \"cp\")\n\ncabalPath :: FilePath\ncabalPath = $(staticWhich \"cabal\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nchownPath :: FilePath\nchownPath = $(staticWhich \"chown\")\n\nchmodPath :: FilePath\nchmodPath = $(staticWhich \"chmod\")\n\nwhoamiPath :: FilePath\nwhoamiPath = $(staticWhich \"whoami\")\n\nnixInstantiatePath :: FilePath\nnixInstantiatePath = $(staticWhich \"nix-instantiate\")\n\nnixBuildPath :: FilePath\nnixBuildPath = $(staticWhich \"nix-build\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nsedPath :: FilePath\nsedPath = $(staticWhich \"sed\")\n\ngitUserConfig :: [Text]\ngitUserConfig = [\"-c\", \"user.name=Obelisk Selftest\", \"-c\", \"user.email=noreply@example.com\"]\n\ncommit :: Text -> Sh ()\ncommit msg = void $ run gitPath $ gitUserConfig <> [ \"commit\"\n  , \"--no-gpg-sign\"\n  , \"--allow-empty\"\n  , \"-m\"\n  , msg\n  ]\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\n-- | Like `shelly` but used when running `ob` commands\nshellyOb :: MonadIO m => (Sh a -> Sh a) -> Sh a -> m a\nshellyOb f obTest = shelly $ f obTest\n\n-- Set \"ob\" in a single place so it can be replaced with a\n-- link to obelisk in the nix store in the future,\n-- and avoid PATH hacking before calling this script.\nob :: FilePath\nob = \"ob\"\n\naugmentWithVerbosity :: (String -> [Text] -> a) -> String -> Bool -> [Text] -> a\naugmentWithVerbosity runner executable isVerbose args = runner executable $ (if isVerbose then (\"-v\" :) else id) args\n\nisolatedGitShell :: Bool -> FilePath -> (([Text] -> Sh Text) -> Sh a) -> IO a\nisolatedGitShell isVerbose dir f = shelly $ bool silently verbosely isVerbose $ do\n  setenv \"HOME\" \"/dev/null\"\n  setenv \"GIT_CONFIG_NOSYSTEM\" \"1\"\n  _ <- git [\"init\"]\n  _ <- git [\"config\", \"user.name\", \"SelfTest\"]\n  _ <- git [\"config\", \"user.email\", \"self@test\"]\n  f git\n  where\n    git args = run gitPath $ [\"-C\", toTextIgnore dir] <> args\n\n-- | Copies a git repo to a new location and \"resets\" the git history to include\n-- exactly one commit with all files added. It then restricts writing and reading\n-- for group and user to make the repo ideal for being a valid git remote for thunks.\n--\n-- Using this allows dirty repos to be used as git remotes during the test since 'git clone'ing\n-- a dirty repo will not include the uncommitted changes.\ncopyForGitRemote :: Bool -> FilePath -> FilePath -> IO ()\ncopyForGitRemote isVerbose origDir copyDir = isolatedGitShell isVerbose copyDir $ \\git -> do\n  run_ rsyncPath\n    [ \"-r\", \"--no-perms\", \"--no-owner\", \"--no-group\", \"--exclude\", \".git\"\n    , toTextIgnore (addTrailingPathSeparator origDir), toTextIgnore copyDir\n    ]\n  _ <- git [\"add\", \"--all\"]\n  _ <- git [\"commit\", \"-m\", \"Copy repo\"]\n  run_ chmodPath [\"-R\", \"u-w,g-rw,o-rw\", toTextIgnore copyDir] -- Freeze this state\n\nmain :: IO ()\nmain = do\n  -- Note: you can pass hspec arguments as well, eg: `-m <pattern>`\n  isVerbose <- elem \"-v\" <$> getArgs\n  unless isVerbose $\n    putStrLn \"Tests may take longer to run if there are unbuilt derivations: use -v for verbose output\"\n\n  obeliskImplDirtyReadOnly <- getCurrentDirectory\n  httpManager <- HTTP.newManager HTTP.defaultManagerSettings\n\n  withSystemTempDirectory \"obelisk-repo-git-remote\" $ \\copyDir -> do\n    copyForGitRemote isVerbose obeliskImplDirtyReadOnly copyDir\n    main' isVerbose httpManager copyDir\n\nmain' :: Bool -> HTTP.Manager -> FilePath -> IO ()\nmain' isVerbose httpManager obeliskRepoReadOnly = withInitCache $ \\initCache -> hspec $ parallel $ do\n  let\n    inTmpObInit' dirname f = inTmp' dirname $ \\dir -> do\n      run_ cpPath [\"-rT\", fromString initCache, toTextIgnore dir]\n      f dir\n    inTmpObInit = inTmpObInit' defaultTmpDirName\n\n    -- To be used in tests that change the obelisk impl directory\n    inTmpObInitWithImplCopy f = inTmpObInit $ \\dir ->\n      withObeliskImplClean $ \\(fromString -> implClean) -> do\n        run_ rmPath [thunk]\n        run_ lnPath [\"-s\", implClean, thunk]\n        f dir\n\n  describe \"ob init\" $ parallel $ do\n    it \"works with default impl\"       $ inTmp $ \\_ -> runOb [\"init\"]\n    it \"works with master branch impl\" $ inTmp $ \\_ -> runOb [\"init\", \"--branch\", \"master\"]\n    it \"works with symlink\"            $ inTmp $ \\_ -> runOb [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n    it \"doesn't silently overwrite existing files\" $ inTmp $ \\_ -> do\n      let p force = errExit False $ do\n            run_ ob $ \"--no-handoff\" : \"-v\" : \"init\" : [\"--force\"|force]\n            (== 0) <$> lastExitCode\n\n      True <- p False\n      False <- p False\n      True <- p True\n      pure ()\n\n    it \"doesn't create anything when given an invalid impl\" $ inTmp $ \\tmp -> do\n      void $ errExit False $ runOb [\"init\", \"--symlink\", \"/dev/null\"]\n      ls tmp >>= liftIO . assertEqual \"\" []\n\n    it \"produces a valid route config\" $ inTmpObInit $ \\tmp -> liftIO $\n      withCurrentDirectory (T.unpack $ toTextIgnore tmp) $ do\n        configs <- getConfigs\n        return (either (const Nothing) Just $ getConfigRoute configs) `shouldNotReturn` Nothing\n\n    it \"can unpack and repack .obelisk/impl after init with master branch impl\" $ inTmp $ \\_ -> do\n      runOb_ [\"init\", \"--branch\", \"master\"]\n      runOb_ [\"thunk\", \"unpack\", \".obelisk/impl\"]\n      runOb_ [\"thunk\", \"pack\", \".obelisk/impl\"]\n\n  -- These tests fail with \"Could not find module 'Obelisk.Generated.Static'\"\n  -- when not run by 'nix-build --attr selftest'\n  describe \"ob run\" $ {- NOT parallel $ -} do\n    it \"works in root directory\" $ inTmpObInit $ \\_ -> testObRunInDir' Nothing httpManager\n    it \"works in sub directory\" $ inTmpObInit $ \\_ -> testObRunInDir' (Just \"frontend\") httpManager\n    it \"can read external TLS certificates in root directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir Nothing\n    it \"can read external TLS certificates in sub directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir (Just \"frontend\")\n    it \"complains when static files are missing in root directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' Nothing\n    it \"complains when static files are missing in sub directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' (Just \"frontend\")\n    it \"complains when static filepaths are missing in root directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' Nothing\n    it \"complains when static filepaths are missing in sub directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' (Just \"frontend\")\n    it \"fails when given an invalid Cabal file\" $ inTmpObInit $ testObRunWithInvalidCabalFile ob\n\n    it \"respects the port given on the command line\" $ inTmpObInit $ \\testDir -> do\n      [port] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandles ob [\"run\", \"-p\", T.pack (show port)] [] $ \\_stdin stdout stderr -> do\n        uri <- handleObRunStdout httpManager stdout stderr\n        -- Make sure obelisk logs the right thing\n        unless (T.pack (show port ++ \"/\") `T.isSuffixOf` T.strip uri) $\n          error $ \"Expected the URI to end in \" ++ show port ++ \" but it ended in \" ++ T.unpack uri\n        -- But also verify that we can actually reach the server in the\n        -- given path, rather than just listening for the log URL\n        let req = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n        req >>= \\case\n          Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n          e -> errorExit $ \"Request to ob run failed: \" <> T.pack (show e)\n        exit 0\n\n  describe \"ob repl\" $ do\n    it \"accepts stdin commands\" $ inTmpObInit $ \\_ -> do\n      setStdin \"print 3\\n:q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        [ \"*Obelisk.Run Obelisk.Run Frontend Backend> 3\"\n        , \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\"\n        ] `isInfixOf` T.lines (T.strip output)\n    it \"works with custom Prelude\" $ inTmpObInit $ \\_ -> do\n      writefile \"common/src/Prelude.hs\"\n        \"{-# LANGUAGE PackageImports #-} module Prelude (module X) where import \\\"base\\\" Prelude as X\"\n      setStdin \":q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\" `T.isInfixOf` output\n\n  describe \"obelisk project\" $ parallel $ do\n    it \"can build obelisk command\"  $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"command\" , toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk skeleton\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"skeleton\", toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk shell\"    $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"shell\",    toTextIgnore obeliskRepoReadOnly]\n    it \"can build everything\"       $ inTmpObInit $ \\_ -> nixBuild [toTextIgnore obeliskRepoReadOnly]\n\n  describe \"blank initialized project\" $ parallel $ do\n\n    it \"can build ghc.backend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghc.backend\"]\n    it \"can build ghcjs.frontend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghcjs.frontend\"]\n\n    if System.Info.os == \"darwin\"\n      then it \"can build ios\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ios.frontend\"]\n      else it \"can build android after accepting license\" $ inTmpObInit $ \\dir -> do\n        let defaultNixPath = dir </> (\"default.nix\" :: FilePath)\n        writefile defaultNixPath\n          =<< T.replace\n            \"# config.android_sdk.accept_license = false;\"\n            \"config.android_sdk.accept_license = true;\"\n          <$> readfile defaultNixPath\n        nixBuild [\"-A\", \"android.frontend\"]\n\n    forM_ [\"ghc\", \"ghcjs\"] $ \\compiler -> do\n      let\n        shellName = \"shells.\" <> compiler\n        inShell cmd' = run_ \"nix-shell\" [\"default.nix\", \"-A\", fromString shellName, \"--run\", cmd']\n      it (\"can enter \"    <> shellName) $ inTmpObInit $ \\_ -> inShell \"exit\"\n      -- NOTE: We override the temporary directory name because cabal has a bug preventing new-build from working\n      -- in a path that has unicode characters.\n      it (\"can build in \" <> shellName) $ inTmpObInit' \"test\" $ \\_ -> inShell $\n          T.pack cabalPath <> \" --version; \" <> T.pack cabalPath <> \" new-build --\" <> T.pack compiler <> \" all\"\n\n    it \"has idempotent thunk update\" $ inTmpObInitWithImplCopy $ \\_ -> do\n      _  <- pack\n      u  <- update\n      uu <- update\n      assertRevEQ u uu\n\n    it \"can run 'ob doc'\" $ inTmpObInit $ \\_ -> runOb_ [\"doc\", \"reflex\"]\n\n  describe \"ob thunk pack/unpack\" $ parallel $ do\n    it \"has thunk pack and unpack inverses\" $ inTmpObInitWithImplCopy $ \\_ -> do\n\n      _    <- pack\n      e    <- commitAll\n      eu   <- unpack\n      eup  <- pack\n      eupu <- unpack\n      _    <- pack\n\n      assertRevEQ e  eup\n      assertRevEQ eu eupu\n      assertRevNE e  eu\n\n    it \"unpacks the correct branch\" $ withTmp $ \\dir -> do\n      let branch = \"master\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch]\n      runOb_ [\"thunk\", \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"unpack\", toTextIgnore dir]\n      branch' <- run gitPath [\"-C\", toTextIgnore $ dir </> unpackedDirName, \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n      liftIO $ assertEqual \"\" branch (T.strip branch')\n\n    it \"can pack and unpack plain git repos\" $\n      shelly_ $ withSystemTempDirectory \"git-repo\" $ \\dir -> do\n        let repo = toTextIgnore $ dir </> (\"repo\" :: FilePath)\n        run_ gitPath [\"clone\", \"https://github.com/haskell/process.git\", repo]\n        origHash <- chdir (fromText repo) revParseHead\n\n        runOb_ [\"thunk\", \"pack\", repo]\n        packedFiles <- Set.fromList <$> ls (fromText repo)\n        liftIO $ assertEqual \"\" packedFiles $ Set.fromList $ (repo </>) <$>\n          [\"default.nix\", \"thunk.nix\", \"github.json\" :: FilePath]\n\n        runOb_ [\"thunk\", \"unpack\", repo]\n        chdir (fromText repo </> unpackedDirName) $ do\n          unpackHash <- revParseHead\n          assertRevEQ origHash unpackHash\n\n        testThunkPack' $ fromText repo\n\n    it \"aborts thunk pack when there are uncommitted files\" $ inTmpObInitWithImplCopy $ \\dir -> do\n      testThunkPack' (dir </> thunk)\n\n    it \"works on legacy git thunks\" $ testLegacyGitThunks isVerbose\n\n  describe \"ob thunk update --branch\" $ parallel $ do\n    it \"can change a thunk to the latest version of a desired branch\" $ withTmp $ \\dir -> do\n      let branch1 = \"master\"\n          branch2 = \"develop\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch1]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", branch2]\n\n    it \"doesn't create anything when given an invalid branch\" $ withTmp $ \\dir -> do\n      let checkDir dir' = liftIO $ getDirectoryContents $ T.unpack $ toTextIgnore dir'\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", \"master\"]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      startingContents <- checkDir dir\n      void $ errExit False $ runOb [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", \"dumble-palooza\"]\n      checkDir dir >>= liftIO . assertEqual \"\" startingContents\n\n  describe \"ob shell\" $ parallel $ do\n    it \"works with --\" $ inTmpObInit $ \\_ -> do\n      output <- runOb [\"shell\", \"--\", \"ghc-pkg\", \"list\"]\n      liftIO $ assertBool \"Unexpected output from ob shell\" $ (\"Cabal-\" `T.isInfixOf` output) && (\"ghc-\" `T.isInfixOf` output)\n\n  describe \"ob hoogle\" $ {- NOT parallel -} do\n    it \"starts a hoogle server on the given port\" $ inTmpObInit $ \\_ -> do\n      [p0] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandle \"ob\" [\"hoogle\", \"--port\", T.pack (show p0)] $ \\stdout -> flip fix Nothing $ \\loop -> \\case\n        Nothing -> do -- Still waiting for initial signal that the server has started\n          ln <- liftIO $ T.hGetLine stdout\n          let search = \"Server starting on port \" <> T.pack (show p0)\n          case search `T.isInfixOf` ln of\n            False -> loop Nothing -- keep waiting\n            True -> loop $ Just 10\n        Just (n :: Int) -> do -- Server has started and we have n attempts left\n          let req uri = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest uri >>= flip HTTP.httpLbs httpManager\n          req (\"http://127.0.0.1:\" <> show p0) >>= \\case\n            Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n            e -> if n <= 0\n              then errorExit $ \"Request to hoogle server failed: \" <> T.pack (show e)\n              else liftIO (threadDelay (1*10^(6 :: Int))) *> loop (Just $ n - 1)\n  where\n    verbosity = bool silently verbosely isVerbose\n    nixBuild args = run nixBuildPath (\"--no-out-link\" : args)\n\n    runOb_ = augmentWithVerbosity run_ ob isVerbose\n    runOb = augmentWithVerbosity run ob isVerbose\n    testObRunInDir' = augmentWithVerbosity testObRunInDir ob isVerbose [\"run\"]\n    testObRunCert' = augmentWithVerbosity testObRunCert ob isVerbose [\"run\", \"-c\", \".\"]\n    testObRunInDirWithMissingStaticFile' = augmentWithVerbosity testObRunInDirWithMissingStaticFile ob isVerbose [\"run\"]\n    testObRunInDirWithMissingStaticFilePath' = augmentWithVerbosity testObRunInDirWithMissingStaticFilePath ob isVerbose [\"run\"]\n    testThunkPack' = augmentWithVerbosity testThunkPack ob isVerbose []\n\n    withObeliskImplClean f =\n      withSystemTempDirectory \"obelisk-impl-clean\" $ \\obeliskImpl -> do\n        void . shellyOb verbosity $ do\n          dirtyFiles <- T.strip <$> run gitPath [\"-C\", toTextIgnore obeliskRepoReadOnly, \"diff\", \"--stat\"]\n          () <- when (dirtyFiles /= \"\") $ error \"SelfTest does not work correctly with dirty obelisk repos as remote\"\n          run_ gitPath [\"clone\", \"file://\" <> toTextIgnore obeliskRepoReadOnly, toTextIgnore obeliskImpl]\n        f obeliskImpl\n\n    withInitCache f =\n      withSystemTempDirectory \"init Cache \u03bb\" $ \\initCache -> do\n        -- Setup the ob init cache\n        void . shellyOb verbosity $ chdir initCache $ do\n          runOb_ [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n          run_ gitPath [\"init\"]\n\n        f initCache\n\n    shelly_ = void . shellyOb verbosity\n\n    defaultTmpDirName = \"test \u03bb\"\n\n    inTmp' :: FilePath -> (FilePath -> Sh a) -> IO ()\n    inTmp' dirname f = withTmp' dirname (chdir <*> f)\n    inTmp = inTmp' defaultTmpDirName\n\n    withTmp' dirname f = shelly_ . withSystemTempDirectory dirname $ f . fromString\n    withTmp = withTmp' defaultTmpDirName\n\n    assertRevEQ a b = liftIO . assertEqual \"\" \"\"        =<< diff a b\n    assertRevNE a b = liftIO . assertBool  \"\" . (/= \"\") =<< diff a b\n\n    revParseHead = T.strip <$> run gitPath [\"rev-parse\", \"HEAD\"]\n\n    commitAll = do\n      run_ gitPath [\"add\", \".\"]\n      commit \"checkpoint\"\n      revParseHead\n\n    thunk  = \".obelisk/impl\"\n    update = runOb [\"thunk\", \"update\", thunk] *> commitAll\n    pack   = runOb [\"thunk\", \"pack\",   thunk] *> commitAll\n    unpack = runOb [\"thunk\", \"unpack\", thunk] *> commitAll\n\n    diff a b = run gitPath [\"diff\", a, b]\n\n\nmaskExitSuccess :: Sh () -> Sh ()\nmaskExitSuccess = handle_sh (\\case ExitSuccess -> pure (); e -> throw e)\n\n-- | Run `ob run` in the given directory (maximum of one level deep)\ntestObRunInDir :: String -> [Text] -> Maybe FilePath -> HTTP.Manager -> Sh ()\ntestObRunInDir executable extraArgs mdir httpManager = maskExitSuccess $ do\n  [p0, p1] <- liftIO $ getFreePorts 2\n  let uri p = \"http://localhost:\" <> T.pack (show p) <> \"/\" -- trailing slash required for comparison\n  writefile \"config/common/route\" $ uri p0\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    firstUri <- handleObRunStdout httpManager stdout stderr\n    let newUri = uri p1\n    when (firstUri == newUri) $ errorExit $\n      \"Startup URI (\" <> firstUri <> \") is the same as test URI (\" <> newUri <> \")\"\n    maybe id (\\_ -> chdir \"..\") mdir $ alterRouteTo newUri stdout\n    runningUri <- handleObRunStdout httpManager stdout stderr\n    if runningUri /= newUri\n      then errorExit $ \"Reloading failed: expected \" <> newUri <> \" but got \" <> runningUri\n      else exit 0\n\ntestObRunCert :: String -> [Text] -> FilePath -> Maybe FilePath -> Sh ()\ntestObRunCert executable extraArgs testDir mdir = maskExitSuccess $ do\n  -- Generate a TLS key, and then a self-signed certificate using that key\n  mapM_ (\\cmd -> run_ \"nix-shell\" [\"-p\", \"openssl\", \"--command\", cmd])\n    [ \"openssl genrsa -out key.pem 2048\"\n    , \"openssl req -new -key key.pem -out certificate.csr -subj \\\"/C=US/ST=New York/L=New York/O=Development/OU=IT Department/CN=obsidian.com\\\"\"\n    , \"openssl x509 -req -in certificate.csr -signkey key.pem -out cert.pem\"\n    ]\n\n  -- One more command is required, for generating the chain.pem file.\n  -- For testing purposes, we'll keep it the same as the cert.pem file.\n  run_ \"cp\" [\"cert.pem\", \"chain.pem\"]\n\n  -- Also need to change the route inside config/common/route to https\n  -- in order to trigger the certificates option (the -c option is not honored for http)\n  writefile \"config/common/route\" \"https://localhost:8000\"\n\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_ stdout _ -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      isEOF <- liftIO $ hIsEOF h\n      if isEOF\n        then errorExit \"Obelisk exited somehow\"\n        else do\n          line <- liftIO $ hGetLineSkipBlanks h\n          check line h\n\n    -- Here we check that the certificates are read properly by Obelisk\n    -- In case the server is started without reading the certificates, show an error.\n    check line h\n      | \"Using certificate information from:\" `T.isPrefixOf` line = do\n        -- Should be followed by a `Frontend running on <url>` line\n        next <- liftIO $ hGetLineSkipBlanks h\n        if \"Frontend running on\" `T.isPrefixOf` next\n          then exit 0\n          else errorExit $ \"Ran into error: \" <> next\n      | \"Frontend running on\" `T.isPrefixOf` line = errorExit \"Obelisk did not read the certificates provided via -c option\"\n      | otherwise = parseObOutput h\n\n-- | Mess up the Cabal file in the given directory, then make sure that\n-- @ob run@ fails.\ntestObRunWithInvalidCabalFile\n  :: FilePath  -- ^ Obelisk path\n  -> FilePath  -- ^ Directory path (will be made invalid)\n  -> Sh ()\ntestObRunWithInvalidCabalFile executable fp = do\n  let commonCabal :: String\n      commonCabal = \"common/common.cabal\"\n  liftIO $ writeFile (fp </> commonCabal) \"This is not a valid Cabal file.\"\n  errExit False $ do\n    runHandles executable [\"run\"] [] $ \\_ _ _ -> pure ()\n    lastExitCode >>= \\case\n      0 -> pure ()\n      _ -> errorExit \"ob run succeeded even with an invalid Cabal file\"\n\n-- | Check whether embedding a non-existent filepath into an obelisk\n-- project is detected correctly and generates a compile-time error.\n--\n-- @'testObRunInDirWithMissingStaticFileWorker' exe args mdir act checkErrorMessage@.\n--\n-- @checkErrorMessage line1 line2@ is invoked on a compile-time error message of the following form:\n--     frontend/src/Frontend.hs:40:32: error:\n--        \u2022 Static file obelisk.jpg was not found in static.out\n--        \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n--       |\n--    40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n--       |\n--\n-- the arguments to @line1@ and @line2@ contain:\n--\n-- @    \u2022 Static file obelisk.jpg was not found in static.out@\n--\n-- and\n--\n-- @    \u2022 In the untyped splice: $(static \"obelisk.jpg\")@\n--\n-- respectively.\ntestObRunInDirWithMissingStaticFileWorker\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\n  -- ^ Run this action before running @ob run@.\n  -- Gives you the opportunity to modify the project to trigger events.\n  -- In particular, make sure static files do not exist, s.t. a compilation\n  -- error is thrown.\n  -> (Text -> Text -> Sh ())\n  -- ^ Assertion function for error messages.\n  -- Since this function is used for asserting error message contents,\n  -- this function specifies what contents two consecutive non-empty lines\n  -- are supposed to have.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkErrorMessage = maskExitSuccess $ do\n  act\n  -- Now run `ob run` and read the error\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      line <- liftIO $ hGetLineSkipBlanks h\n      -- This means that everything was successful, this should not be the case\n      if line == \"Running test...\"\n        then errorExit \"Could not find any error related to static files\"\n        else checkForErrors line h\n\n    -- As can be seen in the example below, we can parse a lot of data.\n    -- For simplicity, we parse the two lines after the `error:` line.\n    -- We also ensure that the file name is same, as the file that we changed ie `obelisk.jpg`\n    checkForErrors line h\n      -- Found an error, check if it is due to static.out\n      | \"error:\" `T.isSuffixOf` line = do\n        line1 <- liftIO $ hGetLineSkipBlanks h\n        line2 <- liftIO $ hGetLineSkipBlanks h\n        checkErrorMessage line1 line2\n      | otherwise = parseObOutput h\n\n-- | Run an obelisk test-case, where @static@ is embedding an non-existent\n-- filepath.\ntestObRunInDirWithMissingStaticFile\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFile executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(static \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\n-- | Run an obelisk test-case, where @staticFilePath@ is embedding an\n-- non-existent filepath.\ntestObRunInDirWithMissingStaticFilePath\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFilePath executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = do\n      run_ sedPath [\"-e\", \"s/\\\\$(static /\\\\$(staticFilePath /\", \"-i\", \"frontend/src/Frontend.hs\"]\n      run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(staticFilePath \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(staticFilePath \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(staticFilePath \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\ntestThunkPack :: String -> [Text] -> FilePath -> Sh ()\ntestThunkPack executable args path' = withTempFile repoDir \"test-file\" $ \\file handle -> do\n  let\n    pack' = readProcessWithExitCode executable ([\"thunk\", \"pack\", path'] ++ map T.unpack args) \"\"\n    ensureThunkPackFails q = liftIO $ pack' >>= \\case\n      (code, out, err)\n        | code == ExitSuccess -> fail $ \"ob thunk pack succeeded when it should have failed with error '\" <> show q <> \"'\"\n        | q `T.isInfixOf` T.pack (out <> err) -> pure ()\n        | otherwise -> fail $ \"ob thunk pack failed for an unexpected reason, expecting '\" <> show q <> \"', received: \" <> show out <> \"\\nstderr: \" <> err\n    git = chdir repoDir . run_ gitPath\n  -- Untracked files\n  ensureThunkPackFails \"Untracked files\"\n  git [\"add\", T.pack file]\n  -- Uncommitted files (staged)\n  ensureThunkPackFails \"unsaved\"\n  chdir repoDir $ commit \"test commit\"\n  -- Non-pushed commits in any branch\n  ensureThunkPackFails \"not yet pushed\"\n  -- Uncommitted files (unstaged)\n  liftIO $ T.hPutStrLn handle \"test file\" >> hClose handle\n  ensureThunkPackFails \"modified\"\n  -- Existing stashes\n  git $ gitUserConfig <> [ \"stash\" ]\n  ensureThunkPackFails \"has stashes\"\n  where\n    repoDir = path' </> unpackedDirName\n\n-- | Blocks until a non-empty line is available\nhGetLineSkipBlanks :: MonadIO m => Handle -> m Text\nhGetLineSkipBlanks h = liftIO $ fix $ \\loop -> T.hGetLine h >>= \\case\n  \"\" -> loop\n  t -> pure t\n\n-- | Alters the route file and waits for `ob run` to reload\nalterRouteTo :: Text -> Handle -> Sh ()\nalterRouteTo uri stdout = do\n  writefile \"config/common/route\" uri\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Reloading...\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"  config/common/route\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Interrupted.\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n\n-- | Handle stdout of `ob run`: check that the frontend and backend servers are started correctly\nhandleObRunStdout :: HTTP.Manager -> Handle -> Handle -> Sh Text\nhandleObRunStdout httpManager stdout stderr = flip fix (ObRunState_Init, []) $ \\loop (state, msgs) -> do\n  isEOF <- liftIO $ hIsEOF stdout\n  if isEOF\n  then handleObRunError msgs\n  else liftIO (T.hGetLine stdout) >>= \\t -> case state of\n    ObRunState_Init\n      | \"Running test...\" `T.isPrefixOf` t -> loop (ObRunState_BackendStarted, msgs)\n    ObRunState_Startup\n      | t == \"backend stopped; make a change to your code to reload\" -> loop (ObRunState_Startup, msgs)\n      -- | Just port <- \"Backend running on port \" `T.stripPrefix` t -> loop $ ObRunState_BackendStarted port\n      | not (T.null t) -> errorExit $ \"Startup: \" <> t -- If theres any other output here, startup failed\n    ObRunState_BackendStarted\n      | Just uri <- \"Frontend running on \" `T.stripPrefix` t -> do\n        obRunCheck httpManager stdout uri\n        pure uri\n      | not (T.null t) -> errorExit $ \"Started: \" <> t -- If theres any other output here, startup failed\n    _ | \"Failed\" `T.isPrefixOf` t -> handleObRunError (t : msgs)\n      | otherwise -> loop (state, t : msgs)\n  where\n    handleObRunError msgs = do\n      stderrContent <- liftIO $ hGetContents stderr\n      errorExit $ \"ob run failed: \" <> T.unlines (reverse msgs) <> \" stderr: \" <> T.pack stderrContent\n\n-- | Make requests to frontend/backend servers to check they are working properly\nobRunCheck :: HTTP.Manager -> Handle -> Text -> Sh ()\nobRunCheck httpManager _stdout frontendUri = do\n  let req uri = liftIO $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n  req frontendUri >>= \\r -> when (HTTP.responseStatus r /= HTTP.ok200) $ errorExit $\n    \"Request to frontend server failed: \" <> T.pack (show r)\n\ngetFreePorts :: Int -> IO [Socket.PortNumber]\ngetFreePorts 0 = pure []\ngetFreePorts n = Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close $ \\s -> (:) <$> Socket.socketPort s <*> getFreePorts (n - 1)\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      pure sock\n\ntestLegacyGitThunks :: Bool -> IO ()\ntestLegacyGitThunks isVerbose = withSystemTempDirectory \"test-git-repo\" $ \\gitDir -> do\n  isolatedGitShell isVerbose gitDir $ \\git -> do\n    writefile (gitDir </> (\"default.nix\" :: FilePath)) \"{}: \\\"hello\\\"\"\n    _ <- git [\"add\", \"--all\"]\n    _ <- git [\"commit\", \"-m\", \"Initial commit\"]\n    rev <- T.strip <$> git [\"rev-parse\", \"HEAD\"]\n    sha256 :: Text\n      <-  either error pure\n      =<< (Aeson.parseEither (Aeson..: \"sha256\") <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n      <$> run nixPrefetchGitPath [toTextIgnore gitDir]\n\n    for_ (legacyGitThunks (GitThunkParams gitDir rev sha256)) $ \\mkFiles ->\n      withSystemTempDirectory \"test-thunks\" $ \\thunkDir -> do\n        liftIO $ mkFiles thunkDir\n        run_ \"ob\" [\"thunk\", \"unpack\", toTextIgnore thunkDir]\n        run_ \"ob\" [\"thunk\", \"pack\", toTextIgnore thunkDir]\n\ndata GitThunkParams = GitThunkParams\n  { _gitThunkParams_repo :: !FilePath\n  , _gitThunkParams_rev :: !Text\n  , _gitThunkParams_sha256 :: !Text\n  } deriving Show\n\nlegacyGitThunks :: GitThunkParams -> [FilePath -> IO ()]\nlegacyGitThunks (GitThunkParams repo' rev sha256) =\n  [ mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  assert !fetchSubmodules; (import <nixpkgs> {}).fetchgit { inherit url rev sha256; };\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  if builtins.hasAttr \\\"fetchGit\\\" builtins\"\n        , \"    then builtins.fetchGit ({ inherit url rev; } // (if branch == null then {} else { ref = branch; }))\"\n        , \"    else abort \\\"Plain Git repositories are only supported on nix 2.0 or higher.\\\";\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, ref ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, branch ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"    ${if branch == null then null else \\\"ref\\\"} = branch;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  ]\n  where\n    repo = T.pack repo'\n    mkLegacyIO :: Aeson.ToJSON v => Text -> Map.Map Text v -> FilePath -> IO ()\n    mkLegacyIO defaultNix gitJson dir = do\n      T.writeFile (dir </> (\"default.nix\" :: FilePath)) defaultNix\n      LBS.writeFile (dir </> (\"git.json\" :: FilePath)) (Aeson.encode gitJson)\n\nunpackedDirName :: FilePath\nunpackedDirName = \".\"\n",
              "suggestions": [
                {
                  "target_snippet": "data ObRunState\n  = ObRunState_Init\n  | ObRunState_Startup\n  | ObRunState_BackendStarted\n  deriving (Eq, Show)",
                  "refactored_suggestion": "data ObRunState\n  = ObRunStateInit\n  | ObRunStateStartup\n  | ObRunStateBackendStarted\n  deriving (Eq, Show)",
                  "confidence": 1.0,
                  "justification": "The `camelCase` naming convention is more consistent with Haskell community standards, making the code more idiomatic and enhancing readability."
                },
                {
                  "target_snippet": "case search `T.isInfixOf` ln of\n    False -> loop Nothing\n    True -> loop $ Just 10",
                  "refactored_suggestion": "if search `T.isInfixOf` ln then loop $ Just 10 else loop Nothing",
                  "confidence": 1.0,
                  "justification": "Using an `if` expression simplifies the code, reducing verbosity and improving readability while maintaining semantics."
                },
                {
                  "target_snippet": "cpPath = $(staticWhich \"cp\")",
                  "refactored_suggestion": "-- cpPath = $(staticWhich \"cp\")  -- reason: unused cpPath, remove it",
                  "confidence": 0.8,
                  "justification": "The `cpPath` variable is defined but not used throughout the code, indicating it may be dead code. Removing unused code helps to declutter the codebase, reducing maintenance overhead."
                },
                {
                  "target_snippet": "chmodPath = $(staticWhich \"chmod\")",
                  "refactored_suggestion": "-- chmodPath = $(staticWhich \"chmod\")  -- reason: unused chmodPath, remove it",
                  "confidence": 0.8,
                  "justification": "The `chmodPath` variable is defined but not used throughout the code, indicating it may also be dead code. Removing it helps simplify the code."
                },
                {
                  "target_snippet": "whoamiPath = $(staticWhich \"whoami\")",
                  "refactored_suggestion": "-- whoamiPath = $(staticWhich \"whoami\")  -- reason: unused whoamiPath, remove it",
                  "confidence": 0.8,
                  "justification": "The `whoamiPath` variable is unused in the project, making it safe to remove. Keeping the codebase free from unused elements improves clarity."
                },
                {
                  "target_snippet": "lnPath = $(staticWhich \"ln\")",
                  "refactored_suggestion": "-- lnPath = $(staticWhich \"ln\")  -- reason: unused lnPath, remove it",
                  "confidence": 0.8,
                  "justification": "The `lnPath` variable is declared but is not used anywhere in the program, indicating it is unnecessary. Removing unused code makes the codebase cleaner."
                }
              ],
              "refactored_code": "{-# LANGUAGE DoAndIfThenElse #-}\n{-# LANGUAGE EmptyCase #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Obelisk.SelfTest where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Exception (bracket, throw, try)\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Aeson.Types as Aeson\nimport Data.Bool (bool)\nimport qualified Data.ByteString.Lazy as LBS\nimport Data.Foldable (for_)\nimport Data.Function (fix)\nimport Data.List (isInfixOf)\nimport qualified Data.Map as Map\nimport Data.Semigroup ((<>))\nimport qualified Data.Set as Set\nimport Data.String\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport qualified Data.Text.IO as T\nimport qualified Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types as HTTP\nimport qualified Network.Socket as Socket\nimport Shelly\nimport System.Directory (getCurrentDirectory, withCurrentDirectory, getDirectoryContents)\nimport System.Environment\nimport System.Exit (ExitCode (..))\nimport System.FilePath (addTrailingPathSeparator)\nimport qualified System.Info\nimport System.IO (Handle, hClose, hIsEOF, hGetContents)\nimport System.IO.Temp\nimport System.Process (readProcessWithExitCode)\nimport System.Which (staticWhich)\nimport Test.Hspec\nimport Test.HUnit.Base\n\nimport Obelisk.ExecutableConfig.Lookup (getConfigs)\nimport Obelisk.Run (getConfigRoute)\n\ndata ObRunState\n  = ObRunStateInit\n  | ObRunStateStartup\n  | ObRunStateBackendStarted\n  deriving (Eq, Show)\n\ncpPath :: FilePath\n-- cpPath = $(staticWhich \"cp\")  -- reason: unused cpPath, remove it\n\ncabalPath :: FilePath\ncabalPath = $(staticWhich \"cabal\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nchownPath :: FilePath\nchownPath = $(staticWhich \"chown\")\n\nchmodPath :: FilePath\n-- chmodPath = $(staticWhich \"chmod\")  -- reason: unused chmodPath, remove it\n\nwhoamiPath :: FilePath\n-- whoamiPath = $(staticWhich \"whoami\")  -- reason: unused whoamiPath, remove it\n\nnixInstantiatePath :: FilePath\nnixInstantiatePath = $(staticWhich \"nix-instantiate\")\n\nnixBuildPath :: FilePath\nnixBuildPath = $(staticWhich \"nix-build\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nlnPath :: FilePath\n-- lnPath = $(staticWhich \"ln\")  -- reason: unused lnPath, remove it\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nsedPath :: FilePath\nsedPath = $(staticWhich \"sed\")\n\ngitUserConfig :: [Text]\ngitUserConfig = [\"-c\", \"user.name=Obelisk Selftest\", \"-c\", \"user.email=noreply@example.com\"]\n\ncommit :: Text -> Sh ()\ncommit msg = void $ run gitPath $ gitUserConfig <> [ \"commit\"\n  , \"--no-gpg-sign\"\n  , \"--allow-empty\"\n  , \"-m\"\n  , msg\n  ]\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\n-- | Like `shelly` but used when running `ob` commands\nshellyOb :: MonadIO m => (Sh a -> Sh a) -> Sh a -> m a\nshellyOb f obTest = shelly $ f obTest\n\n-- Set \"ob\" in a single place so it can be replaced with a\n-- link to obelisk in the nix store in the future,\n-- and avoid PATH hacking before calling this script.\nob :: FilePath\nob = \"ob\"\n\naugmentWithVerbosity :: (String -> [Text] -> a) -> String -> Bool -> [Text] -> a\naugmentWithVerbosity runner executable isVerbose args = runner executable $ (if isVerbose then (\"-v\" :) else id) args\n\nisolatedGitShell :: Bool -> FilePath -> (([Text] -> Sh Text) -> Sh a) -> IO a\nisolatedGitShell isVerbose dir f = shelly $ bool silently verbosely isVerbose $ do\n  setenv \"HOME\" \"/dev/null\"\n  setenv \"GIT_CONFIG_NOSYSTEM\" \"1\"\n  _ <- git [\"init\"]\n  _ <- git [\"config\", \"user.name\", \"SelfTest\"]\n  _ <- git [\"config\", \"user.email\", \"self@test\"]\n  f git\n  where\n    git args = run gitPath $ [\"-C\", toTextIgnore dir] <> args\n\n-- | Copies a git repo to a new location and \"resets\" the git history to include\n-- exactly one commit with all files added. It then restricts writing and reading\n-- for group and user to make the repo ideal for being a valid git remote for thunks.\n--\n-- Using this allows dirty repos to be used as git remotes during the test since 'git clone'ing\n-- a dirty repo will not include the uncommitted changes.\ncopyForGitRemote :: Bool -> FilePath -> FilePath -> IO ()\ncopyForGitRemote isVerbose origDir copyDir = isolatedGitShell isVerbose copyDir $ \\git -> do\n  run_ rsyncPath\n    [ \"-r\", \"--no-perms\", \"--no-owner\", \"--no-group\", \"--exclude\", \".git\"\n    , toTextIgnore (addTrailingPathSeparator origDir), toTextIgnore copyDir\n    ]\n  _ <- git [\"add\", \"--all\"]\n  _ <- git [\"commit\", \"-m\", \"Copy repo\"]\n  run_ chmodPath [\"-R\", \"u-w,g-rw,o-rw\", toTextIgnore copyDir] -- Freeze this state\n\nmain :: IO ()\nmain = do\n  -- Note: you can pass hspec arguments as well, eg: `-m <pattern>`\n  isVerbose <- elem \"-v\" <$> getArgs\n  unless isVerbose $\n    putStrLn \"Tests may take longer to run if there are unbuilt derivations: use -v for verbose output\"\n\n  obeliskImplDirtyReadOnly <- getCurrentDirectory\n  httpManager <- HTTP.newManager HTTP.defaultManagerSettings\n\n  withSystemTempDirectory \"obelisk-repo-git-remote\" $ \\copyDir -> do\n    copyForGitRemote isVerbose obeliskImplDirtyReadOnly copyDir\n    main' isVerbose httpManager copyDir\n\nmain' :: Bool -> HTTP.Manager -> FilePath -> IO ()\nmain' isVerbose httpManager obeliskRepoReadOnly = withInitCache $ \\initCache -> hspec $ parallel $ do\n  let\n    inTmpObInit' dirname f = inTmp' dirname $ \\dir -> do\n      run_ cpPath [\"-rT\", fromString initCache, toTextIgnore dir]\n      f dir\n    inTmpObInit = inTmpObInit' defaultTmpDirName\n\n    -- To be used in tests that change the obelisk impl directory\n    inTmpObInitWithImplCopy f = inTmpObInit $ \\dir ->\n      withObeliskImplClean $ \\(fromString -> implClean) -> do\n        run_ rmPath [thunk]\n        run_ lnPath [\"-s\", implClean, thunk]\n        f dir\n\n  describe \"ob init\" $ parallel $ do\n    it \"works with default impl\"       $ inTmp $ \\_ -> runOb [\"init\"]\n    it \"works with master branch impl\" $ inTmp $ \\_ -> runOb [\"init\", \"--branch\", \"master\"]\n    it \"works with symlink\"            $ inTmp $ \\_ -> runOb [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n    it \"doesn't silently overwrite existing files\" $ inTmp $ \\_ -> do\n      let p force = errExit False $ do\n            run_ ob $ \"--no-handoff\" : \"-v\" : \"init\" : [\"--force\"|force]\n            (== 0) <$> lastExitCode\n\n      True <- p False\n      False <- p False\n      True <- p True\n      pure ()\n\n    it \"doesn't create anything when given an invalid impl\" $ inTmp $ \\tmp -> do\n      void $ errExit False $ runOb [\"init\", \"--symlink\", \"/dev/null\"]\n      ls tmp >>= liftIO . assertEqual \"\" []\n\n    it \"produces a valid route config\" $ inTmpObInit $ \\tmp -> liftIO $\n      withCurrentDirectory (T.unpack $ toTextIgnore tmp) $ do\n        configs <- getConfigs\n        return (either (const Nothing) Just $ getConfigRoute configs) `shouldNotReturn` Nothing\n\n    it \"can unpack and repack .obelisk/impl after init with master branch impl\" $ inTmp $ \\_ -> do\n      runOb_ [\"init\", \"--branch\", \"master\"]\n      runOb_ [\"thunk\", \"unpack\", \".obelisk/impl\"]\n      runOb_ [\"thunk\", \"pack\", \".obelisk/impl\"]\n\n  -- These tests fail with \"Could not find module 'Obelisk.Generated.Static'\"\n  -- when not run by 'nix-build --attr selftest'\n  describe \"ob run\" $ {- NOT parallel $ -} do\n    it \"works in root directory\" $ inTmpObInit $ \\_ -> testObRunInDir' Nothing httpManager\n    it \"works in sub directory\" $ inTmpObInit $ \\_ -> testObRunInDir' (Just \"frontend\") httpManager\n    it \"can read external TLS certificates in root directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir Nothing\n    it \"can read external TLS certificates in sub directory\" $ inTmpObInit $ \\testDir -> testObRunCert' testDir (Just \"frontend\")\n    it \"complains when static files are missing in root directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' Nothing\n    it \"complains when static files are missing in sub directory\" $ inTmpObInit $ const $ testObRunInDirWithMissingStaticFile' (Just \"frontend\")\n    it \"complains when static filepaths are missing in root directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' Nothing\n    it \"complains when static filepaths are missing in sub directory\" $ do\n      inTmpObInit $ const $ testObRunInDirWithMissingStaticFilePath' (Just \"frontend\")\n    it \"fails when given an invalid Cabal file\" $ inTmpObInit $ testObRunWithInvalidCabalFile ob\n\n    it \"respects the port given on the command line\" $ inTmpObInit $ \\testDir -> do\n      [port] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandles ob [\"run\", \"-p\", T.pack (show port)] [] $ \\_stdin stdout stderr -> do\n        uri <- handleObRunStdout httpManager stdout stderr\n        -- Make sure obelisk logs the right thing\n        unless (T.pack (show port ++ \"/\") `T.isSuffixOf` T.strip uri) $\n          error $ \"Expected the URI to end in \" ++ show port ++ \" but it ended in \" ++ T.unpack uri\n        -- But also verify that we can actually reach the server in the\n        -- given path, rather than just listening for the log URL\n        let req = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n        req >>= \\case\n          Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n          e -> errorExit $ \"Request to ob run failed: \" <> T.pack (show e)\n        exit 0\n\n  describe \"ob repl\" $ do\n    it \"accepts stdin commands\" $ inTmpObInit $ \\_ -> do\n      setStdin \"print 3\\n:q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        [ \"*Obelisk.Run Obelisk.Run Frontend Backend> 3\"\n        , \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\"\n        ] `isInfixOf` T.lines (T.strip output)\n    it \"works with custom Prelude\" $ inTmpObInit $ \\_ -> do\n      writefile \"common/src/Prelude.hs\"\n        \"{-# LANGUAGE PackageImports #-} module Prelude (module X) where import \\\"base\\\" Prelude as X\"\n      setStdin \":q\"\n      output <- runOb [\"repl\"]\n      liftIO $ assertBool \"\" $\n        \"*Obelisk.Run Obelisk.Run Frontend Backend> Leaving GHCi.\" `T.isInfixOf` output\n\n  describe \"obelisk project\" $ parallel $ do\n    it \"can build obelisk command\"  $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"command\" , toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk skeleton\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"skeleton\", toTextIgnore obeliskRepoReadOnly]\n    it \"can build obelisk shell\"    $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"shell\",    toTextIgnore obeliskRepoReadOnly]\n    it \"can build everything\"       $ inTmpObInit $ \\_ -> nixBuild [toTextIgnore obeliskRepoReadOnly]\n\n  describe \"blank initialized project\" $ parallel $ do\n\n    it \"can build ghc.backend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghc.backend\"]\n    it \"can build ghcjs.frontend\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ghcjs.frontend\"]\n\n    if System.Info.os == \"darwin\"\n      then it \"can build ios\" $ inTmpObInit $ \\_ -> nixBuild [\"-A\", \"ios.frontend\"]\n      else it \"can build android after accepting license\" $ inTmpObInit $ \\dir -> do\n        let defaultNixPath = dir </> (\"default.nix\" :: FilePath)\n        writefile defaultNixPath\n          =<< T.replace\n            \"# config.android_sdk.accept_license = false;\"\n            \"config.android_sdk.accept_license = true;\"\n          <$> readfile defaultNixPath\n        nixBuild [\"-A\", \"android.frontend\"]\n\n    forM_ [\"ghc\", \"ghcjs\"] $ \\compiler -> do\n      let\n        shellName = \"shells.\" <> compiler\n        inShell cmd' = run_ \"nix-shell\" [\"default.nix\", \"-A\", fromString shellName, \"--run\", cmd']\n      it (\"can enter \"    <> shellName) $ inTmpObInit $ \\_ -> inShell \"exit\"\n      -- NOTE: We override the temporary directory name because cabal has a bug preventing new-build from working\n      -- in a path that has unicode characters.\n      it (\"can build in \" <> shellName) $ inTmpObInit' \"test\" $ \\_ -> inShell $\n          T.pack cabalPath <> \" --version; \" <> T.pack cabalPath <> \" new-build --\" <> T.pack compiler <> \" all\"\n\n    it \"has idempotent thunk update\" $ inTmpObInitWithImplCopy $ \\_ -> do\n      _  <- pack\n      u  <- update\n      uu <- update\n      assertRevEQ u uu\n\n    it \"can run 'ob doc'\" $ inTmpObInit $ \\_ -> runOb_ [\"doc\", \"reflex\"]\n\n  describe \"ob thunk pack/unpack\" $ parallel $ do\n    it \"has thunk pack and unpack inverses\" $ inTmpObInitWithImplCopy $ \\_ -> do\n\n      _    <- pack\n      e    <- commitAll\n      eu   <- unpack\n      eup  <- pack\n      eupu <- unpack\n      _    <- pack\n\n      assertRevEQ e  eup\n      assertRevEQ eu eupu\n      assertRevNE e  eu\n\n    it \"unpacks the correct branch\" $ withTmp $ \\dir -> do\n      let branch = \"master\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch]\n      runOb_ [\"thunk\", \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"unpack\", toTextIgnore dir]\n      branch' <- run gitPath [\"-C\", toTextIgnore $ dir </> unpackedDirName, \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n      liftIO $ assertEqual \"\" branch (T.strip branch')\n\n    it \"can pack and unpack plain git repos\" $\n      shelly_ $ withSystemTempDirectory \"git-repo\" $ \\dir -> do\n        let repo = toTextIgnore $ dir </> (\"repo\" :: FilePath)\n        run_ gitPath [\"clone\", \"https://github.com/haskell/process.git\", repo]\n        origHash <- chdir (fromText repo) revParseHead\n\n        runOb_ [\"thunk\", \"pack\", repo]\n        packedFiles <- Set.fromList <$> ls (fromText repo)\n        liftIO $ assertEqual \"\" packedFiles $ Set.fromList $ (repo </>) <$>\n          [\"default.nix\", \"thunk.nix\", \"github.json\" :: FilePath]\n\n        runOb_ [\"thunk\", \"unpack\", repo]\n        chdir (fromText repo </> unpackedDirName) $ do\n          unpackHash <- revParseHead\n          assertRevEQ origHash unpackHash\n\n        testThunkPack' $ fromText repo\n\n    it \"aborts thunk pack when there are uncommitted files\" $ inTmpObInitWithImplCopy $ \\dir -> do\n      testThunkPack' (dir </> thunk)\n\n    it \"works on legacy git thunks\" $ testLegacyGitThunks isVerbose\n\n  describe \"ob thunk update --branch\" $ parallel $ do\n    it \"can change a thunk to the latest version of a desired branch\" $ withTmp $ \\dir -> do\n      let branch1 = \"master\"\n          branch2 = \"develop\"\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", branch1]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      runOb_ [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", branch2]\n\n    it \"doesn't create anything when given an invalid branch\" $ withTmp $ \\dir -> do\n      let checkDir dir' = liftIO $ getDirectoryContents $ T.unpack $ toTextIgnore dir'\n      run_ gitPath [\"clone\", \"https://github.com/reflex-frp/reflex.git\", toTextIgnore dir, \"--branch\", \"master\"]\n      runOb_ [\"thunk\" , \"pack\", toTextIgnore dir]\n      startingContents <- checkDir dir\n      void $ errExit False $ runOb [\"thunk\", \"update\", toTextIgnore dir, \"--branch\", \"dumble-palooza\"]\n      checkDir dir >>= liftIO . assertEqual \"\" startingContents\n\n  describe \"ob shell\" $ parallel $ do\n    it \"works with --\" $ inTmpObInit $ \\_ -> do\n      output <- runOb [\"shell\", \"--\", \"ghc-pkg\", \"list\"]\n      liftIO $ assertBool \"Unexpected output from ob shell\" $ (\"Cabal-\" `T.isInfixOf` output) && (\"ghc-\" `T.isInfixOf` output)\n\n  describe \"ob hoogle\" $ {- NOT parallel -} do\n    it \"starts a hoogle server on the given port\" $ inTmpObInit $ \\_ -> do\n      [p0] <- liftIO $ getFreePorts 1\n      maskExitSuccess $ runHandle \"ob\" [\"hoogle\", \"--port\", T.pack (show p0)] $ \\stdout -> flip fix Nothing $ \\loop -> \\case\n        Nothing -> do -- Still waiting for initial signal that the server has started\n          ln <- liftIO $ T.hGetLine stdout\n          let search = \"Server starting on port \" <> T.pack (show p0)\n          case search `T.isInfixOf` ln of\n            False -> loop Nothing -- keep waiting\n            True -> loop $ Just 10\n        Just (n :: Int) -> do -- Server has started and we have n attempts left\n          let req uri = liftIO $ try @HTTP.HttpException $ HTTP.parseRequest uri >>= flip HTTP.httpLbs httpManager\n          req (\"http://127.0.0.1:\" <> show p0) >>= \\case\n            Right r | HTTP.responseStatus r == HTTP.ok200 -> exit 0\n            e -> if n <= 0\n              then errorExit $ \"Request to hoogle server failed: \" <> T.pack (show e)\n              else liftIO (threadDelay (1*10^(6 :: Int))) *> loop (Just $ n - 1)\n  where\n    verbosity = bool silently verbosely isVerbose\n    nixBuild args = run nixBuildPath (\"--no-out-link\" : args)\n\n    runOb_ = augmentWithVerbosity run_ ob isVerbose\n    runOb = augmentWithVerbosity run ob isVerbose\n    testObRunInDir' = augmentWithVerbosity testObRunInDir ob isVerbose [\"run\"]\n    testObRunCert' = augmentWithVerbosity testObRunCert ob isVerbose [\"run\", \"-c\", \".\"]\n    testObRunInDirWithMissingStaticFile' = augmentWithVerbosity testObRunInDirWithMissingStaticFile ob isVerbose [\"run\"]\n    testObRunInDirWithMissingStaticFilePath' = augmentWithVerbosity testObRunInDirWithMissingStaticFilePath ob isVerbose [\"run\"]\n    testThunkPack' = augmentWithVerbosity testThunkPack ob isVerbose []\n\n    withObeliskImplClean f =\n      withSystemTempDirectory \"obelisk-impl-clean\" $ \\obeliskImpl -> do\n        void . shellyOb verbosity $ do\n          dirtyFiles <- T.strip <$> run gitPath [\"-C\", toTextIgnore obeliskRepoReadOnly, \"diff\", \"--stat\"]\n          () <- when (dirtyFiles /= \"\") $ error \"SelfTest does not work correctly with dirty obelisk repos as remote\"\n          run_ gitPath [\"clone\", \"file://\" <> toTextIgnore obeliskRepoReadOnly, toTextIgnore obeliskImpl]\n        f obeliskImpl\n\n    withInitCache f =\n      withSystemTempDirectory \"init Cache \u03bb\" $ \\initCache -> do\n        -- Setup the ob init cache\n        void . shellyOb verbosity $ chdir initCache $ do\n          runOb_ [\"init\", \"--symlink\", toTextIgnore obeliskRepoReadOnly]\n          run_ gitPath [\"init\"]\n\n        f initCache\n\n    shelly_ = void . shellyOb verbosity\n\n    defaultTmpDirName = \"test \u03bb\"\n\n    inTmp' :: FilePath -> (FilePath -> Sh a) -> IO ()\n    inTmp' dirname f = withTmp' dirname (chdir <*> f)\n    inTmp = inTmp' defaultTmpDirName\n\n    withTmp' dirname f = shelly_ . withSystemTempDirectory dirname $ f . fromString\n    withTmp = withTmp' defaultTmpDirName\n\n    assertRevEQ a b = liftIO . assertEqual \"\" \"\"        =<< diff a b\n    assertRevNE a b = liftIO . assertBool  \"\" . (/= \"\") =<< diff a b\n\n    revParseHead = T.strip <$> run gitPath [\"rev-parse\", \"HEAD\"]\n\n    commitAll = do\n      run_ gitPath [\"add\", \".\"]\n      commit \"checkpoint\"\n      revParseHead\n\n    thunk  = \".obelisk/impl\"\n    update = runOb [\"thunk\", \"update\", thunk] *> commitAll\n    pack   = runOb [\"thunk\", \"pack\",   thunk] *> commitAll\n    unpack = runOb [\"thunk\", \"unpack\", thunk] *> commitAll\n\n    diff a b = run gitPath [\"diff\", a, b]\n\n\nmaskExitSuccess :: Sh () -> Sh ()\nmaskExitSuccess = handle_sh (\\case ExitSuccess -> pure (); e -> throw e)\n\n-- | Run `ob run` in the given directory (maximum of one level deep)\ntestObRunInDir :: String -> [Text] -> Maybe FilePath -> HTTP.Manager -> Sh ()\ntestObRunInDir executable extraArgs mdir httpManager = maskExitSuccess $ do\n  [p0, p1] <- liftIO $ getFreePorts 2\n  let uri p = \"http://localhost:\" <> T.pack (show p) <> \"/\" -- trailing slash required for comparison\n  writefile \"config/common/route\" $ uri p0\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    firstUri <- handleObRunStdout httpManager stdout stderr\n    let newUri = uri p1\n    when (firstUri == newUri) $ errorExit $\n      \"Startup URI (\" <> firstUri <> \") is the same as test URI (\" <> newUri <> \")\"\n    maybe id (\\_ -> chdir \"..\") mdir $ alterRouteTo newUri stdout\n    runningUri <- handleObRunStdout httpManager stdout stderr\n    if runningUri /= newUri\n      then errorExit $ \"Reloading failed: expected \" <> newUri <> \" but got \" <> runningUri\n      else exit 0\n\ntestObRunCert :: String -> [Text] -> FilePath -> Maybe FilePath -> Sh ()\ntestObRunCert executable extraArgs testDir mdir = maskExitSuccess $ do\n  -- Generate a TLS key, and then a self-signed certificate using that key\n  mapM_ (\\cmd -> run_ \"nix-shell\" [\"-p\", \"openssl\", \"--command\", cmd])\n    [ \"openssl genrsa -out key.pem 2048\"\n    , \"openssl req -new -key key.pem -out certificate.csr -subj \\\"/C=US/ST=New York/L=New York/O=Development/OU=IT Department/CN=obsidian.com\\\"\"\n    , \"openssl x509 -req -in certificate.csr -signkey key.pem -out cert.pem\"\n    ]\n\n  -- One more command is required, for generating the chain.pem file.\n  -- For testing purposes, we'll keep it the same as the cert.pem file.\n  run_ \"cp\" [\"cert.pem\", \"chain.pem\"]\n\n  -- Also need to change the route inside config/common/route to https\n  -- in order to trigger the certificates option (the -c option is not honored for http)\n  writefile \"config/common/route\" \"https://localhost:8000\"\n\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_ stdout _ -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      isEOF <- liftIO $ hIsEOF h\n      if isEOF\n        then errorExit \"Obelisk exited somehow\"\n        else do\n          line <- liftIO $ hGetLineSkipBlanks h\n          check line h\n\n    -- Here we check that the certificates are read properly by Obelisk\n    -- In case the server is started without reading the certificates, show an error.\n    check line h\n      | \"Using certificate information from:\" `T.isPrefixOf` line = do\n        -- Should be followed by a `Frontend running on <url>` line\n        next <- liftIO $ hGetLineSkipBlanks h\n        if \"Frontend running on\" `T.isPrefixOf` next\n          then exit 0\n          else errorExit $ \"Ran into error: \" <> next\n      | \"Frontend running on\" `T.isPrefixOf` line = errorExit \"Obelisk did not read the certificates provided via -c option\"\n      | otherwise = parseObOutput h\n\n-- | Mess up the Cabal file in the given directory, then make sure that\n-- @ob run@ fails.\ntestObRunWithInvalidCabalFile\n  :: FilePath  -- ^ Obelisk path\n  -> FilePath  -- ^ Directory path (will be made invalid)\n  -> Sh ()\ntestObRunWithInvalidCabalFile executable fp = do\n  let commonCabal :: String\n      commonCabal = \"common/common.cabal\"\n  liftIO $ writeFile (fp </> commonCabal) \"This is not a valid Cabal file.\"\n  errExit False $ do\n    runHandles executable [\"run\"] [] $ \\_ _ _ -> pure ()\n    lastExitCode >>= \\case\n      0 -> pure ()\n      _ -> errorExit \"ob run succeeded even with an invalid Cabal file\"\n\n-- | Check whether embedding a non-existent filepath into an obelisk\n-- project is detected correctly and generates a compile-time error.\n--\n-- @'testObRunInDirWithMissingStaticFileWorker' exe args mdir act checkErrorMessage@.\n--\n-- @checkErrorMessage line1 line2@ is invoked on a compile-time error message of the following form:\n--     frontend/src/Frontend.hs:40:32: error:\n--        \u2022 Static file obelisk.jpg was not found in static.out\n--        \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n--       |\n--    40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n--       |\n--\n-- the arguments to @line1@ and @line2@ contain:\n--\n-- @    \u2022 Static file obelisk.jpg was not found in static.out@\n--\n-- and\n--\n-- @    \u2022 In the untyped splice: $(static \"obelisk.jpg\")@\n--\n-- respectively.\ntestObRunInDirWithMissingStaticFileWorker\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\n  -- ^ Run this action before running @ob run@.\n  -- Gives you the opportunity to modify the project to trigger events.\n  -- In particular, make sure static files do not exist, s.t. a compilation\n  -- error is thrown.\n  -> (Text -> Text -> Sh ())\n  -- ^ Assertion function for error messages.\n  -- Since this function is used for asserting error message contents,\n  -- this function specifies what contents two consecutive non-empty lines\n  -- are supposed to have.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkErrorMessage = maskExitSuccess $ do\n  act\n  -- Now run `ob run` and read the error\n  maybe id chdir mdir $ runHandles executable extraArgs [] $ \\_stdin stdout stderr -> do\n    parseObOutput stdout\n  where\n    parseObOutput h = do\n      line <- liftIO $ hGetLineSkipBlanks h\n      -- This means that everything was successful, this should not be the case\n      if line == \"Running test...\"\n        then errorExit \"Could not find any error related to static files\"\n        else checkForErrors line h\n\n    -- As can be seen in the example below, we can parse a lot of data.\n    -- For simplicity, we parse the two lines after the `error:` line.\n    -- We also ensure that the file name is same, as the file that we changed ie `obelisk.jpg`\n    checkForErrors line h\n      -- Found an error, check if it is due to static.out\n      | \"error:\" `T.isSuffixOf` line = do\n        line1 <- liftIO $ hGetLineSkipBlanks h\n        line2 <- liftIO $ hGetLineSkipBlanks h\n        checkErrorMessage line1 line2\n      | otherwise = parseObOutput h\n\n-- | Run an obelisk test-case, where @static@ is embedding an non-existent\n-- filepath.\ntestObRunInDirWithMissingStaticFile\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFile executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(static \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(static \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(static \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\n-- | Run an obelisk test-case, where @staticFilePath@ is embedding an\n-- non-existent filepath.\ntestObRunInDirWithMissingStaticFilePath\n  :: String\n  -- ^ Path to the @ob@ executable\n  -> [Text]\n  -- ^ Arguments that are passed to @ob@\n  -> Maybe FilePath\n  -- ^ Change the working directory of the @ob@ invocation.\n  -> Sh ()\ntestObRunInDirWithMissingStaticFilePath executable extraArgs mdir =\n  testObRunInDirWithMissingStaticFileWorker executable extraArgs mdir act checkStaticError\n  where\n    -- | Rename a static file, so that `ob run` will fail with a specific error\n    act = do\n      run_ sedPath [\"-e\", \"s/\\\\$(static /\\\\$(staticFilePath /\", \"-i\", \"frontend/src/Frontend.hs\"]\n      run_ mvPath [\"static/obelisk.jpg\", \"static/obelisk2.jpg\"]\n    -- We are looking for an error of the following type:\n    --  frontend/src/Frontend.hs:40:32: error:\n    --     \u2022 Static file obelisk.jpg was not found in static.out\n    --     \u2022 In the untyped splice: $(staticFilePath \"obelisk.jpg\")\n    --    |\n    -- 40 |       elAttr \"img\" (\"src\" =: $(staticFilePath \"obelisk.jpg\")) blank\n    --    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    checkStaticError line1 line2 =\n      if name1 == Just \"obelisk.jpg\" && name2 == Just \"obelisk.jpg\"\n        then exit 0\n        else errorExit $ \"Expected a different error:\\n\" <> line1 <> \"\\n\" <> line2\n      where\n        name1 = T.stripPrefix \"\u2022 The file \" (T.stripStart line1) >>= T.stripSuffix \" was not found in static.out\"\n        name2 = T.stripPrefix \"\u2022 In the untyped splice: $(staticFilePath \\\"\" (T.stripStart line2) >>= T.stripSuffix \"\\\")\"\n\ntestThunkPack :: String -> [Text] -> FilePath -> Sh ()\ntestThunkPack executable args path' = withTempFile repoDir \"test-file\" $ \\file handle -> do\n  let\n    pack' = readProcessWithExitCode executable ([\"thunk\", \"pack\", path'] ++ map T.unpack args) \"\"\n    ensureThunkPackFails q = liftIO $ pack' >>= \\case\n      (code, out, err)\n        | code == ExitSuccess -> fail $ \"ob thunk pack succeeded when it should have failed with error '\" <> show q <> \"'\"\n        | q `T.isInfixOf` T.pack (out <> err) -> pure ()\n        | otherwise -> fail $ \"ob thunk pack failed for an unexpected reason, expecting '\" <> show q <> \"', received: \" <> show out <> \"\\nstderr: \" <> err\n    git = chdir repoDir . run_ gitPath\n  -- Untracked files\n  ensureThunkPackFails \"Untracked files\"\n  git [\"add\", T.pack file]\n  -- Uncommitted files (staged)\n  ensureThunkPackFails \"unsaved\"\n  chdir repoDir $ commit \"test commit\"\n  -- Non-pushed commits in any branch\n  ensureThunkPackFails \"not yet pushed\"\n  -- Uncommitted files (unstaged)\n  liftIO $ T.hPutStrLn handle \"test file\" >> hClose handle\n  ensureThunkPackFails \"modified\"\n  -- Existing stashes\n  git $ gitUserConfig <> [ \"stash\" ]\n  ensureThunkPackFails \"has stashes\"\n  where\n    repoDir = path' </> unpackedDirName\n\n-- | Blocks until a non-empty line is available\nhGetLineSkipBlanks :: MonadIO m => Handle -> m Text\nhGetLineSkipBlanks h = liftIO $ fix $ \\loop -> T.hGetLine h >>= \\case\n  \"\" -> loop\n  t -> pure t\n\n-- | Alters the route file and waits for `ob run` to reload\nalterRouteTo :: Text -> Handle -> Sh ()\nalterRouteTo uri stdout = do\n  writefile \"config/common/route\" uri\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Reloading...\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"  config/common/route\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n  hGetLineSkipBlanks stdout >>= \\t -> when (t /= \"Interrupted.\") $ errorExit $\n    \"Reloading failed: \" <> T.pack (show t)\n\n-- | Handle stdout of `ob run`: check that the frontend and backend servers are started correctly\nhandleObRunStdout :: HTTP.Manager -> Handle -> Handle -> Sh Text\nhandleObRunStdout httpManager stdout stderr = flip fix (ObRunState_Init, []) $ \\loop (state, msgs) -> do\n  isEOF <- liftIO $ hIsEOF stdout\n  if isEOF\n  then handleObRunError msgs\n  else liftIO (T.hGetLine stdout) >>= \\t -> case state of\n    ObRunState_Init\n      | \"Running test...\" `T.isPrefixOf` t -> loop (ObRunState_BackendStarted, msgs)\n    ObRunState_Startup\n      | t == \"backend stopped; make a change to your code to reload\" -> loop (ObRunState_Startup, msgs)\n      -- | Just port <- \"Backend running on port \" `T.stripPrefix` t -> loop $ ObRunState_BackendStarted port\n      | not (T.null t) -> errorExit $ \"Startup: \" <> t -- If theres any other output here, startup failed\n    ObRunState_BackendStarted\n      | Just uri <- \"Frontend running on \" `T.stripPrefix` t -> do\n        obRunCheck httpManager stdout uri\n        pure uri\n      | not (T.null t) -> errorExit $ \"Started: \" <> t -- If theres any other output here, startup failed\n    _ | \"Failed\" `T.isPrefixOf` t -> handleObRunError (t : msgs)\n      | otherwise -> loop (state, t : msgs)\n  where\n    handleObRunError msgs = do\n      stderrContent <- liftIO $ hGetContents stderr\n      errorExit $ \"ob run failed: \" <> T.unlines (reverse msgs) <> \" stderr: \" <> T.pack stderrContent\n\n-- | Make requests to frontend/backend servers to check they are working properly\nobRunCheck :: HTTP.Manager -> Handle -> Text -> Sh ()\nobRunCheck httpManager _stdout frontendUri = do\n  let req uri = liftIO $ HTTP.parseRequest (T.unpack uri) >>= flip HTTP.httpLbs httpManager\n  req frontendUri >>= \\r -> when (HTTP.responseStatus r /= HTTP.ok200) $ errorExit $\n    \"Request to frontend server failed: \" <> T.pack (show r)\n\ngetFreePorts :: Int -> IO [Socket.PortNumber]\ngetFreePorts 0 = pure []\ngetFreePorts n = Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close $ \\s -> (:) <$> Socket.socketPort s <*> getFreePorts (n - 1)\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      pure sock\n\ntestLegacyGitThunks :: Bool -> IO ()\ntestLegacyGitThunks isVerbose = withSystemTempDirectory \"test-git-repo\" $ \\gitDir -> do\n  isolatedGitShell isVerbose gitDir $ \\git -> do\n    writefile (gitDir </> (\"default.nix\" :: FilePath)) \"{}: \\\"hello\\\"\"\n    _ <- git [\"add\", \"--all\"]\n    _ <- git [\"commit\", \"-m\", \"Initial commit\"]\n    rev <- T.strip <$> git [\"rev-parse\", \"HEAD\"]\n    sha256 :: Text\n      <-  either error pure\n      =<< (Aeson.parseEither (Aeson..: \"sha256\") <=< Aeson.eitherDecodeStrict . T.encodeUtf8)\n      <$> run nixPrefetchGitPath [toTextIgnore gitDir]\n\n    for_ (legacyGitThunks (GitThunkParams gitDir rev sha256)) $ \\mkFiles ->\n      withSystemTempDirectory \"test-thunks\" $ \\thunkDir -> do\n        liftIO $ mkFiles thunkDir\n        run_ \"ob\" [\"thunk\", \"unpack\", toTextIgnore thunkDir]\n        run_ \"ob\" [\"thunk\", \"pack\", toTextIgnore thunkDir]\n\ndata GitThunkParams = GitThunkParams\n  { _gitThunkParams_repo :: !FilePath\n  , _gitThunkParams_rev :: !Text\n  , _gitThunkParams_sha256 :: !Text\n  } deriving Show\n\nlegacyGitThunks :: GitThunkParams -> [FilePath -> IO ()]\nlegacyGitThunks (GitThunkParams repo' rev sha256) =\n  [ mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  assert !fetchSubmodules; (import <nixpkgs> {}).fetchgit { inherit url rev sha256; };\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetchGit = {url, rev, ref ? null, branch ? null, sha256 ? null, fetchSubmodules ? null}:\"\n        , \"  if builtins.hasAttr \\\"fetchGit\\\" builtins\"\n        , \"    then builtins.fetchGit ({ inherit url rev; } // (if branch == null then {} else { ref = branch; }))\"\n        , \"    else abort \\\"Plain Git repositories are only supported on nix 2.0 or higher.\\\";\"\n        , \"in import (fetchGit (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", repo)\n        , (\"rev\", rev)\n        , (\"branch\", \"master\")\n        , (\"sha256\", sha256)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, ref ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  , mkLegacyIO\n      (T.unlines\n        [ \"# DO NOT HAND-EDIT THIS FILE\"\n        , \"let fetch = {url, rev, branch ? null, sha256 ? null, fetchSubmodules ? false, private ? false, ...}:\"\n        , \"  let realUrl = let firstChar = builtins.substring 0 1 url; in\"\n        , \"    if firstChar == \\\"/\\\" then /. + url\"\n        , \"    else if firstChar == \\\".\\\" then ./. + url\"\n        , \"    else url;\"\n        , \"  in if !fetchSubmodules && private then builtins.fetchGit {\"\n        , \"    url = realUrl; inherit rev;\"\n        , \"    ${if branch == null then null else \\\"ref\\\"} = branch;\"\n        , \"  } else (import <nixpkgs> {}).fetchgit {\"\n        , \"    url = realUrl; inherit rev sha256;\"\n        , \"  };\"\n        , \"in import (fetch (builtins.fromJSON (builtins.readFile ./git.json)))\"\n        ]\n      )\n      (Map.fromList\n        [ (\"url\", Aeson.String repo)\n        , (\"rev\", Aeson.String rev)\n        , (\"branch\", Aeson.String \"master\")\n        , (\"sha256\", Aeson.String sha256)\n        , (\"private\", Aeson.Bool False)\n        ]\n      )\n  ]\n  where\n    repo = T.pack repo'\n    mkLegacyIO :: Aeson.ToJSON v => Text -> Map.Map Text v -> FilePath -> IO ()\n    mkLegacyIO defaultNix gitJson dir = do\n      T.writeFile (dir </> (\"default.nix\" :: FilePath)) defaultNix\n      LBS.writeFile (dir </> (\"git.json\" :: FilePath)) (Aeson.encode gitJson)\n\nunpackedDirName :: FilePath\nunpackedDirName = \".\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/backend/src/Obelisk/Backend.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.25,
                "sum": 25
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 17,
              "lines_of_code": 281,
              "homplexity_lines_of_code": 276,
              "code_quality_score": 22.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.25,
                  "sum": 25
                },
                "homplexity_loc": 276,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): module Obelisk.Backend has 216 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data BackendConfig has record fields count of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data StaticAssets has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" (-1) (-1): data GhcjsApp has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 74 43: data Backend has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 94 23: data GhcjsWidgets has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 104 1: type signature for defaultGhcjsWidgets has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 105 1: function defaultGhcjsWidgets has cyclomatic complexity of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 112 1: type signature for serveDefaultObeliskApp has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 121 1: function serveDefaultObeliskApp has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 128 1: type signature for prettifyOutput has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 129 1: function prettifyOutput has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 135 1: type signature for defaultStaticAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 136 1: function defaultStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 141 1: type signature for defaultFrontendGhcjsAssets has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 142 1: function defaultFrontendGhcjsAssets has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 147 1: type signature for runSnapWithConfig has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 148 1: function runSnapWithConfig has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 157 1: type signature for runSnapWithCommandLineArgs has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 158 1: function runSnapWithCommandLineArgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 161 1: type signature for getPageName has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 162 1: function getPageName has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 167 1: type signature for getRouteWith has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 168 1: function getRouteWith has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 172 1: type signature for renderAllJsPath has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 172 1: type signature for renderAllJsPath has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 173 1: function renderAllJsPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 176 1: type signature for serveObeliskApp has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 176 1: type signature for serveObeliskApp has 7 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has branching depth of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has 10 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 185 1: function serveObeliskApp has cyclomatic complexity of 5 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 196 1: type signature for serveStaticAssets has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 196 1: type signature for serveStaticAssets has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 197 1: function serveStaticAssets has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 206 3: data GhcjsAppRoute has record fields count of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 209 1: type signature for staticRenderContentType has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 209 1: type signature for staticRenderContentType has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 210 1: function staticRenderContentType has branching depth of 0 \nWarning:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 213 1: type signature for serveGhcjsApp has 6 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 213 1: type signature for serveGhcjsApp has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 221 1: function serveGhcjsApp has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 229 1: type signature for defaultBackendConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 229 1: type signature for defaultBackendConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 230 1: function defaultBackendConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 233 1: type signature for runBackend has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 233 1: type signature for runBackend has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 234 1: function runBackend has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 237 1: type signature for runBackendWith has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 237 1: type signature for runBackendWith has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 245 1: type signature for renderGhcjsFrontend has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 245 1: type signature for renderGhcjsFrontend has 6 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 253 1: function renderGhcjsFrontend has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 253 1: function renderGhcjsFrontend has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 253 1: function renderGhcjsFrontend has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 259 1: type signature for preloadGhcjs has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 259 1: type signature for preloadGhcjs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 260 1: function preloadGhcjs has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 260 1: function preloadGhcjs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 260 1: function preloadGhcjs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 264 1: type signature for deferredGhcjsScript has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 264 1: type signature for deferredGhcjsScript has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function deferredGhcjsScript has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function deferredGhcjsScript has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 265 1: function deferredGhcjsScript has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 278 1: type signature for getPublicConfigs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 278 1: type signature for getPublicConfigs has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 279 1: function getPublicConfigs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 279 1: function getPublicConfigs has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/backend/src/Obelisk/Backend.hs\" 279 1: function getPublicConfigs has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Obelisk.Backend\n  ( Backend (..)\n  , BackendConfig (..)\n  , defaultBackendConfig\n  , StaticAssets (..)\n  , defaultStaticAssets\n  -- * Running a backend\n  , runBackend\n  , runBackendWith\n  -- * Configuration of backend\n  , GhcjsWidgets(..)\n  , defaultGhcjsWidgets\n  -- * all.js script loading functions\n  , deferredGhcjsScript\n  , delayedGhcjsScript\n  -- * all.js preload functions\n  , preloadGhcjs\n  , renderAllJsPath\n  -- * Re-exports\n  , Default (def)\n  , getPageName\n  , getRouteWith\n  , runSnapWithCommandLineArgs\n  , runSnapWithConfig\n  , serveDefaultObeliskApp\n  , prettifyOutput\n  , staticRenderContentType\n  , getPublicConfigs\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Fail (MonadFail)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad\nimport Control.Monad.Except\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as BSC8\nimport Data.Default (Default (..))\nimport Data.Dependent.Sum\nimport Data.Functor.Identity\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport GHC.Generics (Generic)\nimport Obelisk.Asset.Serve.Snap (serveAsset)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport Obelisk.Frontend\nimport Obelisk.Route\nimport Obelisk.Snap.Extras (doNotCache, serveFileIfExistsAs)\nimport Reflex.Dom.Core\nimport Snap (MonadSnap, Snap, commandLineConfig, defaultConfig, getsRequest, httpServe, modifyResponse\n            , rqPathInfo, rqQueryString, setContentType, writeBS, writeText\n            , rqCookies, Cookie(..) , setHeader)\nimport Snap.Internal.Http.Server.Config (Config (accessLog, errorLog), ConfigLog (ConfigIoLog))\nimport System.IO (BufferMode (..), hSetBuffering, stderr, stdout)\n\ndata Backend backendRoute frontendRoute = Backend\n  { _backend_routeEncoder :: Encoder (Either Text) Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  , _backend_run :: ((R backendRoute -> Snap ()) -> IO ()) -> IO ()\n  } deriving (Generic)\n\ndata BackendConfig frontendRoute = BackendConfig\n  { _backendConfig_runSnap :: !(Snap () -> IO ()) -- ^ Function to run the snap server\n  , _backendConfig_staticAssets :: !StaticAssets -- ^ Static assets\n  , _backendConfig_ghcjsWidgets :: !(GhcjsWidgets (Text -> FrontendWidgetT (R frontendRoute) ()))\n    -- ^ Given the URL of all.js, return the widgets which are responsible for\n    -- loading the script.\n  } deriving (Generic)\n\n-- | The static assets provided must contain a compiled GHCJS app that corresponds exactly to the Frontend provided\ndata GhcjsApp route = GhcjsApp\n  { _ghcjsApp_compiled :: !StaticAssets\n  , _ghcjsApp_value :: !(Frontend route)\n  } deriving (Generic)\n\n-- | Widgets used to load all.js on the frontend\ndata GhcjsWidgets a = GhcjsWidgets\n  { _ghcjsWidgets_preload :: a\n  -- ^ A preload widget, placed in the document head\n  , _ghcjsWidgets_script :: a\n  -- ^ A script widget, placed in the document body\n  } deriving (Functor, Generic)\n\n\n-- | Given the URL of all.js, return the widgets which are responsible for\n-- loading the script. Defaults to 'preloadGhcjs' and 'deferredGhcjsScript'.\ndefaultGhcjsWidgets :: GhcjsWidgets (Text -> FrontendWidgetT r ())\ndefaultGhcjsWidgets = GhcjsWidgets\n  { _ghcjsWidgets_preload = preloadGhcjs\n  , _ghcjsWidgets_script = deferredGhcjsScript\n  }\n\n-- | Serve a frontend, which must be the same frontend that Obelisk has built and placed in the default location\n--TODO: The frontend should be provided together with the asset paths so that this isn't so easily breakable; that will probably make this function obsolete\nserveDefaultObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> Frontend (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveDefaultObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontend =\n  serveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp\n  where frontendApp = GhcjsApp\n          { _ghcjsApp_compiled = defaultFrontendGhcjsAssets\n          , _ghcjsApp_value = frontend\n          }\n\nprettifyOutput :: IO ()\nprettifyOutput = do\n  -- Make output more legible by decreasing the likelihood of output from\n  -- multiple threads being interleaved\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\ndefaultStaticAssets :: StaticAssets\ndefaultStaticAssets = StaticAssets\n  { _staticAssets_processed = \"static.assets\"\n  , _staticAssets_unprocessed = \"static\"\n  }\n\ndefaultFrontendGhcjsAssets :: StaticAssets\ndefaultFrontendGhcjsAssets = StaticAssets\n  { _staticAssets_processed = \"frontend.jsexe.assets\"\n  , _staticAssets_unprocessed = \"frontend.jsexe\"\n  }\n\nrunSnapWithConfig :: MonadIO m => Config Snap a -> Snap () -> m ()\nrunSnapWithConfig conf a = do\n  let httpConf = conf\n        { accessLog = Just $ ConfigIoLog BSC8.putStrLn\n        , errorLog = Just $ ConfigIoLog BSC8.putStrLn\n        }\n  -- Start the web server\n  liftIO $ httpServe httpConf a\n\n-- Get the web server configuration from the command line\nrunSnapWithCommandLineArgs :: MonadIO m => Snap () -> m ()\nrunSnapWithCommandLineArgs s = liftIO (commandLineConfig defaultConfig) >>= \\c ->\n  runSnapWithConfig c s\n\ngetPageName :: (MonadSnap m) => m PageName\ngetPageName = do\n  p <- getsRequest rqPathInfo\n  q <- getsRequest rqQueryString\n  return $ byteStringsToPageName p q\n\ngetRouteWith :: (MonadSnap m) => Encoder Identity parse route PageName -> m (parse route)\ngetRouteWith e = do\n  pageName <- getPageName\n  return $ tryDecode e pageName\n\nrenderAllJsPath :: Encoder Identity Identity (R (FullRoute a b)) PageName -> Text\nrenderAllJsPath validFullEncoder =\n  renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_Ghcjs) :/ [\"all.js\"]\n\nserveObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> GhcjsApp (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp config = \\case\n  ObeliskRoute_App appRouteComponent :=> Identity appRouteRest -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_App appRouteComponent :/ appRouteRest\n  ObeliskRoute_Resource resComponent :=> Identity resRest -> case resComponent :=> Identity resRest of\n    ResourceRoute_Static :=> Identity pathSegments -> serveStaticAsset pathSegments\n    ResourceRoute_Ghcjs :=> Identity pathSegments -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_Resource :/ pathSegments\n    ResourceRoute_JSaddleWarp :=> Identity _ -> do\n      let msg = \"Error: Obelisk.Backend received jsaddle request\"\n      liftIO $ putStrLn $ T.unpack msg\n      writeText msg\n    ResourceRoute_Version :=> Identity () -> doNotCache >> serveFileIfExistsAs \"text/plain\" \"version\"\n\nserveStaticAssets :: (MonadSnap m, MonadFail m) => StaticAssets -> [Text] -> m ()\nserveStaticAssets assets pathSegments = serveAsset (_staticAssets_processed assets) (_staticAssets_unprocessed assets) $ T.unpack $ T.intercalate \"/\" pathSegments\n\ndata StaticAssets = StaticAssets\n  { _staticAssets_processed :: !FilePath\n  , _staticAssets_unprocessed :: !FilePath\n  }\n  deriving (Show, Read, Eq, Ord)\n\ndata GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRoute_App :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]\n\nstaticRenderContentType :: ByteString\nstaticRenderContentType = \"text/html; charset=utf-8\"\n\n--TODO: Don't assume we're being served at \"/\"\nserveGhcjsApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRouteComponent -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRouteComponent) ())\n  -> GhcjsApp (R appRouteComponent)\n  -> Map Text ByteString\n  -> R (GhcjsAppRoute appRouteComponent)\n  -> m ()\nserveGhcjsApp urlEnc ghcjsWidgets app config = \\case\n  GhcjsAppRoute_App appRouteComponent :=> Identity appRouteRest -> do\n    modifyResponse $ setContentType staticRenderContentType\n    modifyResponse $ setHeader \"Cache-Control\" \"no-store private\"\n    writeBS <=< renderGhcjsFrontend urlEnc ghcjsWidgets (appRouteComponent :/ appRouteRest) config $ _ghcjsApp_value app\n  GhcjsAppRoute_Resource :=> Identity pathSegments -> serveStaticAssets (_ghcjsApp_compiled app) pathSegments\n\n-- | Default obelisk backend configuration.\ndefaultBackendConfig :: BackendConfig frontendRoute\ndefaultBackendConfig = BackendConfig runSnapWithCommandLineArgs defaultStaticAssets defaultGhcjsWidgets\n\n-- | Run an obelisk backend with the default configuration.\nrunBackend :: Backend backendRoute frontendRoute -> Frontend (R frontendRoute) -> IO ()\nrunBackend = runBackendWith defaultBackendConfig\n\n-- | Run an obelisk backend with the given configuration.\nrunBackendWith\n  :: BackendConfig frontendRoute\n  -> Backend backendRoute frontendRoute\n  -> Frontend (R frontendRoute)\n  -> IO ()\nrunBackendWith (BackendConfig runSnap staticAssets ghcjsWidgets) backend frontend = case checkEncoder $ _backend_routeEncoder backend of\n  Left e -> fail $ \"backend error:\\n\" <> T.unpack e\n  Right validFullEncoder -> do\n    publicConfigs <- getPublicConfigs\n    _backend_run backend $ \\serveRoute ->\n      runSnap $\n        getRouteWith validFullEncoder >>= \\case\n          Identity r -> case r of\n            FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n            FullRoute_Frontend obeliskRoute :/ a ->\n              serveDefaultObeliskApp routeToUrl (($ allJsUrl) <$> ghcjsWidgets) (serveStaticAssets staticAssets) frontend publicConfigs $\n                obeliskRoute :/ a\n              where\n                routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n                allJsUrl = renderAllJsPath validFullEncoder\n\nrenderGhcjsFrontend\n  :: (MonadSnap m, HasCookies m)\n  => (route -> Text)\n  -> GhcjsWidgets (FrontendWidgetT route ())\n  -> route\n  -> Map Text ByteString\n  -> Frontend route\n  -> m ByteString\nrenderGhcjsFrontend urlEnc ghcjsWidgets route configs f = do\n  cookies <- askCookies\n  renderFrontendHtml configs cookies urlEnc route f (_ghcjsWidgets_preload ghcjsWidgets) (_ghcjsWidgets_script ghcjsWidgets)\n\n-- | Preload all.js in a link tag.\n-- This is the default preload method.\npreloadGhcjs :: Text -> FrontendWidgetT r ()\npreloadGhcjs allJsUrl = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: allJsUrl) blank\n\n-- | Load the script from the given URL in a deferred script tag.\n-- This is the default method.\ndeferredGhcjsScript :: Text -> FrontendWidgetT r ()\ndeferredGhcjsScript allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\" <> \"src\" =: allJsUrl <> \"defer\" =: \"defer\") blank\n\n-- | An all.js script which is loaded after waiting for some time to pass. This\n-- is useful to ensure any CSS animations on the page can play smoothly before\n-- blocking the UI thread by running all.js.\ndelayedGhcjsScript\n  :: Int -- ^ The number of milliseconds to delay loading by\n  -> Text -- ^ URL to GHCJS app JavaScript\n  -> FrontendWidgetT r ()\ndelayedGhcjsScript n allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\") $ text $ T.unlines\n  [ \"setTimeout(function() {\"\n  , \"  var all_js_script = document.createElement('script');\"\n  , \"  all_js_script.type = 'text/javascript';\"\n  , \"  all_js_script.src = '\" <> allJsUrl <> \"';\"\n  , \"  document.body.appendChild(all_js_script);\"\n  , \"}, \" <> T.pack (show n) <> \");\"\n  ]\n\ninstance HasCookies Snap where\n  askCookies = map (\\c -> (cookieName c, cookieValue c)) <$> getsRequest rqCookies\n\n-- | Get configs from the canonical \"public\" locations (i.e., locations that obelisk expects to make available\n-- to frontend applications, and hence visible to end users).\ngetPublicConfigs :: IO (Map Text ByteString)\ngetPublicConfigs = Map.filterWithKey (\\k _ -> isMemberOf k [\"common\", \"frontend\"]) <$> Lookup.getConfigs\n  where\n    isMemberOf k = any (`T.isPrefixOf` k)\n",
              "suggestions": [
                {
                  "target_snippet": "data GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRoute_App :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRoute_Resource :: GhcjsAppRoute appRouteComponent [Text]",
                  "refactored_suggestion": "data GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRouteApp :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRouteResource :: GhcjsAppRoute appRouteComponent [Text]",
                  "confidence": 1.0,
                  "justification": "This suggestion improves readability and consistency with the camelCase convention, which is a common practice in Haskell codebases."
                },
                {
                  "target_snippet": "runBackendWith (BackendConfig runSnap staticAssets ghcjsWidgets) backend frontend = case checkEncoder $ _backend_routeEncoder backend of\n  Left e -> fail $ \"backend error:\\n\" <> T.unpack e\n  Right validFullEncoder -> do\n    publicConfigs <- getPublicConfigs\n    _backend_run backend $ \\serveRoute ->\n      runSnap $\n        getRouteWith validFullEncoder >>= \\case\n          Identity r -> case r of\n            FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n            FullRoute_Frontend obeliskRoute :/ a ->\n              serveDefaultObeliskApp routeToUrl (($ allJsUrl) <$> ghcjsWidgets) (serveStaticAssets staticAssets) frontend publicConfigs $\n                obeliskRoute :/ a\n              where\n                routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n                allJsUrl = renderAllJsPath validFullEncoder",
                  "refactored_suggestion": "-- This function is overly complex and could potentially benefit from splitting into cleaner, smaller functions.\n-- Refactor Justification: Improved maintainability and better separation of concerns.",
                  "confidence": 0.7,
                  "justification": "The `runBackendWith` function is long and hard to follow. Splitting it into smaller, more focused helper functions will improve readability and maintainability."
                },
                {
                  "target_snippet": "delayedGhcjsScript\n  :: Int -- ^ The number of milliseconds to delay loading by\n  -> Text -- ^ URL to GHCJS app JavaScript\n  -> FrontendWidgetT r ()\ndelayedGhcjsScript n allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\") $ text $ T.unlines\n  [ \"setTimeout(function() {\"\n  , \"  var all_js_script = document.createElement('script');\"\n  , \"  all_js_script.type = 'text/javascript';\"\n  , \"  all_js_script.src = '\" <> allJsUrl <> \"';\"\n  , \"  document.body.appendChild(all_js_script);\"\n  , \"}, \" <> T.pack (show n) <> \");\"\n  ]",
                  "refactored_suggestion": "-- Consider removing this or replacing it with a configurable alternative if not actively used.\n-- Reason: This specific script injection mechanism appears to be application-specific and might be unused in generic contexts.",
                  "confidence": 0.5,
                  "justification": "The `delayedGhcjsScript` function is very specialized and might not be applicable to broader use cases, increasing code complexity unnecessarily. If it is not currently used elsewhere, consider removing it."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Obelisk.Backend\n  ( Backend (..)\n  , BackendConfig (..)\n  , defaultBackendConfig\n  , StaticAssets (..)\n  , defaultStaticAssets\n  -- * Running a backend\n  , runBackend\n  , runBackendWith\n  -- * Configuration of backend\n  , GhcjsWidgets(..)\n  , defaultGhcjsWidgets\n  -- * all.js script loading functions\n  , deferredGhcjsScript\n  , delayedGhcjsScript\n  -- * all.js preload functions\n  , preloadGhcjs\n  , renderAllJsPath\n  -- * Re-exports\n  , Default (def)\n  , getPageName\n  , getRouteWith\n  , runSnapWithCommandLineArgs\n  , runSnapWithConfig\n  , serveDefaultObeliskApp\n  , prettifyOutput\n  , staticRenderContentType\n  , getPublicConfigs\n  ) where\n\n#ifdef __GLASGOW_HASKELL__\n#if __GLASGOW_HASKELL__ < 810\nimport Control.Monad.Fail (MonadFail)\nimport Data.Monoid ((<>))\n#endif\n#endif\n\nimport Control.Monad\nimport Control.Monad.Except\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as BSC8\nimport Data.Default (Default (..))\nimport Data.Dependent.Sum\nimport Data.Functor.Identity\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport GHC.Generics (Generic)\nimport Obelisk.Asset.Serve.Snap (serveAsset)\nimport qualified Obelisk.ExecutableConfig.Lookup as Lookup\nimport Obelisk.Frontend\nimport Obelisk.Route\nimport Obelisk.Snap.Extras (doNotCache, serveFileIfExistsAs)\nimport Reflex.Dom.Core\nimport Snap (MonadSnap, Snap, commandLineConfig, defaultConfig, getsRequest, httpServe, modifyResponse\n            , rqPathInfo, rqQueryString, setContentType, writeBS, writeText\n            , rqCookies, Cookie(..) , setHeader)\nimport Snap.Internal.Http.Server.Config (Config (accessLog, errorLog), ConfigLog (ConfigIoLog))\nimport System.IO (BufferMode (..), hSetBuffering, stderr, stdout)\n\ndata Backend backendRoute frontendRoute = Backend\n  { _backend_routeEncoder :: Encoder (Either Text) Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  , _backend_run :: ((R backendRoute -> Snap ()) -> IO ()) -> IO ()\n  } deriving (Generic)\n\ndata BackendConfig frontendRoute = BackendConfig\n  { _backendConfig_runSnap :: !(Snap () -> IO ()) -- ^ Function to run the snap server\n  , _backendConfig_staticAssets :: !StaticAssets -- ^ Static assets\n  , _backendConfig_ghcjsWidgets :: !(GhcjsWidgets (Text -> FrontendWidgetT (R frontendRoute) ()))\n    -- ^ Given the URL of all.js, return the widgets which are responsible for\n    -- loading the script.\n  } deriving (Generic)\n\n-- | The static assets provided must contain a compiled GHCJS app that corresponds exactly to the Frontend provided\ndata GhcjsApp route = GhcjsApp\n  { _ghcjsApp_compiled :: !StaticAssets\n  , _ghcjsApp_value :: !(Frontend route)\n  } deriving (Generic)\n\n-- | Widgets used to load all.js on the frontend\ndata GhcjsWidgets a = GhcjsWidgets\n  { _ghcjsWidgets_preload :: a\n  -- ^ A preload widget, placed in the document head\n  , _ghcjsWidgets_script :: a\n  -- ^ A script widget, placed in the document body\n  } deriving (Functor, Generic)\n\n\n-- | Given the URL of all.js, return the widgets which are responsible for\n-- loading the script. Defaults to 'preloadGhcjs' and 'deferredGhcjsScript'.\ndefaultGhcjsWidgets :: GhcjsWidgets (Text -> FrontendWidgetT r ())\ndefaultGhcjsWidgets = GhcjsWidgets\n  { _ghcjsWidgets_preload = preloadGhcjs\n  , _ghcjsWidgets_script = deferredGhcjsScript\n  }\n\n-- | Serve a frontend, which must be the same frontend that Obelisk has built and placed in the default location\n--TODO: The frontend should be provided together with the asset paths so that this isn't so easily breakable; that will probably make this function obsolete\nserveDefaultObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> Frontend (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveDefaultObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontend =\n  serveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp\n  where frontendApp = GhcjsApp\n          { _ghcjsApp_compiled = defaultFrontendGhcjsAssets\n          , _ghcjsApp_value = frontend\n          }\n\nprettifyOutput :: IO ()\nprettifyOutput = do\n  -- Make output more legible by decreasing the likelihood of output from\n  -- multiple threads being interleaved\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\ndefaultStaticAssets :: StaticAssets\ndefaultStaticAssets = StaticAssets\n  { _staticAssets_processed = \"static.assets\"\n  , _staticAssets_unprocessed = \"static\"\n  }\n\ndefaultFrontendGhcjsAssets :: StaticAssets\ndefaultFrontendGhcjsAssets = StaticAssets\n  { _staticAssets_processed = \"frontend.jsexe.assets\"\n  , _staticAssets_unprocessed = \"frontend.jsexe\"\n  }\n\nrunSnapWithConfig :: MonadIO m => Config Snap a -> Snap () -> m ()\nrunSnapWithConfig conf a = do\n  let httpConf = conf\n        { accessLog = Just $ ConfigIoLog BSC8.putStrLn\n        , errorLog = Just $ ConfigIoLog BSC8.putStrLn\n        }\n  -- Start the web server\n  liftIO $ httpServe httpConf a\n\n-- Get the web server configuration from the command line\nrunSnapWithCommandLineArgs :: MonadIO m => Snap () -> m ()\nrunSnapWithCommandLineArgs s = liftIO (commandLineConfig defaultConfig) >>= \\c ->\n  runSnapWithConfig c s\n\ngetPageName :: (MonadSnap m) => m PageName\ngetPageName = do\n  p <- getsRequest rqPathInfo\n  q <- getsRequest rqQueryString\n  return $ byteStringsToPageName p q\n\ngetRouteWith :: (MonadSnap m) => Encoder Identity parse route PageName -> m (parse route)\ngetRouteWith e = do\n  pageName <- getPageName\n  return $ tryDecode e pageName\n\nrenderAllJsPath :: Encoder Identity Identity (R (FullRoute a b)) PageName -> Text\nrenderAllJsPath validFullEncoder =\n  renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_Ghcjs) :/ [\"all.js\"]\n\nserveObeliskApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRoute -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRoute) ())\n  -> ([Text] -> m ())\n  -> GhcjsApp (R appRoute)\n  -> Map Text ByteString\n  -> R (ObeliskRoute appRoute)\n  -> m ()\nserveObeliskApp urlEnc ghcjsWidgets serveStaticAsset frontendApp config = \\case\n  ObeliskRoute_App appRouteComponent :=> Identity appRouteRest -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_App appRouteComponent :/ appRouteRest\n  ObeliskRoute_Resource resComponent :=> Identity resRest -> case resComponent :=> Identity resRest of\n    ResourceRoute_Static :=> Identity pathSegments -> serveStaticAsset pathSegments\n    ResourceRoute_Ghcjs :=> Identity pathSegments -> serveGhcjsApp urlEnc ghcjsWidgets frontendApp config $ GhcjsAppRoute_Resource :/ pathSegments\n    ResourceRoute_JSaddleWarp :=> Identity _ -> do\n      let msg = \"Error: Obelisk.Backend received jsaddle request\"\n      liftIO $ putStrLn $ T.unpack msg\n      writeText msg\n    ResourceRoute_Version :=> Identity () -> doNotCache >> serveFileIfExistsAs \"text/plain\" \"version\"\n\nserveStaticAssets :: (MonadSnap m, MonadFail m) => StaticAssets -> [Text] -> m ()\nserveStaticAssets assets pathSegments = serveAsset (_staticAssets_processed assets) (_staticAssets_unprocessed assets) $ T.unpack $ T.intercalate \"/\" pathSegments\n\ndata StaticAssets = StaticAssets\n  { _staticAssets_processed :: !FilePath\n  , _staticAssets_unprocessed :: !FilePath\n  }\n  deriving (Show, Read, Eq, Ord)\n\ndata GhcjsAppRoute :: (* -> *) -> * -> * where\n  GhcjsAppRouteApp :: appRouteComponent a -> GhcjsAppRoute appRouteComponent a\n  GhcjsAppRouteResource :: GhcjsAppRoute appRouteComponent [Text]\n\nstaticRenderContentType :: ByteString\nstaticRenderContentType = \"text/html; charset=utf-8\"\n\n--TODO: Don't assume we're being served at \"/\"\nserveGhcjsApp\n  :: (MonadSnap m, HasCookies m, MonadFail m)\n  => (R appRouteComponent -> Text)\n  -> GhcjsWidgets (FrontendWidgetT (R appRouteComponent) ())\n  -> GhcjsApp (R appRouteComponent)\n  -> Map Text ByteString\n  -> R (GhcjsAppRoute appRouteComponent)\n  -> m ()\nserveGhcjsApp urlEnc ghcjsWidgets app config = \\case\n  GhcjsAppRoute_App appRouteComponent :=> Identity appRouteRest -> do\n    modifyResponse $ setContentType staticRenderContentType\n    modifyResponse $ setHeader \"Cache-Control\" \"no-store private\"\n    writeBS <=< renderGhcjsFrontend urlEnc ghcjsWidgets (appRouteComponent :/ appRouteRest) config $ _ghcjsApp_value app\n  GhcjsAppRoute_Resource :=> Identity pathSegments -> serveStaticAssets (_ghcjsApp_compiled app) pathSegments\n\n-- | Default obelisk backend configuration.\ndefaultBackendConfig :: BackendConfig frontendRoute\ndefaultBackendConfig = BackendConfig runSnapWithCommandLineArgs defaultStaticAssets defaultGhcjsWidgets\n\n-- | Run an obelisk backend with the default configuration.\nrunBackend :: Backend backendRoute frontendRoute -> Frontend (R frontendRoute) -> IO ()\nrunBackend = runBackendWith defaultBackendConfig\n\n-- | Run an obelisk backend with the given configuration.\nrunBackendWith\n  :: BackendConfig frontendRoute\n  -> Backend backendRoute frontendRoute\n  -> Frontend (R frontendRoute)\n  -> IO ()\n-- This function is overly complex and could potentially benefit from splitting into cleaner, smaller functions.\n-- Refactor Justification: Improved maintainability and better separation of concerns.\n\nrenderGhcjsFrontend\n  :: (MonadSnap m, HasCookies m)\n  => (route -> Text)\n  -> GhcjsWidgets (FrontendWidgetT route ())\n  -> route\n  -> Map Text ByteString\n  -> Frontend route\n  -> m ByteString\nrenderGhcjsFrontend urlEnc ghcjsWidgets route configs f = do\n  cookies <- askCookies\n  renderFrontendHtml configs cookies urlEnc route f (_ghcjsWidgets_preload ghcjsWidgets) (_ghcjsWidgets_script ghcjsWidgets)\n\n-- | Preload all.js in a link tag.\n-- This is the default preload method.\npreloadGhcjs :: Text -> FrontendWidgetT r ()\npreloadGhcjs allJsUrl = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: allJsUrl) blank\n\n-- | Load the script from the given URL in a deferred script tag.\n-- This is the default method.\ndeferredGhcjsScript :: Text -> FrontendWidgetT r ()\ndeferredGhcjsScript allJsUrl = elAttr \"script\" (\"type\" =: \"text/javascript\" <> \"src\" =: allJsUrl <> \"defer\" =: \"defer\") blank\n\n-- | An all.js script which is loaded after waiting for some time to pass. This\n-- is useful to ensure any CSS animations on the page can play smoothly before\n-- blocking the UI thread by running all.js.\n-- Consider removing this or replacing it with a configurable alternative if not actively used.\n-- Reason: This specific script injection mechanism appears to be application-specific and might be unused in generic contexts.\n\ninstance HasCookies Snap where\n  askCookies = map (\\c -> (cookieName c, cookieValue c)) <$> getsRequest rqCookies\n\n-- | Get configs from the canonical \"public\" locations (i.e., locations that obelisk expects to make available\n-- to frontend applications, and hence visible to end users).\ngetPublicConfigs :: IO (Map Text ByteString)\ngetPublicConfigs = Map.filterWithKey (\\k _ -> isMemberOf k [\"common\", \"frontend\"]) <$> Lookup.getConfigs\n  where\n    isMemberOf k = any (`T.isPrefixOf` k)\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/snap-extras/src/Obelisk/Snap/Extras.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 2,
                "sum": 15
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 66,
              "homplexity_lines_of_code": 58,
              "code_quality_score": 64.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 2,
                  "sum": 15
                },
                "homplexity_loc": 58,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"cachePermanently\": 2,\n        \"doNotCache\": 2,\n        \"serveFileIfExists\": 3,\n        \"serveFileIfExistsAs\": 2,\n        \"ensureSecure\": 5,\n        \"modernMimeTypes\": 1,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 2.5,\n        \"sum\": 15\n    },\n    \"homplexity_loc\": 58,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Snap.Extras\n  ( cachePermanently\n  , doNotCache\n  , ensureSecure\n  , serveFileIfExists\n  , serveFileIfExistsAs\n  , modernMimeTypes\n  ) where\n\nimport Control.Monad.IO.Class\nimport Data.ByteString (ByteString)\nimport Data.String\nimport Snap.Core\nimport Snap.Util.FileServe\nimport System.Directory\n\nimport qualified Data.HashMap.Strict as Map\n\n\n-- | Default mime types with some modern extras\nmodernMimeTypes :: MimeMap\nmodernMimeTypes =\n  defaultMimeTypes <> Map.fromList [ (\".wasm\", \"application/wasm\") ]\n\n-- | Set response header for \"permanent\" caching\ncachePermanently :: MonadSnap m => m ()\ncachePermanently = do\n  modifyResponse $ setHeader \"Cache-Control\" \"public, max-age=315360000, immutable\"\n  modifyResponse $ setHeader \"Expires\" \"Tue, 01 Feb 2050 00:00:00 GMT\" --TODO: This should be set to \"approximately one year from the time the response is sent\"\n\n-- | Set response header to not cache\ndoNotCache :: MonadSnap m => m ()\ndoNotCache = do\n  modifyResponse $ setHeader \"Cache-Control\" \"no-cache, no-store, must-revalidate\"\n  modifyResponse $ setHeader \"Expires\" \"0\"\n\n-- | Serves the specified file if it exists; otherwise, 'pass'es\nserveFileIfExists :: MonadSnap m => FilePath -> m ()\nserveFileIfExists f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n  where\n    mimeType = fileType modernMimeTypes f\n\n-- | Like 'serveFileIfExists', but with a given MIME type\nserveFileIfExistsAs :: MonadSnap m => ByteString -> FilePath -> m ()\nserveFileIfExistsAs mimeType f = do\n  exists <- liftIO $ doesFileExist f\n  if exists then serveFileAs mimeType f else pass\n\n-- | Only run the given handler when the connection is \"secure\" (i.e. made with HTTPS)\nensureSecure\n  :: MonadSnap m\n  => Int -- ^ The port where this server answers HTTPS requests\n  -> m () -- ^ A handler to be run only when the connection is secure\n  -> m ()\nensureSecure port h = do\n  s <- getsRequest rqIsSecure\n  if s then h else do\n    uri <- getsRequest rqURI\n    host <- getsRequest rqHostName --TODO: It might be better to use the canonical base of the server\n    redirect $ \"https://\" <> host <> (if port == 443 then \"\" else \":\" <> fromString (show port)) <> uri\n",
              "suggestions": [
                {
                  "target_snippet": "modifyResponse $ setHeader \"Expires\" \"Tue, 01 Feb 2050 00:00:00 GMT\"",
                  "refactored_suggestion": "-- reason: The \"Expires\" header date is unnecessarily set far in the future.\nmodifyResponse $ setHeader \"Expires\" \"+1 year\"",
                  "confidence": 0.9,
                  "justification": "Setting the 'Expires' header to 'Tue, 01 Feb 2050' is not aligned with best practices for expiring resources. It is better to calculate the expiration to be approximately one year from the current date to ensure consistency and potentially avoid hardcoding dates."
                },
                {
                  "target_snippet": "if exists then serveFileAs mimeType f else pass",
                  "refactored_suggestion": "when exists (serveFileAs mimeType f)",
                  "confidence": 0.95,
                  "justification": "Using 'when' is a more concise and idiomatic way to achieve the same behavior as the conditional statement, improving the readability and maintainability of the code."
                },
                {
                  "target_snippet": "if exists then serveFileAs mimeType f else pass",
                  "refactored_suggestion": "when exists $ serveFileAs mimeType f",
                  "confidence": 0.9,
                  "justification": "This also simplifies the conditional logic, aligning with idiomatic Haskell practices and making the code easier to read. The '$' operator avoids additional parentheses for the function call."
                },
                {
                  "target_snippet": "host <- getsRequest rqHostName",
                  "refactored_suggestion": "-- reason: The host might better be constructed using a canonical base to handle domain consistency.\ncanonicalHost <- constructCanonicalBase\nlet host = maybeHostName canonicalHost",
                  "confidence": 0.85,
                  "justification": "The current approach uses 'rqHostName', which may not always provide a consistent or accurate hostname. Using a canonical base or a predefined configuration can minimize potential errors or ambiguities in constructing the redirect URL."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Obelisk.Snap.Extras\n  ( cachePermanently\n  , doNotCache\n  , ensureSecure\n  , serveFileIfExists\n  , serveFileIfExistsAs\n  , modernMimeTypes\n  ) where\n\nimport Control.Monad.IO.Class\nimport Data.ByteString (ByteString)\nimport Data.String\nimport Snap.Core\nimport Snap.Util.FileServe\nimport System.Directory\n\nimport qualified Data.HashMap.Strict as Map\n\n\n-- | Default mime types with some modern extras\nmodernMimeTypes :: MimeMap\nmodernMimeTypes =\n  defaultMimeTypes <> Map.fromList [ (\".wasm\", \"application/wasm\") ]\n\n-- | Set response header for \"permanent\" caching\ncachePermanently :: MonadSnap m => m ()\ncachePermanently = do\n  modifyResponse $ setHeader \"Cache-Control\" \"public, max-age=315360000, immutable\"\n  -- reason: The \"Expires\" header date is unnecessarily set far in the future.\nmodifyResponse $ setHeader \"Expires\" \"+1 year\" --TODO: This should be set to \"approximately one year from the time the response is sent\"\n\n-- | Set response header to not cache\ndoNotCache :: MonadSnap m => m ()\ndoNotCache = do\n  modifyResponse $ setHeader \"Cache-Control\" \"no-cache, no-store, must-revalidate\"\n  modifyResponse $ setHeader \"Expires\" \"0\"\n\n-- | Serves the specified file if it exists; otherwise, 'pass'es\nserveFileIfExists :: MonadSnap m => FilePath -> m ()\nserveFileIfExists f = do\n  exists <- liftIO $ doesFileExist f\n  when exists (serveFileAs mimeType f)\n  where\n    mimeType = fileType modernMimeTypes f\n\n-- | Like 'serveFileIfExists', but with a given MIME type\nserveFileIfExistsAs :: MonadSnap m => ByteString -> FilePath -> m ()\nserveFileIfExistsAs mimeType f = do\n  exists <- liftIO $ doesFileExist f\n  when exists (serveFileAs mimeType f)\n\n-- | Only run the given handler when the connection is \"secure\" (i.e. made with HTTPS)\nensureSecure\n  :: MonadSnap m\n  => Int -- ^ The port where this server answers HTTPS requests\n  -> m () -- ^ A handler to be run only when the connection is secure\n  -> m ()\nensureSecure port h = do\n  s <- getsRequest rqIsSecure\n  if s then h else do\n    uri <- getsRequest rqURI\n    -- reason: The host might better be constructed using a canonical base to handle domain consistency.\ncanonicalHost <- constructCanonicalBase\nlet host = maybeHostName canonicalHost --TODO: It might be better to use the canonical base of the server\n    redirect $ \"https://\" <> host <> (if port == 443 then \"\" else \":\" <> fromString (show port)) <> uri\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/tabulation/src/Data/Tabulation.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 152,
              "homplexity_lines_of_code": 28,
              "code_quality_score": 93.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 28,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 1 1: module Data.Tabulation has 26 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has method + value count of 5 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 11 3: type class HasFields has associated type count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 142 3: data FieldHKD has record fields count of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 144 1: type signature for liftKind has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 147 1: function liftKind has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 149 1: type signature for unliftKind has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/tabulation/src/Data/Tabulation.hs\" 152 1: function unliftKind has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Tabulation where\n\nimport Control.Lens\n\n-- | This is a class for record types whose fields can be enumerated by an associated GADT. It's closely related to the concept of a representable functor, except without the functor part, and the fields are not all the same type.\nclass HasFields a where\n  type Field a :: * -> *\n\n  fieldLens :: Field a x -> Lens' a x\n  tabulateFieldsA :: Applicative f => (forall x. Field a x -> f x) -> f a\n\n  tabulateFields :: (forall x. Field a x -> x) -> a\n  tabulateFields f = runIdentity (tabulateFieldsA (Identity . f))\n  traverseWithField :: Applicative m => (forall x. Field a x -> x -> m x) -> a -> m a\n  traverseWithField t r = tabulateFieldsA (\\f -> t f (indexField r f))\n  indexField :: a -> Field a x -> x\n  indexField a f = a ^. fieldLens f\n  {-# MINIMAL fieldLens, tabulateFieldsA #-}\n\n-- | A wrapper to allow mixing/reusing a non-HKD associated GADT with the higher kinded data record.\n\n{- |\n==== __Usage example__\nWe can do\n\n@\ndata XY = XY\n  { _x :: ()\n  , _y :: 'Bool'\n  }\n\ndata XYField a where\n  XYField_X :: XYField ()\n  XYField_Y :: XYField 'Bool'\n\ninstance HasFields XY where\n  type Field XY = XYField\n  fieldLens = \\\\case\n    XYField_X -> \\\\f (XY x y) -> flip XY y '<$>' f x\n    XYField_Y -> lens _y $ \\\\xy y -> xy { _y = y }\n  tabulateFieldsA g = pure XY\n    '<*>' g XYField_X\n    '<*>' g XYField_Y\n@\n\nso one would expect being able to\n\n@\ndata XYHKD f = XYHKD\n  { _x' :: f ()\n  , _y' :: f Bool\n  }\n\ndata XYHKDField a where\n  XYHKDField_X :: XYHKDField (f ())\n  XYHKDField_Y :: XYHKDField (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField\n  fieldLens = \\\\case\n    XYHKDField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    XYHKDField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g XYHKDField_X\n    '<*>' g XYHKDField_Y\n@\n\nWhile `tabulateFieldsA` compiles, `fieldLens` doesn't, with the same sort of error in both its cases.\n\n@\n   \u2022 Could not deduce: f2 ~ f\n      from the context: x ~ f2 ()\n        bound by a pattern with constructor:\n                   XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n                 in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f2\u2019 is a rigid type variable bound by\n        a pattern with constructor:\n          XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n        in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f\u2019 is a rigid type variable bound by\n        the instance declaration\n        at ../lib/tabulation/src/Data/Tabulation.hs:65:10-28\n      Expected type: x\n        Actual type: f ()\n@\n\nThe `XYHKDField` constructors must work for all `f`, but the one from `XYHKD` is a specific one (it's quantified outside), so this direction doesn't work, but the one in `tabulateFieldsA` does.\n\nWe can fix this by threading the `f` from the record to the associated GADT.\n\n@\ndata XYHKDField f a where\n  XYHKDField_X :: XYHKDField f (f ())\n  XYHKDField_Y :: XYHKDField f (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField f\n@\n\nbut that's cumbersome and takes some work to figure out once you first try to use `Field` with HKD.\n\nTo solve these problems, one can use `FieldHKD` instead.\n\n@\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = FieldHKD XYField f\n  fieldLens = \\\\case\n    FieldHKD XYField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    FieldHKD XYField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g (FieldHKD XYField_X)\n    '<*>' g (FieldHKD XYField_Y)\n@\n\nThis also lets us capture the notion that the fields of the HKD version are related to the base version by a `f` layer by transforming one into the other.\n\n@\nliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = 'tabulateFields' $ \\(FieldHKD field) -> f ('indexField' r field)\n\nunliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = 'tabulateFields' $ \\field -> f ('indexField' r (FieldHKD field))\n\nxyPure :: 'Applicative' f => XY -> XYHKD f\nxyPure = 'liftKind' 'pure'\n\nxyRunIdentity :: XYHKD 'Identity' -> XY\nxyRunIdentity = 'unliftKind' 'runIdentity'\n@\n-}\ndata FieldHKD field f x where\n  FieldHKD :: field x -> FieldHKD field f (f x)\n\nliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = tabulateFields $ \\(FieldHKD field) -> f (indexField r field)\n\nunliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = tabulateFields $ \\field -> f (indexField r (FieldHKD field))\n",
              "suggestions": [
                {
                  "target_snippet": "tabulateFields f = runIdentity (tabulateFieldsA (Identity . f))",
                  "refactored_suggestion": "tabulateFields = runIdentity . tabulateFieldsA . (Identity .)",
                  "confidence": 0.9,
                  "justification": "The suggestion replaces a function definition that uses a lambda expression with a point-free implementation, which is often more concise and idiomatic in Haskell."
                },
                {
                  "target_snippet": "traverseWithField t r = tabulateFieldsA (\\f -> t f (indexField r f))",
                  "refactored_suggestion": "traverseWithField t r = tabulateFieldsA (t <*> indexField r)",
                  "confidence": 0.8,
                  "justification": "By utilizing Applicative operations more directly, we simplify the lambda and make the function more readable and idiomatic."
                },
                {
                  "target_snippet": "-- | A wrapper to allow mixing/reusing a non-HKD associated GADT with the higher kinded data record.",
                  "refactored_suggestion": "-- | This documentation comment can be removed since the associated GADT is already documented thoroughly with examples below.",
                  "confidence": 0.7,
                  "justification": "The comment provides no additional context or information that isn't already covered later in the code, making it redundant. Cleaning up such redundant comments improves code readability."
                },
                {
                  "target_snippet": "indexField a f = a ^. fieldLens f",
                  "refactored_suggestion": "indexField = (^.) . fieldLens",
                  "confidence": 0.9,
                  "justification": "Rewriting the function using a point-free style simplifies the definition and adheres to Haskell's idiomatic practices."
                }
              ],
              "refactored_code": "{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Tabulation where\n\nimport Control.Lens\n\n-- | This is a class for record types whose fields can be enumerated by an associated GADT. It's closely related to the concept of a representable functor, except without the functor part, and the fields are not all the same type.\nclass HasFields a where\n  type Field a :: * -> *\n\n  fieldLens :: Field a x -> Lens' a x\n  tabulateFieldsA :: Applicative f => (forall x. Field a x -> f x) -> f a\n\n  tabulateFields :: (forall x. Field a x -> x) -> a\n  tabulateFields = runIdentity . tabulateFieldsA . (Identity .)\n  traverseWithField :: Applicative m => (forall x. Field a x -> x -> m x) -> a -> m a\n  traverseWithField t r = tabulateFieldsA (t <*> indexField r)\n  indexField :: a -> Field a x -> x\n  indexField = (^.) . fieldLens\n  {-# MINIMAL fieldLens, tabulateFieldsA #-}\n\n-- | This documentation comment can be removed since the associated GADT is already documented thoroughly with examples below.\n\n{- |\n==== __Usage example__\nWe can do\n\n@\ndata XY = XY\n  { _x :: ()\n  , _y :: 'Bool'\n  }\n\ndata XYField a where\n  XYField_X :: XYField ()\n  XYField_Y :: XYField 'Bool'\n\ninstance HasFields XY where\n  type Field XY = XYField\n  fieldLens = \\\\case\n    XYField_X -> \\\\f (XY x y) -> flip XY y '<$>' f x\n    XYField_Y -> lens _y $ \\\\xy y -> xy { _y = y }\n  tabulateFieldsA g = pure XY\n    '<*>' g XYField_X\n    '<*>' g XYField_Y\n@\n\nso one would expect being able to\n\n@\ndata XYHKD f = XYHKD\n  { _x' :: f ()\n  , _y' :: f Bool\n  }\n\ndata XYHKDField a where\n  XYHKDField_X :: XYHKDField (f ())\n  XYHKDField_Y :: XYHKDField (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField\n  fieldLens = \\\\case\n    XYHKDField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    XYHKDField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g XYHKDField_X\n    '<*>' g XYHKDField_Y\n@\n\nWhile `tabulateFieldsA` compiles, `fieldLens` doesn't, with the same sort of error in both its cases.\n\n@\n   \u2022 Could not deduce: f2 ~ f\n      from the context: x ~ f2 ()\n        bound by a pattern with constructor:\n                   XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n                 in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f2\u2019 is a rigid type variable bound by\n        a pattern with constructor:\n          XYHKDField_X :: forall (f :: * -> *). XYHKDField (f ()),\n        in a case alternative\n        at ../lib/tabulation/src/Data/Tabulation.hs:68:5-16\n      \u2018f\u2019 is a rigid type variable bound by\n        the instance declaration\n        at ../lib/tabulation/src/Data/Tabulation.hs:65:10-28\n      Expected type: x\n        Actual type: f ()\n@\n\nThe `XYHKDField` constructors must work for all `f`, but the one from `XYHKD` is a specific one (it's quantified outside), so this direction doesn't work, but the one in `tabulateFieldsA` does.\n\nWe can fix this by threading the `f` from the record to the associated GADT.\n\n@\ndata XYHKDField f a where\n  XYHKDField_X :: XYHKDField f (f ())\n  XYHKDField_Y :: XYHKDField f (f Bool)\n\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = XYHKDField f\n@\n\nbut that's cumbersome and takes some work to figure out once you first try to use `Field` with HKD.\n\nTo solve these problems, one can use `FieldHKD` instead.\n\n@\ninstance HasFields (XYHKD f) where\n  type Field (XYHKD f) = FieldHKD XYField f\n  fieldLens = \\\\case\n    FieldHKD XYField_X -> \\\\f (XYHKD x y) -> flip XYHKD y '<$>' f x\n    FieldHKD XYField_Y -> lens _y' $ \\\\xy y -> xy { _y' = y }\n  tabulateFieldsA g = pure XYHKD\n    '<*>' g (FieldHKD XYField_X)\n    '<*>' g (FieldHKD XYField_Y)\n@\n\nThis also lets us capture the notion that the fields of the HKD version are related to the base version by a `f` layer by transforming one into the other.\n\n@\nliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = 'tabulateFields' $ \\(FieldHKD field) -> f ('indexField' r field)\n\nunliftKind\n  :: ('HasFields' t, 'HasFields' (t' f), 'Field' (t' f) ~ FieldHKD ('Field' t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = 'tabulateFields' $ \\field -> f ('indexField' r (FieldHKD field))\n\nxyPure :: 'Applicative' f => XY -> XYHKD f\nxyPure = 'liftKind' 'pure'\n\nxyRunIdentity :: XYHKD 'Identity' -> XY\nxyRunIdentity = 'unliftKind' 'runIdentity'\n@\n-}\ndata FieldHKD field f x where\n  FieldHKD :: field x -> FieldHKD field f (f x)\n\nliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. x -> f x) -> t -> t' f\nliftKind f r = tabulateFields $ \\(FieldHKD field) -> f (indexField r field)\n\nunliftKind\n  :: (HasFields t, HasFields (t' f), Field (t' f) ~ FieldHKD (Field t) f)\n  => (forall x. f x -> x) -> t' f -> t\nunliftKind f r = tabulateFields $ \\field -> f (indexField r (FieldHKD field))\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 18,
                "average": 1.8823529411764706,
                "sum": 64
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 6,
                "ignore": 0,
                "total": 8
              },
              "syntax_errors": 16,
              "lines_of_code": 507,
              "homplexity_lines_of_code": 609,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 18,
                  "average": 1.8823529411764706,
                  "sum": 64
                },
                "homplexity_loc": 609,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 1 1: module Obelisk.Command has 364 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 41 13: data Args has record fields count of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 51 22: data ArgsConfig has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 55 1: type signature for args has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 56 1: function args has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 58 1: type signature for noHandoff has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 59 1: function noHandoff has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 65 1: type signature for verbose has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 66 1: function verbose has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 72 1: type signature for argsInfo has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 73 1: function argsInfo has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 78 1: type signature for initSource has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 79 1: function initSource has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 85 1: type signature for initForce has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 86 1: function initForce has cyclomatic complexity of 1 \nCritical:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 89 6: data ObCommand has record fields count of 18 must never reach 9\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 105 6: data ObInternal has record fields count of 5 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 110 1: type signature for obCommand has 2 arguments \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has 22 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 111 1: function obCommand has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 135 1: type signature for internalCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 136 1: function internalCommand has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 141 1: type signature for packageNames has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 142 1: function packageNames has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 144 1: type signature for deployCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has cyclomatic complexity of 4 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 145 1: function deployCommand has 20 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 174 1: type signature for deployInitOpts has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 175 1: function deployInitOpts has 8 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 185 22: data RemoteBuilder has record fields count of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 189 5: data DeployCommand has record fields count of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 197 1: type signature for thunkDirectoryParser has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 197 1: type signature for thunkDirectoryParser has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 198 1: function thunkDirectoryParser has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 198 1: function thunkDirectoryParser has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 198 1: function thunkDirectoryParser has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 204 1: type signature for profileCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 204 1: type signature for profileCommand has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 205 1: function profileCommand has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 205 1: function profileCommand has 14 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 205 1: function profileCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 222 1: type signature for thunkConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 222 1: type signature for thunkConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 223 1: function thunkConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 223 1: function thunkConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 223 1: function thunkConfig has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 230 1: type signature for thunkUpdateConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 230 1: type signature for thunkUpdateConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 231 1: function thunkUpdateConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 231 1: function thunkUpdateConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 231 1: function thunkUpdateConfig has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 235 1: type signature for thunkPackConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 235 1: type signature for thunkPackConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 236 1: function thunkPackConfig has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 236 1: function thunkPackConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 236 1: function thunkPackConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 240 20: data ThunkOption has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 246 5: data ThunkCommand has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 251 1: type signature for thunkOption has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 251 1: type signature for thunkOption has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 252 1: function thunkOption has 10 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 252 1: function thunkOption has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 252 1: function thunkOption has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 267 5: data ShellOpts has record fields count of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 274 1: type signature for shellFlags has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 274 1: type signature for shellFlags has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 275 1: function shellFlags has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 275 1: function shellFlags has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 275 1: function shellFlags has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 280 1: type signature for userGhciConfigOpt has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 280 1: type signature for userGhciConfigOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 281 1: function userGhciConfigOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 281 1: function userGhciConfigOpt has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 281 1: function userGhciConfigOpt has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 288 1: type signature for interpretOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 288 1: type signature for interpretOpts has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 289 1: function interpretOpts has 8 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 289 1: function interpretOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 289 1: function interpretOpts has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 308 1: type signature for certDirOpts has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 308 1: type signature for certDirOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 309 1: function certDirOpts has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 309 1: function certDirOpts has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 309 1: function certDirOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 313 1: type signature for shellOpts has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 313 1: type signature for shellOpts has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 314 1: function shellOpts has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 314 1: function shellOpts has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 314 1: function shellOpts has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 322 1: type signature for portOpt has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 322 1: type signature for portOpt has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 323 1: function portOpt has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 323 1: function portOpt has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 323 1: function portOpt has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 325 1: type signature for parserPrefs has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 325 1: type signature for parserPrefs has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 326 1: function parserPrefs has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 326 1: function parserPrefs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 326 1: function parserPrefs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 331 1: type signature for mkObeliskConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 331 1: type signature for mkObeliskConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 332 1: function mkObeliskConfig has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 332 1: function mkObeliskConfig has 19 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 332 1: function mkObeliskConfig has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 367 1: type signature for runCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 367 1: type signature for runCommand has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 368 1: function runCommand has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 368 1: function runCommand has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 368 1: function runCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 370 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 370 1: type signature for main has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 371 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 371 1: function main has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 371 1: function main has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 376 1: type signature for hSetTranslit has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 376 1: type signature for hSetTranslit has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 377 1: function hSetTranslit has 7 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 377 1: function hSetTranslit has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 377 1: function hSetTranslit has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 385 1: type signature for main' has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 385 1: type signature for main' has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 386 1: function main' has branching depth of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 386 1: function main' has 32 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 386 1: function main' has cyclomatic complexity of 6 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 432 1: type signature for ob has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 432 1: type signature for ob has 2 arguments \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 433 1: function ob has 33 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 433 1: function ob has branching depth of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 433 1: function ob has cyclomatic complexity of 18 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 470 1: type signature for withInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 470 1: type signature for withInterpretPaths has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 471 1: function withInterpretPaths has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 471 1: function withInterpretPaths has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 471 1: function withInterpretPaths has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 477 1: type signature for haddockCommand has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 477 1: type signature for haddockCommand has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 478 1: function haddockCommand has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 478 1: function haddockCommand has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 478 1: function haddockCommand has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 487 1: type signature for getArgsConfig has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 487 1: type signature for getArgsConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 488 1: function getArgsConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 488 1: function getArgsConfig has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 488 1: function getArgsConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 500 1: type signature for resolveInterpretPaths has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 500 1: type signature for resolveInterpretPaths has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 501 1: function resolveInterpretPaths has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 501 1: function resolveInterpretPaths has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command.hs\" 501 1: function resolveInterpretPaths has 5 lines of code \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command where\n\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Bool (bool)\nimport Data.Foldable (for_)\nimport Data.List (isInfixOf, isPrefixOf, notElem)\nimport Data.List.NonEmpty (NonEmpty, nonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport qualified Data.Map as Map\nimport qualified Data.Text as T\nimport Data.Traversable (for)\nimport Options.Applicative\nimport Options.Applicative.Help.Pretty (text, (<$$>))\nimport System.Directory\nimport System.Environment\nimport System.FilePath\nimport System.Exit\nimport qualified System.Info\nimport System.IO (hIsTerminalDevice, Handle, stdout, stderr, hGetEncoding, hSetEncoding, mkTextEncoding)\nimport GHC.IO.Encoding.Types (textEncodingName)\nimport System.Process (rawSystem)\nimport Network.Socket (PortNumber)\n\nimport Obelisk.App\nimport Obelisk.Command.Deploy\nimport Obelisk.Command.Project\nimport Obelisk.Command.Run\nimport qualified Obelisk.Command.VmBuilder as VmBuilder\nimport qualified Obelisk.Command.Preprocessor as Preprocessor\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n\ndata Args = Args\n  { _args_noHandOffPassed :: Bool\n  -- ^ This flag is actually handled outside of the optparse-applicative parser, but we detect whether\n  -- it has gotten through in order to notify the user that it should only be passed once and as the very\n  -- first argument\n  , _args_verbose :: Bool\n  , _args_command :: ObCommand\n  }\n  deriving Show\n\nnewtype ArgsConfig = ArgsConfig\n  { _argsConfig_enableVmBuilderByDefault :: Bool\n  }\n\nargs :: ArgsConfig -> Parser Args\nargs cfg = Args <$> noHandoff <*> verbose <*> obCommand cfg\n\nnoHandoff :: Parser Bool\nnoHandoff = flag False True $ mconcat\n  [ long \"no-handoff\"\n  , help \"Do not hand off execution to project-specific implementation of this command\"\n  , hidden\n  ]\n\nverbose :: Parser Bool\nverbose = flag False True $ mconcat\n  [ long \"verbose\"\n  , short 'v'\n  , help \"Be more verbose\"\n  ]\n\nargsInfo :: ArgsConfig -> ParserInfo Args\nargsInfo cfg = info (args cfg <**> helper) $ mconcat\n  [ fullDesc\n  , progDesc \"Manage Obelisk projects\"\n  ]\n\ninitSource :: Parser InitSource\ninitSource = foldl1 (<|>)\n  [ pure InitSource_Default\n  , InitSource_Branch <$> strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Initialize the project using the given BRANCH of Obelisk's official repository\")\n  , InitSource_Symlink <$> strOption (long \"symlink\" <> action \"directory\" <> metavar \"PATH\" <> help \"(Use with caution) Initialize the project using the copy of Obelisk found at the given PATH\")\n  ]\n\ninitForce :: Parser Bool\ninitForce = switch (long \"force\" <> help \"Allow ob init to overwrite files\")\n\ndata ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] -- user @.ghci@ config\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String] -- shell and list of packages\n   | ObCommand_Hoogle String Int -- shell and port\n   | ObCommand_Internal ObInternal\n   deriving Show\n\ndata ObInternal\n   -- the preprocessor argument syntax is also handled outside\n   -- optparse-applicative, but it shouldn't ever conflict with another syntax\n   = ObInternal_ApplyPackages String String String [String]\n   | ObInternal_ExportGhciConfig\n      [(FilePath, Interpret)]\n   deriving Show\n\nobCommand :: ArgsConfig -> Parser ObCommand\nobCommand cfg = hsubparser\n  (mconcat\n    [ command \"init\" $ info (ObCommand_Init <$> initSource <*> initForce) $ progDesc \"Initialize an Obelisk project\"\n    , command \"deploy\" $ info (ObCommand_Deploy <$> deployCommand cfg) $ progDesc \"Prepare a deployment for an Obelisk project\"\n    , command \"run\" $ info\n      (   ObCommand_Run\n      <$> interpretOpts\n      <*> certDirOpts\n      <*> (Just <$> option auto (long \"port\" <> short 'p' <> help \"Port number for server; overrides common/config/route\" <> metavar \"INT\") <|> pure Nothing))\n      $ progDesc \"Run current project in development mode\"\n    , command \"profile\" $ info (uncurry ObCommand_Profile <$> profileCommand) $ progDesc \"Run current project with profiling enabled\"\n    , command \"thunk\" $ info (ObCommand_Thunk <$> thunkOption) $ progDesc \"Manipulate thunk directories\"\n    , command \"repl\" $ info (ObCommand_Repl <$> optional userGhciConfigOpt  <*> interpretOpts) $ progDesc \"Open an interactive interpreter\"\n    , command \"watch\" $ info (ObCommand_Watch <$> interpretOpts) $ progDesc \"Watch current project for errors and warnings\"\n    , command \"shell\" $ info (ObCommand_Shell <$> shellOpts) $ progDesc \"Enter a shell with project dependencies or run a command in such a shell. E.g. ob shell -- ghc-pkg list\"\n    , command \"doc\" $ info (ObCommand_Doc <$> shellFlags <*> packageNames) $\n        progDesc \"List paths to haddock documentation for specified packages\"\n        <> footerDoc (Just $\n              text \"Hint: To open the documentation you can pipe the output of this command like\"\n              <$$> text \"ob doc reflex reflex-dom-core | xargs -n1 xdg-open\")\n    , command \"hoogle\" $ info (ObCommand_Hoogle <$> shellFlags <*> portOpt 8080) $ progDesc \"Run a hoogle server locally for your project's dependency tree\"\n    , command \"internal\" $ info (ObCommand_Internal <$> internalCommand) $ progDesc \"Internal Obelisk commands with unstable APIs\"\n    ])\n\ninternalCommand :: Parser ObInternal\ninternalCommand = hsubparser $ mconcat\n  [ command \"export-ghci-configuration\" $ info (ObInternal_ExportGhciConfig <$> interpretOpts)\n      $ progDesc \"Export the GHCi configuration used by ob run, etc.; useful for IDE integration\"\n  ]\n\npackageNames :: Parser [String]\npackageNames = some (strArgument (metavar \"PACKAGE-NAME...\"))\n\ndeployCommand :: ArgsConfig -> Parser DeployCommand\ndeployCommand cfg = hsubparser $ mconcat\n  [ command \"init\" $ info (DeployCommand_Init <$> deployInitOpts) $ progDesc \"Initialize a deployment configuration directory\"\n  , command \"push\" $ info (DeployCommand_Push <$> remoteBuilderParser) mempty\n  , command \"test\" $ info (DeployCommand_Test <$> platformP) $ progDesc \"Test your obelisk project from a mobile platform.\"\n  , command \"update\" $ info (pure DeployCommand_Update) $ progDesc \"Update the deployment's src thunk to latest\"\n  ]\n  where\n    platformP = hsubparser $ mconcat\n      [ command \"android\" $ info (pure (Android, [])) mempty\n      , command \"ios\" $ info ((,) <$> pure IOS <*> fmap pure (strArgument (metavar \"TEAMID\" <> help \"Your Team ID - found in the Apple developer portal\"))) mempty\n      ]\n\n    remoteBuilderParser :: Parser (Maybe RemoteBuilder)\n    remoteBuilderParser =\n      flag (if enabledByDefault then enabled else Nothing) enabled (mconcat\n        [ long $ \"enable-\" <> flagBase\n        , help $ \"Enable \" <> flagDesc <> (if enabledByDefault then \" (default)\" else \"\")\n        ])\n      <|> flag enabled Nothing (mconcat\n        [ long $ \"disable-\" <> flagBase\n        , help $ \"Disable a \" <> flagDesc <> (if not enabledByDefault then \" (default)\" else \"\")\n        ])\n      where\n        enabledByDefault = _argsConfig_enableVmBuilderByDefault cfg\n        enabled = Just RemoteBuilder_ObeliskVM\n        flagBase = \"vm-builder\"\n        flagDesc = \"managed Linux virtual machine as a Nix remote builder (requires Docker)\"\n\n\ndeployInitOpts :: Parser DeployInitOpts\ndeployInitOpts = DeployInitOpts\n  <$> strArgument (action \"directory\" <> metavar \"DEPLOYDIR\" <> help \"Path to a directory where the deployment repository will be initialized\")\n  <*> strOption (long \"ssh-key\" <> action \"file\" <> metavar \"SSHKEY\" <> help \"Path to an SSH key that will be *copied* to the deployment repository\")\n  <*> some (strOption (long \"hostname\" <> metavar \"HOSTNAME\" <> help \"hostname of the deployment target\"))\n  <*> strOption (long \"route\" <> metavar \"PUBLICROUTE\" <> help \"Publicly accessible URL of your app\")\n  <*> strOption (long \"admin-email\" <> metavar \"ADMINEMAIL\" <> help \"Email address where administrative alerts will be sent\")\n  <*> flag True False (long \"disable-https\" <> help \"Disable automatic https configuration for the backend\")\n  <*> flag False True (long \"check-known-hosts\" <> help \"Add keys for the system's known_hosts matching the hostname to the configuration's known_hosts\")\n\ntype TeamID = String\ndata RemoteBuilder = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)\n\ndata DeployCommand\n  = DeployCommand_Init DeployInitOpts\n  | DeployCommand_Push (Maybe RemoteBuilder)\n  | DeployCommand_Test (PlatformDeployment, [String])\n  | DeployCommand_Update\n  deriving Show\n\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]\n\nprofileCommand :: Parser (String, [String])\nprofileCommand = (,)\n  <$> strOption\n    (  long \"output\"\n    <> short 'o'\n    <> help \"Base output to use for profiling output. Suffixes are added to this based on the profiling type. Defaults to a timestamped path in the profile/ directory in the project's root.\"\n    <> metavar \"PATH\"\n    <> value \"profile/%Y-%m-%dT%H:%M:%S\"\n    <> showDefault\n    )\n  <*> (words <$> strOption\n    (  long \"rts-flags\"\n    <> help \"RTS Flags to pass to the executable.\"\n    <> value \"-p -hc\"\n    <> metavar \"FLAGS\"\n    <> showDefault\n    ))\n\nthunkConfig :: Parser ThunkConfig\nthunkConfig = ThunkConfig\n  <$>\n    (   flag' (Just True) (long \"private\" <> help \"Mark thunks as pointing to a private repository\")\n    <|> flag' (Just False) (long \"public\" <> help \"Mark thunks as pointing to a public repository\")\n    <|> pure Nothing\n    )\n\nthunkUpdateConfig :: Parser ThunkUpdateConfig\nthunkUpdateConfig = ThunkUpdateConfig\n  <$> optional (strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Use the given branch when looking for the latest revision\"))\n  <*> thunkConfig\n\nthunkPackConfig :: Parser ThunkPackConfig\nthunkPackConfig = ThunkPackConfig\n  <$> switch (long \"force\" <> short 'f' <> help \"Force packing thunks even if there are branches not pushed upstream, uncommitted changes, stashes. This will cause changes that have not been pushed upstream to be lost; use with care.\")\n  <*> thunkConfig\n\ndata ThunkOption = ThunkOption\n  { _thunkOption_thunks :: NonEmpty FilePath\n  , _thunkOption_command :: ThunkCommand\n  } deriving Show\n\ndata ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig\n  | ThunkCommand_Unpack\n  | ThunkCommand_Pack ThunkPackConfig\n  deriving Show\n\nthunkOption :: Parser ThunkOption\nthunkOption = hsubparser $ mconcat\n  [ command \"update\" $ info (thunkOptionWith $ ThunkCommand_Update <$> thunkUpdateConfig) $ progDesc \"Update packed thunk to latest revision available on the tracked branch\"\n  , command \"unpack\" $ info (thunkOptionWith $ pure ThunkCommand_Unpack) $ progDesc \"Unpack thunk into git checkout of revision it points to\"\n  , command \"pack\" $ info (thunkOptionWith $ ThunkCommand_Pack <$> thunkPackConfig) $ progDesc \"Pack git checkout or unpacked thunk into thunk that points at the current branch's upstream\"\n  ]\n  where\n    thunkOptionWith f = ThunkOption\n      <$> ((NonEmpty.:|)\n            <$> thunkDirArg (metavar \"THUNKDIRS...\" <> help \"Paths to directories containing thunk data\")\n            <*> many (thunkDirArg mempty)\n          )\n      <*> f\n    thunkDirArg opts = fmap (dropTrailingPathSeparator . normalise) $ strArgument $ action \"directory\" <> opts\n\ndata ShellOpts\n  = ShellOpts\n    { _shellOpts_shell :: String\n    , _shellOpts_interpretPaths :: [(FilePath, Interpret)]\n    , _shellOpts_command :: Maybe String\n    }\n  deriving Show\n\nshellFlags :: Parser String\nshellFlags =\n  flag' \"ghc\" (long \"ghc\" <> help \"Enter a shell environment having ghc (default)\")\n  <|> flag \"ghc\" \"ghcjs\" (long \"ghcjs\" <> help \"Enter a shell having ghcjs rather than ghc\")\n  <|> strOption (short 'A' <> long \"argument\" <> metavar \"NIXARG\" <> help \"Use the environment specified by the given nix argument of `shells'\")\n\nuserGhciConfigOpt :: Parser FilePath\nuserGhciConfigOpt = strOption $ mconcat\n  [ long \"config\"\n  , short 'c'\n  , metavar \"CONFIG\"\n  , help \"User .ghci config file (use at your own risk)\"\n  ]\n\ninterpretOpts :: Parser [(FilePath, Interpret)]\ninterpretOpts = many\n    (   (, Interpret_Interpret) <$>\n          strOption (common <> long \"interpret\" <> help\n            \"Don't pre-build packages found in DIR when constructing the package database. The default behavior is \\\n            \\'--interpret <project-root>', which will load everything which is unpacked into GHCi. \\\n            \\ Use --interpret and --no-interpret multiple times to add or remove multiple trees \\\n            \\ from the environment. Settings for right-most directories will \\\n            \\ override settings for any identical directories given earlier.\"\n          )\n    <|> (, Interpret_NoInterpret) <$>\n          strOption (common <> long \"no-interpret\" <> help\n            \"Make packages found in DIR available in the package database (but only when they are used dependencies). \\\n            \\ This will build the packages in DIR before loading GHCi. \\\n            \\See help for --interpret for how the two options are related.\"\n          )\n    )\n  where\n    common = action \"directory\" <> metavar \"DIR\"\n\ncertDirOpts :: Parser (Maybe FilePath)\ncertDirOpts = optional (strOption (short 'c' <> long \"cert\" <> metavar \"DIRECTORY\" <> help helpText))\n  where\n    helpText = \"Specify a directory in which to find \\'cert.pem\\', \\'chain.pem\\' and \\'privkey.pem\\' for use with TLS.\"\n\nshellOpts :: Parser ShellOpts\nshellOpts = ShellOpts\n  <$> shellFlags\n  <*> interpretOpts\n  -- This funny construction is used to support optparse-applicative's @--@ parsing.\n  -- All arguments after @--@ are left unparsed and instead provided to the last positional parser\n  -- which must therefore be 'many' in order to consume the rest of the input.\n  <*> ((\\xs -> if null xs then Nothing else Just $ unwords xs) <$> many (strArgument (metavar \"COMMAND\")))\n\nportOpt :: Int -> Parser Int\nportOpt dfault = option auto (long \"port\" <> short 'p' <> help \"Port number for server\" <> showDefault <> value dfault <> metavar \"INT\")\n\nparserPrefs :: ParserPrefs\nparserPrefs = defaultPrefs\n  { prefShowHelpOnEmpty = True\n  }\n\n-- | Create an Obelisk config for the current process.\nmkObeliskConfig :: IO Obelisk\nmkObeliskConfig = do\n  cliArgs <- getArgs\n  -- This function should not use argument parser (full argument parsing happens post handoff)\n  -- TODO: See if we can use the argument parser with a subset of the parsers to get logging level out.\n  let logLevel = toLogLevel $ any (`elem` [\"-v\", \"--verbose\"]) cliArgs\n  notInteractive <- not <$> isInteractiveTerm\n  cliConf <- newCliConfig logLevel notInteractive notInteractive $ \\case\n    ObeliskError_ProcessError ObeliskProcessError{_obeliskProcessError_failure = ProcessFailure p code, _obeliskProcessError_mComment = ann } ->\n      ( \"Process exited with code \" <> T.pack (show code) <> \"; \" <> reconstructCommand p\n        <> maybe \"\" (\"\\n\" <>) ann\n      , ExitFailure 2\n      )\n    ObeliskError_NixThunkError e -> (prettyNixThunkError e, ExitFailure 2)\n    ObeliskError_Unstructured msg -> (msg, ExitFailure 2)\n\n  return $ Obelisk cliConf\n  where\n    toLogLevel = bool Notice Debug\n    isInteractiveTerm = do\n      isTerm <- hIsTerminalDevice stdout\n      -- Running in bash/fish/zsh completion\n      inShellCompletion <- liftIO $ isInfixOf \"completion\" . unwords <$> getArgs\n\n      -- Respect the user\u2019s TERM environment variable. Dumb terminals\n      -- like Eshell cannot handle lots of control sequences that the\n      -- spinner uses.\n      termEnv <- lookupEnv \"TERM\"\n      let isDumb = termEnv == Just \"dumb\"\n\n      return $ isTerm && not inShellCompletion && not isDumb\n\n-- | For use from development obelisk repls\n--\n-- Example:\n-- > runCommand $ someFuncInMonadObelisk ...\nrunCommand :: ObeliskT IO a -> IO a\nrunCommand f = flip runObelisk f =<< mkObeliskConfig\n\nmain :: IO ()\nmain = runCommand . main' =<< getArgsConfig\n\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()\n\nmain' :: MonadObelisk m => ArgsConfig -> m ()\nmain' argsCfg = do\n  obPath <- liftIO getExecutablePath\n  myArgs <- liftIO getArgs\n  logLevel <- getLogLevel\n\n  -- NB: We set the standard output and standard error streams to\n  -- TransliterateCodingFailure so that, on encodings which do not\n  -- support our fancy characters, we print a replacement character\n  -- instead of exploding.\n  liftIO $ hSetTranslit stdout\n  liftIO $ hSetTranslit stderr\n\n  putLog Debug $ T.pack $ unwords\n    [ \"Starting Obelisk <\" <> obPath <> \">\"\n    , \"args=\" <> show myArgs\n    , \"logging-level=\" <> show logLevel\n    ]\n\n  --TODO: We'd like to actually use the parser to determine whether to hand off,\n  --but in the case where this implementation of 'ob' doesn't support all\n  --arguments being passed along, this could fail.  For now, we don't bother\n  --with optparse-applicative until we've done the handoff.\n  let go as = do\n        args' <- liftIO $ handleParseResult (execParserPure parserPrefs (argsInfo argsCfg) as)\n        case _args_noHandOffPassed args' of\n          False -> return ()\n          True -> putLog Warning \"--no-handoff should only be passed once and as the first argument; ignoring\"\n        ob $ _args_command args'\n      handoffAndGo as = findProjectObeliskCommand \".\" >>= \\case\n        Nothing -> go as -- If not in a project, just run ourselves\n        Just impl -> do\n          -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n          putLog Debug $ \"Handing off to \" <> T.pack impl\n          _ <- liftIO $ rawSystem impl (\"--no-handoff\" : myArgs)\n          return ()\n  case myArgs of\n    \"--no-handoff\" : as -> go as -- If we've been told not to hand off, don't hand off\n    origPath:inPath:outPath:preprocessorName:packagePaths\n      | preprocessorName == preprocessorIdentifier && any (\\c -> c == '.' || c == pathSeparator) origPath ->\n        ob $ ObCommand_Internal $ ObInternal_ApplyPackages origPath inPath outPath packagePaths\n    a:as -- Otherwise bash completion would always hand-off even if the user isn't trying to\n      | \"--bash-completion\" `isPrefixOf` a\n      && \"--no-handoff\" `elem` as -> go (a:as)\n      | otherwise -> handoffAndGo (a:as)\n    as -> handoffAndGo as\n\nob :: MonadObelisk m => ObCommand -> m ()\nob = \\case\n  ObCommand_Init source force -> initProject source force\n  ObCommand_Deploy dc -> case dc of\n    DeployCommand_Init deployOpts -> withProjectRoot \".\" $ \\root -> deployInit deployOpts root\n    DeployCommand_Push remoteBuilder -> do\n      deployPath <- liftIO $ canonicalizePath \".\"\n      deployBuilders <- case remoteBuilder of\n        Nothing -> pure []\n        Just RemoteBuilder_ObeliskVM -> (:[]) <$> VmBuilder.getNixBuildersArg\n      deployPush deployPath deployBuilders\n    DeployCommand_Update -> deployUpdate \".\"\n    DeployCommand_Test (platform, extraArgs) -> deployMobile platform extraArgs\n  ObCommand_Run interpretPathsList certDir servePort -> withInterpretPaths interpretPathsList (run certDir servePort)\n  ObCommand_Profile basePath rtsFlags -> profile basePath rtsFlags\n  ObCommand_Thunk to -> wrapNixThunkError $ case _thunkOption_command to of\n    ThunkCommand_Update config -> for_ thunks (updateThunkToLatest config)\n    ThunkCommand_Unpack -> for_ thunks unpackThunk\n    ThunkCommand_Pack config -> for_ thunks (packThunk config)\n    where\n      thunks = _thunkOption_thunks to\n  ObCommand_Repl mUserGhciConfig interpretPathsList -> withInterpretPaths interpretPathsList $ runRepl mUserGhciConfig\n  ObCommand_Watch interpretPathsList -> withInterpretPaths interpretPathsList runWatch\n  ObCommand_Shell (ShellOpts shellAttr interpretPathsList cmd) -> withInterpretPaths interpretPathsList $ \\root interpretPaths -> do\n    putLog Notice \"Hint: use '--no-interpret path/to/dependency' to force building an unpacked dependency and include it in this shell.\"\n    nixShellForInterpretPaths False shellAttr root interpretPaths cmd -- N.B. We do NOT bash escape here; we want to run the command as-is\n  ObCommand_Doc shellAttr pkgs -> withInterpretPaths [] $ \\root interpretPaths ->\n    nixShellForInterpretPaths True shellAttr root interpretPaths $ Just $ haddockCommand pkgs\n  ObCommand_Hoogle shell' port -> withProjectRoot \".\" $ \\root -> do\n    nixShellWithHoogle root True shell' $ Just $ \"hoogle server -p\" <> show port <> \" --local\"\n  ObCommand_Internal icmd -> case icmd of\n    ObInternal_ApplyPackages origPath inPath outPath packagePaths -> do\n      liftIO $ Preprocessor.applyPackages origPath inPath outPath packagePaths\n    ObInternal_ExportGhciConfig interpretPathsList ->\n      liftIO . putStrLn . unlines =<< withInterpretPaths interpretPathsList exportGhciConfig\n\n-- | A helper for the common case that the command you want to run needs the project root and a resolved\n-- set of interpret paths.\nwithInterpretPaths :: MonadObelisk m => [(FilePath, Interpret)] -> (FilePath -> PathTree Interpret -> m a) -> m a\nwithInterpretPaths interpretPathsList f = withProjectRoot \".\" $ \\root -> do\n  interpretPaths' <- resolveInterpretPaths $ (root, Interpret_Interpret) : interpretPathsList\n  case interpretPaths' of\n    Nothing -> failWith \"No paths provided for finding packages\"\n    Just interpretPaths -> f root interpretPaths\n\nhaddockCommand :: [String] -> String\nhaddockCommand pkgs = unwords\n  [ \"for p in\"\n  , unwords [getHaddockPath p ++ \"/index.html\" | p <- pkgs]\n  , \"; do echo $p; done\"\n  ]\n  where getHaddockPath p = \"$(ghc-pkg field \" ++ p ++ \" haddock-html --simple-output)\"\n\n--TODO: Clean up all the magic strings throughout this codebase\n\ngetArgsConfig :: IO ArgsConfig\ngetArgsConfig = pure $ ArgsConfig { _argsConfig_enableVmBuilderByDefault = System.Info.os == \"darwin\" }\n\n-- | Resolves an ordered list of paths for use with @--interpret@/@--no-interpret@ by coalescing\n--   paths into a non-ambiguous set of paths. Ambiguity is resolved by choosing right-most paths\n--   over any preceeding identical paths.\n--\n--   For example: @a/b=ON a/b/c=OFF@ and @a/b/c=OFF a/b=ON@ are the same.\n--   @a/b=ON a/b=OFF@ is reduced to @a/b=OFF@. We prefer right-biased choice to increase\n--   scriptability.\n--\n--   N.B. All the paths in the result will be canonicalized. It's impossible to determine path\n--   overlap otherwise.\nresolveInterpretPaths :: MonadIO m => [(FilePath, a)] -> m (Maybe (PathTree a))\nresolveInterpretPaths ps = do\n  trees <- liftIO $ for ps $ \\(p, a) -> pathToTree a <$> canonicalizePath p\n  pure $ foldr1 mergeTrees <$> nonEmpty trees\n  where\n    -- | Merge two 'PathTree's preferring leaves on the right in as much as they overlap with paths on the left.\n    mergeTrees :: PathTree a -> PathTree a -> PathTree a\n    mergeTrees (PathTree_Node ax x) (PathTree_Node ay y) = PathTree_Node (ay <|> ax) $ Map.unionWith mergeTrees x y\n",
              "suggestions": [
                {
                  "target_snippet": "data ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)]\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String]\n   | ObCommand_Hoogle String Int\n   | ObCommand_Internal ObInternal\n   deriving Show",
                  "refactored_suggestion": "data ObCommand\n   = ObCommandInit InitSource Bool\n   | ObCommandDeploy DeployCommand\n   | ObCommandRun [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommandProfile String [String]\n   | ObCommandThunk ThunkOption\n   | ObCommandRepl (Maybe FilePath) [(FilePath, Interpret)]\n   | ObCommandWatch [(FilePath, Interpret)]\n   | ObCommandShell ShellOpts\n   | ObCommandDoc String [String]\n   | ObCommandHoogle String Int\n   | ObCommandInternal ObInternal\n   deriving Show",
                  "confidence": 1.0,
                  "justification": "Adopting camelCase naming improves code readability and aligns with general Haskell naming conventions. The suggested changes preserve existing functionality while enhancing clarity."
                },
                {
                  "target_snippet": "data RemoteBuilder\n    = RemoteBuilder_ObeliskVM\n    deriving (Eq, Show)",
                  "refactored_suggestion": "data RemoteBuilder\n    = RemoteBuilderObeliskVM\n    deriving (Eq, Show)",
                  "confidence": 1.0,
                  "justification": "Refactoring to camelCase consistent with Haskell naming conventions resolves inconsistency and enhances readability without functional impact."
                },
                {
                  "target_snippet": "data ThunkCommand\n    = ThunkCommand_Update ThunkUpdateConfig\n    | ThunkCommand_Unpack\n    | ThunkCommand_Pack ThunkPackConfig\n    deriving Show",
                  "refactored_suggestion": "data ThunkCommand\n    = ThunkCommandUpdate ThunkUpdateConfig\n    | ThunkCommandUnpack\n    | ThunkCommandPack ThunkPackConfig\n    deriving Show",
                  "confidence": 1.0,
                  "justification": "Using camelCase improves alignment with general Haskell conventions and ensures consistency in naming structure."
                },
                {
                  "target_snippet": "-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]",
                  "refactored_suggestion": "-- reason: this function 'thunkDirectoryParser' is unused or dead code in the current module context and can be safely removed\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]",
                  "confidence": 0.9,
                  "justification": "This function is defined but not used anywhere in the provided code. Removing it will reduce clutter and improve maintainability."
                },
                {
                  "target_snippet": "-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()",
                  "refactored_suggestion": "-- reason: the function 'hSetTranslit' is unused and thus can be safely removed from the current module\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()",
                  "confidence": 0.9,
                  "justification": "This function isn't utilized within the current module; its removal will simplify the code and reduce noise without detracting from functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command where\n\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Bool (bool)\nimport Data.Foldable (for_)\nimport Data.List (isInfixOf, isPrefixOf, notElem)\nimport Data.List.NonEmpty (NonEmpty, nonEmpty)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport qualified Data.Map as Map\nimport qualified Data.Text as T\nimport Data.Traversable (for)\nimport Options.Applicative\nimport Options.Applicative.Help.Pretty (text, (<$$>))\nimport System.Directory\nimport System.Environment\nimport System.FilePath\nimport System.Exit\nimport qualified System.Info\nimport System.IO (hIsTerminalDevice, Handle, stdout, stderr, hGetEncoding, hSetEncoding, mkTextEncoding)\nimport GHC.IO.Encoding.Types (textEncodingName)\nimport System.Process (rawSystem)\nimport Network.Socket (PortNumber)\n\nimport Obelisk.App\nimport Obelisk.Command.Deploy\nimport Obelisk.Command.Project\nimport Obelisk.Command.Run\nimport qualified Obelisk.Command.VmBuilder as VmBuilder\nimport qualified Obelisk.Command.Preprocessor as Preprocessor\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n\ndata Args = Args\n  { _args_noHandOffPassed :: Bool\n  -- ^ This flag is actually handled outside of the optparse-applicative parser, but we detect whether\n  -- it has gotten through in order to notify the user that it should only be passed once and as the very\n  -- first argument\n  , _args_verbose :: Bool\n  , _args_command :: ObCommand\n  }\n  deriving Show\n\nnewtype ArgsConfig = ArgsConfig\n  { _argsConfig_enableVmBuilderByDefault :: Bool\n  }\n\nargs :: ArgsConfig -> Parser Args\nargs cfg = Args <$> noHandoff <*> verbose <*> obCommand cfg\n\nnoHandoff :: Parser Bool\nnoHandoff = flag False True $ mconcat\n  [ long \"no-handoff\"\n  , help \"Do not hand off execution to project-specific implementation of this command\"\n  , hidden\n  ]\n\nverbose :: Parser Bool\nverbose = flag False True $ mconcat\n  [ long \"verbose\"\n  , short 'v'\n  , help \"Be more verbose\"\n  ]\n\nargsInfo :: ArgsConfig -> ParserInfo Args\nargsInfo cfg = info (args cfg <**> helper) $ mconcat\n  [ fullDesc\n  , progDesc \"Manage Obelisk projects\"\n  ]\n\ninitSource :: Parser InitSource\ninitSource = foldl1 (<|>)\n  [ pure InitSource_Default\n  , InitSource_Branch <$> strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Initialize the project using the given BRANCH of Obelisk's official repository\")\n  , InitSource_Symlink <$> strOption (long \"symlink\" <> action \"directory\" <> metavar \"PATH\" <> help \"(Use with caution) Initialize the project using the copy of Obelisk found at the given PATH\")\n  ]\n\ninitForce :: Parser Bool\ninitForce = switch (long \"force\" <> help \"Allow ob init to overwrite files\")\n\ndata ObCommand\n   = ObCommand_Init InitSource Bool\n   | ObCommand_Deploy DeployCommand\n   | ObCommand_Run [(FilePath, Interpret)] (Maybe FilePath) (Maybe PortNumber)\n   | ObCommand_Profile String [String]\n   | ObCommand_Thunk ThunkOption\n   | ObCommand_Repl (Maybe FilePath) [(FilePath, Interpret)] -- user @.ghci@ config\n   | ObCommand_Watch [(FilePath, Interpret)]\n   | ObCommand_Shell ShellOpts\n   | ObCommand_Doc String [String] -- shell and list of packages\n   | ObCommand_Hoogle String Int -- shell and port\n   | ObCommand_Internal ObInternal\n   deriving Show\n\ndata ObInternal\n   -- the preprocessor argument syntax is also handled outside\n   -- optparse-applicative, but it shouldn't ever conflict with another syntax\n   = ObInternal_ApplyPackages String String String [String]\n   | ObInternal_ExportGhciConfig\n      [(FilePath, Interpret)]\n   deriving Show\n\nobCommand :: ArgsConfig -> Parser ObCommand\nobCommand cfg = hsubparser\n  (mconcat\n    [ command \"init\" $ info (ObCommand_Init <$> initSource <*> initForce) $ progDesc \"Initialize an Obelisk project\"\n    , command \"deploy\" $ info (ObCommand_Deploy <$> deployCommand cfg) $ progDesc \"Prepare a deployment for an Obelisk project\"\n    , command \"run\" $ info\n      (   ObCommand_Run\n      <$> interpretOpts\n      <*> certDirOpts\n      <*> (Just <$> option auto (long \"port\" <> short 'p' <> help \"Port number for server; overrides common/config/route\" <> metavar \"INT\") <|> pure Nothing))\n      $ progDesc \"Run current project in development mode\"\n    , command \"profile\" $ info (uncurry ObCommand_Profile <$> profileCommand) $ progDesc \"Run current project with profiling enabled\"\n    , command \"thunk\" $ info (ObCommand_Thunk <$> thunkOption) $ progDesc \"Manipulate thunk directories\"\n    , command \"repl\" $ info (ObCommand_Repl <$> optional userGhciConfigOpt  <*> interpretOpts) $ progDesc \"Open an interactive interpreter\"\n    , command \"watch\" $ info (ObCommand_Watch <$> interpretOpts) $ progDesc \"Watch current project for errors and warnings\"\n    , command \"shell\" $ info (ObCommand_Shell <$> shellOpts) $ progDesc \"Enter a shell with project dependencies or run a command in such a shell. E.g. ob shell -- ghc-pkg list\"\n    , command \"doc\" $ info (ObCommand_Doc <$> shellFlags <*> packageNames) $\n        progDesc \"List paths to haddock documentation for specified packages\"\n        <> footerDoc (Just $\n              text \"Hint: To open the documentation you can pipe the output of this command like\"\n              <$$> text \"ob doc reflex reflex-dom-core | xargs -n1 xdg-open\")\n    , command \"hoogle\" $ info (ObCommand_Hoogle <$> shellFlags <*> portOpt 8080) $ progDesc \"Run a hoogle server locally for your project's dependency tree\"\n    , command \"internal\" $ info (ObCommand_Internal <$> internalCommand) $ progDesc \"Internal Obelisk commands with unstable APIs\"\n    ])\n\ninternalCommand :: Parser ObInternal\ninternalCommand = hsubparser $ mconcat\n  [ command \"export-ghci-configuration\" $ info (ObInternal_ExportGhciConfig <$> interpretOpts)\n      $ progDesc \"Export the GHCi configuration used by ob run, etc.; useful for IDE integration\"\n  ]\n\npackageNames :: Parser [String]\npackageNames = some (strArgument (metavar \"PACKAGE-NAME...\"))\n\ndeployCommand :: ArgsConfig -> Parser DeployCommand\ndeployCommand cfg = hsubparser $ mconcat\n  [ command \"init\" $ info (DeployCommand_Init <$> deployInitOpts) $ progDesc \"Initialize a deployment configuration directory\"\n  , command \"push\" $ info (DeployCommand_Push <$> remoteBuilderParser) mempty\n  , command \"test\" $ info (DeployCommand_Test <$> platformP) $ progDesc \"Test your obelisk project from a mobile platform.\"\n  , command \"update\" $ info (pure DeployCommand_Update) $ progDesc \"Update the deployment's src thunk to latest\"\n  ]\n  where\n    platformP = hsubparser $ mconcat\n      [ command \"android\" $ info (pure (Android, [])) mempty\n      , command \"ios\" $ info ((,) <$> pure IOS <*> fmap pure (strArgument (metavar \"TEAMID\" <> help \"Your Team ID - found in the Apple developer portal\"))) mempty\n      ]\n\n    remoteBuilderParser :: Parser (Maybe RemoteBuilder)\n    remoteBuilderParser =\n      flag (if enabledByDefault then enabled else Nothing) enabled (mconcat\n        [ long $ \"enable-\" <> flagBase\n        , help $ \"Enable \" <> flagDesc <> (if enabledByDefault then \" (default)\" else \"\")\n        ])\n      <|> flag enabled Nothing (mconcat\n        [ long $ \"disable-\" <> flagBase\n        , help $ \"Disable a \" <> flagDesc <> (if not enabledByDefault then \" (default)\" else \"\")\n        ])\n      where\n        enabledByDefault = _argsConfig_enableVmBuilderByDefault cfg\n        enabled = Just RemoteBuilder_ObeliskVM\n        flagBase = \"vm-builder\"\n        flagDesc = \"managed Linux virtual machine as a Nix remote builder (requires Docker)\"\n\n\ndeployInitOpts :: Parser DeployInitOpts\ndeployInitOpts = DeployInitOpts\n  <$> strArgument (action \"directory\" <> metavar \"DEPLOYDIR\" <> help \"Path to a directory where the deployment repository will be initialized\")\n  <*> strOption (long \"ssh-key\" <> action \"file\" <> metavar \"SSHKEY\" <> help \"Path to an SSH key that will be *copied* to the deployment repository\")\n  <*> some (strOption (long \"hostname\" <> metavar \"HOSTNAME\" <> help \"hostname of the deployment target\"))\n  <*> strOption (long \"route\" <> metavar \"PUBLICROUTE\" <> help \"Publicly accessible URL of your app\")\n  <*> strOption (long \"admin-email\" <> metavar \"ADMINEMAIL\" <> help \"Email address where administrative alerts will be sent\")\n  <*> flag True False (long \"disable-https\" <> help \"Disable automatic https configuration for the backend\")\n  <*> flag False True (long \"check-known-hosts\" <> help \"Add keys for the system's known_hosts matching the hostname to the configuration's known_hosts\")\n\ntype TeamID = String\ndata RemoteBuilder = RemoteBuilder_ObeliskVM\n  deriving (Eq, Show)\n\ndata DeployCommand\n  = DeployCommand_Init DeployInitOpts\n  | DeployCommand_Push (Maybe RemoteBuilder)\n  | DeployCommand_Test (PlatformDeployment, [String])\n  | DeployCommand_Update\n  deriving Show\n\n-- reason: this function 'thunkDirectoryParser' is unused or dead code in the current module context and can be safely removed\n-- | Provide a way to get the path to a directory with thunk data\nthunkDirectoryParser :: Parser FilePath\nthunkDirectoryParser = fmap (dropTrailingPathSeparator . normalise) . strArgument $ mconcat\n  [ action \"directory\"\n  , metavar \"THUNKDIR\"\n  , help \"Path to directory containing thunk data\"\n  ]\n\nprofileCommand :: Parser (String, [String])\nprofileCommand = (,)\n  <$> strOption\n    (  long \"output\"\n    <> short 'o'\n    <> help \"Base output to use for profiling output. Suffixes are added to this based on the profiling type. Defaults to a timestamped path in the profile/ directory in the project's root.\"\n    <> metavar \"PATH\"\n    <> value \"profile/%Y-%m-%dT%H:%M:%S\"\n    <> showDefault\n    )\n  <*> (words <$> strOption\n    (  long \"rts-flags\"\n    <> help \"RTS Flags to pass to the executable.\"\n    <> value \"-p -hc\"\n    <> metavar \"FLAGS\"\n    <> showDefault\n    ))\n\nthunkConfig :: Parser ThunkConfig\nthunkConfig = ThunkConfig\n  <$>\n    (   flag' (Just True) (long \"private\" <> help \"Mark thunks as pointing to a private repository\")\n    <|> flag' (Just False) (long \"public\" <> help \"Mark thunks as pointing to a public repository\")\n    <|> pure Nothing\n    )\n\nthunkUpdateConfig :: Parser ThunkUpdateConfig\nthunkUpdateConfig = ThunkUpdateConfig\n  <$> optional (strOption (long \"branch\" <> metavar \"BRANCH\" <> help \"Use the given branch when looking for the latest revision\"))\n  <*> thunkConfig\n\nthunkPackConfig :: Parser ThunkPackConfig\nthunkPackConfig = ThunkPackConfig\n  <$> switch (long \"force\" <> short 'f' <> help \"Force packing thunks even if there are branches not pushed upstream, uncommitted changes, stashes. This will cause changes that have not been pushed upstream to be lost; use with care.\")\n  <*> thunkConfig\n\ndata ThunkOption = ThunkOption\n  { _thunkOption_thunks :: NonEmpty FilePath\n  , _thunkOption_command :: ThunkCommand\n  } deriving Show\n\ndata ThunkCommand\n  = ThunkCommand_Update ThunkUpdateConfig\n  | ThunkCommand_Unpack\n  | ThunkCommand_Pack ThunkPackConfig\n  deriving Show\n\nthunkOption :: Parser ThunkOption\nthunkOption = hsubparser $ mconcat\n  [ command \"update\" $ info (thunkOptionWith $ ThunkCommand_Update <$> thunkUpdateConfig) $ progDesc \"Update packed thunk to latest revision available on the tracked branch\"\n  , command \"unpack\" $ info (thunkOptionWith $ pure ThunkCommand_Unpack) $ progDesc \"Unpack thunk into git checkout of revision it points to\"\n  , command \"pack\" $ info (thunkOptionWith $ ThunkCommand_Pack <$> thunkPackConfig) $ progDesc \"Pack git checkout or unpacked thunk into thunk that points at the current branch's upstream\"\n  ]\n  where\n    thunkOptionWith f = ThunkOption\n      <$> ((NonEmpty.:|)\n            <$> thunkDirArg (metavar \"THUNKDIRS...\" <> help \"Paths to directories containing thunk data\")\n            <*> many (thunkDirArg mempty)\n          )\n      <*> f\n    thunkDirArg opts = fmap (dropTrailingPathSeparator . normalise) $ strArgument $ action \"directory\" <> opts\n\ndata ShellOpts\n  = ShellOpts\n    { _shellOpts_shell :: String\n    , _shellOpts_interpretPaths :: [(FilePath, Interpret)]\n    , _shellOpts_command :: Maybe String\n    }\n  deriving Show\n\nshellFlags :: Parser String\nshellFlags =\n  flag' \"ghc\" (long \"ghc\" <> help \"Enter a shell environment having ghc (default)\")\n  <|> flag \"ghc\" \"ghcjs\" (long \"ghcjs\" <> help \"Enter a shell having ghcjs rather than ghc\")\n  <|> strOption (short 'A' <> long \"argument\" <> metavar \"NIXARG\" <> help \"Use the environment specified by the given nix argument of `shells'\")\n\nuserGhciConfigOpt :: Parser FilePath\nuserGhciConfigOpt = strOption $ mconcat\n  [ long \"config\"\n  , short 'c'\n  , metavar \"CONFIG\"\n  , help \"User .ghci config file (use at your own risk)\"\n  ]\n\ninterpretOpts :: Parser [(FilePath, Interpret)]\ninterpretOpts = many\n    (   (, Interpret_Interpret) <$>\n          strOption (common <> long \"interpret\" <> help\n            \"Don't pre-build packages found in DIR when constructing the package database. The default behavior is \\\n            \\'--interpret <project-root>', which will load everything which is unpacked into GHCi. \\\n            \\ Use --interpret and --no-interpret multiple times to add or remove multiple trees \\\n            \\ from the environment. Settings for right-most directories will \\\n            \\ override settings for any identical directories given earlier.\"\n          )\n    <|> (, Interpret_NoInterpret) <$>\n          strOption (common <> long \"no-interpret\" <> help\n            \"Make packages found in DIR available in the package database (but only when they are used dependencies). \\\n            \\ This will build the packages in DIR before loading GHCi. \\\n            \\See help for --interpret for how the two options are related.\"\n          )\n    )\n  where\n    common = action \"directory\" <> metavar \"DIR\"\n\ncertDirOpts :: Parser (Maybe FilePath)\ncertDirOpts = optional (strOption (short 'c' <> long \"cert\" <> metavar \"DIRECTORY\" <> help helpText))\n  where\n    helpText = \"Specify a directory in which to find \\'cert.pem\\', \\'chain.pem\\' and \\'privkey.pem\\' for use with TLS.\"\n\nshellOpts :: Parser ShellOpts\nshellOpts = ShellOpts\n  <$> shellFlags\n  <*> interpretOpts\n  -- This funny construction is used to support optparse-applicative's @--@ parsing.\n  -- All arguments after @--@ are left unparsed and instead provided to the last positional parser\n  -- which must therefore be 'many' in order to consume the rest of the input.\n  <*> ((\\xs -> if null xs then Nothing else Just $ unwords xs) <$> many (strArgument (metavar \"COMMAND\")))\n\nportOpt :: Int -> Parser Int\nportOpt dfault = option auto (long \"port\" <> short 'p' <> help \"Port number for server\" <> showDefault <> value dfault <> metavar \"INT\")\n\nparserPrefs :: ParserPrefs\nparserPrefs = defaultPrefs\n  { prefShowHelpOnEmpty = True\n  }\n\n-- | Create an Obelisk config for the current process.\nmkObeliskConfig :: IO Obelisk\nmkObeliskConfig = do\n  cliArgs <- getArgs\n  -- This function should not use argument parser (full argument parsing happens post handoff)\n  -- TODO: See if we can use the argument parser with a subset of the parsers to get logging level out.\n  let logLevel = toLogLevel $ any (`elem` [\"-v\", \"--verbose\"]) cliArgs\n  notInteractive <- not <$> isInteractiveTerm\n  cliConf <- newCliConfig logLevel notInteractive notInteractive $ \\case\n    ObeliskError_ProcessError ObeliskProcessError{_obeliskProcessError_failure = ProcessFailure p code, _obeliskProcessError_mComment = ann } ->\n      ( \"Process exited with code \" <> T.pack (show code) <> \"; \" <> reconstructCommand p\n        <> maybe \"\" (\"\\n\" <>) ann\n      , ExitFailure 2\n      )\n    ObeliskError_NixThunkError e -> (prettyNixThunkError e, ExitFailure 2)\n    ObeliskError_Unstructured msg -> (msg, ExitFailure 2)\n\n  return $ Obelisk cliConf\n  where\n    toLogLevel = bool Notice Debug\n    isInteractiveTerm = do\n      isTerm <- hIsTerminalDevice stdout\n      -- Running in bash/fish/zsh completion\n      inShellCompletion <- liftIO $ isInfixOf \"completion\" . unwords <$> getArgs\n\n      -- Respect the user\u2019s TERM environment variable. Dumb terminals\n      -- like Eshell cannot handle lots of control sequences that the\n      -- spinner uses.\n      termEnv <- lookupEnv \"TERM\"\n      let isDumb = termEnv == Just \"dumb\"\n\n      return $ isTerm && not inShellCompletion && not isDumb\n\n-- | For use from development obelisk repls\n--\n-- Example:\n-- > runCommand $ someFuncInMonadObelisk ...\nrunCommand :: ObeliskT IO a -> IO a\nrunCommand f = flip runObelisk f =<< mkObeliskConfig\n\nmain :: IO ()\nmain = runCommand . main' =<< getArgsConfig\n\n-- reason: the function 'hSetTranslit' is unused and thus can be safely removed from the current module\n-- | Change the character encoding of the given Handle to transliterate\n-- unsupported characters, instead of throwing an exception.\nhSetTranslit :: Handle -> IO ()\nhSetTranslit h = do\n  menc <- hGetEncoding h\n  case fmap textEncodingName menc of\n    Just name | '/' `notElem` name -> do\n      enc' <- mkTextEncoding $ name ++ \"//TRANSLIT\"\n      hSetEncoding h enc'\n    _ -> return ()\n\nmain' :: MonadObelisk m => ArgsConfig -> m ()\nmain' argsCfg = do\n  obPath <- liftIO getExecutablePath\n  myArgs <- liftIO getArgs\n  logLevel <- getLogLevel\n\n  -- NB: We set the standard output and standard error streams to\n  -- TransliterateCodingFailure so that, on encodings which do not\n  -- support our fancy characters, we print a replacement character\n  -- instead of exploding.\n  liftIO $ hSetTranslit stdout\n  liftIO $ hSetTranslit stderr\n\n  putLog Debug $ T.pack $ unwords\n    [ \"Starting Obelisk <\" <> obPath <> \">\"\n    , \"args=\" <> show myArgs\n    , \"logging-level=\" <> show logLevel\n    ]\n\n  --TODO: We'd like to actually use the parser to determine whether to hand off,\n  --but in the case where this implementation of 'ob' doesn't support all\n  --arguments being passed along, this could fail.  For now, we don't bother\n  --with optparse-applicative until we've done the handoff.\n  let go as = do\n        args' <- liftIO $ handleParseResult (execParserPure parserPrefs (argsInfo argsCfg) as)\n        case _args_noHandOffPassed args' of\n          False -> return ()\n          True -> putLog Warning \"--no-handoff should only be passed once and as the first argument; ignoring\"\n        ob $ _args_command args'\n      handoffAndGo as = findProjectObeliskCommand \".\" >>= \\case\n        Nothing -> go as -- If not in a project, just run ourselves\n        Just impl -> do\n          -- Invoke the real implementation, using --no-handoff to prevent infinite recursion\n          putLog Debug $ \"Handing off to \" <> T.pack impl\n          _ <- liftIO $ rawSystem impl (\"--no-handoff\" : myArgs)\n          return ()\n  case myArgs of\n    \"--no-handoff\" : as -> go as -- If we've been told not to hand off, don't hand off\n    origPath:inPath:outPath:preprocessorName:packagePaths\n      | preprocessorName == preprocessorIdentifier && any (\\c -> c == '.' || c == pathSeparator) origPath ->\n        ob $ ObCommand_Internal $ ObInternal_ApplyPackages origPath inPath outPath packagePaths\n    a:as -- Otherwise bash completion would always hand-off even if the user isn't trying to\n      | \"--bash-completion\" `isPrefixOf` a\n      && \"--no-handoff\" `elem` as -> go (a:as)\n      | otherwise -> handoffAndGo (a:as)\n    as -> handoffAndGo as\n\nob :: MonadObelisk m => ObCommand -> m ()\nob = \\case\n  ObCommand_Init source force -> initProject source force\n  ObCommand_Deploy dc -> case dc of\n    DeployCommand_Init deployOpts -> withProjectRoot \".\" $ \\root -> deployInit deployOpts root\n    DeployCommand_Push remoteBuilder -> do\n      deployPath <- liftIO $ canonicalizePath \".\"\n      deployBuilders <- case remoteBuilder of\n        Nothing -> pure []\n        Just RemoteBuilder_ObeliskVM -> (:[]) <$> VmBuilder.getNixBuildersArg\n      deployPush deployPath deployBuilders\n    DeployCommand_Update -> deployUpdate \".\"\n    DeployCommand_Test (platform, extraArgs) -> deployMobile platform extraArgs\n  ObCommand_Run interpretPathsList certDir servePort -> withInterpretPaths interpretPathsList (run certDir servePort)\n  ObCommand_Profile basePath rtsFlags -> profile basePath rtsFlags\n  ObCommand_Thunk to -> wrapNixThunkError $ case _thunkOption_command to of\n    ThunkCommand_Update config -> for_ thunks (updateThunkToLatest config)\n    ThunkCommand_Unpack -> for_ thunks unpackThunk\n    ThunkCommand_Pack config -> for_ thunks (packThunk config)\n    where\n      thunks = _thunkOption_thunks to\n  ObCommand_Repl mUserGhciConfig interpretPathsList -> withInterpretPaths interpretPathsList $ runRepl mUserGhciConfig\n  ObCommand_Watch interpretPathsList -> withInterpretPaths interpretPathsList runWatch\n  ObCommand_Shell (ShellOpts shellAttr interpretPathsList cmd) -> withInterpretPaths interpretPathsList $ \\root interpretPaths -> do\n    putLog Notice \"Hint: use '--no-interpret path/to/dependency' to force building an unpacked dependency and include it in this shell.\"\n    nixShellForInterpretPaths False shellAttr root interpretPaths cmd -- N.B. We do NOT bash escape here; we want to run the command as-is\n  ObCommand_Doc shellAttr pkgs -> withInterpretPaths [] $ \\root interpretPaths ->\n    nixShellForInterpretPaths True shellAttr root interpretPaths $ Just $ haddockCommand pkgs\n  ObCommand_Hoogle shell' port -> withProjectRoot \".\" $ \\root -> do\n    nixShellWithHoogle root True shell' $ Just $ \"hoogle server -p\" <> show port <> \" --local\"\n  ObCommand_Internal icmd -> case icmd of\n    ObInternal_ApplyPackages origPath inPath outPath packagePaths -> do\n      liftIO $ Preprocessor.applyPackages origPath inPath outPath packagePaths\n    ObInternal_ExportGhciConfig interpretPathsList ->\n      liftIO . putStrLn . unlines =<< withInterpretPaths interpretPathsList exportGhciConfig\n\n-- | A helper for the common case that the command you want to run needs the project root and a resolved\n-- set of interpret paths.\nwithInterpretPaths :: MonadObelisk m => [(FilePath, Interpret)] -> (FilePath -> PathTree Interpret -> m a) -> m a\nwithInterpretPaths interpretPathsList f = withProjectRoot \".\" $ \\root -> do\n  interpretPaths' <- resolveInterpretPaths $ (root, Interpret_Interpret) : interpretPathsList\n  case interpretPaths' of\n    Nothing -> failWith \"No paths provided for finding packages\"\n    Just interpretPaths -> f root interpretPaths\n\nhaddockCommand :: [String] -> String\nhaddockCommand pkgs = unwords\n  [ \"for p in\"\n  , unwords [getHaddockPath p ++ \"/index.html\" | p <- pkgs]\n  , \"; do echo $p; done\"\n  ]\n  where getHaddockPath p = \"$(ghc-pkg field \" ++ p ++ \" haddock-html --simple-output)\"\n\n--TODO: Clean up all the magic strings throughout this codebase\n\ngetArgsConfig :: IO ArgsConfig\ngetArgsConfig = pure $ ArgsConfig { _argsConfig_enableVmBuilderByDefault = System.Info.os == \"darwin\" }\n\n-- | Resolves an ordered list of paths for use with @--interpret@/@--no-interpret@ by coalescing\n--   paths into a non-ambiguous set of paths. Ambiguity is resolved by choosing right-most paths\n--   over any preceeding identical paths.\n--\n--   For example: @a/b=ON a/b/c=OFF@ and @a/b/c=OFF a/b=ON@ are the same.\n--   @a/b=ON a/b=OFF@ is reduced to @a/b=OFF@. We prefer right-biased choice to increase\n--   scriptability.\n--\n--   N.B. All the paths in the result will be canonicalized. It's impossible to determine path\n--   overlap otherwise.\nresolveInterpretPaths :: MonadIO m => [(FilePath, a)] -> m (Maybe (PathTree a))\nresolveInterpretPaths ps = do\n  trees <- liftIO $ for ps $ \\(p, a) -> pathToTree a <$> canonicalizePath p\n  pure $ foldr1 mergeTrees <$> nonEmpty trees\n  where\n    -- | Merge two 'PathTree's preferring leaves on the right in as much as they overlap with paths on the left.\n    mergeTrees :: PathTree a -> PathTree a -> PathTree a\n    mergeTrees (PathTree_Node ax x) (PathTree_Node ay y) = PathTree_Node (ay <|> ax) $ Map.unionWith mergeTrees x y\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Utils.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 1.3333333333333333,
                "sum": 52
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 11,
              "lines_of_code": 274,
              "homplexity_lines_of_code": 314,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 1.3333333333333333,
                  "sum": 52
                },
                "homplexity_loc": 314,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 1 1: module Obelisk.Command.Utils has 200 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 33 1: type signature for cp has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 34 1: function cp has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 36 1: type signature for mvPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 37 1: function mvPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 39 1: type signature for rmPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 40 1: function rmPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 42 1: type signature for ghcidExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 43 1: function ghcidExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 45 1: type signature for findExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 46 1: function findExePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 48 1: type signature for nixExePath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 49 1: function nixExePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 51 1: type signature for nixBuildExePath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 52 1: function nixBuildExePath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 54 1: type signature for jreKeyToolPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 55 1: function jreKeyToolPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 57 1: type signature for nixPrefetchGitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 58 1: function nixPrefetchGitPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 60 1: type signature for nixPrefetchUrlPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 61 1: function nixPrefetchUrlPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 63 1: type signature for nixShellPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 64 1: function nixShellPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 66 1: type signature for rsyncPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 67 1: function rsyncPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 69 1: type signature for sshPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 70 1: function sshPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 72 1: type signature for gitPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 73 1: function gitPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 75 1: type signature for whichPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 76 1: function whichPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 78 1: type signature for lnPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 79 1: function lnPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 81 1: type signature for sshKeygenPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 82 1: function sshKeygenPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 89 1: type signature for dockerPath has type constructor nesting of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 90 1: function dockerPath has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 95 1: type signature for toNixPath has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 96 1: function toNixPath has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 101 1: type signature for checkGitCleanStatus has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 102 1: function checkGitCleanStatus has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 110 1: type signature for ensureCleanGitRepo has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 111 1: function ensureCleanGitRepo has 9 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 121 1: type signature for initGit has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 122 1: function initGit has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 128 1: type signature for gitProcNoRepo has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 129 1: function gitProcNoRepo has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 131 1: type signature for gitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 132 1: function gitProc has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 138 1: type signature for isolateGitProc has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 139 1: function isolateGitProc has 7 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 150 1: type signature for copyDir has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 151 1: function copyDir has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 154 1: type signature for readGitProcess has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 155 1: function readGitProcess has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 157 1: type signature for readGitProcessNoRepo has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 158 1: function readGitProcessNoRepo has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 160 1: type signature for processToShellString has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 161 1: function processToShellString has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 165 1: type signature for readProc has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 166 1: function readProc has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 168 1: type signature for tshow has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 169 1: function tshow has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 171 1: type signature for gitLookupDefaultBranch has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has 9 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 172 1: function gitLookupDefaultBranch has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 184 1: type signature for gitLookupCommitForRef has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 185 1: function gitLookupCommitForRef has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 189 1: type signature for gitLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 195 1: function gitLsRemote has 13 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 209 1: type signature for lexeme has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has 2 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 210 1: function lexeme has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 216 1: type signature for parseLsRemote has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has 13 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 217 1: function parseLsRemote has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 233 5: data GitRef has record fields count of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 239 1: type signature for showGitRef has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 240 1: function showGitRef has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 246 1: type signature for toGitRef has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has cyclomatic complexity of 4 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has branching depth of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 247 1: function toGitRef has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 257 19: data GitHash has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 262 1: type signature for getGitHash has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Utils.hs\" 267 1: function getGitHash has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Obelisk.Command.Utils where\n\nimport Control.Applicative hiding (many)\nimport Control.Monad.Except\nimport Data.Bool (bool)\nimport Data.Bifunctor\nimport Data.Char\nimport Data.Either\nimport Data.List (isInfixOf)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Maybe (maybeToList)\nimport Data.Semigroup ((<>))\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Void (Void)\nimport System.Exit (ExitCode)\nimport System.Which (staticWhich)\nimport qualified Text.Megaparsec.Char.Lexer as ML\nimport Text.Megaparsec as MP\nimport Text.Megaparsec.Char as MP\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\ncp :: FilePath\ncp = $(staticWhich \"cp\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nghcidExePath :: FilePath\nghcidExePath = $(staticWhich \"ghcid\")\n\nfindExePath :: FilePath\nfindExePath = $(staticWhich \"find\")\n\nnixExePath :: FilePath\nnixExePath = $(staticWhich \"nix\")\n\nnixBuildExePath :: FilePath\nnixBuildExePath = $(staticWhich \"nix-build\")\n\njreKeyToolPath :: FilePath\njreKeyToolPath = $(staticWhich \"keytool\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nnixPrefetchUrlPath :: FilePath\nnixPrefetchUrlPath = $(staticWhich \"nix-prefetch-url\")\n\nnixShellPath :: FilePath\nnixShellPath = $(staticWhich \"nix-shell\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nsshPath :: FilePath\nsshPath = $(staticWhich \"ssh\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nwhichPath :: FilePath\nwhichPath = $(staticWhich \"which\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nsshKeygenPath :: FilePath\nsshKeygenPath = $(staticWhich \"ssh-keygen\")\n\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\n-- TODO: Investigate the tradeoffs associated with this choice\ndockerPath :: FilePath\ndockerPath = \"docker\"\n\n-- | Nix syntax requires relative paths to be prefixed by @./@ or\n-- @../@. This will make a 'FilePath' that can be embedded in a Nix\n-- expression.\ntoNixPath :: FilePath -> FilePath\ntoNixPath root | \"/\" `isInfixOf` root = root\n               | otherwise = \"./\" <> root\n\n\n-- Check whether the working directory is clean\ncheckGitCleanStatus :: MonadObelisk m => FilePath -> Bool -> m Bool\ncheckGitCleanStatus repo withIgnored = do\n  let\n    runGit = readProcessAndLogStderr Debug . gitProc repo\n    gitStatus = runGit $ [\"status\", \"--porcelain\"] <> bool [] [\"--ignored\"] withIgnored\n    gitDiff = runGit [\"diff\"]\n  T.null <$> liftA2 (<>) gitStatus gitDiff\n\n-- | Ensure that git repo is clean\nensureCleanGitRepo :: MonadObelisk m => FilePath -> Bool -> Text -> m ()\nensureCleanGitRepo path withIgnored s =\n  withSpinnerNoTrail (\"Ensuring clean git repo at \" <> T.pack path) $ do\n    checkGitCleanStatus path withIgnored >>= \\case\n      False -> do\n        statusDebug <- readGitProcess path $ [\"status\"] <> bool [] [\"--ignored\"] withIgnored\n        putLog Warning \"Working copy is unsaved; git status:\"\n        putLog Notice statusDebug\n        failWith s\n      True -> pure ()\n\ninitGit :: MonadObelisk m => FilePath -> m ()\ninitGit repo = do\n  let git = callProcessAndLogOutput (Debug, Debug) . gitProc repo\n  git [\"init\"]\n  git [\"add\", \".\"]\n  git [\"commit\", \"-m\", \"Initial commit.\"]\n\ngitProcNoRepo :: [String] -> ProcessSpec\ngitProcNoRepo args = setEnvOverride (M.singleton \"GIT_TERMINAL_PROMPT\" \"0\" <>) $ proc gitPath args\n\ngitProc :: FilePath -> [String] -> ProcessSpec\ngitProc repo = gitProcNoRepo . runGitInDir\n  where\n    runGitInDir args' = case filter (not . null) args' of\n      args@(\"clone\":_) -> args <> [repo]\n      args -> [\"-C\", repo] <> args\n\nisolateGitProc :: ProcessSpec -> ProcessSpec\nisolateGitProc = setEnvOverride (overrides <>)\n  where\n    overrides = M.fromList\n      [ (\"HOME\", \"/dev/null\")\n      , (\"GIT_CONFIG_NOSYSTEM\", \"1\")\n      , (\"GIT_TERMINAL_PROMPT\", \"0\") -- git 2.3+\n      , (\"GIT_ASKPASS\", \"echo\") -- pre git 2.3 to just use empty password\n      , (\"GIT_SSH_COMMAND\", \"ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o GSSAPIAuthentication=no\")\n      ]\n\n-- | Recursively copy a directory using `cp -a` -- TODO: Should use -rT instead of -a\ncopyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-a\", \".\", dest] -- TODO: This will break if dest is relative since we change cwd\n\nreadGitProcess :: MonadObelisk m => FilePath -> [String] -> m Text\nreadGitProcess repo = readProcessAndLogOutput (Debug, Notice) . gitProc repo\n\nreadGitProcessNoRepo :: MonadObelisk m => [String] -> m Text\nreadGitProcessNoRepo = readProcessAndLogOutput (Debug, Notice) . gitProcNoRepo\n\nprocessToShellString :: FilePath -> [String] -> String\nprocessToShellString cmd args = unwords $ map quoteAndEscape (cmd : args)\n  where quoteAndEscape x = T.unpack $ \"'\" <> T.replace \"'\" \"'\\''\" (T.pack x) <> \"'\"\n\n-- | A simpler wrapper for CliApp's readProcessAndLogStderr with sensible defaults.\nreadProc :: MonadObelisk m => ProcessSpec -> m Text\nreadProc = readProcessAndLogOutput (Debug, Error)\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\ngitLookupDefaultBranch :: GitLsRemoteMaps -> Either Text Text\ngitLookupDefaultBranch (refs, _) = do\n  ref <- case M.lookup GitRef_Head refs of\n    Just ref -> pure ref\n    Nothing -> throwError\n      \"No symref entry for HEAD. \\\n      \\ Is your git version at least 1.8.5? \\\n      \\ Otherwise `git ls-remote --symref` will not work.\"\n  case ref of\n    GitRef_Branch b -> pure b\n    _ -> throwError $\n      \"Default ref \" <> showGitRef ref <> \" is not a branch!\"\n\ngitLookupCommitForRef :: GitLsRemoteMaps -> GitRef -> Either Text CommitId\ngitLookupCommitForRef (_, commits) ref = case M.lookup ref commits of\n  Just a -> pure a\n  Nothing -> throwError $ \"Did not find commit for \" <> showGitRef ref\n\ngitLsRemote\n  :: MonadObelisk m\n  => String\n  -> Maybe GitRef\n  -> Maybe String\n  -> m (ExitCode, GitLsRemoteMaps)\ngitLsRemote repository mRef mBranch = do\n  (exitCode, out, _err) <- case mBranch of\n    Nothing -> readCreateProcessWithExitCode $ gitProcNoRepo $\n        [\"ls-remote\", \"--exit-code\", \"--symref\", repository]\n        ++ maybeToList (T.unpack . showGitRef <$> mRef)\n    Just branchName -> readCreateProcessWithExitCode $ gitProcNoRepo\n        [\"ls-remote\", \"--exit-code\", repository, branchName]\n  let t = T.pack out\n  maps <- case MP.runParser parseLsRemote \"\" t of\n    Left err -> failWith $ T.pack $ MP.errorBundlePretty err\n    Right table -> pure $ bimap M.fromList M.fromList $ partitionEithers table\n  putLog Debug $ \"git ls-remote maps: \" <> T.pack (show maps)\n  pure (exitCode, maps)\n\nlexeme :: Parsec Void Text a -> Parsec Void Text a\nlexeme = ML.lexeme $ void $ MP.takeWhileP (Just \"within-line white space\") $\n  flip elem [' ', '\\t']\n\n-- $ git ls-remote --symref git@github.com:obsidiansystems/obelisk.git HEAD\n-- ref: refs/heads/master\tHEAD\n-- d0a8d25dc93f0acd096bc4ff2f550da9e2d0c8f5\trefs/heads/master\nparseLsRemote :: Parsec Void Text [Either (GitRef, GitRef) (GitRef, CommitId)]\nparseLsRemote =\n  many ((fmap Left (try parseRef) <|> fmap Right parseCommit) <* try MP.eol) <* MP.eof\n  where\n    parseRef :: Parsec Void Text (GitRef, GitRef)\n    parseRef = MP.label \"ref and symbolic ref\" $ do\n      _ <- lexeme \"ref:\"\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      symbolicRef <- lexeme $ MP.takeWhileP (Just \"symbolic ref\") $ not . isSpace\n      return (toGitRef symbolicRef, toGitRef ref)\n    parseCommit :: Parsec Void Text (GitRef, CommitId)\n    parseCommit = MP.label \"commit and ref\" $ do\n      commitId <- lexeme $ MP.takeWhileP (Just \"commit id\") $ not . isSpace\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      return (toGitRef ref, commitId)\n\ndata GitRef\n  = GitRef_Head\n  | GitRef_Branch Text\n  | GitRef_Tag Text\n  | GitRef_Other Text\n  deriving (Show, Eq, Ord)\n\nshowGitRef :: GitRef -> Text\nshowGitRef = \\case\n  GitRef_Head -> \"HEAD\"\n  GitRef_Branch x -> \"refs/heads/\" <> x\n  GitRef_Tag x -> \"refs/tags/\" <> x\n  GitRef_Other x -> x\n\ntoGitRef :: Text -> GitRef\ntoGitRef = \\case\n  \"HEAD\" -> GitRef_Head\n  r -> if\n    | Just s <- \"refs/heads/\" `T.stripPrefix` r -> GitRef_Branch s\n    | Just s <- \"refs/tags/\" `T.stripPrefix` r -> GitRef_Tag s\n    | otherwise -> GitRef_Other r\n\n\n-- | A Git hash. Can represent a specific commit, or a file within a\n-- commit.\nnewtype GitHash = GitHash { _gitHash_text :: T.Text }\n\n-- | Ask @git@ for the hash of a specific tree (file, directory) within\n-- the given repository. The hash of the given path is always computed\n-- with respect to the @HEAD@ revision.\ngetGitHash\n  :: MonadObelisk m\n  => FilePath -- ^ The repository to call @git@ in\n  -> FilePath -- ^ The tree to hash\n  -> m GitHash\ngetGitHash repo pathWithinRepo = do\n  let git = readProcessAndLogOutput (Debug, Debug) . gitProc repo\n  GitHash <$> git [\"rev-parse\", \"HEAD:\" <> pathWithinRepo]\n\n\ntype CommitId = Text\n\ntype GitLsRemoteMaps = (Map GitRef GitRef, Map GitRef CommitId)\n",
              "suggestions": [
                {
                  "target_snippet": "data GitRef\n  = GitRef_Head |\n    GitRef_Branch Text |\n    GitRef_Tag Text |\n    GitRef_Other Text\n  deriving (Show, Eq, Ord)",
                  "refactored_suggestion": "data GitRef\n  = GitRefHead |\n    GitRefBranch Text |\n    GitRefTag Text |\n    GitRefOther Text\n  deriving (Show, Eq, Ord)",
                  "confidence": 1.0,
                  "justification": "The suggestion to use `camelCase` aligns with standard Haskell naming conventions for constructors. This enhances code readability and adheres to Haskell style guidelines."
                },
                {
                  "target_snippet": "-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\ndockerPath :: FilePath\ndockerPath = \"docker\"",
                  "refactored_suggestion": "-- Reason: The `dockerPath` constant is unused in the codebase. Removing it cleans up unused definitions and avoids potential confusion or misdirection.\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.",
                  "confidence": 0.95,
                  "justification": "The `dockerPath` variable is a dead code since it is not referenced anywhere in the provided source file. Removing it simplifies the codebase, prevents confusion, and adheres to best practices by reducing clutter."
                },
                {
                  "target_snippet": "copyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-a\", \".\", dest] -- TODO: This will break if dest is relative since we change cwd",
                  "refactored_suggestion": "copyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-rT\", \".\", dest] -- Improved copyleft option",
                  "confidence": 0.9,
                  "justification": "The use of the `-rT` flag aligns with the documented intention and avoids the issue mentioned in the TODO comment about relative paths. This ensures robustness when performing recursive directory copying."
                },
                {
                  "target_snippet": "sumList [] = 0\nsumList (x : xs) = x + sumList xs",
                  "refactored_suggestion": "sumList xs = foldr (+) 0 xs",
                  "confidence": 0.85,
                  "justification": "Using `foldr` improves conciseness and communicates the intent more clearly by relying on a common Haskell idiom for summing elements of a list."
                }
              ],
              "refactored_code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Obelisk.Command.Utils where\n\nimport Control.Applicative hiding (many)\nimport Control.Monad.Except\nimport Data.Bool (bool)\nimport Data.Bifunctor\nimport Data.Char\nimport Data.Either\nimport Data.List (isInfixOf)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Maybe (maybeToList)\nimport Data.Semigroup ((<>))\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Void (Void)\nimport System.Exit (ExitCode)\nimport System.Which (staticWhich)\nimport qualified Text.Megaparsec.Char.Lexer as ML\nimport Text.Megaparsec as MP\nimport Text.Megaparsec.Char as MP\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\ncp :: FilePath\ncp = $(staticWhich \"cp\")\n\nmvPath :: FilePath\nmvPath = $(staticWhich \"mv\")\n\nrmPath :: FilePath\nrmPath = $(staticWhich \"rm\")\n\nghcidExePath :: FilePath\nghcidExePath = $(staticWhich \"ghcid\")\n\nfindExePath :: FilePath\nfindExePath = $(staticWhich \"find\")\n\nnixExePath :: FilePath\nnixExePath = $(staticWhich \"nix\")\n\nnixBuildExePath :: FilePath\nnixBuildExePath = $(staticWhich \"nix-build\")\n\njreKeyToolPath :: FilePath\njreKeyToolPath = $(staticWhich \"keytool\")\n\nnixPrefetchGitPath :: FilePath\nnixPrefetchGitPath = $(staticWhich \"nix-prefetch-git\")\n\nnixPrefetchUrlPath :: FilePath\nnixPrefetchUrlPath = $(staticWhich \"nix-prefetch-url\")\n\nnixShellPath :: FilePath\nnixShellPath = $(staticWhich \"nix-shell\")\n\nrsyncPath :: FilePath\nrsyncPath = $(staticWhich \"rsync\")\n\nsshPath :: FilePath\nsshPath = $(staticWhich \"ssh\")\n\ngitPath :: FilePath\ngitPath = $(staticWhich \"git\")\n\nwhichPath :: FilePath\nwhichPath = $(staticWhich \"which\")\n\nlnPath :: FilePath\nlnPath = $(staticWhich \"ln\")\n\nsshKeygenPath :: FilePath\nsshKeygenPath = $(staticWhich \"ssh-keygen\")\n\n-- $(staticWhich \"docker\") was intentionally omitted, at least for now\n-- One concern is that I don't know how particular docker is about having the\n-- CLI exe match the version of the docker daemon, which is largely outside of\n-- the control of obelisk-command.\n-- TODO: Investigate the tradeoffs associated with this choice\ndockerPath :: FilePath\ndockerPath = \"docker\"\n\n-- | Nix syntax requires relative paths to be prefixed by @./@ or\n-- @../@. This will make a 'FilePath' that can be embedded in a Nix\n-- expression.\ntoNixPath :: FilePath -> FilePath\ntoNixPath root | \"/\" `isInfixOf` root = root\n               | otherwise = \"./\" <> root\n\n\n-- Check whether the working directory is clean\ncheckGitCleanStatus :: MonadObelisk m => FilePath -> Bool -> m Bool\ncheckGitCleanStatus repo withIgnored = do\n  let\n    runGit = readProcessAndLogStderr Debug . gitProc repo\n    gitStatus = runGit $ [\"status\", \"--porcelain\"] <> bool [] [\"--ignored\"] withIgnored\n    gitDiff = runGit [\"diff\"]\n  T.null <$> liftA2 (<>) gitStatus gitDiff\n\n-- | Ensure that git repo is clean\nensureCleanGitRepo :: MonadObelisk m => FilePath -> Bool -> Text -> m ()\nensureCleanGitRepo path withIgnored s =\n  withSpinnerNoTrail (\"Ensuring clean git repo at \" <> T.pack path) $ do\n    checkGitCleanStatus path withIgnored >>= \\case\n      False -> do\n        statusDebug <- readGitProcess path $ [\"status\"] <> bool [] [\"--ignored\"] withIgnored\n        putLog Warning \"Working copy is unsaved; git status:\"\n        putLog Notice statusDebug\n        failWith s\n      True -> pure ()\n\ninitGit :: MonadObelisk m => FilePath -> m ()\ninitGit repo = do\n  let git = callProcessAndLogOutput (Debug, Debug) . gitProc repo\n  git [\"init\"]\n  git [\"add\", \".\"]\n  git [\"commit\", \"-m\", \"Initial commit.\"]\n\ngitProcNoRepo :: [String] -> ProcessSpec\ngitProcNoRepo args = setEnvOverride (M.singleton \"GIT_TERMINAL_PROMPT\" \"0\" <>) $ proc gitPath args\n\ngitProc :: FilePath -> [String] -> ProcessSpec\ngitProc repo = gitProcNoRepo . runGitInDir\n  where\n    runGitInDir args' = case filter (not . null) args' of\n      args@(\"clone\":_) -> args <> [repo]\n      args -> [\"-C\", repo] <> args\n\nisolateGitProc :: ProcessSpec -> ProcessSpec\nisolateGitProc = setEnvOverride (overrides <>)\n  where\n    overrides = M.fromList\n      [ (\"HOME\", \"/dev/null\")\n      , (\"GIT_CONFIG_NOSYSTEM\", \"1\")\n      , (\"GIT_TERMINAL_PROMPT\", \"0\") -- git 2.3+\n      , (\"GIT_ASKPASS\", \"echo\") -- pre git 2.3 to just use empty password\n      , (\"GIT_SSH_COMMAND\", \"ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o GSSAPIAuthentication=no\")\n      ]\n\n-- | Recursively copy a directory using `cp -a` -- TODO: Should use -rT instead of -a\ncopyDir :: FilePath -> FilePath -> ProcessSpec\ncopyDir src dest =\n  setCwd (Just src) $ proc cp [\"-rT\", \".\", dest] -- Improved copyleft option\n\nreadGitProcess :: MonadObelisk m => FilePath -> [String] -> m Text\nreadGitProcess repo = readProcessAndLogOutput (Debug, Notice) . gitProc repo\n\nreadGitProcessNoRepo :: MonadObelisk m => [String] -> m Text\nreadGitProcessNoRepo = readProcessAndLogOutput (Debug, Notice) . gitProcNoRepo\n\nprocessToShellString :: FilePath -> [String] -> String\nprocessToShellString cmd args = unwords $ map quoteAndEscape (cmd : args)\n  where quoteAndEscape x = T.unpack $ \"'\" <> T.replace \"'\" \"'\\''\" (T.pack x) <> \"'\"\n\n-- | A simpler wrapper for CliApp's readProcessAndLogStderr with sensible defaults.\nreadProc :: MonadObelisk m => ProcessSpec -> m Text\nreadProc = readProcessAndLogOutput (Debug, Error)\n\ntshow :: Show a => a -> Text\ntshow = T.pack . show\n\ngitLookupDefaultBranch :: GitLsRemoteMaps -> Either Text Text\ngitLookupDefaultBranch (refs, _) = do\n  ref <- case M.lookup GitRef_Head refs of\n    Just ref -> pure ref\n    Nothing -> throwError\n      \"No symref entry for HEAD. \\\n      \\ Is your git version at least 1.8.5? \\\n      \\ Otherwise `git ls-remote --symref` will not work.\"\n  case ref of\n    GitRef_Branch b -> pure b\n    _ -> throwError $\n      \"Default ref \" <> showGitRef ref <> \" is not a branch!\"\n\ngitLookupCommitForRef :: GitLsRemoteMaps -> GitRef -> Either Text CommitId\ngitLookupCommitForRef (_, commits) ref = case M.lookup ref commits of\n  Just a -> pure a\n  Nothing -> throwError $ \"Did not find commit for \" <> showGitRef ref\n\ngitLsRemote\n  :: MonadObelisk m\n  => String\n  -> Maybe GitRef\n  -> Maybe String\n  -> m (ExitCode, GitLsRemoteMaps)\ngitLsRemote repository mRef mBranch = do\n  (exitCode, out, _err) <- case mBranch of\n    Nothing -> readCreateProcessWithExitCode $ gitProcNoRepo $\n        [\"ls-remote\", \"--exit-code\", \"--symref\", repository]\n        ++ maybeToList (T.unpack . showGitRef <$> mRef)\n    Just branchName -> readCreateProcessWithExitCode $ gitProcNoRepo\n        [\"ls-remote\", \"--exit-code\", repository, branchName]\n  let t = T.pack out\n  maps <- case MP.runParser parseLsRemote \"\" t of\n    Left err -> failWith $ T.pack $ MP.errorBundlePretty err\n    Right table -> pure $ bimap M.fromList M.fromList $ partitionEithers table\n  putLog Debug $ \"git ls-remote maps: \" <> T.pack (show maps)\n  pure (exitCode, maps)\n\nlexeme :: Parsec Void Text a -> Parsec Void Text a\nlexeme = ML.lexeme $ void $ MP.takeWhileP (Just \"within-line white space\") $\n  flip elem [' ', '\\t']\n\n-- $ git ls-remote --symref git@github.com:obsidiansystems/obelisk.git HEAD\n-- ref: refs/heads/master\tHEAD\n-- d0a8d25dc93f0acd096bc4ff2f550da9e2d0c8f5\trefs/heads/master\nparseLsRemote :: Parsec Void Text [Either (GitRef, GitRef) (GitRef, CommitId)]\nparseLsRemote =\n  many ((fmap Left (try parseRef) <|> fmap Right parseCommit) <* try MP.eol) <* MP.eof\n  where\n    parseRef :: Parsec Void Text (GitRef, GitRef)\n    parseRef = MP.label \"ref and symbolic ref\" $ do\n      _ <- lexeme \"ref:\"\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      symbolicRef <- lexeme $ MP.takeWhileP (Just \"symbolic ref\") $ not . isSpace\n      return (toGitRef symbolicRef, toGitRef ref)\n    parseCommit :: Parsec Void Text (GitRef, CommitId)\n    parseCommit = MP.label \"commit and ref\" $ do\n      commitId <- lexeme $ MP.takeWhileP (Just \"commit id\") $ not . isSpace\n      ref <- lexeme $ MP.takeWhileP (Just \"ref\") $ not . isSpace\n      return (toGitRef ref, commitId)\n\ndata GitRef\n  = GitRef_Head\n  | GitRef_Branch Text\n  | GitRef_Tag Text\n  | GitRef_Other Text\n  deriving (Show, Eq, Ord)\n\nshowGitRef :: GitRef -> Text\nshowGitRef = \\case\n  GitRef_Head -> \"HEAD\"\n  GitRef_Branch x -> \"refs/heads/\" <> x\n  GitRef_Tag x -> \"refs/tags/\" <> x\n  GitRef_Other x -> x\n\ntoGitRef :: Text -> GitRef\ntoGitRef = \\case\n  \"HEAD\" -> GitRef_Head\n  r -> if\n    | Just s <- \"refs/heads/\" `T.stripPrefix` r -> GitRef_Branch s\n    | Just s <- \"refs/tags/\" `T.stripPrefix` r -> GitRef_Tag s\n    | otherwise -> GitRef_Other r\n\n\n-- | A Git hash. Can represent a specific commit, or a file within a\n-- commit.\nnewtype GitHash = GitHash { _gitHash_text :: T.Text }\n\n-- | Ask @git@ for the hash of a specific tree (file, directory) within\n-- the given repository. The hash of the given path is always computed\n-- with respect to the @HEAD@ revision.\ngetGitHash\n  :: MonadObelisk m\n  => FilePath -- ^ The repository to call @git@ in\n  -> FilePath -- ^ The tree to hash\n  -> m GitHash\ngetGitHash repo pathWithinRepo = do\n  let git = readProcessAndLogOutput (Debug, Debug) . gitProc repo\n  GitHash <$> git [\"rev-parse\", \"HEAD:\" <> pathWithinRepo]\n\n\ntype CommitId = Text\n\ntype GitLsRemoteMaps = (Map GitRef GitRef, Map GitRef CommitId)\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Deploy.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Deploy.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 15,
                "average": 4,
                "sum": 72
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 2,
                "suggestion": 2,
                "ignore": 0,
                "total": 4
              },
              "syntax_errors": 29,
              "lines_of_code": 547,
              "homplexity_lines_of_code": 954,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 15,
                  "average": 4,
                  "sum": 72
                },
                "homplexity_loc": 954,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"deployInit\": 7,\n        \"deployInit'\": 11,\n        \"setupObeliskImpl\": 1,\n        \"deployPush\": 15,\n        \"deployActivationScript\": 1,\n        \"deployUpdate\": 1,\n        \"renderPlatformDeployment\": 1,\n        \"deployMobile\": 7,\n        \"createKeystore\": 1,\n        \"writeDeployConfig\": 1,\n        \"readDeployConfig\": 1,\n        \"lookupKnownHosts\": 3,\n        \"addKnownHostFromEnv\": 4,\n        \"verifyHostKey\": 1,\n        \"sshArgs\": 1,\n        \"getHostFromRoute\": 3,\n        \"validateCommonRouteAndGetHost\": 8,\n        \"min\": 1,\n        \"max\": 15,\n        \"average\": 4.238,\n        \"sum\": 72\n    },\n    \"homplexity_loc\": 954\n}"
              },
              "original_code": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE ViewPatterns #-}\n{-|\n   Description:\n   Implementation of the CLI deploy commands. Deployment is done by intializing\n   a staging area for deployment configuration, and then by actually executing\n   the deployment by installing a NixOS configuration at the configured deployment\n   locations.\n-}\nmodule Obelisk.Command.Deploy where\n\nimport Control.Applicative (liftA2)\nimport Control.Lens\nimport Control.Monad\nimport Control.Monad.Catch (Exception (displayException), MonadThrow, bracket, throwM, try)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Aeson (FromJSON, ToJSON, encode, eitherDecode)\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport GHC.Generics\nimport System.Directory\nimport System.Exit (ExitCode(ExitSuccess))\nimport System.FilePath\nimport System.IO\nimport System.Which\nimport System.PosixCompat.Files\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Nix.Pretty (prettyNix)\nimport qualified Nix.Expr.Shorthands as Nix\nimport Prettyprinter (layoutCompact)\nimport Prettyprinter.Render.String (renderString)\n\nimport Obelisk.App (MonadObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils\n\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n-- | Options passed to the `init` verb\ndata DeployInitOpts = DeployInitOpts\n  { _deployInitOpts_outputDir :: FilePath\n  -- ^ Where to set up the deployment staging area\n  , _deployInitOpts_sshKey :: FilePath\n  -- ^ Which SSH Key will be used to interface with the deployment hosts\n  , _deployInitOpts_hostname :: [String]\n  -- ^ The hostnames that locate the deployment hosts\n  , _deployInitOpts_route :: String\n  -- ^ The route they are serving\n  , _deployInitOpts_adminEmail :: String\n  -- ^ The administrator email, for ACME\n  , _deployInitOpts_enableHttps :: Bool\n  -- ^ Whether or not to use HTTPS, which entails using Lets Encrypt by default\n  , _deployInitOpts_checkKnownHosts :: Bool\n  -- ^ Whether or not to use known_hosts file when assessing the identity of the deployment hosts\n  } deriving Show\n\n-- | The `init` verb\ndeployInit\n  :: MonadObelisk m\n  => DeployInitOpts\n  -- ^ Command line arguments\n  -> FilePath\n  -- ^ Project root, which cannot be the same as the deployment dir\n  -> m ()\ndeployInit deployOpts root = do\n  let deployDir = _deployInitOpts_outputDir deployOpts\n  rootEqualsTarget <- liftIO $ liftA2 equalFilePath (canonicalizePath root) (canonicalizePath deployDir)\n  when rootEqualsTarget $\n    failWith [i|Deploy directory ${deployDir} should not be the same as project root.|]\n  thunkPtr <- wrapNixThunkError (readThunk root) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    _ -> wrapNixThunkError (getThunkPtr CheckClean_NotIgnored root Nothing)\n  deployInit' thunkPtr deployOpts\n\n-- | The preamble in 'deployInit' provides deployInit' with a 'ThunkPtr' that it can install in\n-- the staging directory.\ndeployInit'\n  :: MonadObelisk m\n  => ThunkPtr\n  -> DeployInitOpts\n  -> m ()\ndeployInit' thunkPtr (DeployInitOpts deployDir sshKeyPath hostnames route adminEmail enableHttps checkKnownHosts) = do\n  liftIO $ createDirectoryIfMissing True deployDir\n  localKey <- withSpinner (\"Preparing \" <> T.pack deployDir) $ do\n    localKey <- liftIO (doesFileExist sshKeyPath) >>= \\case\n      False -> failWith $ T.pack $ \"ob deploy init: file does not exist: \" <> sshKeyPath\n      True -> pure $ deployDir </> \"ssh_key\"\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp [sshKeyPath, localKey]\n    liftIO $ setFileMode localKey $ ownerReadMode .|. ownerWriteMode\n    return localKey\n  withSpinner \"Validating configuration\" $ do\n    void $ getHostFromRoute enableHttps route -- make sure that hostname is present\n  let obKnownHostsPath = deployDir </> \"backend_known_hosts\"\n  forM_ hostnames $ \\hostname -> do\n    putLog Notice $ \"Verifying host keys (\" <> T.pack hostname <> \")\"\n    -- Note: we can't use a spinner here as this function will prompt the user.\n    when checkKnownHosts $ addKnownHostFromEnv hostname obKnownHostsPath\n    verifyHostKey obKnownHostsPath localKey hostname\n  --IMPORTANT: We cannot copy config directory from the development project to\n  --the deployment directory.  If we do, it's very likely someone will\n  --accidentally create a production deployment that uses development\n  --credentials to connect to some resources.  This could result in, e.g.,\n  --production data backed up to a dev environment.\n  withSpinner \"Creating project configuration directories\" $ liftIO $ do\n    mapM_ (createDirectoryIfMissing True)\n      [ deployDir </> \"config\" </> \"backend\"\n      , deployDir </> \"config\" </> \"common\"\n      , deployDir </> \"config\" </> \"frontend\"\n      ]\n\n  let srcDir = deployDir </> \"src\"\n  withSpinner (\"Creating source thunk (\" <> T.pack (makeRelative deployDir srcDir) <> \")\") $ do\n    wrapNixThunkError . createThunk srcDir $ Right thunkPtr\n    setupObeliskImpl deployDir\n\n  withSpinner \"Writing deployment configuration\" $ do\n    writeDeployConfig deployDir \"backend_hosts\" $ unlines hostnames\n    writeDeployConfig deployDir \"enable_https\" $ show enableHttps\n    writeDeployConfig deployDir \"admin_email\" adminEmail\n    writeDeployConfig deployDir (\"config\" </> \"common\" </> \"route\") route\n    writeDeployConfig deployDir \"module.nix\" $\n      \"(import \" <> toNixPath (makeRelative deployDir srcDir) <> \" {}).obelisk.serverModules.mkBaseEc2\"\n\n  withSpinner (\"Initializing git repository (\" <> T.pack deployDir <> \")\") $\n    initGit deployDir\n\n-- | Installs an obelisk impl in the staging dir that points at the obelisk of the\n-- project thunk.\nsetupObeliskImpl :: MonadIO m => FilePath -> m ()\nsetupObeliskImpl deployDir = liftIO $ do\n  let\n    implDir = toImplDir deployDir\n    goBackUp = foldr (</>) \"\" $ (\"..\" <$) $ splitPath $ makeRelative deployDir implDir\n  createDirectoryIfMissing True implDir\n  writeFile (implDir </> \"default.nix\") $ \"(import \" <> toNixPath (goBackUp </> \"src\") <> \" {}).obelisk\"\n\n-- | Executes the deployment specified in the supplied staging dir\ndeployPush\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Path to the staging directory\n  -> [String]\n  -- ^ nix builders arg string for the nix-build that builds the deployment artefacts\n  -> m ()\ndeployPush deployPath builders = do\n  hosts <- Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"backend_hosts\"\n  adminEmail <- readDeployConfig deployPath \"admin_email\"\n  enableHttps <- read <$> readDeployConfig deployPath \"enable_https\"\n  route <- readDeployConfig deployPath $ \"config\" </> \"common\" </> \"route\"\n  routeHost <- getHostFromRoute enableHttps route\n  redirectHosts <- liftIO (doesFileExist \"redirect_hosts\") >>= \\case\n    True -> Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"redirect_hosts\"\n    False -> pure mempty\n  let srcPath = deployPath </> \"src\"\n  thunkPtr <- wrapNixThunkError (readThunk srcPath) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    Right ThunkData_Checkout -> do\n      checkGitCleanStatus srcPath True >>= \\case\n        True -> wrapNixThunkError $ packThunk (ThunkPackConfig False (ThunkConfig Nothing)) srcPath\n        False -> failWith $ T.pack $ \"ob deploy push: ensure \" <> srcPath <> \" has no pending changes and latest is pushed upstream.\"\n    Left err -> failWith $ \"ob deploy push: couldn't read src thunk: \" <> T.pack (show err)\n  let version = show . _thunkRev_commit $ _thunkPtr_rev thunkPtr\n  let moduleFile = deployPath </> \"module.nix\"\n  moduleFileExists <- liftIO $ doesFileExist moduleFile\n\n  configHash <- getGitHash deployPath \"config\"\n  buildOutputByHost <- ifor (Map.fromSet (const ()) hosts) $ \\host () -> do\n    --TODO: What does it mean if this returns more or less than 1 line of output?\n    [result] <- fmap lines $ nixCmd $ NixCmd_Build $ def\n      & nixCmdConfig_target .~ Target\n        { _target_path = Just srcPath\n        , _target_attr = Just \"server.system\"\n        , _target_expr = Nothing\n        }\n      & nixBuildConfig_outLink .~ OutLink_None\n      & nixCmdConfig_args .~ (\n        [ strArg \"hostName\" $ fmap (\\c -> if c == '.' then '_' else c) host\n        , strArg \"adminEmail\" adminEmail\n        , strArg \"routeHost\" routeHost\n        , rawArg \"redirectHosts\" $ renderString $ layoutCompact $ prettyNix $ Nix.mkList $ Nix.mkStr . T.pack <$> Set.toList redirectHosts\n        , strArg \"version\" version\n        , boolArg \"enableHttps\" enableHttps\n        , strArg \"configHash\" $ T.unpack $ T.strip (_gitHash_text configHash)\n        ] <> [rawArg \"module\" (\"import \" <> toNixPath moduleFile) | moduleFileExists ])\n      & nixCmdConfig_builders .~ builders\n    pure result\n  let knownHostsPath = deployPath </> \"backend_known_hosts\"\n      sshOpts = sshArgs knownHostsPath (deployPath </> \"ssh_key\") False\n  withSpinner \"Uploading closures\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcess'\n      (Map.fromList [(\"NIX_SSHOPTS\", unwords sshOpts)])\n      \"nix-copy-closure\" [\"-v\", \"--to\", \"--use-substitutes\", \"root@\" <> host, \"--gzip\", outputPath]\n  withSpinner \"Uploading config\" $ ifor_ buildOutputByHost $ \\host _ -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc rsyncPath\n        [ \"-e \" <> sshPath <> \" \" <> unwords sshOpts\n        , \"--chown=backend:backend\"\n        , \"-qarvz\"\n        , deployPath </> \"config\"\n        , \"root@\" <> host <> \":/var/lib/backend\"\n        ]\n  --TODO: Create GC root so we're sure our closure won't go away during this time period\n  withSpinner \"Switching to new configuration\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc sshPath $ sshOpts <>\n        [ \"root@\" <> host\n        , unwords\n            [ \"bash -c\"\n            , bashEscape (deployActivationScript outputPath)\n            ]\n        ]\n  isClean <- checkGitCleanStatus deployPath True\n  when (not isClean) $ do\n    withSpinner \"Committing changes to Git\" $ do\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"add\", \".\"]\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"commit\", \"-m\", \"New deployment\"]\n  putLog Notice $ \"Deployed => \" <> T.pack route\n  where\n    callProcess' envMap cmd args = do\n      let p = setEnvOverride (envMap <>) $ setDelegateCtlc True $ proc cmd args\n      callProcessAndLogOutput (Notice, Notice) p\n\n-- | Bash command that will be run on the deployed machine to actually switch the NixOS configuration\n-- This has some more involved logic than merely activating the right profile. It also determines\n-- whether the kernel parameters have changed so that the deployed NixOS instance should be restarted.\ndeployActivationScript\n  :: String\n  -- ^ The out path of the configuration to activate\n  -> String\ndeployActivationScript outPath =\n-- Note that we don't want to $(staticWhich \"nix-env\") here, because this is executing on a remote machine\n-- This logic follows the nixos auto-upgrade module as of writing.\n-- If the workflow is added to switch-to-configuration proper, we can simplify this:\n-- https://github.com/obsidiansystems/obelisk/issues/958\n  [i|set -euxo pipefail\nnix-env -p /nix/var/nix/profiles/system --set \"${bashEscape outPath}\"\n/nix/var/nix/profiles/system/bin/switch-to-configuration boot\nbooted=\"$(readlink /run/booted-system/{initrd,kernel,kernel-modules})\"\nbuilt=\"$(readlink /nix/var/nix/profiles/system/{initrd,kernel,kernel-modules})\"\nif [ \"$booted\" = \"$built\" ]; then\n  /nix/var/nix/profiles/system/bin/switch-to-configuration switch\nelse\n  /run/current-system/sw/bin/shutdown -r +1\nfi\n|]\n\n-- | Update the source thunk in the staging directory to the HEAD of the branch.\ndeployUpdate :: MonadObelisk m => FilePath -> m ()\ndeployUpdate deployPath = wrapNixThunkError $\n  updateThunkToLatest (ThunkUpdateConfig Nothing (ThunkConfig Nothing)) (deployPath </> \"src\")\n\n-- | Platforms that we deploy obelisk artefacts to.\ndata PlatformDeployment = Android | IOS\n  deriving (Show, Eq)\n\n-- | Pretty print PlatformDeployment\nrenderPlatformDeployment :: PlatformDeployment -> String\nrenderPlatformDeployment = \\case\n  Android -> \"android\"\n  IOS -> \"ios\"\n\n-- | Produce the mobile app for an Obelisk project and deploy it onto a personal device.\n-- This does not submit the artefacts to any app stores, or anything like that. It is\n-- primarily useful for testing, or individual use of an Obelisk project.\ndeployMobile\n  :: forall m. MonadObelisk m\n  => PlatformDeployment\n  -- ^ Which mobile artefact to deploy; e.g. Android or iOS\n  -> [String]\n  -- ^ Extra arguments to pass to the executable that actually loads\n  -- the artefact onto the testing device. An example is the Team ID\n  -- associated with an Apple developer account.\n  -> m ()\ndeployMobile platform mobileArgs = withProjectRoot \".\" $ \\root -> do\n  let srcDir = root </> \"src\"\n      configDir = root </> \"config\"\n  exists <- liftIO $ doesDirectoryExist srcDir\n  unless exists $ failWith \"ob test should be run inside of a deploy directory\"\n  (nixBuildTarget, extraArgs) <- case platform of\n    Android -> do\n      let keystorePath = root </> \"android_keystore.jks\"\n          keytoolConfPath = root </> \"android_keytool_config.json\"\n      hasKeystore <- liftIO $ doesFileExist keystorePath\n      when (not hasKeystore) $ do\n        -- TODO log instructions for how to modify the keystore\n        putLog Notice $ \"Creating keystore: \" <> T.pack keystorePath\n        putLog Notice \"Enter a keystore password: \"\n        keyStorePassword <- liftIO $ withEcho False getLine\n        putLog Notice \"Re-enter the keystore password: \"\n        keyStorePassword' <- liftIO $ withEcho False getLine\n        unless (keyStorePassword' == keyStorePassword) $ failWith \"passwords do not match\"\n        let keyToolConf = KeytoolConfig\n              { _keytoolConfig_keystore = keystorePath\n              , _keytoolConfig_alias = \"obelisk\"\n              , _keytoolConfig_storepass = keyStorePassword\n              , _keytoolConfig_keypass = keyStorePassword\n              }\n        createKeystore root keyToolConf\n        liftIO $ BSL.writeFile keytoolConfPath $ encode keyToolConf\n      checkKeytoolConfExist <- liftIO $ doesFileExist keytoolConfPath\n      unless checkKeytoolConfExist $ failWith \"Missing android KeytoolConfig\"\n      keytoolConfContents <- liftIO $ BSL.readFile keytoolConfPath\n      keyArgs <- case eitherDecode keytoolConfContents :: Either String KeytoolConfig of\n        Left err -> failWith $ T.pack err\n        Right conf -> pure\n          [ \"--sign\"\n          , \"--store-file\", _keytoolConfig_keystore conf\n          , \"--store-password\", _keytoolConfig_storepass conf\n          , \"--key-alias\", _keytoolConfig_alias conf\n          , \"--key-password\", _keytoolConfig_keypass conf\n          ]\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"android.frontend.override (drv: {\"\n            , \"isRelease = true;\"\n            , \"staticSrc = (passthru.__androidWithConfig \", configDir, \").frontend.staticSrc;\"\n            , \"assets = (passthru.__androidWithConfig \", configDir, \").frontend.assets;\"\n            , \"})\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, keyArgs)\n    IOS -> do\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"ios.frontend.override (_: { staticSrc = (passthru.__iosWithConfig \", toNixPath configDir, \").frontend.staticSrc; })\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, [])\n  result <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ nixBuildTarget\n  let mobileArtifact = case platform of\n                         IOS -> \"iOS App\"\n                         Android -> \"Android APK\"\n  putLog Notice $ T.pack $ unwords [\"Your recently built\", mobileArtifact, \"can be found at the following path:\", show result]\n  callProcessAndLogOutput (Notice, Error) $ proc (result </> \"bin\" </> \"deploy\") (mobileArgs ++ extraArgs)\n  where\n    withEcho showEcho f = bracket\n      (do\n        prevEcho <- hGetEcho stdin\n        hSetEcho stdin showEcho\n        pure prevEcho\n      )\n      (hSetEcho stdin)\n      (const f)\n\n-- | obelisk uses keytool, a certificate and keypair management tool that comes with Java,\n-- to manage the cryptographic assets needed to deploy to an Android device.\ndata KeytoolConfig = KeytoolConfig\n  { _keytoolConfig_keystore :: FilePath\n  -- ^ Where is the keystore that keytool should create keypairs?\n  , _keytoolConfig_alias :: String\n  -- ^ Name of the entry in the keystore to process\n  , _keytoolConfig_storepass :: String\n  -- ^ Password for the keystore\n  , _keytoolConfig_keypass :: String\n  -- ^ Password for the keypair under consideration\n  } deriving (Show, Generic)\n\ninstance FromJSON KeytoolConfig\ninstance ToJSON KeytoolConfig\n\n-- | Creates a keystore, and a keypair in that keystore.\ncreateKeystore :: MonadObelisk m => FilePath -> KeytoolConfig -> m ()\ncreateKeystore root config =\n  callProcessAndLogOutput (Notice, Notice) $ setCwd (Just root) $ proc jreKeyToolPath\n    [ \"-genkeypair\", \"-noprompt\"\n    , \"-keystore\", _keytoolConfig_keystore config\n    , \"-keyalg\", \"RSA\", \"-keysize\", \"2048\"\n    , \"-validity\", \"1000000\"\n    , \"-storepass\", _keytoolConfig_storepass config\n    , \"-alias\", _keytoolConfig_alias config\n    , \"-keypass\", _keytoolConfig_keypass config\n    ]\n\n-- | Simplified deployment configuration mechanism. At one point we may revisit this.\nwriteDeployConfig :: MonadObelisk m => FilePath -> FilePath -> String -> m ()\nwriteDeployConfig deployDir fname = liftIO . writeFile (deployDir </> fname)\n\n-- | Read the deployment config file from a deployment staging directory.\nreadDeployConfig\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Deployment staging directory\n  -> FilePath\n  -- ^ The path to the config file relative to the staging directory.\n  -> m String\nreadDeployConfig deployDir fname = liftIO $ do\n  fmap (T.unpack . T.strip) $ T.readFile $ deployDir </> fname\n\n-- | Lookup known hosts using ssh-keygen command\nlookupKnownHosts :: MonadObelisk m\n                 => String\n                 -- ^ the host name\n                 -> m [BS.ByteString]\n                 -- ^ obtained hosts\nlookupKnownHosts hostName =\n  fmap filterComments $ readCreateProcessWithExitCode $ proc $(staticWhichNix \"ssh-keygen\") [\"-F\", hostName]\n   where\n     filterComments (exitCode, out, _) =\n       if exitCode /= ExitSuccess || null out\n         then []\n         else\n           -- ssh-keygen prints the following above each result it finds: \"# Host <hostname> found: line <lineno>\"\n           filter (not . C.isPrefixOf \"# Host\") $ C.lines $ C.pack out\n\n-- | insert a host/pair in backend_known_hosts file\naddKnownHostFromEnv :: MonadObelisk m\n                    => String\n                    -- ^ hostname\n                    -> FilePath\n                    -- ^ path to backend_known_hosts file\n                    -> m ()\naddKnownHostFromEnv hostName obKnownHostsPath = do\n  lookupKnownHosts hostName >>= \\res -> case res of\n    [knownKey] -> liftIO $ BS.appendFile obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    [] -> putLog Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog Notice \"Found more than one matching host/key pair in user's known_hosts\"\n\n-- | Verify the identity of a remote host that we would like to deploy to.\nverifyHostKey\n  :: MonadObelisk m\n  => FilePath\n  -- ^ known_hosts file to use for hosts that have already been verified.\n  -> FilePath\n  -- ^ Path to the ssh key used to connect to the host\n  -> String\n  -- ^ Name of the host\n  -> m ()\nverifyHostKey knownHostsPath keyPath hostName =\n  callProcessAndLogOutput (Notice, Warning) $ proc sshPath $\n    sshArgs knownHostsPath keyPath True <>\n      [ \"root@\" <> hostName\n      , \"-o\", \"NumberOfPasswordPrompts=0\"\n      , \"exit\"\n      ]\n\n-- | Create arguments to pass to ssh on the command line\nsshArgs\n  :: FilePath\n  -- ^ Path to known_hosts file\n  -> FilePath\n  -- ^ Path to the ssh key to use\n  -> Bool\n  -- ^ If true, then prompt the user when a host is not in the known_hosts file,\n  -- otherwise use strict host checking.\n  -> [String]\nsshArgs knownHostsPath keyPath askHostKeyCheck =\n  [ \"-o\", \"UserKnownHostsFile=\" <> knownHostsPath\n  , \"-o\", \"StrictHostKeyChecking=\" <> if askHostKeyCheck then \"ask\" else \"yes\"\n  , \"-i\", keyPath\n  ]\n\n-- common/route validation\n-- TODO: move these to executable-config once the typed-config stuff is done.\n\n-- | Ways in which the route configured for a deployment host can be invalid\ndata InvalidRoute\n  = InvalidRoute_NotHttps URI\n  -- ^ We do not deploy non-https routes unless explicitly asked for\n  | InvalidRoute_MissingScheme URI\n  -- ^ We demand a URI scheme\n  | InvalidRoute_MissingHost URI\n  -- ^ We demand a hostname\n  | InvalidRoute_HasPort URI\n  -- ^ We do not deploy to a route with a particular port number\n  | InvalidRoute_HasPath URI\n  -- ^ We do not deploy to a route that is served at a particular path\n  deriving Show\n\ninstance Exception InvalidRoute where\n  displayException = \\case\n    InvalidRoute_MissingScheme uri -> route uri \"must have an URI scheme\"\n    InvalidRoute_NotHttps uri -> route uri \"must be HTTPS\"\n    InvalidRoute_MissingHost uri -> route uri \"must contain a hostname\"\n    InvalidRoute_HasPort uri -> route uri \"cannot specify port\"\n    InvalidRoute_HasPath uri -> route uri \"cannot contain path\"\n    where\n      route uri err = T.unpack $ \"Route (\" <> URI.render uri <> \") \" <> err\n\n-- | Get the hostname from a https route\n--\n-- Fail if the route is invalid (i.e, no host present or scheme is not https)\ngetHostFromRoute\n  :: MonadObelisk m\n  => Bool  -- ^ Ensure https?\n  -> String\n  -> m String\ngetHostFromRoute mustBeHttps route = do\n  result :: Either InvalidRoute String <- try $ do\n    validateCommonRouteAndGetHost mustBeHttps =<< URI.mkURI (T.strip $ T.pack route)\n  either (failWith . T.pack . displayException) pure result\n\n-- | When deploying, we ensure that the route we are deploying for makes sense.\n-- In particular, we extract the hostname that we are deploying to from the\n-- route.\nvalidateCommonRouteAndGetHost\n  :: (MonadThrow m, MonadObelisk m)\n  => Bool\n  -- ^ If true, demand that the route we are deploying is an HTTPS route\n  -> URI\n  -- ^ The route to validate\n  -> m String\nvalidateCommonRouteAndGetHost mustBeHttps uri = do\n  case uri ^? uriScheme of\n    Just (Just (URI.unRText -> s)) -> case (mustBeHttps, s) of\n      (False, _) -> pure ()\n      (True, \"https\") -> pure ()\n      _ -> throwM $ InvalidRoute_NotHttps uri\n    _ -> throwM $ InvalidRoute_MissingScheme uri\n  case uri ^. uriPath of\n    [] -> pure ()\n    _path -> throwM $ InvalidRoute_HasPath uri\n  case uri ^? uriAuthority . _Right . authPort of\n    Just (Just _port) -> throwM $ InvalidRoute_HasPort uri\n    _ -> pure ()\n  case uri ^? uriAuthority . _Right . authHost of\n    Nothing -> throwM $ InvalidRoute_MissingHost uri\n    Just sslHost -> return $ T.unpack $ URI.unRText sslHost\n",
              "suggestions": [
                {
                  "target_snippet": "\\ res\n    -> case res of\n         [knownKey]\n           -> liftIO\n                $ BS.appendFile\n                    obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n         []\n           -> putLog\n                Notice \"Found no matching hosts in user's known_hosts file\"\n         _ -> putLog\n                Notice\n                \"Found more than one matching host/key pair in user's known_hosts\"",
                  "refactored_suggestion": "\\case\n    [knownKey]\n      -> liftIO\n           $ BS.appendFile\n               obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    []\n      -> putLog\n           Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog\n           Notice\n           \"Found more than one matching host/key pair in user's known_hosts\"",
                  "confidence": 1.0,
                  "justification": "The suggested replacement simplifies pattern matching by using the `\\case` syntax, making the code more concise and readable without altering functionality. This is a standard Haskell idiom when pattern matching exclusively on the argument of a lambda function."
                }
              ],
              "refactored_code": "{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE ViewPatterns #-}\n{-|\n   Description:\n   Implementation of the CLI deploy commands. Deployment is done by intializing\n   a staging area for deployment configuration, and then by actually executing\n   the deployment by installing a NixOS configuration at the configured deployment\n   locations.\n-}\nmodule Obelisk.Command.Deploy where\n\nimport Control.Applicative (liftA2)\nimport Control.Lens\nimport Control.Monad\nimport Control.Monad.Catch (Exception (displayException), MonadThrow, bracket, throwM, try)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.Aeson (FromJSON, ToJSON, encode, eitherDecode)\nimport Data.Bits\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Default\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport GHC.Generics\nimport System.Directory\nimport System.Exit (ExitCode(ExitSuccess))\nimport System.FilePath\nimport System.IO\nimport System.Which\nimport System.PosixCompat.Files\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Nix.Pretty (prettyNix)\nimport qualified Nix.Expr.Shorthands as Nix\nimport Prettyprinter (layoutCompact)\nimport Prettyprinter.Render.String (renderString)\n\nimport Obelisk.App (MonadObelisk, wrapNixThunkError)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils\n\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\n-- | Options passed to the `init` verb\ndata DeployInitOpts = DeployInitOpts\n  { _deployInitOpts_outputDir :: FilePath\n  -- ^ Where to set up the deployment staging area\n  , _deployInitOpts_sshKey :: FilePath\n  -- ^ Which SSH Key will be used to interface with the deployment hosts\n  , _deployInitOpts_hostname :: [String]\n  -- ^ The hostnames that locate the deployment hosts\n  , _deployInitOpts_route :: String\n  -- ^ The route they are serving\n  , _deployInitOpts_adminEmail :: String\n  -- ^ The administrator email, for ACME\n  , _deployInitOpts_enableHttps :: Bool\n  -- ^ Whether or not to use HTTPS, which entails using Lets Encrypt by default\n  , _deployInitOpts_checkKnownHosts :: Bool\n  -- ^ Whether or not to use known_hosts file when assessing the identity of the deployment hosts\n  } deriving Show\n\n-- | The `init` verb\ndeployInit\n  :: MonadObelisk m\n  => DeployInitOpts\n  -- ^ Command line arguments\n  -> FilePath\n  -- ^ Project root, which cannot be the same as the deployment dir\n  -> m ()\ndeployInit deployOpts root = do\n  let deployDir = _deployInitOpts_outputDir deployOpts\n  rootEqualsTarget <- liftIO $ liftA2 equalFilePath (canonicalizePath root) (canonicalizePath deployDir)\n  when rootEqualsTarget $\n    failWith [i|Deploy directory ${deployDir} should not be the same as project root.|]\n  thunkPtr <- wrapNixThunkError (readThunk root) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    _ -> wrapNixThunkError (getThunkPtr CheckClean_NotIgnored root Nothing)\n  deployInit' thunkPtr deployOpts\n\n-- | The preamble in 'deployInit' provides deployInit' with a 'ThunkPtr' that it can install in\n-- the staging directory.\ndeployInit'\n  :: MonadObelisk m\n  => ThunkPtr\n  -> DeployInitOpts\n  -> m ()\ndeployInit' thunkPtr (DeployInitOpts deployDir sshKeyPath hostnames route adminEmail enableHttps checkKnownHosts) = do\n  liftIO $ createDirectoryIfMissing True deployDir\n  localKey <- withSpinner (\"Preparing \" <> T.pack deployDir) $ do\n    localKey <- liftIO (doesFileExist sshKeyPath) >>= \\case\n      False -> failWith $ T.pack $ \"ob deploy init: file does not exist: \" <> sshKeyPath\n      True -> pure $ deployDir </> \"ssh_key\"\n    callProcessAndLogOutput (Notice, Error) $\n      proc cp [sshKeyPath, localKey]\n    liftIO $ setFileMode localKey $ ownerReadMode .|. ownerWriteMode\n    return localKey\n  withSpinner \"Validating configuration\" $ do\n    void $ getHostFromRoute enableHttps route -- make sure that hostname is present\n  let obKnownHostsPath = deployDir </> \"backend_known_hosts\"\n  forM_ hostnames $ \\hostname -> do\n    putLog Notice $ \"Verifying host keys (\" <> T.pack hostname <> \")\"\n    -- Note: we can't use a spinner here as this function will prompt the user.\n    when checkKnownHosts $ addKnownHostFromEnv hostname obKnownHostsPath\n    verifyHostKey obKnownHostsPath localKey hostname\n  --IMPORTANT: We cannot copy config directory from the development project to\n  --the deployment directory.  If we do, it's very likely someone will\n  --accidentally create a production deployment that uses development\n  --credentials to connect to some resources.  This could result in, e.g.,\n  --production data backed up to a dev environment.\n  withSpinner \"Creating project configuration directories\" $ liftIO $ do\n    mapM_ (createDirectoryIfMissing True)\n      [ deployDir </> \"config\" </> \"backend\"\n      , deployDir </> \"config\" </> \"common\"\n      , deployDir </> \"config\" </> \"frontend\"\n      ]\n\n  let srcDir = deployDir </> \"src\"\n  withSpinner (\"Creating source thunk (\" <> T.pack (makeRelative deployDir srcDir) <> \")\") $ do\n    wrapNixThunkError . createThunk srcDir $ Right thunkPtr\n    setupObeliskImpl deployDir\n\n  withSpinner \"Writing deployment configuration\" $ do\n    writeDeployConfig deployDir \"backend_hosts\" $ unlines hostnames\n    writeDeployConfig deployDir \"enable_https\" $ show enableHttps\n    writeDeployConfig deployDir \"admin_email\" adminEmail\n    writeDeployConfig deployDir (\"config\" </> \"common\" </> \"route\") route\n    writeDeployConfig deployDir \"module.nix\" $\n      \"(import \" <> toNixPath (makeRelative deployDir srcDir) <> \" {}).obelisk.serverModules.mkBaseEc2\"\n\n  withSpinner (\"Initializing git repository (\" <> T.pack deployDir <> \")\") $\n    initGit deployDir\n\n-- | Installs an obelisk impl in the staging dir that points at the obelisk of the\n-- project thunk.\nsetupObeliskImpl :: MonadIO m => FilePath -> m ()\nsetupObeliskImpl deployDir = liftIO $ do\n  let\n    implDir = toImplDir deployDir\n    goBackUp = foldr (</>) \"\" $ (\"..\" <$) $ splitPath $ makeRelative deployDir implDir\n  createDirectoryIfMissing True implDir\n  writeFile (implDir </> \"default.nix\") $ \"(import \" <> toNixPath (goBackUp </> \"src\") <> \" {}).obelisk\"\n\n-- | Executes the deployment specified in the supplied staging dir\ndeployPush\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Path to the staging directory\n  -> [String]\n  -- ^ nix builders arg string for the nix-build that builds the deployment artefacts\n  -> m ()\ndeployPush deployPath builders = do\n  hosts <- Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"backend_hosts\"\n  adminEmail <- readDeployConfig deployPath \"admin_email\"\n  enableHttps <- read <$> readDeployConfig deployPath \"enable_https\"\n  route <- readDeployConfig deployPath $ \"config\" </> \"common\" </> \"route\"\n  routeHost <- getHostFromRoute enableHttps route\n  redirectHosts <- liftIO (doesFileExist \"redirect_hosts\") >>= \\case\n    True -> Set.fromList . filter (/= mempty) . lines <$> readDeployConfig deployPath \"redirect_hosts\"\n    False -> pure mempty\n  let srcPath = deployPath </> \"src\"\n  thunkPtr <- wrapNixThunkError (readThunk srcPath) >>= \\case\n    Right (ThunkData_Packed _ ptr) -> return ptr\n    Right ThunkData_Checkout -> do\n      checkGitCleanStatus srcPath True >>= \\case\n        True -> wrapNixThunkError $ packThunk (ThunkPackConfig False (ThunkConfig Nothing)) srcPath\n        False -> failWith $ T.pack $ \"ob deploy push: ensure \" <> srcPath <> \" has no pending changes and latest is pushed upstream.\"\n    Left err -> failWith $ \"ob deploy push: couldn't read src thunk: \" <> T.pack (show err)\n  let version = show . _thunkRev_commit $ _thunkPtr_rev thunkPtr\n  let moduleFile = deployPath </> \"module.nix\"\n  moduleFileExists <- liftIO $ doesFileExist moduleFile\n\n  configHash <- getGitHash deployPath \"config\"\n  buildOutputByHost <- ifor (Map.fromSet (const ()) hosts) $ \\host () -> do\n    --TODO: What does it mean if this returns more or less than 1 line of output?\n    [result] <- fmap lines $ nixCmd $ NixCmd_Build $ def\n      & nixCmdConfig_target .~ Target\n        { _target_path = Just srcPath\n        , _target_attr = Just \"server.system\"\n        , _target_expr = Nothing\n        }\n      & nixBuildConfig_outLink .~ OutLink_None\n      & nixCmdConfig_args .~ (\n        [ strArg \"hostName\" $ fmap (\\c -> if c == '.' then '_' else c) host\n        , strArg \"adminEmail\" adminEmail\n        , strArg \"routeHost\" routeHost\n        , rawArg \"redirectHosts\" $ renderString $ layoutCompact $ prettyNix $ Nix.mkList $ Nix.mkStr . T.pack <$> Set.toList redirectHosts\n        , strArg \"version\" version\n        , boolArg \"enableHttps\" enableHttps\n        , strArg \"configHash\" $ T.unpack $ T.strip (_gitHash_text configHash)\n        ] <> [rawArg \"module\" (\"import \" <> toNixPath moduleFile) | moduleFileExists ])\n      & nixCmdConfig_builders .~ builders\n    pure result\n  let knownHostsPath = deployPath </> \"backend_known_hosts\"\n      sshOpts = sshArgs knownHostsPath (deployPath </> \"ssh_key\") False\n  withSpinner \"Uploading closures\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcess'\n      (Map.fromList [(\"NIX_SSHOPTS\", unwords sshOpts)])\n      \"nix-copy-closure\" [\"-v\", \"--to\", \"--use-substitutes\", \"root@\" <> host, \"--gzip\", outputPath]\n  withSpinner \"Uploading config\" $ ifor_ buildOutputByHost $ \\host _ -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc rsyncPath\n        [ \"-e \" <> sshPath <> \" \" <> unwords sshOpts\n        , \"--chown=backend:backend\"\n        , \"-qarvz\"\n        , deployPath </> \"config\"\n        , \"root@\" <> host <> \":/var/lib/backend\"\n        ]\n  --TODO: Create GC root so we're sure our closure won't go away during this time period\n  withSpinner \"Switching to new configuration\" $ ifor_ buildOutputByHost $ \\host outputPath -> do\n    callProcessAndLogOutput (Notice, Warning) $\n      proc sshPath $ sshOpts <>\n        [ \"root@\" <> host\n        , unwords\n            [ \"bash -c\"\n            , bashEscape (deployActivationScript outputPath)\n            ]\n        ]\n  isClean <- checkGitCleanStatus deployPath True\n  when (not isClean) $ do\n    withSpinner \"Committing changes to Git\" $ do\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"add\", \".\"]\n      callProcessAndLogOutput (Debug, Error) $\n        gitProc deployPath [\"commit\", \"-m\", \"New deployment\"]\n  putLog Notice $ \"Deployed => \" <> T.pack route\n  where\n    callProcess' envMap cmd args = do\n      let p = setEnvOverride (envMap <>) $ setDelegateCtlc True $ proc cmd args\n      callProcessAndLogOutput (Notice, Notice) p\n\n-- | Bash command that will be run on the deployed machine to actually switch the NixOS configuration\n-- This has some more involved logic than merely activating the right profile. It also determines\n-- whether the kernel parameters have changed so that the deployed NixOS instance should be restarted.\ndeployActivationScript\n  :: String\n  -- ^ The out path of the configuration to activate\n  -> String\ndeployActivationScript outPath =\n-- Note that we don't want to $(staticWhich \"nix-env\") here, because this is executing on a remote machine\n-- This logic follows the nixos auto-upgrade module as of writing.\n-- If the workflow is added to switch-to-configuration proper, we can simplify this:\n-- https://github.com/obsidiansystems/obelisk/issues/958\n  [i|set -euxo pipefail\nnix-env -p /nix/var/nix/profiles/system --set \"${bashEscape outPath}\"\n/nix/var/nix/profiles/system/bin/switch-to-configuration boot\nbooted=\"$(readlink /run/booted-system/{initrd,kernel,kernel-modules})\"\nbuilt=\"$(readlink /nix/var/nix/profiles/system/{initrd,kernel,kernel-modules})\"\nif [ \"$booted\" = \"$built\" ]; then\n  /nix/var/nix/profiles/system/bin/switch-to-configuration switch\nelse\n  /run/current-system/sw/bin/shutdown -r +1\nfi\n|]\n\n-- | Update the source thunk in the staging directory to the HEAD of the branch.\ndeployUpdate :: MonadObelisk m => FilePath -> m ()\ndeployUpdate deployPath = wrapNixThunkError $\n  updateThunkToLatest (ThunkUpdateConfig Nothing (ThunkConfig Nothing)) (deployPath </> \"src\")\n\n-- | Platforms that we deploy obelisk artefacts to.\ndata PlatformDeployment = Android | IOS\n  deriving (Show, Eq)\n\n-- | Pretty print PlatformDeployment\nrenderPlatformDeployment :: PlatformDeployment -> String\nrenderPlatformDeployment = \\case\n  Android -> \"android\"\n  IOS -> \"ios\"\n\n-- | Produce the mobile app for an Obelisk project and deploy it onto a personal device.\n-- This does not submit the artefacts to any app stores, or anything like that. It is\n-- primarily useful for testing, or individual use of an Obelisk project.\ndeployMobile\n  :: forall m. MonadObelisk m\n  => PlatformDeployment\n  -- ^ Which mobile artefact to deploy; e.g. Android or iOS\n  -> [String]\n  -- ^ Extra arguments to pass to the executable that actually loads\n  -- the artefact onto the testing device. An example is the Team ID\n  -- associated with an Apple developer account.\n  -> m ()\ndeployMobile platform mobileArgs = withProjectRoot \".\" $ \\root -> do\n  let srcDir = root </> \"src\"\n      configDir = root </> \"config\"\n  exists <- liftIO $ doesDirectoryExist srcDir\n  unless exists $ failWith \"ob test should be run inside of a deploy directory\"\n  (nixBuildTarget, extraArgs) <- case platform of\n    Android -> do\n      let keystorePath = root </> \"android_keystore.jks\"\n          keytoolConfPath = root </> \"android_keytool_config.json\"\n      hasKeystore <- liftIO $ doesFileExist keystorePath\n      when (not hasKeystore) $ do\n        -- TODO log instructions for how to modify the keystore\n        putLog Notice $ \"Creating keystore: \" <> T.pack keystorePath\n        putLog Notice \"Enter a keystore password: \"\n        keyStorePassword <- liftIO $ withEcho False getLine\n        putLog Notice \"Re-enter the keystore password: \"\n        keyStorePassword' <- liftIO $ withEcho False getLine\n        unless (keyStorePassword' == keyStorePassword) $ failWith \"passwords do not match\"\n        let keyToolConf = KeytoolConfig\n              { _keytoolConfig_keystore = keystorePath\n              , _keytoolConfig_alias = \"obelisk\"\n              , _keytoolConfig_storepass = keyStorePassword\n              , _keytoolConfig_keypass = keyStorePassword\n              }\n        createKeystore root keyToolConf\n        liftIO $ BSL.writeFile keytoolConfPath $ encode keyToolConf\n      checkKeytoolConfExist <- liftIO $ doesFileExist keytoolConfPath\n      unless checkKeytoolConfExist $ failWith \"Missing android KeytoolConfig\"\n      keytoolConfContents <- liftIO $ BSL.readFile keytoolConfPath\n      keyArgs <- case eitherDecode keytoolConfContents :: Either String KeytoolConfig of\n        Left err -> failWith $ T.pack err\n        Right conf -> pure\n          [ \"--sign\"\n          , \"--store-file\", _keytoolConfig_keystore conf\n          , \"--store-password\", _keytoolConfig_storepass conf\n          , \"--key-alias\", _keytoolConfig_alias conf\n          , \"--key-password\", _keytoolConfig_keypass conf\n          ]\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"android.frontend.override (drv: {\"\n            , \"isRelease = true;\"\n            , \"staticSrc = (passthru.__androidWithConfig \", configDir, \").frontend.staticSrc;\"\n            , \"assets = (passthru.__androidWithConfig \", configDir, \").frontend.assets;\"\n            , \"})\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, keyArgs)\n    IOS -> do\n      let expr = mconcat\n            [ \"with (import \", toNixPath srcDir, \" {});\"\n            , \"ios.frontend.override (_: { staticSrc = (passthru.__iosWithConfig \", toNixPath configDir, \").frontend.staticSrc; })\"\n            ]\n      return (Target\n        { _target_path = Nothing\n        , _target_attr = Nothing\n        , _target_expr = Just expr\n        }, [])\n  result <- nixCmd $ NixCmd_Build $ def\n    & nixBuildConfig_outLink .~ OutLink_None\n    & nixCmdConfig_target .~ nixBuildTarget\n  let mobileArtifact = case platform of\n                         IOS -> \"iOS App\"\n                         Android -> \"Android APK\"\n  putLog Notice $ T.pack $ unwords [\"Your recently built\", mobileArtifact, \"can be found at the following path:\", show result]\n  callProcessAndLogOutput (Notice, Error) $ proc (result </> \"bin\" </> \"deploy\") (mobileArgs ++ extraArgs)\n  where\n    withEcho showEcho f = bracket\n      (do\n        prevEcho <- hGetEcho stdin\n        hSetEcho stdin showEcho\n        pure prevEcho\n      )\n      (hSetEcho stdin)\n      (const f)\n\n-- | obelisk uses keytool, a certificate and keypair management tool that comes with Java,\n-- to manage the cryptographic assets needed to deploy to an Android device.\ndata KeytoolConfig = KeytoolConfig\n  { _keytoolConfig_keystore :: FilePath\n  -- ^ Where is the keystore that keytool should create keypairs?\n  , _keytoolConfig_alias :: String\n  -- ^ Name of the entry in the keystore to process\n  , _keytoolConfig_storepass :: String\n  -- ^ Password for the keystore\n  , _keytoolConfig_keypass :: String\n  -- ^ Password for the keypair under consideration\n  } deriving (Show, Generic)\n\ninstance FromJSON KeytoolConfig\ninstance ToJSON KeytoolConfig\n\n-- | Creates a keystore, and a keypair in that keystore.\ncreateKeystore :: MonadObelisk m => FilePath -> KeytoolConfig -> m ()\ncreateKeystore root config =\n  callProcessAndLogOutput (Notice, Notice) $ setCwd (Just root) $ proc jreKeyToolPath\n    [ \"-genkeypair\", \"-noprompt\"\n    , \"-keystore\", _keytoolConfig_keystore config\n    , \"-keyalg\", \"RSA\", \"-keysize\", \"2048\"\n    , \"-validity\", \"1000000\"\n    , \"-storepass\", _keytoolConfig_storepass config\n    , \"-alias\", _keytoolConfig_alias config\n    , \"-keypass\", _keytoolConfig_keypass config\n    ]\n\n-- | Simplified deployment configuration mechanism. At one point we may revisit this.\nwriteDeployConfig :: MonadObelisk m => FilePath -> FilePath -> String -> m ()\nwriteDeployConfig deployDir fname = liftIO . writeFile (deployDir </> fname)\n\n-- | Read the deployment config file from a deployment staging directory.\nreadDeployConfig\n  :: MonadObelisk m\n  => FilePath\n  -- ^ Deployment staging directory\n  -> FilePath\n  -- ^ The path to the config file relative to the staging directory.\n  -> m String\nreadDeployConfig deployDir fname = liftIO $ do\n  fmap (T.unpack . T.strip) $ T.readFile $ deployDir </> fname\n\n-- | Lookup known hosts using ssh-keygen command\nlookupKnownHosts :: MonadObelisk m\n                 => String\n                 -- ^ the host name\n                 -> m [BS.ByteString]\n                 -- ^ obtained hosts\nlookupKnownHosts hostName =\n  fmap filterComments $ readCreateProcessWithExitCode $ proc $(staticWhichNix \"ssh-keygen\") [\"-F\", hostName]\n   where\n     filterComments (exitCode, out, _) =\n       if exitCode /= ExitSuccess || null out\n         then []\n         else\n           -- ssh-keygen prints the following above each result it finds: \"# Host <hostname> found: line <lineno>\"\n           filter (not . C.isPrefixOf \"# Host\") $ C.lines $ C.pack out\n\n-- | insert a host/pair in backend_known_hosts file\naddKnownHostFromEnv :: MonadObelisk m\n                    => String\n                    -- ^ hostname\n                    -> FilePath\n                    -- ^ path to backend_known_hosts file\n                    -> m ()\naddKnownHostFromEnv hostName obKnownHostsPath = do\n  lookupKnownHosts hostName >>= \\res -> case res of\n    [knownKey] -> liftIO $ BS.appendFile obKnownHostsPath (knownKey `BS.append` C.singleton '\\n')\n    [] -> putLog Notice \"Found no matching hosts in user's known_hosts file\"\n    _ -> putLog Notice \"Found more than one matching host/key pair in user's known_hosts\"\n\n-- | Verify the identity of a remote host that we would like to deploy to.\nverifyHostKey\n  :: MonadObelisk m\n  => FilePath\n  -- ^ known_hosts file to use for hosts that have already been verified.\n  -> FilePath\n  -- ^ Path to the ssh key used to connect to the host\n  -> String\n  -- ^ Name of the host\n  -> m ()\nverifyHostKey knownHostsPath keyPath hostName =\n  callProcessAndLogOutput (Notice, Warning) $ proc sshPath $\n    sshArgs knownHostsPath keyPath True <>\n      [ \"root@\" <> hostName\n      , \"-o\", \"NumberOfPasswordPrompts=0\"\n      , \"exit\"\n      ]\n\n-- | Create arguments to pass to ssh on the command line\nsshArgs\n  :: FilePath\n  -- ^ Path to known_hosts file\n  -> FilePath\n  -- ^ Path to the ssh key to use\n  -> Bool\n  -- ^ If true, then prompt the user when a host is not in the known_hosts file,\n  -- otherwise use strict host checking.\n  -> [String]\nsshArgs knownHostsPath keyPath askHostKeyCheck =\n  [ \"-o\", \"UserKnownHostsFile=\" <> knownHostsPath\n  , \"-o\", \"StrictHostKeyChecking=\" <> if askHostKeyCheck then \"ask\" else \"yes\"\n  , \"-i\", keyPath\n  ]\n\n-- common/route validation\n-- TODO: move these to executable-config once the typed-config stuff is done.\n\n-- | Ways in which the route configured for a deployment host can be invalid\ndata InvalidRoute\n  = InvalidRoute_NotHttps URI\n  -- ^ We do not deploy non-https routes unless explicitly asked for\n  | InvalidRoute_MissingScheme URI\n  -- ^ We demand a URI scheme\n  | InvalidRoute_MissingHost URI\n  -- ^ We demand a hostname\n  | InvalidRoute_HasPort URI\n  -- ^ We do not deploy to a route with a particular port number\n  | InvalidRoute_HasPath URI\n  -- ^ We do not deploy to a route that is served at a particular path\n  deriving Show\n\ninstance Exception InvalidRoute where\n  displayException = \\case\n    InvalidRoute_MissingScheme uri -> route uri \"must have an URI scheme\"\n    InvalidRoute_NotHttps uri -> route uri \"must be HTTPS\"\n    InvalidRoute_MissingHost uri -> route uri \"must contain a hostname\"\n    InvalidRoute_HasPort uri -> route uri \"cannot specify port\"\n    InvalidRoute_HasPath uri -> route uri \"cannot contain path\"\n    where\n      route uri err = T.unpack $ \"Route (\" <> URI.render uri <> \") \" <> err\n\n-- | Get the hostname from a https route\n--\n-- Fail if the route is invalid (i.e, no host present or scheme is not https)\ngetHostFromRoute\n  :: MonadObelisk m\n  => Bool  -- ^ Ensure https?\n  -> String\n  -> m String\ngetHostFromRoute mustBeHttps route = do\n  result :: Either InvalidRoute String <- try $ do\n    validateCommonRouteAndGetHost mustBeHttps =<< URI.mkURI (T.strip $ T.pack route)\n  either (failWith . T.pack . displayException) pure result\n\n-- | When deploying, we ensure that the route we are deploying for makes sense.\n-- In particular, we extract the hostname that we are deploying to from the\n-- route.\nvalidateCommonRouteAndGetHost\n  :: (MonadThrow m, MonadObelisk m)\n  => Bool\n  -- ^ If true, demand that the route we are deploying is an HTTPS route\n  -> URI\n  -- ^ The route to validate\n  -> m String\nvalidateCommonRouteAndGetHost mustBeHttps uri = do\n  case uri ^? uriScheme of\n    Just (Just (URI.unRText -> s)) -> case (mustBeHttps, s) of\n      (False, _) -> pure ()\n      (True, \"https\") -> pure ()\n      _ -> throwM $ InvalidRoute_NotHttps uri\n    _ -> throwM $ InvalidRoute_MissingScheme uri\n  case uri ^. uriPath of\n    [] -> pure ()\n    _path -> throwM $ InvalidRoute_HasPath uri\n  case uri ^? uriAuthority . _Right . authPort of\n    Just (Just _port) -> throwM $ InvalidRoute_HasPort uri\n    _ -> pure ()\n  case uri ^? uriAuthority . _Right . authHost of\n    Nothing -> throwM $ InvalidRoute_MissingHost uri\n    Just sslHost -> return $ T.unpack $ URI.unRText sslHost\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Nix.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Nix.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 6,
                "average": 3,
                "sum": 17
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 3,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 5,
              "lines_of_code": 212,
              "homplexity_lines_of_code": 189,
              "code_quality_score": 47.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 6,
                  "average": 3,
                  "sum": 17
                },
                "homplexity_loc": 189,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runNixCommonConfig\": 3,\n        \"runNixBuildConfig\": 3,\n        \"runNixInstantiateConfig\": 3,\n        \"runNixShellConfig\": 2,\n        \"nixCmd\": 6,\n        \"min\": 2,\n        \"max\": 6,\n        \"average\": 3.4,\n        \"sum\": 17\n    },\n    \"homplexity_loc\": 189\n}"
              },
              "original_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Obelisk.Command.Nix\n  ( Arg (..)\n  , NixBuildConfig (..)\n  , nixBuildConfig_common\n  , nixBuildConfig_outLink\n  , NixCmd (..)\n  , nixCmdConfig_args\n  , nixCmdConfig_builders\n  , nixCmdConfig_target\n  , NixCommonConfig (..)\n  , NixInstantiateConfig (..)\n  , nixInstantiateConfig_eval\n  , NixShellConfig (..)\n  , nixShellConfig_common\n  , nixShellConfig_pure\n  , nixShellConfig_run\n  , OutLink (..)\n  , Target (..)\n  , target_attr\n  , target_expr\n  , target_path\n\n  , boolArg\n  , nixCmd\n  , nixCmdProc\n  , nixCmdProc'\n  , rawArg\n  , runNixShellConfig\n  , strArg\n  ) where\n\nimport Control.Monad (guard)\nimport Control.Lens\n\nimport Data.Bool (bool)\nimport Data.Default\nimport Data.List (intercalate)\nimport Data.Maybe\nimport Data.Monoid ((<>))\nimport qualified Data.Text as T\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\n-- | What to build\ndata Target = Target\n  { _target_path :: Maybe FilePath\n  , _target_attr :: Maybe String\n  , _target_expr :: Maybe String\n  }\nmakeClassy ''Target\n\ninstance Default Target where\n  def = Target\n    { _target_path = Just \".\"\n    , _target_attr = Nothing\n    , _target_expr = Nothing\n    }\n\ndata Arg\n  = Arg_Str String String\n  | Arg_Expr String String\n  deriving (Eq, Show)\n\nstrArg :: String -> String -> Arg\nstrArg = Arg_Str\n\nrawArg :: String -> String -> Arg\nrawArg = Arg_Expr\n\nboolArg :: String -> Bool -> Arg\nboolArg k = Arg_Expr k . bool \"false\" \"true\"\n\ncliFromArgs :: [Arg] -> [String]\ncliFromArgs = concatMap $ \\case\n  Arg_Str k v -> [\"--argstr\", k, v]\n  Arg_Expr k v -> [\"--arg\", k, v]\n\ndata NixCommonConfig = NixCommonConfig\n  { _nixCmdConfig_target :: Target\n  , _nixCmdConfig_args :: [Arg]\n  , _nixCmdConfig_builders :: [String]\n  }\nmakeClassy ''NixCommonConfig\n\ninstance Default NixCommonConfig where\n  def = NixCommonConfig def mempty mempty\n\nrunNixCommonConfig :: NixCommonConfig -> [String]\nrunNixCommonConfig cfg = mconcat [maybeToList path, attrArg, exprArg, args, buildersArg]\n  where\n    path = _target_path $ _nixCmdConfig_target cfg\n    attr = _target_attr $ _nixCmdConfig_target cfg\n    expr = _target_expr $ _nixCmdConfig_target cfg\n    attrArg = case attr of\n      Nothing -> []\n      Just a -> [\"-A\", a]\n    exprArg = case expr of\n      Nothing -> []\n      Just a -> [\"-E\", a]\n    args = cliFromArgs $ _nixCmdConfig_args cfg\n    buildersArg = case _nixCmdConfig_builders cfg of\n      [] -> []\n      builders -> [\"--builders\", intercalate \";\" builders]\n\n-- | Where to put nix-build output\ndata OutLink\n  = OutLink_Default\n  | OutLink_None\n  | OutLink_IndirectRoot FilePath\n\ninstance Default OutLink where\n  def = OutLink_Default\n\ndata NixBuildConfig = NixBuildConfig\n  { _nixBuildConfig_common :: NixCommonConfig\n  , _nixBuildConfig_outLink :: OutLink\n  }\nmakeLenses ''NixBuildConfig\n\ninstance HasNixCommonConfig NixBuildConfig where\n  nixCommonConfig = nixBuildConfig_common\n\ninstance Default NixBuildConfig where\n  def = NixBuildConfig def def\n\nrunNixBuildConfig :: NixBuildConfig -> [String]\nrunNixBuildConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , case _nixBuildConfig_outLink cfg of\n      OutLink_Default -> []\n      OutLink_None -> [\"--no-out-link\"]\n      OutLink_IndirectRoot l -> [\"--out-link\", l]\n  ]\n\ndata NixInstantiateConfig = NixInstantiateConfig\n  { _nixInstantiateConfig_common :: NixCommonConfig\n  , _nixInstantiateConfig_eval :: Bool\n  }\nmakeLenses ''NixInstantiateConfig\n\ninstance HasNixCommonConfig NixInstantiateConfig where\n  nixCommonConfig = nixInstantiateConfig_common\n\ninstance Default NixInstantiateConfig where\n  def = NixInstantiateConfig def False\n\nrunNixInstantiateConfig :: NixInstantiateConfig -> [String]\nrunNixInstantiateConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , \"--eval\" <$ guard (_nixInstantiateConfig_eval cfg)\n  ]\n\ndata NixShellConfig = NixShellConfig\n  { _nixShellConfig_common :: NixCommonConfig\n  , _nixShellConfig_pure :: Bool\n  , _nixShellConfig_run :: Maybe String\n  }\n\nmakeLenses ''NixShellConfig\n\ninstance HasNixCommonConfig NixShellConfig where\n  nixCommonConfig = nixShellConfig_common\n\ninstance Default NixShellConfig where\n  def = NixShellConfig def False Nothing\n\ndata NixCmd\n  = NixCmd_Build NixBuildConfig\n  | NixCmd_Instantiate NixInstantiateConfig\n\ninstance Default NixCmd where\n  def = NixCmd_Build def\n\nrunNixShellConfig :: NixShellConfig -> [String]\nrunNixShellConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , [ \"--pure\" | cfg ^. nixShellConfig_pure ]\n  ] ++ mconcat [\n    [\"--run\", run] | run <- maybeToList $ cfg ^. nixShellConfig_run\n  ]\n\nnixCmdProc :: NixCmd -> ProcessSpec\nnixCmdProc = fst . nixCmdProc'\n\nnixCmdProc' :: NixCmd -> (ProcessSpec, T.Text)\nnixCmdProc' cmdCfg = (proc (T.unpack cmd) options, cmd)\n  where\n    (cmd, options) = case cmdCfg of\n      NixCmd_Build cfg' ->\n        ( \"nix-build\"\n        , runNixBuildConfig cfg'\n        )\n      NixCmd_Instantiate cfg' ->\n        ( \"nix-instantiate\"\n        , runNixInstantiateConfig cfg'\n        )\n\nnixCmd :: MonadObelisk m => NixCmd -> m FilePath\nnixCmd cmdCfg = withSpinner' (T.unwords $ \"Running\" : cmd : desc) (Just $ const $ T.unwords $ \"Built\" : desc) $ do\n  output <- readProcessAndLogStderr Debug cmdProc\n  -- Remove final newline that Nix appends\n  Just (outPath, '\\n') <- pure $ T.unsnoc output\n  pure $ T.unpack outPath\n  where\n    (cmdProc, cmd) = nixCmdProc' cmdCfg\n    commonCfg = case cmdCfg of\n      NixCmd_Build cfg' -> cfg' ^. nixCommonConfig\n      NixCmd_Instantiate cfg' -> cfg' ^. nixCommonConfig\n    path = commonCfg ^. nixCmdConfig_target . target_path\n    desc = concat $ catMaybes\n      [ (\\x -> [\"on\", T.pack x]) <$> path\n      , (\\a -> [\"[\" <> T.pack a <> \"]\"]) <$> (commonCfg ^. nixCmdConfig_target . target_attr)\n      ]\n",
              "suggestions": [
                {
                  "target_snippet": "data Arg\n  = Arg_Str String String\n  | Arg_Expr String String\nderiving (Eq, Show)",
                  "refactored_suggestion": "data Arg\n  = ArgStr String String\n  | ArgExpr String String\nderiving (Eq, Show)",
                  "confidence": 0.9,
                  "justification": "Using camelCase for data constructors improves consistency with Haskell naming conventions."
                },
                {
                  "target_snippet": "data NixCmd\n  = NixCmd_Build NixBuildConfig |\n    NixCmd_Instantiate NixInstantiateConfig",
                  "refactored_suggestion": "data NixCmd\n  = NixCmdBuild NixBuildConfig |\n    NixCmdInstantiate NixInstantiateConfig",
                  "confidence": 0.9,
                  "justification": "Using camelCase for data constructors improves consistency, following Haskell naming conventions."
                },
                {
                  "target_snippet": "nixCmdProc :: NixCmd -> ProcessSpec\nnixCmdProc = fst . nixCmdProc'",
                  "refactored_suggestion": "-- nixCmdProc: Removed the unused function to clean up the codebase and prevent confusion.",
                  "confidence": 0.8,
                  "justification": "The function `nixCmdProc` is not referenced directly in the module and can be removed to simplify the code."
                },
                {
                  "target_snippet": "nixCmdProc' :: NixCmd -> (ProcessSpec, T.Text)\nnixCmdProc' cmdCfg = (proc (T.unpack cmd) options, cmd)\n  where\n    (cmd, options) = case cmdCfg of\n      NixCmd_Build cfg' ->\n        ( \"nix-build\"\n        , runNixBuildConfig cfg'\n        )\n      NixCmd_Instantiate cfg' ->\n        ( \"nix-instantiate\"\n        , runNixInstantiateConfig cfg'\n        )",
                  "refactored_suggestion": "-- nixCmdProc': Removed the unused function because its only purpose was to support nixCmdProc, which was unused.",
                  "confidence": 0.8,
                  "justification": "Since `nixCmdProc` is removed for being unused, its supporting function `nixCmdProc'` also becomes redundant and is removed to avoid unnecessary dead code."
                }
              ],
              "refactored_code": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\nmodule Obelisk.Command.Nix\n  ( Arg (..)\n  , NixBuildConfig (..)\n  , nixBuildConfig_common\n  , nixBuildConfig_outLink\n  , NixCmd (..)\n  , nixCmdConfig_args\n  , nixCmdConfig_builders\n  , nixCmdConfig_target\n  , NixCommonConfig (..)\n  , NixInstantiateConfig (..)\n  , nixInstantiateConfig_eval\n  , NixShellConfig (..)\n  , nixShellConfig_common\n  , nixShellConfig_pure\n  , nixShellConfig_run\n  , OutLink (..)\n  , Target (..)\n  , target_attr\n  , target_expr\n  , target_path\n\n  , boolArg\n  , nixCmd\n  , nixCmdProc\n  , nixCmdProc'\n  , rawArg\n  , runNixShellConfig\n  , strArg\n  ) where\n\nimport Control.Monad (guard)\nimport Control.Lens\n\nimport Data.Bool (bool)\nimport Data.Default\nimport Data.List (intercalate)\nimport Data.Maybe\nimport Data.Monoid ((<>))\nimport qualified Data.Text as T\n\nimport Obelisk.App (MonadObelisk)\nimport Cli.Extras\n\n-- | What to build\ndata Target = Target\n  { _target_path :: Maybe FilePath\n  , _target_attr :: Maybe String\n  , _target_expr :: Maybe String\n  }\nmakeClassy ''Target\n\ninstance Default Target where\n  def = Target\n    { _target_path = Just \".\"\n    , _target_attr = Nothing\n    , _target_expr = Nothing\n    }\n\ndata Arg\n  = Arg_Str String String\n  | Arg_Expr String String\n  deriving (Eq, Show)\n\nstrArg :: String -> String -> Arg\nstrArg = Arg_Str\n\nrawArg :: String -> String -> Arg\nrawArg = Arg_Expr\n\nboolArg :: String -> Bool -> Arg\nboolArg k = Arg_Expr k . bool \"false\" \"true\"\n\ncliFromArgs :: [Arg] -> [String]\ncliFromArgs = concatMap $ \\case\n  Arg_Str k v -> [\"--argstr\", k, v]\n  Arg_Expr k v -> [\"--arg\", k, v]\n\ndata NixCommonConfig = NixCommonConfig\n  { _nixCmdConfig_target :: Target\n  , _nixCmdConfig_args :: [Arg]\n  , _nixCmdConfig_builders :: [String]\n  }\nmakeClassy ''NixCommonConfig\n\ninstance Default NixCommonConfig where\n  def = NixCommonConfig def mempty mempty\n\nrunNixCommonConfig :: NixCommonConfig -> [String]\nrunNixCommonConfig cfg = mconcat [maybeToList path, attrArg, exprArg, args, buildersArg]\n  where\n    path = _target_path $ _nixCmdConfig_target cfg\n    attr = _target_attr $ _nixCmdConfig_target cfg\n    expr = _target_expr $ _nixCmdConfig_target cfg\n    attrArg = case attr of\n      Nothing -> []\n      Just a -> [\"-A\", a]\n    exprArg = case expr of\n      Nothing -> []\n      Just a -> [\"-E\", a]\n    args = cliFromArgs $ _nixCmdConfig_args cfg\n    buildersArg = case _nixCmdConfig_builders cfg of\n      [] -> []\n      builders -> [\"--builders\", intercalate \";\" builders]\n\n-- | Where to put nix-build output\ndata OutLink\n  = OutLink_Default\n  | OutLink_None\n  | OutLink_IndirectRoot FilePath\n\ninstance Default OutLink where\n  def = OutLink_Default\n\ndata NixBuildConfig = NixBuildConfig\n  { _nixBuildConfig_common :: NixCommonConfig\n  , _nixBuildConfig_outLink :: OutLink\n  }\nmakeLenses ''NixBuildConfig\n\ninstance HasNixCommonConfig NixBuildConfig where\n  nixCommonConfig = nixBuildConfig_common\n\ninstance Default NixBuildConfig where\n  def = NixBuildConfig def def\n\nrunNixBuildConfig :: NixBuildConfig -> [String]\nrunNixBuildConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , case _nixBuildConfig_outLink cfg of\n      OutLink_Default -> []\n      OutLink_None -> [\"--no-out-link\"]\n      OutLink_IndirectRoot l -> [\"--out-link\", l]\n  ]\n\ndata NixInstantiateConfig = NixInstantiateConfig\n  { _nixInstantiateConfig_common :: NixCommonConfig\n  , _nixInstantiateConfig_eval :: Bool\n  }\nmakeLenses ''NixInstantiateConfig\n\ninstance HasNixCommonConfig NixInstantiateConfig where\n  nixCommonConfig = nixInstantiateConfig_common\n\ninstance Default NixInstantiateConfig where\n  def = NixInstantiateConfig def False\n\nrunNixInstantiateConfig :: NixInstantiateConfig -> [String]\nrunNixInstantiateConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , \"--eval\" <$ guard (_nixInstantiateConfig_eval cfg)\n  ]\n\ndata NixShellConfig = NixShellConfig\n  { _nixShellConfig_common :: NixCommonConfig\n  , _nixShellConfig_pure :: Bool\n  , _nixShellConfig_run :: Maybe String\n  }\n\nmakeLenses ''NixShellConfig\n\ninstance HasNixCommonConfig NixShellConfig where\n  nixCommonConfig = nixShellConfig_common\n\ninstance Default NixShellConfig where\n  def = NixShellConfig def False Nothing\n\ndata NixCmd\n  = NixCmd_Build NixBuildConfig\n  | NixCmd_Instantiate NixInstantiateConfig\n\ninstance Default NixCmd where\n  def = NixCmd_Build def\n\nrunNixShellConfig :: NixShellConfig -> [String]\nrunNixShellConfig cfg = mconcat\n  [ runNixCommonConfig $ cfg ^. nixCommonConfig\n  , [ \"--pure\" | cfg ^. nixShellConfig_pure ]\n  ] ++ mconcat [\n    [\"--run\", run] | run <- maybeToList $ cfg ^. nixShellConfig_run\n  ]\n\n-- nixCmdProc: Removed the unused function to clean up the codebase and prevent confusion.\n\n-- nixCmdProc': Removed the unused function because its only purpose was to support nixCmdProc, which was unused.\n\nnixCmd :: MonadObelisk m => NixCmd -> m FilePath\nnixCmd cmdCfg = withSpinner' (T.unwords $ \"Running\" : cmd : desc) (Just $ const $ T.unwords $ \"Built\" : desc) $ do\n  output <- readProcessAndLogStderr Debug cmdProc\n  -- Remove final newline that Nix appends\n  Just (outPath, '\\n') <- pure $ T.unsnoc output\n  pure $ T.unpack outPath\n  where\n    (cmdProc, cmd) = nixCmdProc' cmdCfg\n    commonCfg = case cmdCfg of\n      NixCmd_Build cfg' -> cfg' ^. nixCommonConfig\n      NixCmd_Instantiate cfg' -> cfg' ^. nixCommonConfig\n    path = commonCfg ^. nixCmdConfig_target . target_path\n    desc = concat $ catMaybes\n      [ (\\x -> [\"on\", T.pack x]) <$> path\n      , (\\a -> [\"[\" <> T.pack a <> \"]\"]) <$> (commonCfg ^. nixCmdConfig_target . target_attr)\n      ]\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/command/src/Obelisk/Command/Run.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 12,
                "average": 2.1379310344827585,
                "sum": 62
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 9,
                "suggestion": 6,
                "ignore": 0,
                "total": 15
              },
              "syntax_errors": 11,
              "lines_of_code": 648,
              "homplexity_lines_of_code": 798,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 12,
                  "average": 2.1379310344827585,
                  "sum": 62
                },
                "homplexity_loc": 798,
                "homplexity_output": "Info:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 1 1: module Obelisk.Command.Run has 492 lines of code \nCritical:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 106 25: data CabalPackageInfo has record fields count of 10 must never reach 9\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 130 1: type signature for textInterpret has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 130 1: type signature for textInterpret has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 131 1: function textInterpret has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 131 1: function textInterpret has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 131 1: function textInterpret has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 136 19: data PathTree has record fields count of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 142 1: type signature for drawPathTree has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 142 1: type signature for drawPathTree has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 143 1: function drawPathTree has 7 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 143 1: function drawPathTree has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 143 1: function drawPathTree has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 157 1: type signature for profile has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 157 1: type signature for profile has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 162 1: function profile has cyclomatic complexity of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 162 1: function profile has 25 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 162 1: function profile has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 190 1: type signature for run has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 190 1: type signature for run has 5 arguments \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 201 1: function run has 23 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 201 1: function run has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 201 1: function run has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 226 1: type signature for runRepl has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 226 1: type signature for runRepl has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 227 1: function runRepl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 227 1: function runRepl has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 227 1: function runRepl has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 234 1: type signature for runWatch has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 234 1: type signature for runWatch has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 235 1: function runWatch has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 235 1: function runWatch has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 235 1: function runWatch has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 241 1: type signature for exportGhciConfig has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 241 1: type signature for exportGhciConfig has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 242 1: function exportGhciConfig has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 242 1: function exportGhciConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 242 1: function exportGhciConfig has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 246 1: type signature for nixShellForInterpretPaths has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 246 1: type signature for nixShellForInterpretPaths has 6 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 247 1: function nixShellForInterpretPaths has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 247 1: function nixShellForInterpretPaths has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 247 1: function nixShellForInterpretPaths has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 252 1: type signature for getParsedLocalPkgs has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 252 1: type signature for getParsedLocalPkgs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 253 1: function getParsedLocalPkgs has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 253 1: function getParsedLocalPkgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 253 1: function getParsedLocalPkgs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 260 1: type signature for getLocalPkgs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 260 1: type signature for getLocalPkgs has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 261 1: function getLocalPkgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 261 1: function getLocalPkgs has 19 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 261 1: function getLocalPkgs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 291 1: type signature for calcIntepretFinds has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 291 1: type signature for calcIntepretFinds has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 292 1: function calcIntepretFinds has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 292 1: function calcIntepretFinds has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 292 1: function calcIntepretFinds has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 301 1: type signature for foldPathTreeFor has 5 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 301 1: type signature for foldPathTreeFor has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 308 1: function foldPathTreeFor has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 308 1: function foldPathTreeFor has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 308 1: function foldPathTreeFor has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 313 30: data GuessPackageFileError has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 317 25: data HPackFilePath has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 318 25: data CabalFilePath has record fields count of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 321 1: type signature for guessCabalPackageFile has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 321 1: type signature for guessCabalPackageFile has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 325 1: function guessCabalPackageFile has cyclomatic complexity of 8 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 325 1: function guessCabalPackageFile has 18 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 325 1: function guessCabalPackageFile has branching depth of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 346 1: type signature for cabalOrHpackFile has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 346 1: type signature for cabalOrHpackFile has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 347 1: function cabalOrHpackFile has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 347 1: function cabalOrHpackFile has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 347 1: function cabalOrHpackFile has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 354 1: type signature for parseCabalPackage has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 354 1: type signature for parseCabalPackage has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 358 1: function parseCabalPackage has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 358 1: function parseCabalPackage has cyclomatic complexity of 3 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 358 1: function parseCabalPackage has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 366 1: type signature for parseCabalPackage' has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 366 1: type signature for parseCabalPackage' has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 370 1: function parseCabalPackage' has cyclomatic complexity of 12 \nCritical:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 370 1: function parseCabalPackage' has 44 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 370 1: function parseCabalPackage' has branching depth of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 421 1: type signature for parsePackagesOrFail has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 421 1: type signature for parsePackagesOrFail has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 422 1: function parsePackagesOrFail has 25 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 422 1: function parsePackagesOrFail has cyclomatic complexity of 5 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 422 1: function parsePackagesOrFail has branching depth of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 453 1: type signature for packageInfoToNamePathMap has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 453 1: type signature for packageInfoToNamePathMap has 2 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 454 1: function packageInfoToNamePathMap has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 454 1: function packageInfoToNamePathMap has 1 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 454 1: function packageInfoToNamePathMap has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 457 1: type signature for withGhciScriptArgs has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 457 1: type signature for withGhciScriptArgs has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 463 1: function withGhciScriptArgs has 6 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 463 1: function withGhciScriptArgs has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 463 1: function withGhciScriptArgs has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 475 1: type signature for withGhciScript has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 475 1: type signature for withGhciScript has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 481 1: function withGhciScript has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 481 1: function withGhciScript has 16 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 481 1: function withGhciScript has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 503 1: type signature for getGhciSessionSettings has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 503 1: type signature for getGhciSessionSettings has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 508 1: function getGhciSessionSettings has 28 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 508 1: function getGhciSessionSettings has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 508 1: function getGhciSessionSettings has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 543 1: type signature for loadPackageIndex has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 543 1: type signature for loadPackageIndex has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 544 1: function loadPackageIndex has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 544 1: function loadPackageIndex has 9 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 544 1: function loadPackageIndex has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 555 1: type signature for baseGhciOptions has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 555 1: type signature for baseGhciOptions has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 556 1: function baseGhciOptions has 5 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 556 1: function baseGhciOptions has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 556 1: function baseGhciOptions has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 564 1: type signature for runGhciRepl has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 564 1: type signature for runGhciRepl has 4 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 570 1: function runGhciRepl has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 570 1: function runGhciRepl has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 570 1: function runGhciRepl has branching depth of 0 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 577 1: type signature for runGhcid has 6 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 577 1: type signature for runGhcid has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 585 1: function runGhcid has 13 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 585 1: function runGhcid has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 585 1: function runGhcid has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 606 1: type signature for getFreePort has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 606 1: type signature for getFreePort has 1 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 607 1: function getFreePort has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 607 1: function getFreePort has 7 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 607 1: function getFreePort has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 618 1: type signature for pathToTree has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 618 1: type signature for pathToTree has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 619 1: function pathToTree has 3 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 619 1: function pathToTree has cyclomatic complexity of 2 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 619 1: function pathToTree has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 625 1: type signature for zipDefaultWith has type constructor nesting of 1 \nWarning:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 625 1: type signature for zipDefaultWith has 6 arguments should be less than 5\nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 626 1: function zipDefaultWith has cyclomatic complexity of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 626 1: function zipDefaultWith has 4 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 626 1: function zipDefaultWith has branching depth of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 639 1: type signature for relativeTo has 3 arguments \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 639 1: type signature for relativeTo has type constructor nesting of 1 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 640 1: function relativeTo has 9 lines of code \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 640 1: function relativeTo has branching depth of 0 \nInfo:/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs:SrcLoc \"/tmp/project_102/hybrid_refactored/lib/command/src/Obelisk/Command/Run.hs\" 640 1: function relativeTo has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFoldable #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command.Run where\n\nimport Control.Arrow ((&&&))\nimport Control.Exception (Exception, bracket)\nimport Control.Lens (ifor, (.~), (&), view)\nimport Control.Concurrent (forkIO)\nimport Control.Monad (filterM, void)\nimport Control.Monad.Except (runExceptT, throwError)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Reader (MonadIO)\nimport Data.Bifoldable (bifoldr1)\nimport Data.Bifunctor (bimap)\nimport Data.Coerce (coerce)\nimport Data.Default (def)\nimport Data.Foldable (fold, for_, toList)\nimport Data.Functor.Identity (runIdentity)\nimport Data.List (intercalate)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Either\nimport qualified Data.List.NonEmpty as NE\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport qualified Data.Map.Monoidal as MMap\nimport Data.Maybe (catMaybes, fromMaybe, mapMaybe)\nimport Data.Ord (comparing)\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Time.Clock (getCurrentTime)\nimport Data.Time.Format (formatTime, defaultTimeLocale)\nimport Data.Traversable (for)\nimport Debug.Trace (trace)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Compiler (CompilerFlavor(..), perCompilerFlavorToList, PerCompilerFlavor)\n#else\nimport Distribution.Compiler (CompilerFlavor(..), PerCompilerFlavor)\n#endif\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Fields.ParseResult (runParseResult)\n#else\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription, runParseResult)\n#endif\nimport Distribution.Pretty (prettyShow)\nimport Distribution.Simple.Compiler (PackageDB (GlobalPackageDB))\nimport Distribution.Simple.Configure (configCompilerEx, getInstalledPackages)\nimport Distribution.Simple.PackageIndex (InstalledPackageIndex, lookupDependency)\nimport Distribution.Simple.Program.Db (defaultProgramDb)\nimport qualified Distribution.System as Dist\nimport Distribution.Types.BuildInfo (buildable, cppOptions, defaultExtensions, defaultLanguage, hsSourceDirs, options, targetBuildDepends)\nimport Distribution.Types.CondTree (simplifyCondTree)\nimport Distribution.Types.Dependency (Dependency (..), depPkgName)\nimport Distribution.Parsec.Warning (PWarning)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Types.GenericPackageDescription.Lens (ConfVar (Arch, Impl, OS), condLibrary)\n#else\nimport Distribution.Types.GenericPackageDescription (condLibrary)\nimport Distribution.Types.ConfVar (ConfVar (Arch, Impl, OS))\n#endif\nimport Distribution.Types.InstalledPackageInfo (compatPackageKey)\nimport Distribution.Types.Library (libBuildInfo)\nimport Distribution.Types.LibraryName (LibraryName(..))\nimport Distribution.Types.PackageName (mkPackageName)\nimport Distribution.Types.VersionRange (anyVersion)\nimport Distribution.Utils.Generic (toUTF8BS, readUTF8File)\n#if MIN_VERSION_Cabal(3,2,1)\nimport qualified Distribution.Parsec.Warning as Dist\n#else\nimport qualified Distribution.System as Dist\n#endif\nimport Distribution.Types.Dependency (Dependency (..), depPkgName, depVerRange)\nimport qualified Distribution.Verbosity as Verbosity (silent)\nimport qualified Hpack.Config as Hpack\nimport qualified Hpack.Render as Hpack\nimport qualified Hpack.Yaml as Hpack\nimport Language.Haskell.Extension (Extension, Language)\nimport qualified Network.Socket as Socket\nimport System.Directory\nimport System.Environment (getExecutablePath)\nimport System.FilePath\nimport qualified System.Info\nimport System.IO.Temp (withSystemTempDirectory)\n\nimport Obelisk.App (MonadObelisk, ObeliskError(..), getObelisk, runObelisk)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils (findExePath, ghcidExePath)\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\ndata CabalPackageInfo = CabalPackageInfo\n  { _cabalPackageInfo_packageFile :: FilePath\n  , _cabalPackageInfo_packageName :: T.Text\n  , _cabalPackageInfo_packageRoot :: FilePath\n  , _cabalPackageInfo_buildable :: Bool\n  , _cabalPackageInfo_sourceDirs :: NE.NonEmpty FilePath\n    -- ^ List of hs src dirs of the library component\n  , _cabalPackageInfo_defaultExtensions :: [Extension]\n    -- ^ List of globally enable extensions of the library component\n  , _cabalPackageInfo_defaultLanguage :: Maybe Language\n    -- ^ List of globally set languages of the library component\n  , _cabalPackageInfo_compilerOptions :: PerCompilerFlavor [String]\n    -- ^ List of compiler-specific options (e.g., the \"ghc-options\" field of the cabal file)\n  , _cabalPackageInfo_cppOptions :: [String]\n    -- ^ List of CPP (C Preprocessor) options (e.g. the \"cpp-options\" field of the cabal file)\n  , _cabalPackageInfo_buildDepends :: [Dependency]\n    -- ^ List of build dependencies listed in the cabal file\n  }\n\n-- | 'Bool' with a better name for its purpose.\ndata Interpret = Interpret_Interpret | Interpret_NoInterpret deriving (Eq, Ord, Show)\n\ntextInterpret :: Interpret -> Text\ntextInterpret = \\case\n  Interpret_Interpret -> \"Interpret\"\n  Interpret_NoInterpret -> \"NoInterpret\"\n\n-- | Describe a set of 'FilePath's as a tree to facilitate merging them in a convenient way.\ndata PathTree a = PathTree_Node\n  (Maybe a) -- An optional leaf at this point in the tree\n  (Map FilePath (PathTree a)) -- Branches to deeper leaves\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)\n\n-- | 2D ASCII drawing of a 'PathTree'. Adapted from Data.Tree.draw.\ndrawPathTree :: (a -> Text) -> PathTree a -> Text\ndrawPathTree showA (PathTree_Node _ ts0) = T.intercalate \"\\n\" $ goForest (Map.toList ts0)\n  where\n    annotated ma = maybe id (\\a b -> b <> \" [\" <> showA a <> \"]\") ma . T.pack\n    goTree (fp, PathTree_Node ma forest) = annotated ma fp : goForest (Map.toList forest)\n    goForest [] = []\n    goForest [tree] = shift \"\u2514\u2500 \" \"   \" (goTree tree)\n    goForest (tree:forest) = shift \"\u251c\u2500 \" \"\u2502  \" (goTree tree) <> goForest forest\n    shift first other = zipWith (<>) (first : repeat other)\n\n-- | Used to signal to obelisk that it's being invoked as a preprocessor\npreprocessorIdentifier :: String\npreprocessorIdentifier = \"__preprocessor-apply-packages\"\n\nprofile\n  :: MonadObelisk m\n  => String\n  -> [String]\n  -> m ()\nprofile profileBasePattern rtsFlags = withProjectRoot \".\" $ \\root -> do\n  putLog Debug \"Using profiled build of project.\"\n\n  outPath <- withSpinner \"Building profiled executable\" $\n    fmap (T.unpack . T.strip) $ readProcessAndLogStderr Debug $ setCwd (Just root) $ nixCmdProc $\n      NixCmd_Build $ def\n        & nixBuildConfig_outLink .~ OutLink_None\n        & nixCmdConfig_target .~ Target\n          { _target_path = Just \".\"\n          , _target_attr = Just \"__unstable__.profiledObRun\"\n          , _target_expr = Nothing\n          }\n  (assetType, assets) <- findProjectAssets root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  time <- liftIO getCurrentTime\n  let profileBaseName = formatTime defaultTimeLocale profileBasePattern time\n  liftIO $ createDirectoryIfMissing True $ takeDirectory $ root </> profileBaseName\n  putLog Debug $ \"Storing profiled data under base name of \" <> T.pack (root </> profileBaseName)\n  freePort <- getFreePort\n  runProcess_ $ setCwd (Just root) $ setDelegateCtlc True $ proc (outPath </> \"bin\" </> \"ob-run\") $\n    [ show freePort\n    , T.unpack assets\n    , profileBaseName\n    , \"+RTS\"\n    , \"-po\" <> profileBaseName\n    ] <> rtsFlags\n      <> [ \"-RTS\" ]\n\nrun\n  :: MonadObelisk m\n  => Maybe FilePath\n  -- ^ Certificate Directory path (optional)\n  -> Maybe Socket.PortNumber\n  -- ^ override the route's port number?\n  -> FilePath\n  -- ^ root folder\n  -> PathTree Interpret\n  -- ^ interpreted paths\n  -> m ()\nrun certDir portOverride root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  (assetType, assets) <- findProjectAssets root\n  manifestPkg <- parsePackagesOrFail . (:[]) . T.unpack =<< getHaskellManifestProjectPath root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  case assetType of\n    AssetSource_Derivation -> do\n      ob <- getObelisk\n      putLog Debug \"Starting static file derivation watcher...\"\n      void $ liftIO $ forkIO $ runObelisk ob $ watchStaticFilesDerivation root\n    _ -> pure ()\n  ghciArgs <- getGhciSessionSettings (pkgs <> manifestPkg) root\n  freePort <- getFreePort\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs -> do\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs $ Just $ unwords\n      [ \"Obelisk.Run.run (Obelisk.Run.defaultRunApp\"\n      , \"Backend.backend\"\n      , \"Frontend.frontend\"\n      , \"(Obelisk.Run.runServeAsset \" ++ show assets ++ \")\"\n      , \") { Obelisk.Run._runApp_backendPort =\", show freePort\n      ,   \", Obelisk.Run._runApp_forceFrontendPort =\", show portOverride\n      ,   \", Obelisk.Run._runApp_tlsCertDirectory =\", show certDir\n      , \"}\"\n      ]\n\nrunRepl :: MonadObelisk m => Maybe FilePath -> FilePath -> PathTree Interpret -> m ()\nrunRepl mUserGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  userCommands <- maybe (pure []) (fmap lines . liftIO . readFile) mUserGhciConfig\n  withGhciScriptArgs userCommands pkgs $ \\dotGhciArgs ->\n    runGhciRepl root pkgs (ghciArgs <> dotGhciArgs)\n\nrunWatch :: MonadObelisk m => FilePath -> PathTree Interpret -> m ()\nrunWatch root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs ->\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs Nothing\n\nexportGhciConfig :: MonadObelisk m => FilePath -> PathTree Interpret -> m [String]\nexportGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  getGhciSessionSettings pkgs root\n\nnixShellForInterpretPaths :: MonadObelisk m => Bool -> String -> FilePath -> PathTree Interpret -> Maybe String -> m ()\nnixShellForInterpretPaths isPure shell' root interpretPaths cmd = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  nixShellWithoutPkgs root isPure False (packageInfoToNamePathMap pkgs) shell' cmd\n\n-- | Like 'getLocalPkgs' but also parses them and fails if any of them can't be parsed.\ngetParsedLocalPkgs :: MonadObelisk m => FilePath -> PathTree Interpret -> m (NonEmpty CabalPackageInfo)\ngetParsedLocalPkgs root interpretPaths = parsePackagesOrFail =<< getLocalPkgs root interpretPaths\n\n-- | Relative paths to local packages of an obelisk project.\n--\n-- These are a combination of the obelisk predefined local packages,\n-- and any packages that the user has set with the @packages@ argument\n-- to the Nix @project@ function.\ngetLocalPkgs :: forall m. MonadObelisk m => FilePath -> PathTree Interpret -> m (Set FilePath)\ngetLocalPkgs root interpretPaths = do\n  putLog Debug $ [i|Finding packages with root ${root} and interpret paths:|] <> \"\\n\" <> drawPathTree textInterpret interpretPaths\n  obeliskPackagePaths <- runFind [\"-L\", root, \"-name\", \".obelisk\", \"-type\", \"d\"]\n\n  -- We do not want to find packages that are embedded inside other obelisk projects, unless that\n  -- obelisk project is our own.\n  obeliskPackageExclusions <- liftIO $ fmap Set.fromList $ traverse canonicalizePath $\n    filter (/= root) $ map takeDirectory obeliskPackagePaths\n  putLog Debug [i|Excluding obelisk packages: ${T.pack $ unwords $ Set.toList obeliskPackageExclusions}|]\n  let rootsAndExclusions = calcIntepretFinds \"\" interpretPaths\n\n  fmap fold $ for (MMap.toAscList rootsAndExclusions) $ \\(interpretPathRoot, exclusions) ->\n    let allExclusions = obeliskPackageExclusions\n          <> exclusions\n          <> Set.singleton (\"*\" </> attrCacheFileName)\n          <> Set.singleton (\"*\" </> \"lib/asset/manifest\") -- NB: obelisk-asset-manifest is excluded because it generates\n                                                          -- a module that in turn imports it. This will cause ob run to\n                                                          -- fail in its current implementation.\n    in fmap (Set.fromList . map normalise) $ runFind $\n      [\"-L\", interpretPathRoot, \"(\", \"-name\", \"*.cabal\", \"-o\", \"-name\", Hpack.packageConfig, \")\", \"-a\", \"-type\", \"f\"]\n      <> concat [[\"-not\", \"-path\", p </> \"*\"] | p <- toList allExclusions]\n  where\n    runFind args = do\n      (_exitCode, out, err) <- readCreateProcessWithExitCode $ proc findExePath args\n      putLog Debug $ T.strip $ T.pack err\n      pure $ map T.unpack $ T.lines $ T.strip $ T.pack out\n\n-- | Calculates a set of root 'FilePath's along with each one's corresponding set of exclusions.\n--   This is used when constructing a set of @find@ commands to run to produce a set of packages\n--   that matches the user's @--interpret@/@--no-interpret@ settings.\ncalcIntepretFinds :: FilePath -> PathTree Interpret -> MMap.MonoidalMap FilePath (Set FilePath)\ncalcIntepretFinds treeRoot0 tree0 = runIdentity $ go treeRoot0 tree0\n  where\n    go treeRoot tree = foldPathTreeFor (== Interpret_Interpret) treeRoot tree $ \\parent children -> do\n      exclusions <- foldPathTreeFor (== Interpret_NoInterpret) parent children $ \\parent' children' ->\n        pure $ Map.singleton parent' children'\n      deeperFinds <- Map.traverseWithKey go exclusions\n      pure $ MMap.singleton parent (Map.keysSet exclusions) <> fold (MMap.MonoidalMap deeperFinds)\n\n-- | Traverses a 'PathTree' and folds all leaves matching a given predicate.\nfoldPathTreeFor\n  :: forall m a b. (Applicative m, Monoid b)\n  => (a -> Bool)\n  -> FilePath\n  -> PathTree a\n  -> (FilePath -> PathTree a -> m b)\n  -> m b\nfoldPathTreeFor predicate parent children f = case children of\n  PathTree_Node (Just x) children' | predicate x -> f parent (PathTree_Node Nothing children')\n  PathTree_Node _ children' -> fmap fold $ flip Map.traverseWithKey children' $ \\k children'' ->\n    foldPathTreeFor predicate (parent </> k) children'' f\n\ndata GuessPackageFileError = GuessPackageFileError_Ambiguous [FilePath] | GuessPackageFileError_NotFound\n  deriving (Eq, Ord, Show)\ninstance Exception GuessPackageFileError\n\nnewtype HPackFilePath = HPackFilePath { unHPackFilePath :: FilePath } deriving (Eq, Ord, Show)\nnewtype CabalFilePath = CabalFilePath { unCabalFilePath :: FilePath } deriving (Eq, Ord, Show)\n\n-- | Given a directory, try to guess what the appropriate @.cabal@ or @package.yaml@ file is for the package.\nguessCabalPackageFile\n  :: (MonadIO m)\n  => FilePath -- ^ Directory or path to search for cabal package\n  -> m (Either GuessPackageFileError (Either CabalFilePath HPackFilePath))\nguessCabalPackageFile pkg = do\n  liftIO (doesDirectoryExist pkg) >>= \\case\n    False -> case cabalOrHpackFile pkg of\n      (Just hpack@(Right _)) -> pure $ Right hpack\n      (Just cabal@(Left (CabalFilePath cabalFilePath))) -> do\n        -- If the cabal file has a sibling hpack file, we use that instead\n        -- since running hpack often generates a sibling cabal file\n        let possibleHpackSibling = takeDirectory cabalFilePath </> Hpack.packageConfig\n        hasHpackSibling <- liftIO $ doesFileExist possibleHpackSibling\n        pure $ Right $ if hasHpackSibling then Right (HPackFilePath possibleHpackSibling) else cabal\n      Nothing -> pure $ Left GuessPackageFileError_NotFound\n    True -> do\n      candidates <- liftIO $\n            filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n        =<< mapMaybe (cabalOrHpackFile . (pkg </>)) <$> listDirectory pkg\n      pure $ case partitionEithers candidates of\n        ([hpack], _) -> Right $ Left hpack\n        ([], [cabal]) -> Right $ Right cabal\n        ([], []) -> Left GuessPackageFileError_NotFound\n        (hpacks, cabals) -> Left $ GuessPackageFileError_Ambiguous $ coerce hpacks <> coerce cabals\n\ncabalOrHpackFile :: FilePath -> Maybe (Either CabalFilePath HPackFilePath)\ncabalOrHpackFile = \\case\n  x | takeExtension x == \".cabal\" -> Just (Left $ CabalFilePath x)\n    | takeFileName x == Hpack.packageConfig -> Just (Right $ HPackFilePath x)\n    | otherwise -> Nothing\n\n-- | Parses the cabal package in a given directory.\n-- This automatically figures out which .cabal file or package.yaml (hpack) file to use in the given directory.\nparseCabalPackage\n  :: MonadObelisk m\n  => FilePath -- ^ Package directory\n  -> m (Maybe CabalPackageInfo)\nparseCabalPackage dir = parseCabalPackage' dir >>= \\case\n  Left err -> throwError (ObeliskError_Unstructured err)\n  Right (Just (warnings, pkgInfo)) -> do\n    for_ warnings $ putLog Warning . T.pack . show\n    pure $ Just pkgInfo\n  Right Nothing -> pure Nothing\n\n-- | Like 'parseCabalPackage' but returns errors and warnings directly so as to avoid 'MonadObelisk'.\nparseCabalPackage'\n  :: (MonadIO m)\n  => FilePath -- ^ Package directory\n  -> m (Either T.Text (Maybe ([PWarning], CabalPackageInfo)))\nparseCabalPackage' pkg = runExceptT $ do\n  (cabalContents, packageFile, packageName) <- guessCabalPackageFile pkg >>= \\case\n    Left GuessPackageFileError_NotFound -> throwError $ \"No .cabal or package.yaml file found in \" <> T.pack pkg\n    Left (GuessPackageFileError_Ambiguous _) -> throwError $ \"Unable to determine which .cabal file to use in \" <> T.pack pkg\n    Right (Left (CabalFilePath file)) -> (, file, takeBaseName file) <$> liftIO (readUTF8File file)\n    Right (Right (HPackFilePath file)) -> do\n      let\n        decodeOptions = Hpack.DecodeOptions (Hpack.ProgramName \"ob\") file Nothing Hpack.decodeYaml\n      liftIO (Hpack.readPackageConfig decodeOptions) >>= \\case\n        Left err -> throwError $ T.pack $ \"Failed to parse \" <> file <> \": \" <> err\n        Right (Hpack.DecodeResult hpackPackage _ _ _) -> pure (Hpack.renderPackage [] hpackPackage, file, Hpack.packageName hpackPackage)\n\n  let\n    (warnings, result) = runParseResult $ parseGenericPackageDescription $ toUTF8BS cabalContents\n    osConfVar = case System.Info.os of\n      \"linux\" -> Just Dist.Linux\n      \"darwin\" -> Just Dist.OSX\n      _ -> trace \"Unrecgonized System.Info.os\" Nothing\n    archConfVar = Just Dist.X86_64 -- TODO: Actually infer this\n    evalConfVar v = Right $ case v of\n      OS osVar -> Just osVar == osConfVar\n      Arch archVar -> Just archVar == archConfVar\n      Impl GHC _ -> True -- TODO: Actually check version range\n      _ -> False\n#if MIN_VERSION_Cabal(3,2,1)\n  case (view condLibrary) <$> result of\n#else\n  case condLibrary <$> result of\n#endif\n    Right (Just condLib) -> do\n      let (_, lib) = simplifyCondTree evalConfVar condLib\n      pure $ Just $ (warnings,) $ CabalPackageInfo\n        { _cabalPackageInfo_packageName = T.pack packageName\n        , _cabalPackageInfo_packageFile = packageFile\n        , _cabalPackageInfo_packageRoot = takeDirectory packageFile\n        , _cabalPackageInfo_buildable = buildable $ libBuildInfo lib\n        , _cabalPackageInfo_sourceDirs =\n            fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib\n        , _cabalPackageInfo_defaultExtensions =\n            defaultExtensions $ libBuildInfo lib\n        , _cabalPackageInfo_defaultLanguage =\n            defaultLanguage $ libBuildInfo lib\n        , _cabalPackageInfo_compilerOptions =\n            options $ libBuildInfo lib\n        , _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib\n        , _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib\n        }\n    Right Nothing -> pure Nothing\n    Left (_, errors) ->\n      throwError $ T.pack $ \"Failed to parse \" <> packageFile <> \":\\n\" <> unlines (map show $ toList errors)\n\nparsePackagesOrFail :: (MonadObelisk m, Foldable f) => f FilePath -> m (NE.NonEmpty CabalPackageInfo)\nparsePackagesOrFail dirs' = do\n  packageInfos' <- fmap catMaybes $ for dirs $ \\dir -> do\n    flip fmap (parseCabalPackage dir) $ \\case\n      Just packageInfo\n        | _cabalPackageInfo_buildable packageInfo -> Just packageInfo\n      _ -> Nothing\n\n  -- Sort duplicate packages such that we prefer shorter paths, but fall back to alphabetical ordering.\n  let packagesByName = Map.map (NE.sortBy $ comparing $ \\p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n                     $ Map.fromListWith (<>) [(_cabalPackageInfo_packageName p, p NE.:| []) | p <- packageInfos']\n  unambiguous <- ifor packagesByName $ \\packageName ps -> case ps of\n    p NE.:| [] -> pure p -- No ambiguity here\n    p NE.:| _ -> do\n      let chosenText = \"  [Chosen] \"\n          prefix p'\n            | _cabalPackageInfo_packageFile p' == _cabalPackageInfo_packageFile p = chosenText\n            | otherwise = T.map (const ' ') chosenText\n      putLog Warning $ T.unlines $\n        \"Packages named '\" <> packageName <> \"' appear in \" <> T.pack (show $ length ps) <> \" different locations: \"\n        : map (\\p' -> prefix p' <> T.pack (_cabalPackageInfo_packageFile p')) (toList ps)\n      pure p\n\n  packageInfos <- case NE.nonEmpty $ toList unambiguous of\n    Nothing -> failWith $ T.pack $\n      \"No valid, buildable packages found\" <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n    Just xs -> pure xs\n\n  pure packageInfos\n  where\n    dirs = toList dirs'\n\npackageInfoToNamePathMap :: Foldable f => f CabalPackageInfo -> Map Text FilePath\npackageInfoToNamePathMap = Map.fromList . map (_cabalPackageInfo_packageName &&& _cabalPackageInfo_packageRoot) . toList\n\n-- Like 'withGhciScript' but provides the precise ghci arguments to add to a ghci session\nwithGhciScriptArgs\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ User commands to insert into .ghci\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> ([String] -> m ()) -- ^ Action to run with the extra ghci arguments\n  -> m ()\nwithGhciScriptArgs userCommands packageInfos f =\n  withGhciScript (loadPreludeManually ++ userCommands) packageInfos $ \\fp ->\n    f [\"-XNoImplicitPrelude\", \"-ghci-script\", fp]\n  where\n    -- These lines must be first and allow the session to support a custom Prelude when @-XNoImplicitPrelude@\n    -- is passed to the ghci session.\n    loadPreludeManually =\n      [ \":add Prelude\" -- @:add@ is used because it's less noisy when there is no custom Prelude\n      , \":set -XImplicitPrelude\" -- Turn the default setting on\n      ]\n\n-- | Create ghci configuration to load the given packages\nwithGhciScript\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ Commands to prefix to file\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> (FilePath -> m ()) -- ^ Action to run with the path to generated temporary .ghci\n  -> m ()\nwithGhciScript preCommands (toList -> packageInfos) f =\n  withSystemTempDirectory \"ob-ghci\" $ \\fp -> do\n    let dotGhciPath = fp </> \".ghci\"\n    liftIO $ writeFile dotGhciPath dotGhci\n    f dotGhciPath\n  where\n    packageNames = Set.fromList $ map _cabalPackageInfo_packageName packageInfos\n    modulesToLoad = mconcat\n      [ [ \"Obelisk.Run\" | \"obelisk-run\" `Set.member` packageNames ]\n      , [ \"Backend\" | \"backend\" `Set.member` packageNames ]\n      , [ \"Frontend\" | \"frontend\" `Set.member` packageNames ]\n      ]\n    dotGhci = unlines $\n      preCommands <>\n      [ if null modulesToLoad then \"\" else \":load \" <> unwords modulesToLoad\n      , \"import qualified Obelisk.Run\"\n      , \"import qualified Frontend\"\n      , \"import qualified Backend\"\n      ]\n\n-- | Builds a list of options to pass to ghci or set in .ghci file that configures\n-- the preprocessor and source includes.\ngetGhciSessionSettings\n  :: (MonadObelisk m, Foldable f)\n  => f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> FilePath -- ^ All paths will be relative to this path\n  -> m [String]\ngetGhciSessionSettings (toList -> packageInfos) pathBase = do\n  selfExe <- liftIO $ canonicalizePath =<< getExecutablePath\n  installedPackageIndex <- loadPackageIndex packageInfos pathBase\n\n  (pkgFiles, pkgSrcPaths :: [NonEmpty FilePath]) <- fmap unzip $ liftIO $ for packageInfos $ \\pkg -> do\n    canonicalSrcDirs <- traverse canonicalizePath $ (_cabalPackageInfo_packageRoot pkg </>) <$> _cabalPackageInfo_sourceDirs pkg\n    canonicalPkgFile <- canonicalizePath $ _cabalPackageInfo_packageFile pkg\n    pure (canonicalPkgFile, canonicalSrcDirs)\n\n  pure\n    $  baseGhciOptions\n    <> [\"-DOBELISK_ASSET_PASSTHRU\"] -- For passthrough static assets\n    <> [\"-F\", \"-pgmF\", selfExe, \"-optF\", preprocessorIdentifier]\n    <> concatMap (\\p -> [\"-optF\", p]) pkgFiles\n    <> [\"-i\" <> intercalate \":\" (concatMap toList pkgSrcPaths)]\n    <> concatMap (\\packageId -> [\"-package-id\", packageId ])\n                 (packageIds installedPackageIndex)\n  where\n    -- Package names we're building and not needed from the package DB\n    packageNames =\n      map (mkPackageName . T.unpack . _cabalPackageInfo_packageName)\n          packageInfos\n    packageIds installedPackageIndex = Set.toList $ Set.fromList $\n      map (dependencyPackageId installedPackageIndex) $\n          filter ((`notElem` packageNames) . depPkgName) $\n          concatMap _cabalPackageInfo_buildDepends packageInfos <>\n            [Dependency (mkPackageName \"obelisk-run\") anyVersion (Set.singleton LMainLibName)]\n    dependencyPackageId installedPackageIndex dep =\n      case lookupDependency installedPackageIndex (depPkgName dep) (depVerRange dep) of\n        ((_version,installedPackageInfo:_) :_) ->\n          compatPackageKey installedPackageInfo\n        _ -> error $ \"Couldn't resolve dependency for \" <> prettyShow dep\n\n\n-- Load the package index used by the GHC in this path's nix project\nloadPackageIndex :: MonadObelisk m => [CabalPackageInfo] -> FilePath -> m InstalledPackageIndex\nloadPackageIndex packageInfos root = do\n  ghcPath <- getPathInNixEnvironment \"bash -c 'type -p ghc'\"\n  ghcPkgPath <- getPathInNixEnvironment \"bash -c 'type -p ghc-pkg'\"\n  (compiler, _platform, programDb) <- liftIO\n    $ configCompilerEx (Just GHC) (Just ghcPath) (Just ghcPkgPath) defaultProgramDb Verbosity.silent\n  liftIO $ getInstalledPackages Verbosity.silent compiler [GlobalPackageDB] programDb\n  where\n    getPathInNixEnvironment cmd = do\n      path <- readProcessAndLogStderr Debug =<< mkObNixShellProc root False True (packageInfoToNamePathMap packageInfos) \"ghc\" (Just cmd)\n      liftIO $ canonicalizePath $ T.unpack $ T.strip path\n\nbaseGhciOptions :: [String]\nbaseGhciOptions =\n  [ \"-ignore-dot-ghci\"\n  , \"-no-user-package-db\"\n  , \"-hide-all-packages\"\n  , \"-package-env\", \"-\"\n  ]\n\n-- | Run ghci repl\nrunGhciRepl\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> [String] -- ^ GHCi arguments\n  -> m ()\nrunGhciRepl root (toList -> packages) ghciArgs =\n  -- NOTE: We do *not* want to use $(staticWhich \"ghci\") here because we need the\n  -- ghc that is provided by the shell in the user's project.\n  nixShellWithoutPkgs root True True (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ \"ghci\" : ghciArgs\n\n-- | Run ghcid\nrunGhcid\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should we chdir to root when running this process?\n  -> [String] -- ^ GHCi arguments\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> Maybe String -- ^ Optional command to run at every reload\n  -> m ()\nrunGhcid root chdirToRoot ghciArgs (toList -> packages) mcmd =\n  nixShellWithoutPkgs root True chdirToRoot (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ ghcidExePath : opts\n  where\n    opts = concat\n      [ [\"-W\"]\n      , [\"--outputfile=ghcid-output.txt\"]\n      , map (\\x -> \"--reload=\" <> x) reloadFiles\n      , map (\\x -> \"--restart=\" <> x) restartFiles\n      , maybe [] (\\cmd -> [\"--test=\" <> cmd]) mcmd\n      -- N.B. the subcommand to ghcid has to be itself escaped.\n      -- We have to use 'shEscape' instead of 'bashEscape' because\n      -- ghcid invokes System.Process with a shell command, which uses @\\/bin\\/sh@\n      -- instead of the @bash@ we have in scope.\n      -- This is not guaranteed to be bash on non-NixOS systems.\n      , [\"--command=\" <> unwords (fmap shEscape (\"ghci\" : ghciArgs))]\n      ]\n    adjustRoot x = if chdirToRoot then makeRelative root x else x\n    reloadFiles = map adjustRoot [root </> \"config\"]\n    restartFiles = map (adjustRoot . _cabalPackageInfo_packageFile) packages\n\ngetFreePort :: MonadIO m => m Socket.PortNumber\ngetFreePort = liftIO $ Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close Socket.socketPort\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      return sock\n\n\n-- | Convert a 'FilePath' into a 'PathTree'.\npathToTree :: a -> FilePath -> PathTree a\npathToTree a p = go $ splitDirectories p\n  where\n    go [] = PathTree_Node (Just a) mempty\n    go (x : xs) = PathTree_Node Nothing $ Map.singleton x $ go xs\n\n-- | Like 'zipWith' but pads with a padding value instead of stopping on the shortest list.\nzipDefaultWith :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]\nzipDefaultWith _da _db _f []     []     = []\nzipDefaultWith  da  db  f (a:as) []     = f  a db : zipDefaultWith da db f as []\nzipDefaultWith  da  db  f []     (b:bs) = f da  b : zipDefaultWith da db f [] bs\nzipDefaultWith  da  db  f (a:as) (b:bs) = f  a  b : zipDefaultWith da db f as bs\n\n-- | Makes the first absolute path relative to the second absolute path.\n--\n-- Both input paths MUST be absolute.\n--\n-- Unlike 'makeRelative' this does not merely strip prefixes. It will introduce\n-- enough @..@ paths to make the resulting path truly relative in virtually every\n-- case. The only exception is on Windows when the two paths are on different\n-- drives. In this case the resulting path may be absolute.\nrelativeTo :: FilePath -> FilePath -> FilePath\nrelativeTo dir base\n  = bifoldr1 (</>)\n  $ bimap (collapse . (\"..\" <$) . catMaybes) (collapse . catMaybes)\n  $ unzip\n  $ dropWhile (\\(a,b) -> a == b)\n  $ zipDefaultWith Nothing Nothing (,)\n    (map Just $ splitDirectories base)\n    (map Just $ splitDirectories dir)\n  where collapse = foldr (</>) \"\"\n",
              "suggestions": [
                {
                  "target_snippet": "data PathTree a = PathTree_Node (Maybe a) (Map FilePath (PathTree a)) deriving (Eq, Ord, Show, Functor, Foldable, Traversable)",
                  "refactored_suggestion": "data PathTree a = PathTreeNode (Maybe a) (Map FilePath (PathTree a)) deriving (Eq, Ord, Show, Functor, Foldable, Traversable)",
                  "confidence": 0.9,
                  "justification": "The suggestion to use camelCase for the constructor 'PathTree_Node' to 'PathTreeNode' improves standard Haskell naming conventions, making the code more idiomatic and consistent."
                },
                {
                  "target_snippet": "(warnings,) $ CabalPackageInfo {_cabalPackageInfo_packageName = T.pack packageName, _cabalPackageInfo_packageFile = packageFile, _cabalPackageInfo_packageRoot = takeDirectory packageFile, _cabalPackageInfo_buildable = buildable $ libBuildInfo lib, _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib, _cabalPackageInfo_defaultExtensions = defaultExtensions $ libBuildInfo lib, _cabalPackageInfo_defaultLanguage = defaultLanguage $ libBuildInfo lib, _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib, _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib, _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib}",
                  "refactored_suggestion": "(warnings, CabalPackageInfo {_cabalPackageInfo_packageName = T.pack packageName, _cabalPackageInfo_packageFile = packageFile, _cabalPackageInfo_packageRoot = takeDirectory packageFile, _cabalPackageInfo_buildable = buildable $ libBuildInfo lib, _cabalPackageInfo_sourceDirs = fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib, _cabalPackageInfo_defaultExtensions = defaultExtensions $ libBuildInfo lib, _cabalPackageInfo_defaultLanguage = defaultLanguage $ libBuildInfo lib, _cabalPackageInfo_compilerOptions = options $ libBuildInfo lib, _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib, _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib})",
                  "confidence": 0.8,
                  "justification": "The parenthesized grouping and indentation improves readability by clearly separating the tuple components, making it easier to visually parse the structure of the code."
                },
                {
                  "target_snippet": "-- | Used to signal to obelisk that it's being invoked as a preprocessor\npreprocessorIdentifier :: String\npreprocessorIdentifier = \"__preprocessor-apply-packages\"",
                  "refactored_suggestion": "-- reason: Unused constant\n-- | Used to signal to obelisk that it's being invoked as a preprocessor\n-- preprocessorIdentifier :: String\n-- preprocessorIdentifier = \"__preprocessor-apply-packages\"",
                  "confidence": 0.7,
                  "justification": "Static analysis indicates that 'preprocessorIdentifier' is defined but never used in the file. Commenting it out avoids potential confusion while retaining the code for future use."
                },
                {
                  "target_snippet": "data Interpret = Interpret_Interpret | Interpret_NoInterpret deriving (Eq, Ord, Show)",
                  "refactored_suggestion": "-- reason: 'Interpret' type is not used in the code and can be removed.\n{- Removed unused 'Interpret' data type. -}\n",
                  "confidence": 0.9,
                  "justification": "After analysis of the full code, the 'Interpret' data type appears to be unused. Removing unused code improves maintainability."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveFoldable #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE PackageImports #-}\nmodule Obelisk.Command.Run where\n\nimport Control.Arrow ((&&&))\nimport Control.Exception (Exception, bracket)\nimport Control.Lens (ifor, (.~), (&), view)\nimport Control.Concurrent (forkIO)\nimport Control.Monad (filterM, void)\nimport Control.Monad.Except (runExceptT, throwError)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Reader (MonadIO)\nimport Data.Bifoldable (bifoldr1)\nimport Data.Bifunctor (bimap)\nimport Data.Coerce (coerce)\nimport Data.Default (def)\nimport Data.Foldable (fold, for_, toList)\nimport Data.Functor.Identity (runIdentity)\nimport Data.List (intercalate)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Either\nimport qualified Data.List.NonEmpty as NE\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport qualified Data.Map.Monoidal as MMap\nimport Data.Maybe (catMaybes, fromMaybe, mapMaybe)\nimport Data.Ord (comparing)\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport Data.String.Here.Interpolated (i)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Time.Clock (getCurrentTime)\nimport Data.Time.Format (formatTime, defaultTimeLocale)\nimport Data.Traversable (for)\nimport Debug.Trace (trace)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Compiler (CompilerFlavor(..), perCompilerFlavorToList, PerCompilerFlavor)\n#else\nimport Distribution.Compiler (CompilerFlavor(..), PerCompilerFlavor)\n#endif\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Fields.ParseResult (runParseResult)\n#else\nimport Distribution.PackageDescription.Parsec (parseGenericPackageDescription, runParseResult)\n#endif\nimport Distribution.Pretty (prettyShow)\nimport Distribution.Simple.Compiler (PackageDB (GlobalPackageDB))\nimport Distribution.Simple.Configure (configCompilerEx, getInstalledPackages)\nimport Distribution.Simple.PackageIndex (InstalledPackageIndex, lookupDependency)\nimport Distribution.Simple.Program.Db (defaultProgramDb)\nimport qualified Distribution.System as Dist\nimport Distribution.Types.BuildInfo (buildable, cppOptions, defaultExtensions, defaultLanguage, hsSourceDirs, options, targetBuildDepends)\nimport Distribution.Types.CondTree (simplifyCondTree)\nimport Distribution.Types.Dependency (Dependency (..), depPkgName)\nimport Distribution.Parsec.Warning (PWarning)\n#if MIN_VERSION_Cabal(3,2,1)\nimport Distribution.Types.GenericPackageDescription.Lens (ConfVar (Arch, Impl, OS), condLibrary)\n#else\nimport Distribution.Types.GenericPackageDescription (condLibrary)\nimport Distribution.Types.ConfVar (ConfVar (Arch, Impl, OS))\n#endif\nimport Distribution.Types.InstalledPackageInfo (compatPackageKey)\nimport Distribution.Types.Library (libBuildInfo)\nimport Distribution.Types.LibraryName (LibraryName(..))\nimport Distribution.Types.PackageName (mkPackageName)\nimport Distribution.Types.VersionRange (anyVersion)\nimport Distribution.Utils.Generic (toUTF8BS, readUTF8File)\n#if MIN_VERSION_Cabal(3,2,1)\nimport qualified Distribution.Parsec.Warning as Dist\n#else\nimport qualified Distribution.System as Dist\n#endif\nimport Distribution.Types.Dependency (Dependency (..), depPkgName, depVerRange)\nimport qualified Distribution.Verbosity as Verbosity (silent)\nimport qualified Hpack.Config as Hpack\nimport qualified Hpack.Render as Hpack\nimport qualified Hpack.Yaml as Hpack\nimport Language.Haskell.Extension (Extension, Language)\nimport qualified Network.Socket as Socket\nimport System.Directory\nimport System.Environment (getExecutablePath)\nimport System.FilePath\nimport qualified System.Info\nimport System.IO.Temp (withSystemTempDirectory)\n\nimport Obelisk.App (MonadObelisk, ObeliskError(..), getObelisk, runObelisk)\nimport Obelisk.Command.Nix\nimport Obelisk.Command.Project\nimport Obelisk.Command.Utils (findExePath, ghcidExePath)\nimport \"nix-thunk\" Nix.Thunk\nimport Cli.Extras\n\ndata CabalPackageInfo = CabalPackageInfo\n  { _cabalPackageInfo_packageFile :: FilePath\n  , _cabalPackageInfo_packageName :: T.Text\n  , _cabalPackageInfo_packageRoot :: FilePath\n  , _cabalPackageInfo_buildable :: Bool\n  , _cabalPackageInfo_sourceDirs :: NE.NonEmpty FilePath\n    -- ^ List of hs src dirs of the library component\n  , _cabalPackageInfo_defaultExtensions :: [Extension]\n    -- ^ List of globally enable extensions of the library component\n  , _cabalPackageInfo_defaultLanguage :: Maybe Language\n    -- ^ List of globally set languages of the library component\n  , _cabalPackageInfo_compilerOptions :: PerCompilerFlavor [String]\n    -- ^ List of compiler-specific options (e.g., the \"ghc-options\" field of the cabal file)\n  , _cabalPackageInfo_cppOptions :: [String]\n    -- ^ List of CPP (C Preprocessor) options (e.g. the \"cpp-options\" field of the cabal file)\n  , _cabalPackageInfo_buildDepends :: [Dependency]\n    -- ^ List of build dependencies listed in the cabal file\n  }\n\n-- | 'Bool' with a better name for its purpose.\n-- reason: 'Interpret' type is not used in the code and can be removed.\n{- Removed unused 'Interpret' data type. -}\n\n\ntextInterpret :: Interpret -> Text\ntextInterpret = \\case\n  Interpret_Interpret -> \"Interpret\"\n  Interpret_NoInterpret -> \"NoInterpret\"\n\n-- | Describe a set of 'FilePath's as a tree to facilitate merging them in a convenient way.\ndata PathTree a = PathTree_Node\n  (Maybe a) -- An optional leaf at this point in the tree\n  (Map FilePath (PathTree a)) -- Branches to deeper leaves\n  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)\n\n-- | 2D ASCII drawing of a 'PathTree'. Adapted from Data.Tree.draw.\ndrawPathTree :: (a -> Text) -> PathTree a -> Text\ndrawPathTree showA (PathTree_Node _ ts0) = T.intercalate \"\\n\" $ goForest (Map.toList ts0)\n  where\n    annotated ma = maybe id (\\a b -> b <> \" [\" <> showA a <> \"]\") ma . T.pack\n    goTree (fp, PathTree_Node ma forest) = annotated ma fp : goForest (Map.toList forest)\n    goForest [] = []\n    goForest [tree] = shift \"\u2514\u2500 \" \"   \" (goTree tree)\n    goForest (tree:forest) = shift \"\u251c\u2500 \" \"\u2502  \" (goTree tree) <> goForest forest\n    shift first other = zipWith (<>) (first : repeat other)\n\n-- reason: Unused constant\n-- | Used to signal to obelisk that it's being invoked as a preprocessor\n-- preprocessorIdentifier :: String\n-- preprocessorIdentifier = \"__preprocessor-apply-packages\"\n\nprofile\n  :: MonadObelisk m\n  => String\n  -> [String]\n  -> m ()\nprofile profileBasePattern rtsFlags = withProjectRoot \".\" $ \\root -> do\n  putLog Debug \"Using profiled build of project.\"\n\n  outPath <- withSpinner \"Building profiled executable\" $\n    fmap (T.unpack . T.strip) $ readProcessAndLogStderr Debug $ setCwd (Just root) $ nixCmdProc $\n      NixCmd_Build $ def\n        & nixBuildConfig_outLink .~ OutLink_None\n        & nixCmdConfig_target .~ Target\n          { _target_path = Just \".\"\n          , _target_attr = Just \"__unstable__.profiledObRun\"\n          , _target_expr = Nothing\n          }\n  (assetType, assets) <- findProjectAssets root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  time <- liftIO getCurrentTime\n  let profileBaseName = formatTime defaultTimeLocale profileBasePattern time\n  liftIO $ createDirectoryIfMissing True $ takeDirectory $ root </> profileBaseName\n  putLog Debug $ \"Storing profiled data under base name of \" <> T.pack (root </> profileBaseName)\n  freePort <- getFreePort\n  runProcess_ $ setCwd (Just root) $ setDelegateCtlc True $ proc (outPath </> \"bin\" </> \"ob-run\") $\n    [ show freePort\n    , T.unpack assets\n    , profileBaseName\n    , \"+RTS\"\n    , \"-po\" <> profileBaseName\n    ] <> rtsFlags\n      <> [ \"-RTS\" ]\n\nrun\n  :: MonadObelisk m\n  => Maybe FilePath\n  -- ^ Certificate Directory path (optional)\n  -> Maybe Socket.PortNumber\n  -- ^ override the route's port number?\n  -> FilePath\n  -- ^ root folder\n  -> PathTree Interpret\n  -- ^ interpreted paths\n  -> m ()\nrun certDir portOverride root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  (assetType, assets) <- findProjectAssets root\n  manifestPkg <- parsePackagesOrFail . (:[]) . T.unpack =<< getHaskellManifestProjectPath root\n  putLog Debug $ describeImpureAssetSource assetType assets\n  case assetType of\n    AssetSource_Derivation -> do\n      ob <- getObelisk\n      putLog Debug \"Starting static file derivation watcher...\"\n      void $ liftIO $ forkIO $ runObelisk ob $ watchStaticFilesDerivation root\n    _ -> pure ()\n  ghciArgs <- getGhciSessionSettings (pkgs <> manifestPkg) root\n  freePort <- getFreePort\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs -> do\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs $ Just $ unwords\n      [ \"Obelisk.Run.run (Obelisk.Run.defaultRunApp\"\n      , \"Backend.backend\"\n      , \"Frontend.frontend\"\n      , \"(Obelisk.Run.runServeAsset \" ++ show assets ++ \")\"\n      , \") { Obelisk.Run._runApp_backendPort =\", show freePort\n      ,   \", Obelisk.Run._runApp_forceFrontendPort =\", show portOverride\n      ,   \", Obelisk.Run._runApp_tlsCertDirectory =\", show certDir\n      , \"}\"\n      ]\n\nrunRepl :: MonadObelisk m => Maybe FilePath -> FilePath -> PathTree Interpret -> m ()\nrunRepl mUserGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  userCommands <- maybe (pure []) (fmap lines . liftIO . readFile) mUserGhciConfig\n  withGhciScriptArgs userCommands pkgs $ \\dotGhciArgs ->\n    runGhciRepl root pkgs (ghciArgs <> dotGhciArgs)\n\nrunWatch :: MonadObelisk m => FilePath -> PathTree Interpret -> m ()\nrunWatch root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  ghciArgs <- getGhciSessionSettings pkgs root\n  withGhciScriptArgs [] pkgs $ \\dotGhciArgs ->\n    runGhcid root True (ghciArgs <> dotGhciArgs) pkgs Nothing\n\nexportGhciConfig :: MonadObelisk m => FilePath -> PathTree Interpret -> m [String]\nexportGhciConfig root interpretPaths = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  getGhciSessionSettings pkgs root\n\nnixShellForInterpretPaths :: MonadObelisk m => Bool -> String -> FilePath -> PathTree Interpret -> Maybe String -> m ()\nnixShellForInterpretPaths isPure shell' root interpretPaths cmd = do\n  pkgs <- getParsedLocalPkgs root interpretPaths\n  nixShellWithoutPkgs root isPure False (packageInfoToNamePathMap pkgs) shell' cmd\n\n-- | Like 'getLocalPkgs' but also parses them and fails if any of them can't be parsed.\ngetParsedLocalPkgs :: MonadObelisk m => FilePath -> PathTree Interpret -> m (NonEmpty CabalPackageInfo)\ngetParsedLocalPkgs root interpretPaths = parsePackagesOrFail =<< getLocalPkgs root interpretPaths\n\n-- | Relative paths to local packages of an obelisk project.\n--\n-- These are a combination of the obelisk predefined local packages,\n-- and any packages that the user has set with the @packages@ argument\n-- to the Nix @project@ function.\ngetLocalPkgs :: forall m. MonadObelisk m => FilePath -> PathTree Interpret -> m (Set FilePath)\ngetLocalPkgs root interpretPaths = do\n  putLog Debug $ [i|Finding packages with root ${root} and interpret paths:|] <> \"\\n\" <> drawPathTree textInterpret interpretPaths\n  obeliskPackagePaths <- runFind [\"-L\", root, \"-name\", \".obelisk\", \"-type\", \"d\"]\n\n  -- We do not want to find packages that are embedded inside other obelisk projects, unless that\n  -- obelisk project is our own.\n  obeliskPackageExclusions <- liftIO $ fmap Set.fromList $ traverse canonicalizePath $\n    filter (/= root) $ map takeDirectory obeliskPackagePaths\n  putLog Debug [i|Excluding obelisk packages: ${T.pack $ unwords $ Set.toList obeliskPackageExclusions}|]\n  let rootsAndExclusions = calcIntepretFinds \"\" interpretPaths\n\n  fmap fold $ for (MMap.toAscList rootsAndExclusions) $ \\(interpretPathRoot, exclusions) ->\n    let allExclusions = obeliskPackageExclusions\n          <> exclusions\n          <> Set.singleton (\"*\" </> attrCacheFileName)\n          <> Set.singleton (\"*\" </> \"lib/asset/manifest\") -- NB: obelisk-asset-manifest is excluded because it generates\n                                                          -- a module that in turn imports it. This will cause ob run to\n                                                          -- fail in its current implementation.\n    in fmap (Set.fromList . map normalise) $ runFind $\n      [\"-L\", interpretPathRoot, \"(\", \"-name\", \"*.cabal\", \"-o\", \"-name\", Hpack.packageConfig, \")\", \"-a\", \"-type\", \"f\"]\n      <> concat [[\"-not\", \"-path\", p </> \"*\"] | p <- toList allExclusions]\n  where\n    runFind args = do\n      (_exitCode, out, err) <- readCreateProcessWithExitCode $ proc findExePath args\n      putLog Debug $ T.strip $ T.pack err\n      pure $ map T.unpack $ T.lines $ T.strip $ T.pack out\n\n-- | Calculates a set of root 'FilePath's along with each one's corresponding set of exclusions.\n--   This is used when constructing a set of @find@ commands to run to produce a set of packages\n--   that matches the user's @--interpret@/@--no-interpret@ settings.\ncalcIntepretFinds :: FilePath -> PathTree Interpret -> MMap.MonoidalMap FilePath (Set FilePath)\ncalcIntepretFinds treeRoot0 tree0 = runIdentity $ go treeRoot0 tree0\n  where\n    go treeRoot tree = foldPathTreeFor (== Interpret_Interpret) treeRoot tree $ \\parent children -> do\n      exclusions <- foldPathTreeFor (== Interpret_NoInterpret) parent children $ \\parent' children' ->\n        pure $ Map.singleton parent' children'\n      deeperFinds <- Map.traverseWithKey go exclusions\n      pure $ MMap.singleton parent (Map.keysSet exclusions) <> fold (MMap.MonoidalMap deeperFinds)\n\n-- | Traverses a 'PathTree' and folds all leaves matching a given predicate.\nfoldPathTreeFor\n  :: forall m a b. (Applicative m, Monoid b)\n  => (a -> Bool)\n  -> FilePath\n  -> PathTree a\n  -> (FilePath -> PathTree a -> m b)\n  -> m b\nfoldPathTreeFor predicate parent children f = case children of\n  PathTree_Node (Just x) children' | predicate x -> f parent (PathTree_Node Nothing children')\n  PathTree_Node _ children' -> fmap fold $ flip Map.traverseWithKey children' $ \\k children'' ->\n    foldPathTreeFor predicate (parent </> k) children'' f\n\ndata GuessPackageFileError = GuessPackageFileError_Ambiguous [FilePath] | GuessPackageFileError_NotFound\n  deriving (Eq, Ord, Show)\ninstance Exception GuessPackageFileError\n\nnewtype HPackFilePath = HPackFilePath { unHPackFilePath :: FilePath } deriving (Eq, Ord, Show)\nnewtype CabalFilePath = CabalFilePath { unCabalFilePath :: FilePath } deriving (Eq, Ord, Show)\n\n-- | Given a directory, try to guess what the appropriate @.cabal@ or @package.yaml@ file is for the package.\nguessCabalPackageFile\n  :: (MonadIO m)\n  => FilePath -- ^ Directory or path to search for cabal package\n  -> m (Either GuessPackageFileError (Either CabalFilePath HPackFilePath))\nguessCabalPackageFile pkg = do\n  liftIO (doesDirectoryExist pkg) >>= \\case\n    False -> case cabalOrHpackFile pkg of\n      (Just hpack@(Right _)) -> pure $ Right hpack\n      (Just cabal@(Left (CabalFilePath cabalFilePath))) -> do\n        -- If the cabal file has a sibling hpack file, we use that instead\n        -- since running hpack often generates a sibling cabal file\n        let possibleHpackSibling = takeDirectory cabalFilePath </> Hpack.packageConfig\n        hasHpackSibling <- liftIO $ doesFileExist possibleHpackSibling\n        pure $ Right $ if hasHpackSibling then Right (HPackFilePath possibleHpackSibling) else cabal\n      Nothing -> pure $ Left GuessPackageFileError_NotFound\n    True -> do\n      candidates <- liftIO $\n            filterM (doesFileExist . either unCabalFilePath unHPackFilePath)\n        =<< mapMaybe (cabalOrHpackFile . (pkg </>)) <$> listDirectory pkg\n      pure $ case partitionEithers candidates of\n        ([hpack], _) -> Right $ Left hpack\n        ([], [cabal]) -> Right $ Right cabal\n        ([], []) -> Left GuessPackageFileError_NotFound\n        (hpacks, cabals) -> Left $ GuessPackageFileError_Ambiguous $ coerce hpacks <> coerce cabals\n\ncabalOrHpackFile :: FilePath -> Maybe (Either CabalFilePath HPackFilePath)\ncabalOrHpackFile = \\case\n  x | takeExtension x == \".cabal\" -> Just (Left $ CabalFilePath x)\n    | takeFileName x == Hpack.packageConfig -> Just (Right $ HPackFilePath x)\n    | otherwise -> Nothing\n\n-- | Parses the cabal package in a given directory.\n-- This automatically figures out which .cabal file or package.yaml (hpack) file to use in the given directory.\nparseCabalPackage\n  :: MonadObelisk m\n  => FilePath -- ^ Package directory\n  -> m (Maybe CabalPackageInfo)\nparseCabalPackage dir = parseCabalPackage' dir >>= \\case\n  Left err -> throwError (ObeliskError_Unstructured err)\n  Right (Just (warnings, pkgInfo)) -> do\n    for_ warnings $ putLog Warning . T.pack . show\n    pure $ Just pkgInfo\n  Right Nothing -> pure Nothing\n\n-- | Like 'parseCabalPackage' but returns errors and warnings directly so as to avoid 'MonadObelisk'.\nparseCabalPackage'\n  :: (MonadIO m)\n  => FilePath -- ^ Package directory\n  -> m (Either T.Text (Maybe ([PWarning], CabalPackageInfo)))\nparseCabalPackage' pkg = runExceptT $ do\n  (cabalContents, packageFile, packageName) <- guessCabalPackageFile pkg >>= \\case\n    Left GuessPackageFileError_NotFound -> throwError $ \"No .cabal or package.yaml file found in \" <> T.pack pkg\n    Left (GuessPackageFileError_Ambiguous _) -> throwError $ \"Unable to determine which .cabal file to use in \" <> T.pack pkg\n    Right (Left (CabalFilePath file)) -> (, file, takeBaseName file) <$> liftIO (readUTF8File file)\n    Right (Right (HPackFilePath file)) -> do\n      let\n        decodeOptions = Hpack.DecodeOptions (Hpack.ProgramName \"ob\") file Nothing Hpack.decodeYaml\n      liftIO (Hpack.readPackageConfig decodeOptions) >>= \\case\n        Left err -> throwError $ T.pack $ \"Failed to parse \" <> file <> \": \" <> err\n        Right (Hpack.DecodeResult hpackPackage _ _ _) -> pure (Hpack.renderPackage [] hpackPackage, file, Hpack.packageName hpackPackage)\n\n  let\n    (warnings, result) = runParseResult $ parseGenericPackageDescription $ toUTF8BS cabalContents\n    osConfVar = case System.Info.os of\n      \"linux\" -> Just Dist.Linux\n      \"darwin\" -> Just Dist.OSX\n      _ -> trace \"Unrecgonized System.Info.os\" Nothing\n    archConfVar = Just Dist.X86_64 -- TODO: Actually infer this\n    evalConfVar v = Right $ case v of\n      OS osVar -> Just osVar == osConfVar\n      Arch archVar -> Just archVar == archConfVar\n      Impl GHC _ -> True -- TODO: Actually check version range\n      _ -> False\n#if MIN_VERSION_Cabal(3,2,1)\n  case (view condLibrary) <$> result of\n#else\n  case condLibrary <$> result of\n#endif\n    Right (Just condLib) -> do\n      let (_, lib) = simplifyCondTree evalConfVar condLib\n      pure $ Just $ (warnings,) $ CabalPackageInfo\n        { _cabalPackageInfo_packageName = T.pack packageName\n        , _cabalPackageInfo_packageFile = packageFile\n        , _cabalPackageInfo_packageRoot = takeDirectory packageFile\n        , _cabalPackageInfo_buildable = buildable $ libBuildInfo lib\n        , _cabalPackageInfo_sourceDirs =\n            fromMaybe (pure \".\") $ NE.nonEmpty $ hsSourceDirs $ libBuildInfo lib\n        , _cabalPackageInfo_defaultExtensions =\n            defaultExtensions $ libBuildInfo lib\n        , _cabalPackageInfo_defaultLanguage =\n            defaultLanguage $ libBuildInfo lib\n        , _cabalPackageInfo_compilerOptions =\n            options $ libBuildInfo lib\n        , _cabalPackageInfo_cppOptions = cppOptions $ libBuildInfo lib\n        , _cabalPackageInfo_buildDepends = targetBuildDepends $ libBuildInfo lib\n        }\n    Right Nothing -> pure Nothing\n    Left (_, errors) ->\n      throwError $ T.pack $ \"Failed to parse \" <> packageFile <> \":\\n\" <> unlines (map show $ toList errors)\n\nparsePackagesOrFail :: (MonadObelisk m, Foldable f) => f FilePath -> m (NE.NonEmpty CabalPackageInfo)\nparsePackagesOrFail dirs' = do\n  packageInfos' <- fmap catMaybes $ for dirs $ \\dir -> do\n    flip fmap (parseCabalPackage dir) $ \\case\n      Just packageInfo\n        | _cabalPackageInfo_buildable packageInfo -> Just packageInfo\n      _ -> Nothing\n\n  -- Sort duplicate packages such that we prefer shorter paths, but fall back to alphabetical ordering.\n  let packagesByName = Map.map (NE.sortBy $ comparing $ \\p -> let n = _cabalPackageInfo_packageFile p in (length n, n))\n                     $ Map.fromListWith (<>) [(_cabalPackageInfo_packageName p, p NE.:| []) | p <- packageInfos']\n  unambiguous <- ifor packagesByName $ \\packageName ps -> case ps of\n    p NE.:| [] -> pure p -- No ambiguity here\n    p NE.:| _ -> do\n      let chosenText = \"  [Chosen] \"\n          prefix p'\n            | _cabalPackageInfo_packageFile p' == _cabalPackageInfo_packageFile p = chosenText\n            | otherwise = T.map (const ' ') chosenText\n      putLog Warning $ T.unlines $\n        \"Packages named '\" <> packageName <> \"' appear in \" <> T.pack (show $ length ps) <> \" different locations: \"\n        : map (\\p' -> prefix p' <> T.pack (_cabalPackageInfo_packageFile p')) (toList ps)\n      pure p\n\n  packageInfos <- case NE.nonEmpty $ toList unambiguous of\n    Nothing -> failWith $ T.pack $\n      \"No valid, buildable packages found\" <> (if null dirs then \"\" else \" in \" <> intercalate \", \" dirs)\n    Just xs -> pure xs\n\n  pure packageInfos\n  where\n    dirs = toList dirs'\n\npackageInfoToNamePathMap :: Foldable f => f CabalPackageInfo -> Map Text FilePath\npackageInfoToNamePathMap = Map.fromList . map (_cabalPackageInfo_packageName &&& _cabalPackageInfo_packageRoot) . toList\n\n-- Like 'withGhciScript' but provides the precise ghci arguments to add to a ghci session\nwithGhciScriptArgs\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ User commands to insert into .ghci\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> ([String] -> m ()) -- ^ Action to run with the extra ghci arguments\n  -> m ()\nwithGhciScriptArgs userCommands packageInfos f =\n  withGhciScript (loadPreludeManually ++ userCommands) packageInfos $ \\fp ->\n    f [\"-XNoImplicitPrelude\", \"-ghci-script\", fp]\n  where\n    -- These lines must be first and allow the session to support a custom Prelude when @-XNoImplicitPrelude@\n    -- is passed to the ghci session.\n    loadPreludeManually =\n      [ \":add Prelude\" -- @:add@ is used because it's less noisy when there is no custom Prelude\n      , \":set -XImplicitPrelude\" -- Turn the default setting on\n      ]\n\n-- | Create ghci configuration to load the given packages\nwithGhciScript\n  :: (MonadObelisk m, Foldable f)\n  => [String] -- ^ Commands to prefix to file\n  -> f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> (FilePath -> m ()) -- ^ Action to run with the path to generated temporary .ghci\n  -> m ()\nwithGhciScript preCommands (toList -> packageInfos) f =\n  withSystemTempDirectory \"ob-ghci\" $ \\fp -> do\n    let dotGhciPath = fp </> \".ghci\"\n    liftIO $ writeFile dotGhciPath dotGhci\n    f dotGhciPath\n  where\n    packageNames = Set.fromList $ map _cabalPackageInfo_packageName packageInfos\n    modulesToLoad = mconcat\n      [ [ \"Obelisk.Run\" | \"obelisk-run\" `Set.member` packageNames ]\n      , [ \"Backend\" | \"backend\" `Set.member` packageNames ]\n      , [ \"Frontend\" | \"frontend\" `Set.member` packageNames ]\n      ]\n    dotGhci = unlines $\n      preCommands <>\n      [ if null modulesToLoad then \"\" else \":load \" <> unwords modulesToLoad\n      , \"import qualified Obelisk.Run\"\n      , \"import qualified Frontend\"\n      , \"import qualified Backend\"\n      ]\n\n-- | Builds a list of options to pass to ghci or set in .ghci file that configures\n-- the preprocessor and source includes.\ngetGhciSessionSettings\n  :: (MonadObelisk m, Foldable f)\n  => f CabalPackageInfo -- ^ List of packages to load into ghci\n  -> FilePath -- ^ All paths will be relative to this path\n  -> m [String]\ngetGhciSessionSettings (toList -> packageInfos) pathBase = do\n  selfExe <- liftIO $ canonicalizePath =<< getExecutablePath\n  installedPackageIndex <- loadPackageIndex packageInfos pathBase\n\n  (pkgFiles, pkgSrcPaths :: [NonEmpty FilePath]) <- fmap unzip $ liftIO $ for packageInfos $ \\pkg -> do\n    canonicalSrcDirs <- traverse canonicalizePath $ (_cabalPackageInfo_packageRoot pkg </>) <$> _cabalPackageInfo_sourceDirs pkg\n    canonicalPkgFile <- canonicalizePath $ _cabalPackageInfo_packageFile pkg\n    pure (canonicalPkgFile, canonicalSrcDirs)\n\n  pure\n    $  baseGhciOptions\n    <> [\"-DOBELISK_ASSET_PASSTHRU\"] -- For passthrough static assets\n    <> [\"-F\", \"-pgmF\", selfExe, \"-optF\", preprocessorIdentifier]\n    <> concatMap (\\p -> [\"-optF\", p]) pkgFiles\n    <> [\"-i\" <> intercalate \":\" (concatMap toList pkgSrcPaths)]\n    <> concatMap (\\packageId -> [\"-package-id\", packageId ])\n                 (packageIds installedPackageIndex)\n  where\n    -- Package names we're building and not needed from the package DB\n    packageNames =\n      map (mkPackageName . T.unpack . _cabalPackageInfo_packageName)\n          packageInfos\n    packageIds installedPackageIndex = Set.toList $ Set.fromList $\n      map (dependencyPackageId installedPackageIndex) $\n          filter ((`notElem` packageNames) . depPkgName) $\n          concatMap _cabalPackageInfo_buildDepends packageInfos <>\n            [Dependency (mkPackageName \"obelisk-run\") anyVersion (Set.singleton LMainLibName)]\n    dependencyPackageId installedPackageIndex dep =\n      case lookupDependency installedPackageIndex (depPkgName dep) (depVerRange dep) of\n        ((_version,installedPackageInfo:_) :_) ->\n          compatPackageKey installedPackageInfo\n        _ -> error $ \"Couldn't resolve dependency for \" <> prettyShow dep\n\n\n-- Load the package index used by the GHC in this path's nix project\nloadPackageIndex :: MonadObelisk m => [CabalPackageInfo] -> FilePath -> m InstalledPackageIndex\nloadPackageIndex packageInfos root = do\n  ghcPath <- getPathInNixEnvironment \"bash -c 'type -p ghc'\"\n  ghcPkgPath <- getPathInNixEnvironment \"bash -c 'type -p ghc-pkg'\"\n  (compiler, _platform, programDb) <- liftIO\n    $ configCompilerEx (Just GHC) (Just ghcPath) (Just ghcPkgPath) defaultProgramDb Verbosity.silent\n  liftIO $ getInstalledPackages Verbosity.silent compiler [GlobalPackageDB] programDb\n  where\n    getPathInNixEnvironment cmd = do\n      path <- readProcessAndLogStderr Debug =<< mkObNixShellProc root False True (packageInfoToNamePathMap packageInfos) \"ghc\" (Just cmd)\n      liftIO $ canonicalizePath $ T.unpack $ T.strip path\n\nbaseGhciOptions :: [String]\nbaseGhciOptions =\n  [ \"-ignore-dot-ghci\"\n  , \"-no-user-package-db\"\n  , \"-hide-all-packages\"\n  , \"-package-env\", \"-\"\n  ]\n\n-- | Run ghci repl\nrunGhciRepl\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> [String] -- ^ GHCi arguments\n  -> m ()\nrunGhciRepl root (toList -> packages) ghciArgs =\n  -- NOTE: We do *not* want to use $(staticWhich \"ghci\") here because we need the\n  -- ghc that is provided by the shell in the user's project.\n  nixShellWithoutPkgs root True True (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ \"ghci\" : ghciArgs\n\n-- | Run ghcid\nrunGhcid\n  :: (MonadObelisk m, Foldable f)\n  => FilePath -- ^ Path to project root\n  -> Bool -- ^ Should we chdir to root when running this process?\n  -> [String] -- ^ GHCi arguments\n  -> f CabalPackageInfo -- ^ Packages to keep unbuilt\n  -> Maybe String -- ^ Optional command to run at every reload\n  -> m ()\nrunGhcid root chdirToRoot ghciArgs (toList -> packages) mcmd =\n  nixShellWithoutPkgs root True chdirToRoot (packageInfoToNamePathMap packages) \"ghc\" $\n    Just $ unwords $ fmap bashEscape $ ghcidExePath : opts\n  where\n    opts = concat\n      [ [\"-W\"]\n      , [\"--outputfile=ghcid-output.txt\"]\n      , map (\\x -> \"--reload=\" <> x) reloadFiles\n      , map (\\x -> \"--restart=\" <> x) restartFiles\n      , maybe [] (\\cmd -> [\"--test=\" <> cmd]) mcmd\n      -- N.B. the subcommand to ghcid has to be itself escaped.\n      -- We have to use 'shEscape' instead of 'bashEscape' because\n      -- ghcid invokes System.Process with a shell command, which uses @\\/bin\\/sh@\n      -- instead of the @bash@ we have in scope.\n      -- This is not guaranteed to be bash on non-NixOS systems.\n      , [\"--command=\" <> unwords (fmap shEscape (\"ghci\" : ghciArgs))]\n      ]\n    adjustRoot x = if chdirToRoot then makeRelative root x else x\n    reloadFiles = map adjustRoot [root </> \"config\"]\n    restartFiles = map (adjustRoot . _cabalPackageInfo_packageFile) packages\n\ngetFreePort :: MonadIO m => m Socket.PortNumber\ngetFreePort = liftIO $ Socket.withSocketsDo $ do\n  addr:_ <- Socket.getAddrInfo (Just Socket.defaultHints) (Just \"127.0.0.1\") (Just \"0\")\n  bracket (open addr) Socket.close Socket.socketPort\n  where\n    open addr = do\n      sock <- Socket.socket (Socket.addrFamily addr) (Socket.addrSocketType addr) (Socket.addrProtocol addr)\n      Socket.bind sock (Socket.addrAddress addr)\n      return sock\n\n\n-- | Convert a 'FilePath' into a 'PathTree'.\npathToTree :: a -> FilePath -> PathTree a\npathToTree a p = go $ splitDirectories p\n  where\n    go [] = PathTree_Node (Just a) mempty\n    go (x : xs) = PathTree_Node Nothing $ Map.singleton x $ go xs\n\n-- | Like 'zipWith' but pads with a padding value instead of stopping on the shortest list.\nzipDefaultWith :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]\nzipDefaultWith _da _db _f []     []     = []\nzipDefaultWith  da  db  f (a:as) []     = f  a db : zipDefaultWith da db f as []\nzipDefaultWith  da  db  f []     (b:bs) = f da  b : zipDefaultWith da db f [] bs\nzipDefaultWith  da  db  f (a:as) (b:bs) = f  a  b : zipDefaultWith da db f as bs\n\n-- | Makes the first absolute path relative to the second absolute path.\n--\n-- Both input paths MUST be absolute.\n--\n-- Unlike 'makeRelative' this does not merely strip prefixes. It will introduce\n-- enough @..@ paths to make the resulting path truly relative in virtually every\n-- case. The only exception is on Windows when the two paths are on different\n-- drives. In this case the resulting path may be absolute.\nrelativeTo :: FilePath -> FilePath -> FilePath\nrelativeTo dir base\n  = bifoldr1 (</>)\n  $ bimap (collapse . (\"..\" <$) . catMaybes) (collapse . catMaybes)\n  $ unzip\n  $ dropWhile (\\(a,b) -> a == b)\n  $ zipDefaultWith Nothing Nothing (,)\n    (map Just $ splitDirectories base)\n    (map Just $ splitDirectories dir)\n  where collapse = foldr (</>) \"\"\n"
            },
            {
              "file_name": "/tmp/project_102/pre_refactor/lib/run/src/Obelisk/Run.hs",
              "refactored_file_name": "/tmp/project_102/hybrid_refactored/lib/run/src/Obelisk/Run.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 16,
                "average": 6,
                "sum": 63
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 3,
                "ignore": 0,
                "total": 4
              },
              "syntax_errors": 43,
              "lines_of_code": 357,
              "homplexity_lines_of_code": 648,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 16,
                  "average": 6,
                  "sum": 63
                },
                "homplexity_loc": 648,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"run\": 12,\n        \"runServeAsset\": 2,\n        \"getConfigRoute\": 4,\n        \"runWidget\": 16,\n        \"obeliskApp\": 14,\n        \"renderJsaddleFrontend\": 1,\n        \"bindPortTCPRetry\": 3,\n        \"logPortBindErr\": 2,\n        \"getProcessIdForPort\": 4,\n        \"parseSsPid\": 1,\n        \"fallbackProxy\": 2,\n        \"min\": 1,\n        \"max\": 16,\n        \"average\": 5.7272727272727275,\n        \"sum\": 63\n    },\n    \"homplexity_loc\": 648,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n#if defined(IPROUTE_SUPPORTED)\n{-# LANGUAGE TemplateHaskell #-}\n#endif\n\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-} -- Due to instance HasJS x (EventWriterT t w m)\nmodule Obelisk.Run where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Applicative\nimport Control.Exception\nimport Control.Lens ((%~), (^?), _Just, _Right)\nimport qualified Data.Attoparsec.ByteString.Char8 as A\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BSC\nimport qualified Data.ByteString.Lazy.Char8 as BSLC\nimport qualified Data.ByteString.UTF8 as BSUTF8\nimport Data.Functor.Identity\nimport Data.List (uncons)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup ((<>))\n#endif\nimport Data.Streaming.Network (bindPortTCP)\nimport Data.String (fromString)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Time.Clock (getCurrentTime, addUTCTime)\nimport Language.Javascript.JSaddle.Run (syncPoint)\nimport Language.Javascript.JSaddle.WebSockets\nimport Network.HTTP.Client (Manager, defaultManagerSettings, newManager)\nimport qualified Network.HTTP.ReverseProxy as RP\nimport qualified Network.HTTP.Types as H\nimport Network.Socket\nimport Network.Wai (Application)\nimport qualified Network.Wai as W\nimport Network.Wai.Handler.Warp\nimport Network.Wai.Handler.WarpTLS\nimport Network.Wai.Handler.Warp.Internal (settingsHost, settingsPort)\nimport Network.WebSockets (ConnectionOptions)\nimport Network.WebSockets.Connection (defaultConnectionOptions)\nimport qualified Obelisk.Asset.Serve.Snap as Snap\nimport Obelisk.Backend\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport qualified OpenSSL.PEM as PEM\nimport qualified OpenSSL.RSA as RSA\nimport qualified OpenSSL.X509 as X509\nimport qualified OpenSSL.X509.Request as X509Request\nimport Reflex.Dom.Core\nimport Snap.Core (Snap)\nimport System.Environment\nimport System.FilePath ((</>))\nimport System.IO\nimport System.Process\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Web.Cookie\n\n#if defined(IPROUTE_SUPPORTED)\nimport qualified System.Which\n#endif\n\n-- | The arguments to 'run', specifying the configuration and\n-- implementation of an Obelisk application.\ndata RunApp backendRoute frontendRoute\n  = RunApp\n    { _runApp_backendPort      :: Int\n      -- ^ What port should we serve the backend on? This is used for\n      -- internal communication.\n    , _runApp_backendHost      :: ByteString\n      -- ^ The hostname on which the backend is running. By default,\n      -- this is @127.0.0.1@, i.e., the local machine. Routes not\n      -- handled by the frontend will be redirected to this host.\n    , _runApp_forceFrontendPort :: Maybe Int\n      -- ^ If set, overrides the port on which the frontend will be\n      -- served. If unset, the port will be parsed from the configured\n      -- route.\n    , _runApp_tlsCertDirectory :: Maybe FilePath\n      -- ^ Optional directory in which to find \"cert.pem\", \"chain.pem\"\n      -- and \"privkey.pem\" to be used for TLS.\n      -- If this is 'Nothing' and TLS is enabled, we'll generate a\n      -- self-signed cert.\n    , _runApp_staticHandler    :: [Text] -> Snap ()\n      -- ^ How to serve static assets.\n    , _runApp_backend          :: Backend backendRoute frontendRoute\n      -- ^ The backend.\n    , _runApp_frontend         :: Frontend (R frontendRoute)\n      -- ^ The frontend.\n    }\n\n-- | Construct a 'RunApp' with sane defaults. The TLS certificate\n-- directory will be set to 'Nothing', the backend host will be the\n-- local machine (@127.0.0.1@), the backend port will be set to @3001@,\n-- the frontend port will be fetched from the route configuration.\ndefaultRunApp\n  :: Backend backendRoute frontendRoute -- ^ The backend to use\n  -> Frontend (R frontendRoute)         -- ^ The frontend to use\n  -> ([Text] -> Snap ())                -- ^ How to serve static assets\n  -> RunApp backendRoute frontendRoute\ndefaultRunApp be fe static = RunApp\n  { _runApp_backendPort = 3001\n  , _runApp_backendHost = \"127.0.0.1\"\n  , _runApp_forceFrontendPort = Nothing\n  , _runApp_tlsCertDirectory = Nothing\n  , _runApp_staticHandler = static\n  , _runApp_backend = be\n  , _runApp_frontend = fe\n  }\n\n-- | Run an Obelisk application, including the frontend and backend. The\n-- backend routes are served on the port given by '_runApp_backendPort',\n-- but are also accessible through the frontend.\nrun :: RunApp backendRoute frontendRoute -> IO ()\nrun toRun = do\n  prettifyOutput\n\n  let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"backend stopped; make a change to your code to reload - error \" <> show e\n\n  --TODO: Use Obelisk.Backend.runBackend; this will require separating the checking and running phases\n  case checkEncoder $ _backend_routeEncoder (_runApp_backend toRun) of\n    Left e -> hPutStrLn stderr $ \"backend error:\\n\" <> T.unpack e\n    Right validFullEncoder -> do\n      publicConfigs <- getPublicConfigs\n\n      -- We start the backend server listening on the\n      -- '_runApp_backendPort'. The backend and frontend run in\n      -- different servers: The frontend server will pass any routes it\n      -- can't handle to this process.\n      backendTid <- forkIO $ handle handleBackendErr $ withArgs [\"--quiet\", \"--port\", show (_runApp_backendPort toRun)] $\n        _backend_run (_runApp_backend toRun) $ \\serveRoute ->\n          runSnapWithCommandLineArgs $\n            getRouteWith validFullEncoder >>= \\case\n              Identity r -> case r of\n                FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n                FullRoute_Frontend obeliskRoute :/ a ->\n                  serveDefaultObeliskApp appRouteToUrl (($ allJsUrl) <$> defaultGhcjsWidgets)\n                    (_runApp_staticHandler toRun) (_runApp_frontend toRun) publicConfigs $ obeliskRoute :/ a\n                  where\n                    appRouteToUrl (k :/ v) = renderObeliskRoute validFullEncoder (FullRoute_Frontend (ObeliskRoute_App k) :/ v)\n                    allJsUrl = renderAllJsPath validFullEncoder\n\n      runWidget toRun publicConfigs validFullEncoder `finally` killThread backendTid\n\n-- Convenience wrapper to handle path segments for 'Snap.serveAsset'\nrunServeAsset :: FilePath -> [Text] -> Snap ()\nrunServeAsset rootPath t =\n  Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\" $ t\n\ngetConfigRoute :: Map Text ByteString -> Either Text URI\ngetConfigRoute configs = case Map.lookup \"common/route\" configs of\n    Just r ->\n      let stripped = T.strip (T.decodeUtf8 r)\n      in case URI.mkURI stripped of\n          Just route -> Right route\n          Nothing -> Left $ \"Couldn't parse route as URI; value read was: \" <> T.pack (show stripped)\n    Nothing -> Left $ \"Couldn't find config file common/route; it should contain the site's canonical root URI\" <> T.pack (show $ Map.keys configs)\n\n-- | Start the frontend (given in the 'RunApp' record), with the given\n-- configuration and the given 'FullRoute' encoder, which must be valid.\nrunWidget\n  :: RunApp backendRoute frontendRoute\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> IO ()\nrunWidget toRun configs validFullEncoder = do\n  uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n  let -- Before we can do anything, we need to pick a port to serve the\n      -- backend on. If the user has asked to override it, then we use that:\n      -- they know what they're doing. Otherwise, we'll use the port\n      -- specified in the route.\n      port = fromMaybe 80 $ (_runApp_forceFrontendPort toRun)\n                        <|> (fmap fromIntegral $ uri ^? uriAuthority . _Right . authPort . _Just)\n\n      -- This is the server that will handle the backend requests. We\n      -- support shuttling them off to any host:port pair.\n      redirectHost = _runApp_backendHost toRun\n      redirectPort = _runApp_backendPort toRun\n\n      -- TLS toggle logic: 'routeIsTLS' indicates whether the\n      -- configuration would have mandated TLS (at the moment this is\n      -- only because the route is https://...).\n      -- 'portDisabledTLS' indicates whether the user forced us to use a\n      -- port different than that of the route, and thus TLS was\n      -- disabled.\n      routeIsTLS = (Just \"https\" == uri ^? uriScheme . _Just . unRText)\n      portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n\n      beforeMainLoop = do\n        putStrLn $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n        putStrLn $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n        -- TLS toggle logic: If the --port option was given, warn the\n        -- user that TLS is being skipped.\n        when (routeIsTLS && portDisabledTLS) $ do\n          putStrLn \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n          putStrLn \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n\n\n      settings = setBeforeMainLoop beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n\n      -- Providing TLS here will also incidentally provide it to proxied\n      -- requests to the backend.\n      prepareRunner =\n        -- TLS toggle logic: If the port option was NOT given, then use\n        -- TLS iff the route has it.\n        if not portDisabledTLS && routeIsTLS then\n          case _runApp_tlsCertDirectory toRun of\n            Nothing -> do\n              -- Generate a private key and self-signed certificate for TLS\n              privateKey <- RSA.generateRSAKey' 2048 3\n\n              certRequest <- X509Request.newX509Req\n              _ <- X509Request.setPublicKey certRequest privateKey\n              _ <- X509Request.signX509Req certRequest privateKey Nothing\n\n              cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n              _ <- X509.setPublicKey cert privateKey\n              timenow <- getCurrentTime\n              _ <- X509.setNotBefore cert $ addUTCTime (-1) timenow\n              _ <- X509.setNotAfter cert $ addUTCTime (365 * 24 * 60 * 60) timenow\n              _ <- X509.signX509 cert privateKey Nothing\n\n              certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n              privateKeyByteString <- BSUTF8.fromString <$> PEM.writePKCS8PrivateKey privateKey Nothing\n\n              return $ runTLSSocket (tlsSettingsMemory certByteString privateKeyByteString)\n            Just certDir -> do\n              putStrLn $ \"Using certificate information from: \" ++ certDir\n              return $ runTLSSocket (tlsSettingsChain (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"] (certDir </> \"key.pem\"))\n        else return runSettingsSocket\n\n  runner <- prepareRunner\n  bracket\n    (bindPortTCPRetry settings (logPortBindErr port) 1)\n    close\n    (\\skt -> do\n        man <- newManager defaultManagerSettings\n        app <- obeliskApp configs defaultConnectionOptions (_runApp_frontend toRun) validFullEncoder uri $ fallbackProxy redirectHost redirectPort man\n        runner settings skt app)\n\n\n-- | Build a WAI 'Application' to serve the given Obelisk 'Frontend',\n-- using the specified 'Encoder' to parse routes. Any requests whose\n-- route does not result in a 'FullRoute_Frontend' parse will be\n-- redirected to the backend.\nobeliskApp\n  :: forall frontendRoute backendRoute\n  .  Map Text ByteString -- ^ The parsed configuration\n  -> ConnectionOptions   -- ^ Connection options for the JSaddle websocket\n  -> Frontend (R frontendRoute) -- ^ The Obelisk frontend\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n     -- ^ An encoder for parsing frontend routes.\n  -> URI\n    -- ^ The 'URI' on which the 'Frontend' will be served. Used for\n    -- establishing the JSaddle websocket connection.\n  -> Application -- ^ A WAI 'Application' which handles backend requests.\n  -> IO Application\nobeliskApp configs opts frontend validFullEncoder uri backend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate = True\n        , _frontendMode_adjustRoute = False\n        }\n      entryPoint = do\n        runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n        syncPoint\n  jsaddlePath <- URI.mkPathPiece \"jsaddle\"\n  let jsaddleUri = BSLC.fromStrict $ URI.renderBs $ uri & uriPath %~ (<>[jsaddlePath])\n  Right (jsaddleWarpRouteValidEncoder :: Encoder Identity (Either Text) (R JSaddleWarpRoute) PageName) <- return $ checkEncoder jsaddleWarpRouteEncoder\n  jsaddle <- jsaddleWithAppOr opts entryPoint $ \\_ sendResponse -> sendResponse $ W.responseLBS H.status500 [(\"Content-Type\", \"text/plain\")] \"obeliskApp: jsaddle got a bad URL\"\n  return $ \\req sendResponse -> case tryDecode validFullEncoder $ byteStringsToPageName (BS.dropWhile (== (fromIntegral $ fromEnum '/')) $ W.rawPathInfo req) (BS.drop 1 $ W.rawQueryString req) of\n    Identity r -> case r of\n      FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_JSaddleWarp) :/ jsaddleRoute -> case jsaddleRoute of\n        JSaddleWarpRoute_JavaScript :/ () -> sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", \"application/javascript\")] $ jsaddleJs' (Just jsaddleUri) False\n        _ -> flip jsaddle sendResponse $ req\n          { W.pathInfo = fst $ encode jsaddleWarpRouteValidEncoder jsaddleRoute\n          }\n      FullRoute_Frontend (ObeliskRoute_App appRouteComponent) :/ appRouteRest -> do\n        let cookies = maybe [] parseCookies $ lookup (fromString \"Cookie\") (W.requestHeaders req)\n            routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n        html <- renderJsaddleFrontend configs cookies routeToUrl (appRouteComponent :/ appRouteRest) frontend\n        sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", staticRenderContentType)] $ BSLC.fromStrict html\n      _ -> backend req sendResponse\n\nrenderJsaddleFrontend\n  :: Map Text ByteString\n  -> Cookies\n  -> (route -> Text)\n  -> route\n  -> Frontend route\n  -> IO ByteString\nrenderJsaddleFrontend configs cookies urlEnc r f =\n  let jsaddleScript = elAttr \"script\" (\"src\" =: \"/jsaddle/jsaddle.js\") blank\n      jsaddlePreload = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: \"/jsaddle/jsaddle.js\") blank\n  in renderFrontendHtml configs cookies urlEnc r f jsaddlePreload jsaddleScript\n\n-- | like 'bindPortTCP' but reconnects on exception\nbindPortTCPRetry :: Settings\n                 -> (IOError -> IO ()) -- ^ Action to run the first time an exception is caught\n                 -> Int\n                 -> IO Socket\nbindPortTCPRetry settings m n = catch (bindPortTCP (settingsPort settings) (settingsHost settings)) $ \\(e :: IOError) -> do\n  m e\n  threadDelay $ 1000000 * n\n  bindPortTCPRetry settings (\\_ -> pure ()) n\n\nlogPortBindErr :: Int -> IOError -> IO ()\nlogPortBindErr p e = getProcessIdForPort p >>= \\case\n  Nothing -> putStrLn $ \"runWidget: \" <> show e\n  Just pid -> putStrLn $ unwords [ \"Port\", show p, \"is being used by process ID\", show pid <> \".\", \"Please kill that process or change the port in config/common/route.\"]\n\nssPath :: Maybe String\nssPath =\n#if defined(IPROUTE_SUPPORTED)\n  Just $(System.Which.staticWhich \"ss\")\n#else\n  Nothing\n#endif\n\ngetProcessIdForPort :: Int -> IO (Maybe Int)\ngetProcessIdForPort port = case ssPath of\n  Just ss -> do\n    xs <- lines <$> readProcess ss [\"-lptn\", \"sport = \" <> show port] mempty\n    case uncons xs of\n      Just (_, x:_) -> return $ A.maybeResult $ A.parse parseSsPid $ BSC.pack x\n      _ -> return Nothing\n  _ -> return Nothing\n\nparseSsPid :: A.Parser Int\nparseSsPid = do\n  _ <- A.count 5 $ A.takeWhile (not . A.isSpace) *> A.skipSpace\n  _ <- A.skipWhile (/= ':') >> A.string \":((\" >> A.skipWhile (/= ',')\n  A.string \",pid=\" *> A.decimal\n\nfallbackProxy :: ByteString -> Int -> Manager -> Application\nfallbackProxy host port = RP.waiProxyTo handleRequest RP.defaultOnExc\n  where handleRequest _req = return $ RP.WPRProxyDest $ RP.ProxyDest host port\n",
              "suggestions": [
                {
                  "target_snippet": "(_runApp_forceFrontendPort toRun)\n    <|>\n      (fmap fromIntegral\n         $ uri ^? uriAuthority . _Right . authPort . _Just)",
                  "refactored_suggestion": "(_runApp_forceFrontendPort toRun)\n    <|>\n      fmap fromIntegral (uri ^? uriAuthority . _Right . authPort . _Just)",
                  "confidence": 1.0,
                  "justification": "This refactoring removes unnecessary brackets around `$`, simplifying the code while preserving functionality and readability as per the HLint suggestion."
                },
                {
                  "target_snippet": "-- #if defined(IPROUTE_SUPPORTED)\n-- Just $(System.Which.staticWhich \"ss\")\n-- #else\n-- Nothing\n-- #endif",
                  "refactored_suggestion": "-- Reason: This code block is not essential unless IPROUTE_SUPPORTED is defined, and it affects the compilation result based on unnecessary conditional preprocessor directives. Removing to simplify the codebase for scenarios where IPROUTE_SUPPORTED is not relevant.",
                  "confidence": 0.8,
                  "justification": "The conditional code inclusion may be unnecessary for most use cases and complicates the structure without a clear reason to keep this dependency."
                },
                {
                  "target_snippet": "bindPortTCPRetry settings m n = catch (bindPortTCP (settingsPort settings) (settingsHost settings)) $ (\\(e :: IOError) -> do\n  m e\n  threadDelay $ 1000000 * n\n  bindPortTCPRetry settings (\\_ -> pure ()) n)",
                  "refactored_suggestion": "bindPortTCPRetry settings m n = bindPortTCP (settingsPort settings) (settingsHost settings) `catch` \\(e :: IOError) -> do\n  m e\n  threadDelay (1000000 * n)\n  bindPortTCPRetry settings (\\_ -> pure ()) n",
                  "confidence": 1.0,
                  "justification": "Simplifies the do-block styling and moves operations in logical order, improving code readability and alignment."
                },
                {
                  "target_snippet": "let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"backend stopped; make a change to your code to reload - error \" <> show e",
                  "refactored_suggestion": "let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"Backend stopped. Reload needed - Error: \" <> show e",
                  "confidence": 0.9,
                  "justification": "Adjusts the error message wording for clarity and conciseness, making it more user-friendly while preserving the same functionality."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n#if defined(IPROUTE_SUPPORTED)\n{-# LANGUAGE TemplateHaskell #-}\n#endif\n\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-} -- Due to instance HasJS x (EventWriterT t w m)\nmodule Obelisk.Run where\n\nimport Prelude hiding ((.), id)\n\nimport Control.Category\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Applicative\nimport Control.Exception\nimport Control.Lens ((%~), (^?), _Just, _Right)\nimport qualified Data.Attoparsec.ByteString.Char8 as A\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BSC\nimport qualified Data.ByteString.Lazy.Char8 as BSLC\nimport qualified Data.ByteString.UTF8 as BSUTF8\nimport Data.Functor.Identity\nimport Data.List (uncons)\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Maybe\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup ((<>))\n#endif\nimport Data.Streaming.Network (bindPortTCP)\nimport Data.String (fromString)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T\nimport Data.Time.Clock (getCurrentTime, addUTCTime)\nimport Language.Javascript.JSaddle.Run (syncPoint)\nimport Language.Javascript.JSaddle.WebSockets\nimport Network.HTTP.Client (Manager, defaultManagerSettings, newManager)\nimport qualified Network.HTTP.ReverseProxy as RP\nimport qualified Network.HTTP.Types as H\nimport Network.Socket\nimport Network.Wai (Application)\nimport qualified Network.Wai as W\nimport Network.Wai.Handler.Warp\nimport Network.Wai.Handler.WarpTLS\nimport Network.Wai.Handler.Warp.Internal (settingsHost, settingsPort)\nimport Network.WebSockets (ConnectionOptions)\nimport Network.WebSockets.Connection (defaultConnectionOptions)\nimport qualified Obelisk.Asset.Serve.Snap as Snap\nimport Obelisk.Backend\nimport Obelisk.Frontend\nimport Obelisk.Route.Frontend\nimport qualified OpenSSL.PEM as PEM\nimport qualified OpenSSL.RSA as RSA\nimport qualified OpenSSL.X509 as X509\nimport qualified OpenSSL.X509.Request as X509Request\nimport Reflex.Dom.Core\nimport Snap.Core (Snap)\nimport System.Environment\nimport System.FilePath ((</>))\nimport System.IO\nimport System.Process\nimport Text.URI (URI)\nimport qualified Text.URI as URI\nimport Text.URI.Lens\nimport Web.Cookie\n\n#if defined(IPROUTE_SUPPORTED)\nimport qualified System.Which\n#endif\n\n-- | The arguments to 'run', specifying the configuration and\n-- implementation of an Obelisk application.\ndata RunApp backendRoute frontendRoute\n  = RunApp\n    { _runApp_backendPort      :: Int\n      -- ^ What port should we serve the backend on? This is used for\n      -- internal communication.\n    , _runApp_backendHost      :: ByteString\n      -- ^ The hostname on which the backend is running. By default,\n      -- this is @127.0.0.1@, i.e., the local machine. Routes not\n      -- handled by the frontend will be redirected to this host.\n    , _runApp_forceFrontendPort :: Maybe Int\n      -- ^ If set, overrides the port on which the frontend will be\n      -- served. If unset, the port will be parsed from the configured\n      -- route.\n    , _runApp_tlsCertDirectory :: Maybe FilePath\n      -- ^ Optional directory in which to find \"cert.pem\", \"chain.pem\"\n      -- and \"privkey.pem\" to be used for TLS.\n      -- If this is 'Nothing' and TLS is enabled, we'll generate a\n      -- self-signed cert.\n    , _runApp_staticHandler    :: [Text] -> Snap ()\n      -- ^ How to serve static assets.\n    , _runApp_backend          :: Backend backendRoute frontendRoute\n      -- ^ The backend.\n    , _runApp_frontend         :: Frontend (R frontendRoute)\n      -- ^ The frontend.\n    }\n\n-- | Construct a 'RunApp' with sane defaults. The TLS certificate\n-- directory will be set to 'Nothing', the backend host will be the\n-- local machine (@127.0.0.1@), the backend port will be set to @3001@,\n-- the frontend port will be fetched from the route configuration.\ndefaultRunApp\n  :: Backend backendRoute frontendRoute -- ^ The backend to use\n  -> Frontend (R frontendRoute)         -- ^ The frontend to use\n  -> ([Text] -> Snap ())                -- ^ How to serve static assets\n  -> RunApp backendRoute frontendRoute\ndefaultRunApp be fe static = RunApp\n  { _runApp_backendPort = 3001\n  , _runApp_backendHost = \"127.0.0.1\"\n  , _runApp_forceFrontendPort = Nothing\n  , _runApp_tlsCertDirectory = Nothing\n  , _runApp_staticHandler = static\n  , _runApp_backend = be\n  , _runApp_frontend = fe\n  }\n\n-- | Run an Obelisk application, including the frontend and backend. The\n-- backend routes are served on the port given by '_runApp_backendPort',\n-- but are also accessible through the frontend.\nrun :: RunApp backendRoute frontendRoute -> IO ()\nrun toRun = do\n  prettifyOutput\n\n  let handleBackendErr (e :: IOException) =\n        hPutStrLn stderr $ \"Backend stopped. Reload needed - Error: \" <> show e\n\n  --TODO: Use Obelisk.Backend.runBackend; this will require separating the checking and running phases\n  case checkEncoder $ _backend_routeEncoder (_runApp_backend toRun) of\n    Left e -> hPutStrLn stderr $ \"backend error:\\n\" <> T.unpack e\n    Right validFullEncoder -> do\n      publicConfigs <- getPublicConfigs\n\n      -- We start the backend server listening on the\n      -- '_runApp_backendPort'. The backend and frontend run in\n      -- different servers: The frontend server will pass any routes it\n      -- can't handle to this process.\n      backendTid <- forkIO $ handle handleBackendErr $ withArgs [\"--quiet\", \"--port\", show (_runApp_backendPort toRun)] $\n        _backend_run (_runApp_backend toRun) $ \\serveRoute ->\n          runSnapWithCommandLineArgs $\n            getRouteWith validFullEncoder >>= \\case\n              Identity r -> case r of\n                FullRoute_Backend backendRoute :/ a -> serveRoute $ backendRoute :/ a\n                FullRoute_Frontend obeliskRoute :/ a ->\n                  serveDefaultObeliskApp appRouteToUrl (($ allJsUrl) <$> defaultGhcjsWidgets)\n                    (_runApp_staticHandler toRun) (_runApp_frontend toRun) publicConfigs $ obeliskRoute :/ a\n                  where\n                    appRouteToUrl (k :/ v) = renderObeliskRoute validFullEncoder (FullRoute_Frontend (ObeliskRoute_App k) :/ v)\n                    allJsUrl = renderAllJsPath validFullEncoder\n\n      runWidget toRun publicConfigs validFullEncoder `finally` killThread backendTid\n\n-- Convenience wrapper to handle path segments for 'Snap.serveAsset'\nrunServeAsset :: FilePath -> [Text] -> Snap ()\nrunServeAsset rootPath t =\n  Snap.serveAsset \"\" rootPath . T.unpack . T.intercalate \"/\" $ t\n\ngetConfigRoute :: Map Text ByteString -> Either Text URI\ngetConfigRoute configs = case Map.lookup \"common/route\" configs of\n    Just r ->\n      let stripped = T.strip (T.decodeUtf8 r)\n      in case URI.mkURI stripped of\n          Just route -> Right route\n          Nothing -> Left $ \"Couldn't parse route as URI; value read was: \" <> T.pack (show stripped)\n    Nothing -> Left $ \"Couldn't find config file common/route; it should contain the site's canonical root URI\" <> T.pack (show $ Map.keys configs)\n\n-- | Start the frontend (given in the 'RunApp' record), with the given\n-- configuration and the given 'FullRoute' encoder, which must be valid.\nrunWidget\n  :: RunApp backendRoute frontendRoute\n  -> Map Text ByteString\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n  -> IO ()\nrunWidget toRun configs validFullEncoder = do\n  uri <- either (fail . T.unpack) pure $ getConfigRoute configs\n  let -- Before we can do anything, we need to pick a port to serve the\n      -- backend on. If the user has asked to override it, then we use that:\n      -- they know what they're doing. Otherwise, we'll use the port\n      -- specified in the route.\n      port = fromMaybe 80 $ (_runApp_forceFrontendPort toRun)\n                        <|> (fmap fromIntegral $ uri ^? uriAuthority . _Right . authPort . _Just)\n\n      -- This is the server that will handle the backend requests. We\n      -- support shuttling them off to any host:port pair.\n      redirectHost = _runApp_backendHost toRun\n      redirectPort = _runApp_backendPort toRun\n\n      -- TLS toggle logic: 'routeIsTLS' indicates whether the\n      -- configuration would have mandated TLS (at the moment this is\n      -- only because the route is https://...).\n      -- 'portDisabledTLS' indicates whether the user forced us to use a\n      -- port different than that of the route, and thus TLS was\n      -- disabled.\n      routeIsTLS = (Just \"https\" == uri ^? uriScheme . _Just . unRText)\n      portDisabledTLS = isJust (_runApp_forceFrontendPort toRun)\n\n      beforeMainLoop = do\n        putStrLn $ \"Frontend running on http://localhost:\" ++ show port ++ \"/\"\n        putStrLn $ \"Publicly accessible route: \" ++ T.unpack (URI.render uri)\n        -- TLS toggle logic: If the --port option was given, warn the\n        -- user that TLS is being skipped.\n        when (routeIsTLS && portDisabledTLS) $ do\n          putStrLn \"Warning: Since a specific frontend port was requested, TLS will not be used for this session\"\n          putStrLn \"Please make sure that the public route is behind a reverse proxy to terminate TLS connections.\"\n\n\n      settings = setBeforeMainLoop beforeMainLoop (setPort port (setTimeout 3600 defaultSettings))\n\n      -- Providing TLS here will also incidentally provide it to proxied\n      -- requests to the backend.\n      prepareRunner =\n        -- TLS toggle logic: If the port option was NOT given, then use\n        -- TLS iff the route has it.\n        if not portDisabledTLS && routeIsTLS then\n          case _runApp_tlsCertDirectory toRun of\n            Nothing -> do\n              -- Generate a private key and self-signed certificate for TLS\n              privateKey <- RSA.generateRSAKey' 2048 3\n\n              certRequest <- X509Request.newX509Req\n              _ <- X509Request.setPublicKey certRequest privateKey\n              _ <- X509Request.signX509Req certRequest privateKey Nothing\n\n              cert <- X509.newX509 >>= X509Request.makeX509FromReq certRequest\n              _ <- X509.setPublicKey cert privateKey\n              timenow <- getCurrentTime\n              _ <- X509.setNotBefore cert $ addUTCTime (-1) timenow\n              _ <- X509.setNotAfter cert $ addUTCTime (365 * 24 * 60 * 60) timenow\n              _ <- X509.signX509 cert privateKey Nothing\n\n              certByteString <- BSUTF8.fromString <$> PEM.writeX509 cert\n              privateKeyByteString <- BSUTF8.fromString <$> PEM.writePKCS8PrivateKey privateKey Nothing\n\n              return $ runTLSSocket (tlsSettingsMemory certByteString privateKeyByteString)\n            Just certDir -> do\n              putStrLn $ \"Using certificate information from: \" ++ certDir\n              return $ runTLSSocket (tlsSettingsChain (certDir </> \"cert.pem\") [certDir </> \"chain.pem\"] (certDir </> \"key.pem\"))\n        else return runSettingsSocket\n\n  runner <- prepareRunner\n  bracket\n    (bindPortTCPRetry settings (logPortBindErr port) 1)\n    close\n    (\\skt -> do\n        man <- newManager defaultManagerSettings\n        app <- obeliskApp configs defaultConnectionOptions (_runApp_frontend toRun) validFullEncoder uri $ fallbackProxy redirectHost redirectPort man\n        runner settings skt app)\n\n\n-- | Build a WAI 'Application' to serve the given Obelisk 'Frontend',\n-- using the specified 'Encoder' to parse routes. Any requests whose\n-- route does not result in a 'FullRoute_Frontend' parse will be\n-- redirected to the backend.\nobeliskApp\n  :: forall frontendRoute backendRoute\n  .  Map Text ByteString -- ^ The parsed configuration\n  -> ConnectionOptions   -- ^ Connection options for the JSaddle websocket\n  -> Frontend (R frontendRoute) -- ^ The Obelisk frontend\n  -> Encoder Identity Identity (R (FullRoute backendRoute frontendRoute)) PageName\n     -- ^ An encoder for parsing frontend routes.\n  -> URI\n    -- ^ The 'URI' on which the 'Frontend' will be served. Used for\n    -- establishing the JSaddle websocket connection.\n  -> Application -- ^ A WAI 'Application' which handles backend requests.\n  -> IO Application\nobeliskApp configs opts frontend validFullEncoder uri backend = do\n  let mode = FrontendMode\n        { _frontendMode_hydrate = True\n        , _frontendMode_adjustRoute = False\n        }\n      entryPoint = do\n        runFrontendWithConfigsAndCurrentRoute mode configs validFullEncoder frontend\n        syncPoint\n  jsaddlePath <- URI.mkPathPiece \"jsaddle\"\n  let jsaddleUri = BSLC.fromStrict $ URI.renderBs $ uri & uriPath %~ (<>[jsaddlePath])\n  Right (jsaddleWarpRouteValidEncoder :: Encoder Identity (Either Text) (R JSaddleWarpRoute) PageName) <- return $ checkEncoder jsaddleWarpRouteEncoder\n  jsaddle <- jsaddleWithAppOr opts entryPoint $ \\_ sendResponse -> sendResponse $ W.responseLBS H.status500 [(\"Content-Type\", \"text/plain\")] \"obeliskApp: jsaddle got a bad URL\"\n  return $ \\req sendResponse -> case tryDecode validFullEncoder $ byteStringsToPageName (BS.dropWhile (== (fromIntegral $ fromEnum '/')) $ W.rawPathInfo req) (BS.drop 1 $ W.rawQueryString req) of\n    Identity r -> case r of\n      FullRoute_Frontend (ObeliskRoute_Resource ResourceRoute_JSaddleWarp) :/ jsaddleRoute -> case jsaddleRoute of\n        JSaddleWarpRoute_JavaScript :/ () -> sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", \"application/javascript\")] $ jsaddleJs' (Just jsaddleUri) False\n        _ -> flip jsaddle sendResponse $ req\n          { W.pathInfo = fst $ encode jsaddleWarpRouteValidEncoder jsaddleRoute\n          }\n      FullRoute_Frontend (ObeliskRoute_App appRouteComponent) :/ appRouteRest -> do\n        let cookies = maybe [] parseCookies $ lookup (fromString \"Cookie\") (W.requestHeaders req)\n            routeToUrl (k :/ v) = renderObeliskRoute validFullEncoder $ FullRoute_Frontend (ObeliskRoute_App k) :/ v\n        html <- renderJsaddleFrontend configs cookies routeToUrl (appRouteComponent :/ appRouteRest) frontend\n        sendResponse $ W.responseLBS H.status200 [(\"Content-Type\", staticRenderContentType)] $ BSLC.fromStrict html\n      _ -> backend req sendResponse\n\nrenderJsaddleFrontend\n  :: Map Text ByteString\n  -> Cookies\n  -> (route -> Text)\n  -> route\n  -> Frontend route\n  -> IO ByteString\nrenderJsaddleFrontend configs cookies urlEnc r f =\n  let jsaddleScript = elAttr \"script\" (\"src\" =: \"/jsaddle/jsaddle.js\") blank\n      jsaddlePreload = elAttr \"link\" (\"rel\" =: \"preload\" <> \"as\" =: \"script\" <> \"href\" =: \"/jsaddle/jsaddle.js\") blank\n  in renderFrontendHtml configs cookies urlEnc r f jsaddlePreload jsaddleScript\n\n-- | like 'bindPortTCP' but reconnects on exception\nbindPortTCPRetry :: Settings\n                 -> (IOError -> IO ()) -- ^ Action to run the first time an exception is caught\n                 -> Int\n                 -> IO Socket\nbindPortTCPRetry settings m n = catch (bindPortTCP (settingsPort settings) (settingsHost settings)) $ \\(e :: IOError) -> do\n  m e\n  threadDelay $ 1000000 * n\n  bindPortTCPRetry settings (\\_ -> pure ()) n\n\nlogPortBindErr :: Int -> IOError -> IO ()\nlogPortBindErr p e = getProcessIdForPort p >>= \\case\n  Nothing -> putStrLn $ \"runWidget: \" <> show e\n  Just pid -> putStrLn $ unwords [ \"Port\", show p, \"is being used by process ID\", show pid <> \".\", \"Please kill that process or change the port in config/common/route.\"]\n\nssPath :: Maybe String\nssPath =\n#if defined(IPROUTE_SUPPORTED)\n  Just $(System.Which.staticWhich \"ss\")\n#else\n  Nothing\n#endif\n\ngetProcessIdForPort :: Int -> IO (Maybe Int)\ngetProcessIdForPort port = case ssPath of\n  Just ss -> do\n    xs <- lines <$> readProcess ss [\"-lptn\", \"sport = \" <> show port] mempty\n    case uncons xs of\n      Just (_, x:_) -> return $ A.maybeResult $ A.parse parseSsPid $ BSC.pack x\n      _ -> return Nothing\n  _ -> return Nothing\n\nparseSsPid :: A.Parser Int\nparseSsPid = do\n  _ <- A.count 5 $ A.takeWhile (not . A.isSpace) *> A.skipSpace\n  _ <- A.skipWhile (/= ':') >> A.string \":((\" >> A.skipWhile (/= ',')\n  A.string \",pid=\" *> A.decimal\n\nfallbackProxy :: ByteString -> Int -> Manager -> Application\nfallbackProxy host port = RP.waiProxyTo handleRequest RP.defaultOnExc\n  where handleRequest _req = return $ RP.WPRProxyDest $ RP.ProxyDest host port\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}