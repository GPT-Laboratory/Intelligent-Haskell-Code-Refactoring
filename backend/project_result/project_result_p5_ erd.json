{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 12,
          "max": 33,
          "average": 11.2,
          "sum": 112
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 0,
          "suggestion": 0,
          "ignore": 0,
          "total": 0
        },
        "syntax_errors": 63,
        "lines_of_code": 1277,
        "homplexity_lines_of_code": 1479,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "128MB",
          "runtime": "1.51 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_91/pre_refactor/Setup.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 2,
          "homplexity_lines_of_code": 3,
          "code_quality_score": 97.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 3,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_91/pre_refactor/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_91/pre_refactor/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_91/pre_refactor/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/Setup.hs:SrcLoc \"/tmp/project_91/pre_refactor/Setup.hs\" 2 1: function main has branching depth of 0 \n"
          },
          "original_code": "import           Distribution.Simple\nmain = defaultMain\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/Setup.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/Setup.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/Setup.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/app/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 6,
            "average": 2.1666666666666665,
            "sum": 13
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 12,
          "lines_of_code": 127,
          "homplexity_lines_of_code": 169,
          "code_quality_score": 57.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 6,
              "average": 2.1666666666666665,
              "sum": 13
            },
            "homplexity_loc": 169,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 1 1: module Main has 98 lines of code \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 28 1: type signature for main has 1 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 28 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 29 1: function main has 14 lines of code \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 29 1: function main has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 29 1: function main has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 45 1: type signature for dotER has 3 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 45 1: type signature for dotER has type constructor nesting of 1 \nWarning:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 46 1: function dotER has 38 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 46 1: function dotER has cyclomatic complexity of 6 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 46 1: function dotER has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 94 1: type signature for htmlEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 94 1: type signature for htmlEntity has 2 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 95 1: function htmlEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 95 1: function htmlEntity has 9 lines of code \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 95 1: function htmlEntity has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 107 1: type signature for dotEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 107 1: type signature for dotEntity has 2 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 108 1: function dotEntity has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 108 1: function dotEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 108 1: function dotEntity has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 114 1: type signature for graphTitle has 2 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 114 1: type signature for graphTitle has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 115 1: function graphTitle has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 115 1: function graphTitle has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 115 1: function graphTitle has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 123 1: type signature for checkRequirements has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 123 1: type signature for checkRequirements has 1 arguments \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 124 1: function checkRequirements has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 124 1: function checkRequirements has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/app/Main.hs:SrcLoc \"/tmp/project_91/pre_refactor/app/Main.hs\" 124 1: function checkRequirements has 3 lines of code \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n  (main)\nwhere\n\nimport           Control.Applicative                 ((<|>))\nimport           Control.Monad                       (forM_, guard)\nimport qualified Data.ByteString                     as SB\nimport           Data.Maybe                          (fromJust, fromMaybe)\nimport qualified Data.Text.Lazy                      as L\nimport           System.Exit                         (exitFailure)\nimport           System.IO                           (hClose, hPutStrLn, stderr)\n\nimport           Data.GraphViz\nimport qualified Data.GraphViz.Attributes.Colors.X11 as C\nimport qualified Data.GraphViz.Attributes.Complete   as A\nimport qualified Data.GraphViz.Attributes.HTML       as H\nimport qualified Data.GraphViz.Types.Generalised     as G\nimport           Data.GraphViz.Types.Monadic\n\nimport           Erd.Config\nimport           Erd.ER\nimport           Erd.Parse\nimport           Erd.Render                          (htmlAttr, htmlFont,\n                                                      recordAttr, withLabelFmt)\n\nmain :: IO ()\nmain = do\n  checkRequirements -- application may terminate here\n  conf <- configIO\n  er' <- uncurry loadER (cin conf)\n  case er' of\n    Left err -> do\n      hPutStrLn stderr err\n      exitFailure\n    Right er -> let erDot = dotER conf er\n                    toFile h = SB.hGetContents h >>= SB.hPut (snd $ cout conf)\n                    fmt = fromMaybe Pdf (outfmt conf)\n                 in graphvizWithHandle Dot erDot fmt toFile\n  hClose (snd $ cin conf)\n  hClose (snd $ cout conf)\n\n-- | Converts an entire ER-diagram from an ER file into a GraphViz graph.\ndotER :: Config -> ER -> G.DotGraph L.Text\ndotER conf er = graph' $ do\n  graphAttrs (graphTitle $ title er)\n  graphAttrs [ A.RankDir A.FromLeft\n             , A.Splines $ fromConfigOrDefault edgeType\n             ]\n  nodeAttrs nodeGlobalAttributes\n  edgeAttrs [ A.Color [A.toWC $ A.toColor C.Gray50] -- easier to read labels\n            , A.MinLen 2 -- give some breathing room\n            , A.Style [A.SItem (fromConfigOrDefault edgePattern) [] ]\n            ]\n  forM_ (entities er) $ \\e ->\n    node (name e) [entityFmt e]\n  forM_ (rels er) $ relToEdge (fromConfigOrDefault notation)\n    where\n      fromConfigOrDefault :: (Config -> Maybe a) -> a\n      fromConfigOrDefault opt = fromJust $ opt conf <|> opt defaultConfig\n      nodeGlobalAttributes\n        | fromConfigOrDefault dotentity = [shape Record, A.RankDir A.FromTop]\n        | otherwise = [shape PlainText] -- recommended for HTML labels\n      entityFmt\n        | fromConfigOrDefault dotentity = toLabel . dotEntity\n        | otherwise = toLabel . htmlEntity\n      relToEdge n r = edge (entity1 r) (entity2 r) (label:eAttr n)\n        where\n          optss = roptions r\n          labelOrXLabel =\n            case fromConfigOrDefault edgeType of\n              A.Ortho -> A.XLabel -- Graphivz recommends xlabels for ortho edges\n              _ -> A.Label\n          label =\n            labelOrXLabel . A.HtmlLabel . H.Text $ withLabelFmt \" %s \" optss []\n          (c1,c2) = (card1 r, card2 r)\n          eAttr UML = [A.TailLabel $ card2label c1\n                      ,A.HeadLabel $ card2label c2\n                      ]\n            where\n              card2label = A.HtmlLabel . H.Text . htmlFont optss . L.pack . show\n          eAttr IE = [A.Dir Both\n                     ,A.ArrowTail $ card2arr c1\n                     ,A.ArrowHead $ card2arr c2\n                     ]\n            where\n              card2arr ZeroOne  = A.AType [(A.openMod, A.DotArrow), (A.noMods, A.Tee)]\n              card2arr One      = A.AType [(A.noMods, A.Tee), (A.noMods, A.Tee)]\n              card2arr ZeroPlus = A.AType [(A.noMods, A.Crow), (A.openMod, A.DotArrow)]\n              card2arr OnePlus  = A.AType [(A.noMods, A.Crow), (A.noMods, A.Tee)]\n\n-- | Converts a single entity to an HTML label.\nhtmlEntity :: Entity -> H.Label\nhtmlEntity e = H.Table H.HTable\n                 { H.tableFontAttrs = Just $ optionsTo optToFont $ eoptions e\n                 , H.tableAttrs = optionsTo optToHtml (eoptions e)\n                 , H.tableRows = rows\n                 }\n  where rows = headerRow : map htmlAttr (attribs e)\n        headerRow = H.Cells [H.LabelCell [] $ H.Text text]\n        text = withLabelFmt \" [%s]\" (hoptions e) $ boldFont hname\n        hname = htmlFont (hoptions e) (name e)\n        boldFont s = [H.Format H.Bold s]\n\n-- | Converts a single entity to a plain Dot Label\ndotEntity :: Entity -> A.RecordFields\ndotEntity e =  A.FieldLabel ( name e ) : map recordAttr (attribs e)\n\n-- | Extracts and formats a graph title from the options given.\n-- The options should be title options from an ER value.\n-- If a title does not exist, an empty list is returned and `graphAttrs attrs`\n-- should be a no-op.\ngraphTitle :: Options -> [A.Attribute]\ngraphTitle topts =\n  let glabel = optionsTo optToLabel topts\n  in if null glabel then [] else\n       [ A.LabelJust A.JLeft\n       , A.LabelLoc A.VTop\n       , A.Label $ A.HtmlLabel $ H.Text $ htmlFont topts (head glabel)\n       ]\n\ncheckRequirements :: IO ()\ncheckRequirements = (isGraphvizInstalled >>= guard) <|> quitWithoutGraphviz msg\n  where\n    msg = \"GraphViz is not installed on your system.\\n\" ++\n          \"Please install it first, https://github.com/BurntSushi/erd\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/app/Main.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/app/Main.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/app/Main.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/test/Spec.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 3,
          "lines_of_code": 14,
          "homplexity_lines_of_code": 13,
          "code_quality_score": 94.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 13,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 1 1: module Main has 10 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 10 1: function main has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 10 1: function main has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 12 1: type signature for tests has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 13 1: function tests has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Spec.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Spec.hs\" 13 1: function tests has branching depth of 0 \n"
          },
          "original_code": "module Main\n  (main)\nwhere\n\nimport           Test.Erd.Render             (testRender)\nimport           Test.Tasty\nimport           Test.Text.Parsec.Erd.Parser (testEr)\n\nmain :: IO ()\nmain = defaultMain $ testGroup \"Erd Tests\" tests\n\ntests :: [TestTree]\ntests = [testEr,\n         testRender]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/test/Spec.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/test/Spec.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/test/Spec.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 25,
          "homplexity_lines_of_code": 26,
          "code_quality_score": 93.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 26,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 1 1: module Test.Erd.Render has 18 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 14 1: type signature for testRender has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 14 1: type signature for testRender has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 15 1: function testRender has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 15 1: function testRender has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 15 1: function testRender has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 18 1: type signature for test01 has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 18 1: type signature for test01 has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 19 1: function test01 has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 19 1: function test01 has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs\" 19 1: function test01 has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Erd.Render\n  (testRender)\nwhere\n\nimport qualified Erd.ER                        as ER\nimport           Erd.Render                    (htmlAttr)\n\nimport qualified Data.GraphViz.Attributes.HTML as H\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntestRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n                                                 ]\ntest01 :: Assertion\ntest01 = result @?= expected\n  where\n    inputF   = \"Field\"\n    input    = ER.Attribute inputF True False ER.defaultAttrOpts\n    result   = htmlAttr input\n    expected = H.Cells [H.LabelCell [H.Align H.HLeft]\n                        (H.Text [H.Format H.Underline [H.Font [] [H.Str inputF]]])]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/test/Test/Erd/Render.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/test/Test/Erd/Render.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/test/Test/Erd/Render.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 7
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 12,
          "lines_of_code": 282,
          "homplexity_lines_of_code": 246,
          "code_quality_score": 61.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 7
            },
            "homplexity_loc": 246,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 1 1: module Test.Text.Parsec.Erd.Parser has 137 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has 3 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: type signature for testEr has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: type signature for testEr has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: type signature for simpleText has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: type signature for simpleText has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: type signature for simpleResult has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: type signature for simpleResult has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has 15 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: type signature for nfldbText has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: type signature for nfldbText has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 172 18: data ChunckAST has record fields count of 3 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for toAST has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for toAST has 2 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 182 1: type signature for nfldbResult has 1 arguments \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 182 1: type signature for nfldbResult has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has branching depth of 0 \nCritical:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has 84 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n\nmodule Test.Text.Parsec.Erd.Parser\n  (testEr\n  ) where\n\nimport           Data.GraphViz.Attributes.Colors (Color (..))\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.Map                        (fromList)\nimport qualified Data.Map                        as M\nimport           Data.Text                       (Text)\nimport           Data.Text.Lazy                  (fromStrict)\nimport           Erd.ER\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Text.Parsec                     (parse)\nimport           Text.Parsec.Erd.Parser          (AST (..), GlobalOptions (..),\n                                                  document)\nimport           Text.RawString.QQ               (r)\n\nparseDoc :: Text -> (GlobalOptions, [AST]) -> Assertion\nparseDoc input expect= Right expect `shouldBe` parse document \"\" (fromStrict input) where\n  shouldBe = assertEqual \"\"\n\ntestEr :: TestTree\ntestEr = testGroup \"Parse Er\" [\n  testCase \"Parse Simple case\" $ parseDoc simpleText simpleResult,\n  testCase \"Parse nfldb case\" $ parseDoc nfldbText nfldbResult\n                              ]\n\n\nsimpleText :: Text\nsimpleText = [r|\n# Entities are declared in '[' ... ']'. All attributes after the entity header\n# up until the end of the file (or the next entity declaration) correspond\n# to this entity.\n[Person]\n*name\nheight\nweight\n`birth date`\n+birth_place_id\n\n[`Birth Place`]\n*id\n`birth city`\n'birth state'\n\"birth country\"\n\n# Each relationship must be between exactly two entities, which need not\n# be distinct. Each entity in the relationship has exactly one of four\n# possible cardinalities:\n#\n# Cardinality    Syntax\n# 0 or 1         ?\n# exactly 1      1\n# 0 or more      *\n# 1 or more      +\nPerson *--1 `Birth Place`\n|]\n\nsimpleResult :: (GlobalOptions, [AST])\nsimpleResult = (opts, asts) where\n  opts = GlobalOptions M.empty M.empty M.empty M.empty\n  asts = [\n    E (Entity {name = \"Person\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"name\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"height\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"weight\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth date\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth_place_id\", pk = False, fk = True, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    E (Entity {name = \"Birth Place\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"id\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth city\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth state\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth country\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    R (Relation {entity1 = \"Person\", entity2 = \"Birth Place\", card1 = ZeroPlus , card2 = One, roptions = M.empty})]\n\nnfldbText :: Text\nnfldbText = [r|\ntitle {label: \"nfldb Entity-Relationship diagram (condensed)\", size: \"20\"}\n\n# Nice colors from Erwiz:\n# red #fcecec\n# blue #ececfc\n# green #d0e0d0\n# yellow #fbfbdb\n# orange #eee0a0\n\n# Entities\n\n[player] {bgcolor: \"#d0e0d0\"}\n  *player_id {label: \"varchar, not null\"}\n  full_name {label: \"varchar, null\"}\n  team {label: \"varchar, not null\"}\n  position {label: \"player_pos, not null\"}\n  status {label: \"player_status, not null\"}\n\n[team] {bgcolor: \"#d0e0d0\"}\n  *team_id {label: \"varchar, not null\"}\n  city {label: \"varchar, not null\"}\n  name {label: \"varchar, not null\"}\n\n[game] {bgcolor: \"#ececfc\"}\n  *gsis_id {label: \"gameid, not null\"}\n  start_time {label: \"utctime, not null\"}\n  week {label: \"usmallint, not null\"}\n  season_year {label: \"usmallint, not null\"}\n  season_type {label: \"season_phase, not null\"}\n  finished {label: \"boolean, not null\"}\n  home_team {label: \"varchar, not null\"}\n  home_score {label: \"usmallint, not null\"}\n  away_team {label: \"varchar, not null\"}\n  away_score {label: \"usmallint, not null\"}\n\n[drive] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *drive_id {label: \"usmallint, not null\"}\n  start_field {label: \"field_pos, null\"}\n  start_time {label: \"game_time, not null\"}\n  end_field {label: \"field_pos, null\"}\n  end_time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  pos_time {label: \"pos_period, null\"}\n\n[play] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *play_id {label: \"usmallint, not null\"}\n  time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  yardline {label: \"field_pos, null\"}\n  down {label: \"smallint, null\"}\n  yards_to_go {label: \"smallint, null\"}\n\n[play_player] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *+play_id {label: \"usmallint, not null\"}\n  *+player_id {label: \"varchar, not null\"}\n  team {label: \"varchar, not null\"}\n\n[meta] {bgcolor: \"#fcecec\"}\n  version {label: \"smallint, null\"}\n  season_type {label: \"season_phase, null\"}\n  season_year {label: \"usmallint, null\"}\n  week {label: \"usmallint, null\"}\n\n# Relationships\n\nplayer      *--1 team\ngame        *--1 team {label: \"home\"}\ngame        *--1 team {label: \"away\"}\ndrive       *--1 team\nplay        *--1 team\nplay_player *--1 team\n\ngame        1--* drive\ngame        1--* play\ngame        1--* play_player\n\ndrive       1--* play\ndrive       1--* play_player\n\nplay        1--* play_player\n\nplayer      1--* play_player\n|]\n\n\ndata ChunckAST = CE [Entity]\n    | CA [Attribute]\n    | CR [Relation]\n    deriving (Eq)\n\ntoAST :: ChunckAST -> [AST]\ntoAST (CE x) = map E x\ntoAST (CA x) = map A x\ntoAST (CR x) = map R x\n\nnfldbResult :: (GlobalOptions, [AST])\nnfldbResult = (opts, asts) where\n  opts = GlobalOptions {gtoptions = fromList [(\"label\",Label \"nfldb Entity-Relationship diagram (condensed)\"),(\"size\",FontSize 20.0)], ghoptions = M.empty, geoptions = M.empty, groptions = M.empty}\n  asts = concatMap toAST $ es:(attributes ++ [relations])\n  es = CE [\n    Entity {name = \"player\", attribs = [],\n      hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))],\n      eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]\n           }\n    ]\n  attributes = [\n    CA [\n        Attribute {field = \"player_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"full_name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"position\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_pos, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"status\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_status, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"team\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]}\n      ],\n    CA [\n        Attribute {field = \"team_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"city\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"game\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"utctime, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"finished\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"boolean, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"drive\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"pos_period, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yardline\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"down\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yards_to_go\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play_player\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"player_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n     ],\n     CE [\n        Entity {name = \"meta\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))]}\n       ],\n    CA [\n        Attribute {field = \"version\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ]\n    ]\n  relations = CR [\n     Relation {entity1 = \"player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"home\")]},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"away\")]},\n     Relation {entity1 = \"drive\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play_player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"drive\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"player\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty} ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/test/Test/Text/Parsec/Erd/Parser.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/src/Erd/ER.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 2,
            "average": 1.0769230769230769,
            "sum": 14
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 201,
          "homplexity_lines_of_code": 181,
          "code_quality_score": 53.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 2,
              "average": 1.0769230769230769,
              "sum": 14
            },
            "homplexity_loc": 181,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 1 1: module Erd.ER has 130 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 24 11: data ER has record fields count of 3 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 32 15: data Entity has record fields count of 4 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 44 18: data Attribute has record fields count of 4 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 65 1: function mergeOpts has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 65 1: function mergeOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 65 1: function mergeOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 70 1: type signature for optionsTo has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 70 1: type signature for optionsTo has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 71 1: function optionsTo has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 71 1: function optionsTo has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 71 1: function optionsTo has cyclomatic complexity of 1 \nCritical:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 75 15: data Option has record fields count of 11 must never reach 9\nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 92 1: type signature for optionByName has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 92 1: type signature for optionByName has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 93 1: function optionByName has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 93 1: function optionByName has 12 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 93 1: function optionByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 107 1: type signature for optionParse has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 107 1: type signature for optionParse has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 108 1: function optionParse has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 108 1: function optionParse has 5 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 108 1: function optionParse has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 115 1: type signature for optToFont has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 115 1: type signature for optToFont has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 116 1: function optToFont has 4 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 116 1: function optToFont has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 116 1: function optToFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 123 1: type signature for optToHtml has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 123 1: type signature for optToHtml has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 124 1: function optToHtml has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 124 1: function optToHtml has 8 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 124 1: function optToHtml has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 135 1: type signature for optToLabel has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 135 1: type signature for optToLabel has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 136 1: function optToLabel has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 136 1: function optToLabel has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 136 1: function optToLabel has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 145 17: data Relation has record fields count of 3 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 152 20: data Cardinality has record fields count of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 165 1: type signature for cardByName has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 165 1: type signature for cardByName has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 166 1: function cardByName has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 166 1: function cardByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 166 1: function cardByName has 5 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 196 1: function defaultRelOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 196 1: function defaultRelOpts has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 196 1: function defaultRelOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 198 1: type signature for defaultAttrOpts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 198 1: type signature for defaultAttrOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has 2 lines of code \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.ER\n  ( ER(..)\n  , Entity(..)\n  , Attribute(..)\n  , Options, mergeOpts, optionsTo\n  , Option(..), optionByName, optToFont, optToHtml, optToLabel\n  , Relation(..) , Cardinality(..), cardByName\n  , defaultAttrOpts, defaultTitleOpts, defaultEntityOpts, defaultHeaderOpts, defaultRelOpts\n  )\nwhere\n\nimport qualified Data.Map                        as M\nimport           Data.Maybe                      (mapMaybe)\nimport           Data.Text.Lazy\nimport           Data.Word                       (Word8)\nimport           Text.Printf                     (printf)\n\nimport           Data.GraphViz.Attributes.Colors (Color)\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.GraphViz.Parsing           (ParseDot, parse, runParser)\n\n-- | Represents a single schema.\ndata ER = ER\n    { entities :: [Entity]\n    , rels     :: [Relation]\n    , title    :: Options\n    }\n    deriving (Show, Eq)\n\n-- | Represents a single entity in a schema.\ndata Entity = Entity\n    { name     :: Text\n    , attribs  :: [Attribute]\n    , hoptions :: Options\n    , eoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Entity where\n  e1 `compare` e2 = name e1 `compare` name e2\n\n-- | Represents a single attribute in a particular entity.\ndata Attribute = Attribute\n    { field    :: Text\n    , pk       :: Bool\n    , fk       :: Bool\n    , aoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Attribute where\n  a1 `compare` a2 = field a1 `compare` field a2\n\n-- | Represents any number of options for an item in an ER diagram.\n-- An item may be the graph title, an entity, an entity header or a\n-- relationship between entities. Keys are options as specified in ER files.\n--\n-- Note that a set of options may include a label for any item.\ntype Options = M.Map String Option\n\n-- | Given two sets of options, merge the second into first, where elements\n-- in the first take precedence.\nmergeOpts :: Options -> Options -> Options\nmergeOpts opts1 opts2 = opts1 `M.union` opts2\n\n-- | Given a set of options and a selector function, return the list of\n-- only those options which matched. Examples of the selector function are\n-- `optToFont`, `optToHtml` and `optToLabel`.\noptionsTo :: (Option -> Maybe a) -> Options -> [a]\noptionsTo f = mapMaybe f . M.elems\n\n-- | A restricted subset of options in GraphViz that can be configured in\n-- an ER file.\ndata Option = Label String\n    | BgColor Color\n    | Color Color\n    | FontFace Text\n    | FontSize Double\n    | Border Word8\n    | BorderColor Color\n    | CellSpacing Word8\n    | CellBorder Word8\n    | CellPadding Word8\n    | TextAlignment H.Align\n    deriving (Show, Eq)\n\n-- | Given an option name and a string representation of its value,\n-- `optionByName` will attempt to parse the string as a value corresponding\n-- to the option. If the option doesn't exist or there was a problem parsing\n-- the value, an error is returned.\noptionByName :: String -> String -> Either String Option\noptionByName \"label\" = Right . Label\noptionByName \"color\" = optionParse Color\noptionByName \"bgcolor\" = optionParse BgColor\noptionByName \"size\" = optionParse FontSize\noptionByName \"font\" = optionParse FontFace\noptionByName \"border\" = optionParse Border\noptionByName \"border-color\" = optionParse BorderColor\noptionByName \"cellspacing\" = optionParse CellSpacing\noptionByName \"cellborder\" = optionParse CellBorder\noptionByName \"cellpadding\" = optionParse CellPadding\noptionByName \"text-alignment\" = optionParse TextAlignment\noptionByName unk = const (Left $ printf \"Option '%s' does not exist.\" unk)\n\n-- | A wrapper around the GraphViz's parser for any particular option.\noptionParse :: ParseDot a => (a -> Option) -> String -> Either String Option\noptionParse con s =\n  case fst $ runParser parse quoted of\n    Left err -> Left (printf \"%s (bad value '%s')\" err s)\n    Right a  -> Right (con a)\n  where quoted = \"\\\"\" `append` pack s `append` \"\\\"\"\n\n-- | Selects an option if and only if it corresponds to a font attribute.\noptToFont :: Option -> Maybe H.Attribute\noptToFont (Color c)    = Just $ H.Color c\noptToFont (FontFace s) = Just $ H.Face s\noptToFont (FontSize d) = Just $ H.PointSize d\noptToFont _            = Nothing\n\n-- | Selects an option if and only if it corresponds to an HTML attribute.\n-- In particular, for tables or table cells.\noptToHtml :: Option -> Maybe H.Attribute\noptToHtml (BgColor c)       = pure $ H.BGColor c\noptToHtml (Border w)        = pure $ H.Border w\noptToHtml (BorderColor c)   = pure $ H.Color c\noptToHtml (CellSpacing w)   = pure $ H.CellSpacing w\noptToHtml (CellBorder w)    = pure $ H.CellBorder w\noptToHtml (CellPadding w)   = pure $ H.CellPadding w\noptToHtml (TextAlignment x) = pure $ H.Align x\noptToHtml _                 = Nothing\n\n\n-- | Selects an option if and only if it corresponds to a label.\noptToLabel :: Option -> Maybe Text\noptToLabel (Label s) = Just $ pack s\noptToLabel _         = Nothing\n\n-- | Represents a relationship between exactly two entities. After parsing,\n-- each `rel` is guaranteed to correspond to an entity defined in the same\n-- ER file.\n--\n-- Each relationship has one of four cardinalities specified for both entities.\n-- Those cardinalities are: 0 or 1, exactly 1, 0 or more and 1 or more.\ndata Relation = Relation\n    { entity1, entity2 :: Text\n    , card1, card2     :: Cardinality\n    , roptions         :: Options\n    }\n    deriving (Show, Eq)\n\ndata Cardinality = ZeroOne\n    | One\n    | ZeroPlus\n    | OnePlus\n    deriving (Eq)\n\ninstance Show Cardinality where\n  show ZeroOne  = \"{0,1}\"\n  show One      = \"1\"\n  show ZeroPlus = \"0..N\"\n  show OnePlus  = \"1..N\"\n\n-- | Maps a string representation to a particular relationship cardinality.\ncardByName :: Char -> Maybe Cardinality\ncardByName '?' = Just ZeroOne\ncardByName '1' = Just One\ncardByName '*' = Just ZeroPlus\ncardByName '+' = Just OnePlus\ncardByName _   = Nothing\n\n-- | Hard-coded default options for all graph titles.\ndefaultTitleOpts :: Options\ndefaultTitleOpts = M.fromList\n  [ (\"size\", FontSize 30)\n  ]\n\n-- | Hard-coded default options for all entity headers.\ndefaultHeaderOpts :: Options\ndefaultHeaderOpts = M.fromList\n  [ (\"size\", FontSize 16)\n  ]\n\n-- | Hard-coded default options for all entities.\ndefaultEntityOpts :: Options\ndefaultEntityOpts = M.fromList\n  [ (\"border\", Border 0)\n  , (\"cellborder\", CellBorder 1)\n  , (\"cellspacing\", CellSpacing 0)\n  , (\"cellpadding\", CellPadding 4)\n  , (\"font\", FontFace \"Helvetica\")\n  ]\n\n-- | Hard-coded default options for all relationships.\ndefaultRelOpts :: Options\ndefaultRelOpts = M.empty\n\ndefaultAttrOpts :: Options\ndefaultAttrOpts = M.fromList\n  [ (\"text-alignment\", TextAlignment H.HLeft)\n  ]\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/src/Erd/ER.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/src/Erd/ER.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/src/Erd/ER.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/src/Erd/Parse.hs",
          "cyclomatic_complexity": {
            "min": 3,
            "max": 6,
            "average": 4.5,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 88,
          "homplexity_lines_of_code": 123,
          "code_quality_score": 69.7,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 3,
              "max": 6,
              "average": 4.5,
              "sum": 9
            },
            "homplexity_loc": 123,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 1 1: module Erd.Parse has 70 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 21 1: type signature for loadER has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 21 1: type signature for loadER has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 22 1: function loadER has 13 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 22 1: function loadER has cyclomatic complexity of 3 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 22 1: function loadER has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 44 1: type signature for toER has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 44 1: type signature for toER has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 45 1: function toER has cyclomatic complexity of 6 \nWarning:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 45 1: function toER has 40 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_91/pre_refactor/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Parse.hs\" 45 1: function toER has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.Parse\n  ( loadER\n  )\nwhere\n\nimport           Erd.ER\n\nimport           Control.Exception      (bracket_)\nimport           Control.Monad          (when,unless)\nimport           Data.List              (find)\nimport           Data.Maybe\nimport           Data.Text.Lazy         hiding (find, map, reverse)\nimport           Data.Text.Lazy.IO\nimport           System.IO              (Handle,hIsTerminalDevice,hSetEncoding,\n                                         hGetEncoding,utf8)\nimport           Text.Parsec\nimport           Text.Parsec.Erd.Parser (AST (..), GlobalOptions (..), document)\nimport           Text.Printf            (printf)\n\nloadER :: String -> Handle -> IO (Either String ER)\nloadER fpath f = do\n  Just initialEncoding <- hGetEncoding f\n  isTerminalDevice <- hIsTerminalDevice f\n  let setEncodingIfNeeded = unless isTerminalDevice . hSetEncoding f\n  bracket_\n    (setEncodingIfNeeded utf8)\n    (setEncodingIfNeeded initialEncoding)\n    (do\n      s <- hGetContents f\n      case parse (do { (opts, ast) <- document; return $ toER opts ast}) fpath s of\n        Left err           -> return $ Left $ show err\n        Right err@(Left _) -> return err\n        Right (Right er)   -> return $ Right er\n    )\n\n-- | Converts a list of syntactic categories in an entity-relationship\n-- description to an ER representation. If there was a problem with the\n-- conversion, an error is reported. This includes checking that each\n-- relationship contains only valid entity names.\n--\n-- This preserves the ordering of the syntactic elements in the original\n-- description.\ntoER :: GlobalOptions -> [AST] -> Either String ER\ntoER gopts = toER' (ER [] [] erTitle)\n  where erTitle = gtoptions gopts `mergeOpts` defaultTitleOpts\n\n        toER' :: ER -> [AST] -> Either String ER\n        toER' er [] = Right (reversed er) >>= validRels\n        toER' ER { entities = [] } (A a:_) =\n          let fieldName = show (field a)\n          in  Left $ printf \"Attribute '%s' comes before first entity.\" fieldName\n        toER' er@ER { entities = e':es } (A a:xs) = do\n          let e = e' { attribs = a:attribs e' }\n          toER' (er { entities = e:es }) xs\n        toER' er@ER { entities = es } (E e:xs) = do\n          let opts = eoptions e\n                     `mergeOpts` geoptions gopts\n                     `mergeOpts` defaultEntityOpts\n          let hopts = eoptions e\n                      `mergeOpts` ghoptions gopts\n                      `mergeOpts` defaultHeaderOpts\n          toER' (er { entities = e { eoptions = opts, hoptions = hopts }:es}) xs\n        toER' er@ER { rels = rs } (R r:xs) = do\n          let opts = roptions r\n                     `mergeOpts` groptions gopts\n                     `mergeOpts` defaultRelOpts\n          toER' (er { rels = r { roptions = opts }:rs }) xs\n\n        reversed :: ER -> ER\n        reversed er@ER { entities = es, rels = rs } =\n          let es' = map (\\e -> e { attribs = reverse (attribs e) }) es\n          in  er { entities = reverse es', rels = reverse rs }\n\n        validRels :: ER -> Either String ER\n        validRels er = validRels' (rels er) er\n\n        validRels' :: [Relation] -> ER -> Either String ER\n        validRels' [] er = return er\n        validRels' (r:_) er = do\n          let r1 = find (\\e -> name e == entity1 r) (entities er)\n          let r2 = find (\\e -> name e == entity2 r) (entities er)\n          let err getter = Left\n                             $ printf \"Unknown entity '%s' in relationship.\"\n                             $ unpack $ getter r\n          when (isNothing r1) (err entity1)\n          when (isNothing r2) (err entity2)\n          return er\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/src/Erd/Parse.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/src/Erd/Parse.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/src/Erd/Parse.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/src/Erd/Render.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 1.75,
            "sum": 7
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 4,
          "lines_of_code": 41,
          "homplexity_lines_of_code": 41,
          "code_quality_score": 81.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 1.75,
              "sum": 7
            },
            "homplexity_loc": 41,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 1 1: module Erd.Render has 28 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 19 1: function htmlAttr has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 19 1: function htmlAttr has 7 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 19 1: function htmlAttr has cyclomatic complexity of 3 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 27 1: type signature for recordAttr has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 27 1: type signature for recordAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 28 1: function recordAttr has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 28 1: function recordAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 28 1: function recordAttr has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 31 1: type signature for htmlFont has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 31 1: type signature for htmlFont has 3 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 32 1: function htmlFont has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 32 1: function htmlFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 32 1: function htmlFont has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 37 1: type signature for withLabelFmt has 4 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 37 1: type signature for withLabelFmt has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 38 1: function withLabelFmt has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 38 1: function withLabelFmt has 4 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Render.hs\" 38 1: function withLabelFmt has branching depth of 1 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Erd.Render\n  (htmlAttr,\n   htmlFont,\n   recordAttr,\n   withLabelFmt\n  ) where\n\nimport qualified Erd.ER                            as ER\n\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Attributes.HTML     as H\nimport qualified Data.Text.Lazy                    as L\nimport           Text.Printf                       (printf)\n\n-- | Converts a single attribute to an HTML table row.\nhtmlAttr :: ER.Attribute -> H.Row\nhtmlAttr a = H.Cells [cell]\n  where cell    = H.LabelCell cellAttrs (H.Text $ withLabelFmt \" [%s]\" opts name)\n        name    = fkfmt $ pkfmt $ htmlFont opts (ER.field a)\n        pkfmt s = if ER.pk a then [H.Format H.Underline s] else s\n        fkfmt s = if ER.fk a then [H.Format H.Italics s] else s\n        opts    = ER.aoptions a\n        cellAttrs = ER.optionsTo ER.optToHtml opts\n-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a -- should change to add port support!\n-- | Formats an arbitrary string with the options given (using only font\n-- attributes).\nhtmlFont :: ER.Options -> L.Text -> H.Text\nhtmlFont opts s = [H.Font (ER.optionsTo ER.optToFont opts) [H.Str s]]\n\n-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\nwithLabelFmt :: String -> ER.Options -> H.Text -> H.Text\nwithLabelFmt fmt opts s =\n  case ER.optionsTo ER.optToLabel opts of\n    (x:_) -> s ++ htmlFont opts (L.pack $ printf fmt $ L.unpack x)\n    _     -> s\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/src/Erd/Render.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/src/Erd/Render.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/src/Erd/Render.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/src/Erd/Config.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 7,
            "average": 1.5217391304347827,
            "sum": 35
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 11,
          "lines_of_code": 335,
          "homplexity_lines_of_code": 446,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 7,
              "average": 1.5217391304347827,
              "sum": 35
            },
            "homplexity_loc": 446,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 1 1: module Erd.Config has 266 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 42 17: data Notation has record fields count of 0 \nWarning:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 46 15: data Config has record fields count of 8 should be less than 6\nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 58 19: data ConfigFile has record fields count of 5 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 68 1: type signature for emptyConfigFile has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 68 1: type signature for emptyConfigFile has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 69 1: function emptyConfigFile has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 69 1: function emptyConfigFile has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 69 1: function emptyConfigFile has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 82 1: type signature for defaultConfig has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 82 1: type signature for defaultConfig has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 83 1: function defaultConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 83 1: function defaultConfig has 9 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 83 1: function defaultConfig has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 94 1: type signature for defaultConfigFile has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 94 1: type signature for defaultConfigFile has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 95 1: function defaultConfigFile has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 95 1: function defaultConfigFile has 8 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 95 1: function defaultConfigFile has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 110 1: type signature for configIO has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 110 1: type signature for configIO has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 111 1: function configIO has branching depth of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 111 1: function configIO has 17 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 111 1: function configIO has cyclomatic complexity of 4 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 135 1: type signature for opts has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 135 1: type signature for opts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 136 1: function opts has cyclomatic complexity of 7 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 136 1: function opts has branching depth of 1 \nCritical:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 136 1: function opts has 87 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 232 1: type signature for toConfig has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 232 1: type signature for toConfig has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 233 1: function toConfig has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 233 1: function toConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 233 1: function toConfig has 5 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 240 1: type signature for readGlobalConfigFile has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 240 1: type signature for readGlobalConfigFile has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has 5 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 249 1: type signature for readConfigFile has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 249 1: type signature for readConfigFile has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 250 1: function readConfigFile has branching depth of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 250 1: function readConfigFile has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 250 1: function readConfigFile has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 258 1: type signature for fmts has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 258 1: type signature for fmts has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 259 1: function fmts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 259 1: function fmts has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 259 1: function fmts has 13 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 274 1: type signature for edges has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 274 1: type signature for edges has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 275 1: function edges has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 275 1: function edges has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 275 1: function edges has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 283 1: type signature for valBool has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 283 1: type signature for valBool has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 284 1: function valBool has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 284 1: function valBool has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 284 1: function valBool has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 288 1: type signature for edgePatterns has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 288 1: type signature for edgePatterns has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 289 1: function edgePatterns has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 289 1: function edgePatterns has 4 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 289 1: function edgePatterns has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 295 1: type signature for notations has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 295 1: type signature for notations has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 296 1: function notations has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 296 1: function notations has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 296 1: function notations has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 304 1: type signature for takeExtension has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 304 1: type signature for takeExtension has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 305 1: function takeExtension has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 305 1: function takeExtension has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 305 1: function takeExtension has 2 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 308 1: type signature for toGraphFmt has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 308 1: type signature for toGraphFmt has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 309 1: function toGraphFmt has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 309 1: function toGraphFmt has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 309 1: function toGraphFmt has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 311 1: type signature for toEdgeG has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 311 1: type signature for toEdgeG has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 312 1: function toEdgeG has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 312 1: function toEdgeG has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 312 1: function toEdgeG has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 314 1: type signature for toEdgePattern has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 314 1: type signature for toEdgePattern has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 315 1: function toEdgePattern has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 315 1: function toEdgePattern has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 315 1: function toEdgePattern has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 317 1: type signature for toNotation has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 317 1: type signature for toNotation has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 318 1: function toNotation has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 318 1: function toNotation has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 318 1: function toNotation has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 320 1: type signature for usageExit has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 320 1: type signature for usageExit has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 321 1: function usageExit has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 321 1: function usageExit has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 321 1: function usageExit has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 323 1: type signature for usage has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 323 1: type signature for usage has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 324 1: function usage has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 324 1: function usage has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 324 1: function usage has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 326 1: type signature for erdVersion has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 326 1: type signature for erdVersion has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 327 1: function erdVersion has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 327 1: function erdVersion has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 327 1: function erdVersion has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 331 1: type signature for ef has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 331 1: type signature for ef has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 332 1: function ef has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 332 1: function ef has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 332 1: function ef has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 334 1: type signature for strip has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 334 1: type signature for strip has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 335 1: function strip has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 335 1: function strip has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Erd/Config.hs\" 335 1: function strip has cyclomatic complexity of 1 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nmodule Erd.Config\n  ( Config(..)\n  , configIO\n  , defaultConfig\n  , defaultConfigFile\n  , Notation(..)\n  )\nwhere\n\nimport           Control.Exception                 (tryJust)\nimport           Control.Monad                     (guard)\nimport qualified Data.ByteString.Char8             as B\nimport           Data.Char                         (isSpace)\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Commands            as G\nimport           Data.List                         (dropWhileEnd, intercalate)\nimport qualified Data.Map                          as M\nimport           Data.Maybe                        (isNothing)\nimport           Data.Version                      (showVersion)\nimport           Data.Yaml                         (FromJSON (..), (.:?))\nimport qualified Data.Yaml                         as Y\nimport           Development.GitRev                (gitHash)\nimport           Paths_erd                         (version)\nimport qualified System.Console.GetOpt             as O\nimport           System.Directory                  (getHomeDirectory)\nimport           System.Environment                (getArgs)\nimport           System.Exit                       (exitFailure, exitSuccess)\nimport           System.FilePath                   ((</>))\nimport           System.IO                         (Handle, IOMode (..),\n                                                    openFile, stderr, stdin,\n                                                    stdout)\nimport           System.IO.Error                   (isDoesNotExistError)\nimport           Text.Printf                       (HPrintfType, hPrintf,\n                                                    printf)\nimport           Text.RawString.QQ\n\n-- | Notation style for relations.\ndata Notation = UML | IE\n  deriving Show\n\n-- | Config represents all information from command line flags.\ndata Config = Config\n    { cin         :: (String, Handle)\n    , cout        :: (String, Handle)\n    , outfmt      :: Maybe G.GraphvizOutput\n    , edgeType    :: Maybe A.EdgeType\n    , configFile  :: Maybe FilePath\n    , dotentity   :: Maybe Bool\n    , edgePattern :: Maybe A.StyleName\n    , notation    :: Maybe Notation\n    }\n\n-- | Represents fields that are stored in the configuration file.\ndata ConfigFile = ConfigFile\n    { cFmtOut      :: Maybe String\n    , cEdgeType    :: Maybe String\n    , cDotEntity   :: Maybe Bool\n    , cEdgePattern :: Maybe String\n    , cNotation    :: Maybe String\n    }\n    deriving Show\n\n-- | A ConfigFile with all fields initialized with Nothing.\nemptyConfigFile :: ConfigFile\nemptyConfigFile = ConfigFile Nothing Nothing Nothing Nothing Nothing\n\ninstance FromJSON ConfigFile where\n  parseJSON (Y.Object v) =\n    ConfigFile <$>\n    v .:? \"output-format\" <*>\n    v .:? \"edge-style\" <*>\n    v .:? \"dot-entity\" <*>\n    v .:? \"edge-pattern\" <*>\n    v .:? \"notation\"\n  parseJSON Y.Null = return emptyConfigFile\n  parseJSON _ = fail \"Incorrect configuration file.\"\n\ndefaultConfig :: Config\ndefaultConfig =\n  Config { cin = (\"<stdin>\", stdin)\n         , cout = (\"<stdout>\", stdout)\n         , outfmt = Nothing\n         , edgeType = Just A.SplineEdges\n         , configFile = Nothing\n         , dotentity = Just False\n         , edgePattern = Just A.Dashed\n         , notation = Just UML\n         }\n\ndefaultConfigFile :: B.ByteString\ndefaultConfigFile = B.unlines\n  [[r|# Erd (~/.erd.yaml) default configuration file.|],\n   B.append [r|output-format: pdf           # Supported formats: |] (defVals fmts),\n   B.append [r|edge-style: spline           # Supported values : |] (defVals edges),\n   B.append [r|dot-entity: false            # Supported values : |] (defVals valBool),\n   B.append [r|edge-pattern: dashed         # Supported values : |] (defVals edgePatterns),\n   B.append [r|notation: uml                # Supported values : |] (defVals notations)\n  ]\n  where\n    defVals = B.pack . unwords . M.keys\n\n-- | Creates a new Config value from command line options.\n-- If an output path is given and `--fmt` is omitted, then a format\n-- will be inferred from the output path extension.\n-- Failing all of that, PDF is used by default.\nconfigIO :: IO Config\nconfigIO = do\n  args <- getArgs\n  case O.getOpt O.Permute opts args of\n    (flags, [], []) -> do\n      conf <- foldl (\\c app -> app c) (return defaultConfig) flags\n      let outpath = fst (cout conf)\n      return $\n        if isNothing (outfmt conf) && outpath /= \"<stdout>\" then\n          conf { outfmt = toGraphFmt $ takeExtension outpath }\n        else\n          conf\n    (_, _, errs@(_:_)) -> do\n      ef \"Error(s) parsing flags:\\n\\t%s\\n\" $\n        intercalate \"\\n\\t\" $ map strip errs\n      exitFailure\n    (_, _, []) -> do\n      ef \"erd does not have any positional arguments.\\n\\n\"\n      usageExit\n\n-- | Order of processing command-line options is important to keep priority of\n-- configuration sources, in terms of increasing precedence.\n-- 1. Command-line options\n-- 2. Configuration file of arbitrary path, e.g. '-c\"/tmp/myconfig.yaml\"'\n-- 3. Configuration file: ~/.erd.yaml\nopts :: [O.OptDescr (IO Config -> IO Config)]\nopts =\n  [ O.Option \"c\" [\"config\"]\n      (O.OptArg (\\mf cIO -> cIO >>= \\c -> do\n                      globConfFile <- readGlobalConfigFile\n                      f <- readConfigFile mf\n                      case (f, globConfFile) of\n                        (Nothing, Nothing) ->      -- Config-file is desired, but unavailable.\n                          B.putStr defaultConfigFile >> return c\n                        (Nothing, Just x) -> -- Use global config-file from ~/.erd.yaml .\n                          return $ toConfig x\n                        (Just x, _) ->        -- Use user specified config-file.\n                          return $ toConfig x\n                    ) \"FILE\")\n      \"Configuration file.\"\n  , O.Option \"i\" [\"input\"]\n      (O.ReqArg (\\fpath cIO -> do\n                   c <- cIO\n                   i <- openFile fpath ReadMode\n                   return $ c {cin = (fpath, i)}\n                )\n                \"FILE\")\n      (\"When set, input will be read from the given file.\\n\"\n       ++ \"Otherwise, stdin will be used.\")\n  , O.Option \"o\" [\"output\"]\n      (O.ReqArg (\\fpath cIO -> do\n                    c <- cIO\n                    o <- openFile fpath WriteMode\n                    return $ c {cout = (fpath, o)}\n                )\n                \"FILE\")\n      (\"When set, output will be written to the given file.\\n\"\n       ++ \"Otherwise, stdout will be used.\\n\"\n       ++ \"If given and if --fmt is omitted, then the format will be\\n\"\n       ++ \"guessed from the file extension.\")\n  , O.Option \"h\" [\"help\"]\n      (O.NoArg $ const usageExit)\n      \"Show this usage message.\"\n  , O.Option \"f\" [\"fmt\"]\n      (O.ReqArg (\\fmt cIO -> do\n                    c <- cIO\n                    let mfmt = toGraphFmt fmt\n                    case mfmt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid output format.\\n\" fmt\n                        exitFailure\n                      Just gfmt -> return c {outfmt = Just gfmt}\n                )\n                \"FMT\")\n      (descriptionWithValuesList \"Force the output format to one of\" fmts)\n  , O.Option \"e\" [\"edge\"]\n      (O.ReqArg (\\edge cIO -> do\n                    c <- cIO\n                    let edgeG = toEdgeG edge\n                    case edgeG of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge.\\n\" edge\n                        exitFailure\n                      Just x -> return c {edgeType = Just x}\n                )\n                \"EDGE\")\n      (descriptionWithValuesList \"Select one type of edge\" edges)\n  , O.Option \"p\" [\"edge-pattern\"]\n      (O.ReqArg (\\epat cIO -> do\n                    c <- cIO\n                    case toEdgePattern epat of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge pattern.\\n\" epat\n                        exitFailure\n                      Just x -> return c {edgePattern = Just x}\n                )\n                \"PATTERN\")\n      (descriptionWithValuesList \"Select one of the edge patterns\" edgePatterns)\n  , O.Option \"n\" [\"notation\"]\n      (O.ReqArg (\\nt cIO -> do\n                    c <- cIO\n                    case toNotation nt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid notation style.\\n\" nt\n                        exitFailure\n                      Just x -> return c {notation = Just x}\n                )\n                \"NOTATION\")\n      (descriptionWithValuesList \"Select one of the notation styles\" notations)\n  , O.Option \"d\" [\"dot-entity\"]\n      (O.NoArg (\\cIO -> do\n                    c <- cIO\n                    return $ c { dotentity = Just True } ))\n      (\"When set, output will consist of regular dot tables instead of HTML tables.\\n\"\n      ++ \"Formatting will be disabled. Use only for further manual configuration.\")\n  , O.Option \"v\" [\"version\"]\n      (O.NoArg $ const erdVersion) \"Shows version of application and revision code.\"\n  ]\n  where\n    descriptionWithValuesList :: String -> M.Map String a -> String\n    descriptionWithValuesList txt m = printf (txt <> \":\\n%s.\") (intercalate \", \" $ M.keys m)\n\ntoConfig :: ConfigFile -> Config\ntoConfig c = defaultConfig {outfmt      = cFmtOut c >>= toGraphFmt,\n                            edgeType    = cEdgeType c >>= toEdgeG,\n                            dotentity   = cDotEntity c,\n                            edgePattern = cEdgePattern c >>= toEdgePattern,\n                            notation    = cNotation c >>= toNotation}\n\n-- | Reads and parses configuration file at default location: ~/.erd.yaml\nreadGlobalConfigFile :: IO (Maybe ConfigFile)\nreadGlobalConfigFile = do\n  mHome <- tryJust (guard . isDoesNotExistError) getHomeDirectory\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> readConfigFile $ Just (home </> \".erd.yaml\")\n\n-- | Reads and parses a configuration file, exceptions may come via\n-- AesonException.\nreadConfigFile :: Maybe FilePath -> IO (Maybe ConfigFile)\nreadConfigFile Nothing = return Nothing\nreadConfigFile (Just f) = do\n  mHome <- tryJust (guard . isDoesNotExistError) $ B.readFile f\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> Y.decodeThrow home\n\n-- | A subset of formats supported from GraphViz.\nfmts :: M.Map String G.GraphvizOutput\nfmts = M.fromList\n  [ (\"pdf\", G.Pdf)\n  , (\"svg\", G.Svg)\n  , (\"eps\", G.Eps)\n  , (\"bmp\", G.Bmp)\n  , (\"jpg\", G.Jpeg)\n  , (\"png\", G.Png)\n  , (\"gif\", G.Gif)\n  , (\"tiff\", G.Tiff)\n  , (\"dot\", G.Canon)\n  , (\"ps\", G.Ps)\n  , (\"ps2\", G.Ps2)\n  , (\"plain\", G.Plain)\n  ]\n\nedges :: M.Map String A.EdgeType\nedges = M.fromList\n  [ (\"spline\", A.SplineEdges)\n  , (\"ortho\", A.Ortho)\n  , (\"noedge\", A.NoEdges)\n  , (\"poly\", A.PolyLine)\n  , (\"compound\", A.CompoundEdge)\n  ]\n\nvalBool :: M.Map String Bool\nvalBool = M.fromList\n  [ (\"true\", True)\n  , (\"false\", False) ]\n\nedgePatterns :: M.Map String A.StyleName\nedgePatterns = M.fromList\n  [ (\"solid\", A.Solid)\n  , (\"dashed\", A.Dashed)\n  , (\"dotted\", A.Dotted)\n  ]\n\nnotations :: M.Map String Notation\nnotations = M.fromList\n  [ (\"uml\", UML)\n  , (\"ie\", IE)\n  ]\n\n-- | takeExtension returns the last extension from a file path, or the\n-- empty string if no extension was found. e.g., the extension of\n-- \"wat.pdf\" is \"pdf\".\ntakeExtension :: String -> String\ntakeExtension s = if null rest then \"\" else reverse ext\n  where (ext, rest) = span (/= '.') $ reverse s\n\ntoGraphFmt :: String -> Maybe G.GraphvizOutput\ntoGraphFmt = (`M.lookup` fmts)\n\ntoEdgeG :: String -> Maybe A.EdgeType\ntoEdgeG = (`M.lookup` edges)\n\ntoEdgePattern :: String -> Maybe A.StyleName\ntoEdgePattern = (`M.lookup` edgePatterns)\n\ntoNotation :: String -> Maybe Notation\ntoNotation = (`M.lookup` notations)\n\nusageExit :: IO a\nusageExit = usage >> exitFailure\n\nusage :: IO ()\nusage = hPrintf stderr \"%s\\n\" $ O.usageInfo \"Usage: erd [flags]\" opts\n\nerdVersion :: IO a\nerdVersion = do\n  hPrintf stdout \"erd-%s %s\\n\" (showVersion version) ($(gitHash) :: String)\n  exitSuccess\n\nef :: HPrintfType r => String -> r\nef = hPrintf stderr\n\nstrip :: String -> String\nstrip = dropWhile isSpace . dropWhileEnd isSpace\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/src/Erd/Config.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/src/Erd/Config.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/src/Erd/Config.hs"
          }
        },
        {
          "file_name": "/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 1.375,
            "sum": 22
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 5,
          "lines_of_code": 162,
          "homplexity_lines_of_code": 231,
          "code_quality_score": 32.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 1.375,
              "sum": 22
            },
            "homplexity_loc": 231,
            "homplexity_output": "Info:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 1 1: module Text.Parsec.Erd.Parser has 138 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 25 12: data AST has record fields count of 3 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 30 22: data GlobalOptions has record fields count of 4 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 38 1: type signature for emptyGlobalOptions has type constructor nesting of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 38 1: type signature for emptyGlobalOptions has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 41 1: type signature for document has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 41 1: type signature for document has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has 10 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 53 1: type signature for entity has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 53 1: type signature for entity has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 61 1: type signature for attr has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 61 1: type signature for attr has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has 9 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 72 1: type signature for rel has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 72 1: type signature for rel has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has 16 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 90 1: type signature for globalOptions has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 90 1: type signature for globalOptions has 2 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has 10 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has cyclomatic complexity of 5 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 102 1: type signature for options has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 102 1: type signature for options has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has 6 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 110 1: type signature for opt has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 110 1: type signature for opt has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has branching depth of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has 9 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has cyclomatic complexity of 2 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 121 1: type signature for comment has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 121 1: type signature for comment has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has 4 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 127 1: type signature for ident has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 127 1: type signature for ident has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has 5 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 134 1: type signature for identQuoted has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 134 1: type signature for identQuoted has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has 7 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 143 1: type signature for identNoSpace has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 143 1: type signature for identNoSpace has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has 4 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 149 1: type signature for emptiness has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 149 1: type signature for emptiness has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 152 1: type signature for eolComment has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 152 1: type signature for eolComment has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 155 1: type signature for spacesNoNew has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 155 1: type signature for spacesNoNew has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has 1 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has branching depth of 0 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 158 1: type signature for eol has type constructor nesting of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 158 1: type signature for eol has 1 arguments \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has cyclomatic complexity of 1 \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has 3 lines of code \nInfo:/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Text.Parsec.Erd.Parser\n  ( AST(..),\n    GlobalOptions(..),\n    document,\n    globalOptions,\n    entity,\n    rel,\n    attr,\n    comment\n  ) where\n\nimport           Erd.ER\n\nimport           Control.Monad         (liftM2, void, when)\nimport           Data.Char             (isAlphaNum, isControl, isSpace)\nimport qualified Data.Map              as M\nimport           Data.Maybe\nimport           Data.Text.Lazy        hiding (elem)\nimport           Text.Parsec\nimport           Text.Parsec.Text.Lazy\nimport           Text.Printf           (printf)\n\ndata AST = E Entity\n    | A Attribute\n    | R Relation\n    deriving (Show, Eq)\n\ndata GlobalOptions = GlobalOptions\n    { gtoptions :: Options\n    , ghoptions :: Options\n    , geoptions :: Options\n    , groptions :: Options\n    }\n    deriving (Show, Eq)\n\nemptyGlobalOptions :: GlobalOptions\nemptyGlobalOptions = GlobalOptions M.empty M.empty M.empty M.empty\n\ndocument :: Parser (GlobalOptions, [AST])\ndocument = do skipMany (comment <|> blanks)\n              opts <- globalOptions emptyGlobalOptions\n              ast <-  catMaybes <$> manyTill top eof\n              return (opts, ast)\n  where top = (entity <?> \"entity declaration\")\n              <|> (try rel <?> \"relationship\") -- must come before attr\n              <|> (try attr <?> \"attribute\")\n              <|> (comment <?> \"comment\")\n              <|> blanks\n        blanks = many1 (space <?> \"whitespace\") >> return Nothing\n\nentity :: Parser (Maybe AST)\nentity = do n <- between (char '[') (char ']') ident\n            spacesNoNew\n            opts <- options\n            eolComment\n            return $ Just $ E Entity { name = n, attribs = [],\n                                       hoptions = opts, eoptions = opts }\n\nattr :: Parser (Maybe AST)\nattr = do\n  keys <- many $ oneOf \"*+ \\t\"\n  let (ispk, isfk) = ('*' `elem` keys, '+' `elem` keys)\n  n <- ident\n  opts <- options\n  eolComment\n  return\n    $ Just\n    $ A Attribute {field = n, pk = ispk, fk = isfk, aoptions = opts <> defaultAttrOpts}\n\nrel :: Parser (Maybe AST)\nrel = do\n  let ops = \"?1*+\"\n  e1 <- ident\n  op1 <- oneOf ops\n  _ <- string \"--\"\n  op2 <- oneOf ops\n  e2 <- ident\n  opts <- options\n  let getCard op =\n        case cardByName op of\n          Just t -> return t\n          Nothing -> unexpected (printf \"Cardinality '%s' does not exist.\" op)\n  t1 <- getCard op1\n  t2 <- getCard op2\n  return $ Just $ R Relation { entity1 = e1, entity2 = e2\n                             , card1 = t1, card2 = t2, roptions = opts }\n\nglobalOptions :: GlobalOptions -> Parser GlobalOptions\nglobalOptions gopts =\n  option gopts $ try $ do\n    n <- ident\n    opts <- options\n    case n of\n      \"title\"        -> emptiness >> globalOptions (gopts { gtoptions = opts})\n      \"header\"       -> emptiness >> globalOptions (gopts { ghoptions = opts})\n      \"entity\"       -> emptiness >> globalOptions (gopts { geoptions = opts})\n      \"relationship\" -> emptiness >> globalOptions (gopts { groptions = opts})\n      _ -> fail \"not a valid directive\"\n\noptions :: Parser (M.Map String Option)\noptions =\n  option M.empty\n    $ fmap M.fromList\n    $ try\n    $ between (char '{' >> emptiness) (emptiness >> char '}')\n    $ opt `sepEndBy` (emptiness >> char ',' >> emptiness)\n\nopt :: Parser (String, Option)\nopt = do\n  optName <- liftM2 (:) letter (manyTill (letter <|> char '-') (char ':'))\n          <?> \"option name\"\n  emptiness\n  value <- between (char '\"') (char '\"') (many $ noneOf \"\\\"\")\n           <?> \"option value\"\n  case optionByName optName value of\n    Left err -> fail err\n    Right o' -> emptiness >> return (optName, o')\n\ncomment :: Parser (Maybe AST)\ncomment = do\n  _ <- char '#'\n  _ <- manyTill anyChar $ try eol\n  return Nothing\n\nident :: Parser Text\nident = do\n  spacesNoNew\n  n <- identQuoted <|> identNoSpace\n  spacesNoNew\n  return n\n\nidentQuoted :: Parser Text\nidentQuoted = do\n  quote <- oneOf \"'\\\"`\"\n  let p = satisfy (\\c -> c /= quote && not (isControl c) )\n            <?> \"any character except \" ++ [quote] ++ \" or control characters\"\n  n <- fmap pack (many1 p)\n  _ <- char quote\n  return n\n\nidentNoSpace :: Parser Text\nidentNoSpace = do\n  let p = satisfy (\\c -> c == '_' || isAlphaNum c)\n            <?> \"letter, digit or underscore\"\n  fmap pack (many1 p)\n\nemptiness :: Parser ()\nemptiness = skipMany (void (many1 space) <|> eolComment)\n\neolComment :: Parser ()\neolComment = spacesNoNew >> (eol <|> void comment)\n\nspacesNoNew :: Parser ()\nspacesNoNew = skipMany $ satisfy $ \\c -> c /= '\\n' && c /= '\\r' && isSpace c\n\neol :: Parser ()\neol = eof <|> do\n  c <- oneOf \"\\n\\r\"\n  when (c == '\\r') $ optional $ char '\\n'\n\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs",
            "llm_only_refactored_file": "/tmp/project_91/llm_only_refactored/src/Text/Parsec/Erd/Parser.hs",
            "hybrid_refactored_file": "/tmp/project_91/hybrid_refactored/src/Text/Parsec/Erd/Parser.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 12,
              "max": 33,
              "average": 11.2,
              "sum": 112
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 0,
              "suggestion": 0,
              "ignore": 0,
              "total": 0
            },
            "syntax_errors": 63,
            "lines_of_code": 1277,
            "homplexity_lines_of_code": 1479,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "68MB",
              "runtime": "1.07 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_91/pre_refactor/Setup.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/Setup.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 2,
              "homplexity_lines_of_code": 3,
              "code_quality_score": 97.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 3,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/Setup.hs:SrcLoc \"/tmp/project_91/static_refactored/Setup.hs\" 1 1: <unnamed module> has 2 lines of code \nInfo:/tmp/project_91/static_refactored/Setup.hs:SrcLoc \"/tmp/project_91/static_refactored/Setup.hs\" 2 1: function main has 1 lines of code \nInfo:/tmp/project_91/static_refactored/Setup.hs:SrcLoc \"/tmp/project_91/static_refactored/Setup.hs\" 2 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/Setup.hs:SrcLoc \"/tmp/project_91/static_refactored/Setup.hs\" 2 1: function main has branching depth of 0 \n"
              },
              "original_code": "import           Distribution.Simple\nmain = defaultMain\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/Setup.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "import           Distribution.Simple\nmain = defaultMain\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/app/Main.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/app/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 2.1666666666666665,
                "sum": 13
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 127,
              "homplexity_lines_of_code": 169,
              "code_quality_score": 57.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 2.1666666666666665,
                  "sum": 13
                },
                "homplexity_loc": 169,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 1 1: module Main has 98 lines of code \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 28 1: type signature for main has 1 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 28 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 29 1: function main has 14 lines of code \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 29 1: function main has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 29 1: function main has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 45 1: type signature for dotER has 3 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 45 1: type signature for dotER has type constructor nesting of 1 \nWarning:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 46 1: function dotER has 38 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 46 1: function dotER has cyclomatic complexity of 6 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 46 1: function dotER has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 94 1: type signature for htmlEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 94 1: type signature for htmlEntity has 2 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 95 1: function htmlEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 95 1: function htmlEntity has 9 lines of code \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 95 1: function htmlEntity has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 107 1: type signature for dotEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 107 1: type signature for dotEntity has 2 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 108 1: function dotEntity has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 108 1: function dotEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 108 1: function dotEntity has 1 lines of code \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 114 1: type signature for graphTitle has 2 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 114 1: type signature for graphTitle has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 115 1: function graphTitle has 6 lines of code \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 115 1: function graphTitle has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 115 1: function graphTitle has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 123 1: type signature for checkRequirements has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 123 1: type signature for checkRequirements has 1 arguments \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 124 1: function checkRequirements has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 124 1: function checkRequirements has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/static_refactored/app/Main.hs\" 124 1: function checkRequirements has 3 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n  (main)\nwhere\n\nimport           Control.Applicative                 ((<|>))\nimport           Control.Monad                       (forM_, guard)\nimport qualified Data.ByteString                     as SB\nimport           Data.Maybe                          (fromJust, fromMaybe)\nimport qualified Data.Text.Lazy                      as L\nimport           System.Exit                         (exitFailure)\nimport           System.IO                           (hClose, hPutStrLn, stderr)\n\nimport           Data.GraphViz\nimport qualified Data.GraphViz.Attributes.Colors.X11 as C\nimport qualified Data.GraphViz.Attributes.Complete   as A\nimport qualified Data.GraphViz.Attributes.HTML       as H\nimport qualified Data.GraphViz.Types.Generalised     as G\nimport           Data.GraphViz.Types.Monadic\n\nimport           Erd.Config\nimport           Erd.ER\nimport           Erd.Parse\nimport           Erd.Render                          (htmlAttr, htmlFont,\n                                                      recordAttr, withLabelFmt)\n\nmain :: IO ()\nmain = do\n  checkRequirements -- application may terminate here\n  conf <- configIO\n  er' <- uncurry loadER (cin conf)\n  case er' of\n    Left err -> do\n      hPutStrLn stderr err\n      exitFailure\n    Right er -> let erDot = dotER conf er\n                    toFile h = SB.hGetContents h >>= SB.hPut (snd $ cout conf)\n                    fmt = fromMaybe Pdf (outfmt conf)\n                 in graphvizWithHandle Dot erDot fmt toFile\n  hClose (snd $ cin conf)\n  hClose (snd $ cout conf)\n\n-- | Converts an entire ER-diagram from an ER file into a GraphViz graph.\ndotER :: Config -> ER -> G.DotGraph L.Text\ndotER conf er = graph' $ do\n  graphAttrs (graphTitle $ title er)\n  graphAttrs [ A.RankDir A.FromLeft\n             , A.Splines $ fromConfigOrDefault edgeType\n             ]\n  nodeAttrs nodeGlobalAttributes\n  edgeAttrs [ A.Color [A.toWC $ A.toColor C.Gray50] -- easier to read labels\n            , A.MinLen 2 -- give some breathing room\n            , A.Style [A.SItem (fromConfigOrDefault edgePattern) [] ]\n            ]\n  forM_ (entities er) $ \\e ->\n    node (name e) [entityFmt e]\n  forM_ (rels er) $ relToEdge (fromConfigOrDefault notation)\n    where\n      fromConfigOrDefault :: (Config -> Maybe a) -> a\n      fromConfigOrDefault opt = fromJust $ opt conf <|> opt defaultConfig\n      nodeGlobalAttributes\n        | fromConfigOrDefault dotentity = [shape Record, A.RankDir A.FromTop]\n        | otherwise = [shape PlainText] -- recommended for HTML labels\n      entityFmt\n        | fromConfigOrDefault dotentity = toLabel . dotEntity\n        | otherwise = toLabel . htmlEntity\n      relToEdge n r = edge (entity1 r) (entity2 r) (label:eAttr n)\n        where\n          optss = roptions r\n          labelOrXLabel =\n            case fromConfigOrDefault edgeType of\n              A.Ortho -> A.XLabel -- Graphivz recommends xlabels for ortho edges\n              _ -> A.Label\n          label =\n            labelOrXLabel . A.HtmlLabel . H.Text $ withLabelFmt \" %s \" optss []\n          (c1,c2) = (card1 r, card2 r)\n          eAttr UML = [A.TailLabel $ card2label c1\n                      ,A.HeadLabel $ card2label c2\n                      ]\n            where\n              card2label = A.HtmlLabel . H.Text . htmlFont optss . L.pack . show\n          eAttr IE = [A.Dir Both\n                     ,A.ArrowTail $ card2arr c1\n                     ,A.ArrowHead $ card2arr c2\n                     ]\n            where\n              card2arr ZeroOne  = A.AType [(A.openMod, A.DotArrow), (A.noMods, A.Tee)]\n              card2arr One      = A.AType [(A.noMods, A.Tee), (A.noMods, A.Tee)]\n              card2arr ZeroPlus = A.AType [(A.noMods, A.Crow), (A.openMod, A.DotArrow)]\n              card2arr OnePlus  = A.AType [(A.noMods, A.Crow), (A.noMods, A.Tee)]\n\n-- | Converts a single entity to an HTML label.\nhtmlEntity :: Entity -> H.Label\nhtmlEntity e = H.Table H.HTable\n                 { H.tableFontAttrs = Just $ optionsTo optToFont $ eoptions e\n                 , H.tableAttrs = optionsTo optToHtml (eoptions e)\n                 , H.tableRows = rows\n                 }\n  where rows = headerRow : map htmlAttr (attribs e)\n        headerRow = H.Cells [H.LabelCell [] $ H.Text text]\n        text = withLabelFmt \" [%s]\" (hoptions e) $ boldFont hname\n        hname = htmlFont (hoptions e) (name e)\n        boldFont s = [H.Format H.Bold s]\n\n-- | Converts a single entity to a plain Dot Label\ndotEntity :: Entity -> A.RecordFields\ndotEntity e =  A.FieldLabel ( name e ) : map recordAttr (attribs e)\n\n-- | Extracts and formats a graph title from the options given.\n-- The options should be title options from an ER value.\n-- If a title does not exist, an empty list is returned and `graphAttrs attrs`\n-- should be a no-op.\ngraphTitle :: Options -> [A.Attribute]\ngraphTitle topts =\n  let glabel = optionsTo optToLabel topts\n  in if null glabel then [] else\n       [ A.LabelJust A.JLeft\n       , A.LabelLoc A.VTop\n       , A.Label $ A.HtmlLabel $ H.Text $ htmlFont topts (head glabel)\n       ]\n\ncheckRequirements :: IO ()\ncheckRequirements = (isGraphvizInstalled >>= guard) <|> quitWithoutGraphviz msg\n  where\n    msg = \"GraphViz is not installed on your system.\\n\" ++\n          \"Please install it first, https://github.com/BurntSushi/erd\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/app/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n  (main)\nwhere\n\nimport           Control.Applicative                 ((<|>))\nimport           Control.Monad                       (forM_, guard)\nimport qualified Data.ByteString                     as SB\nimport           Data.Maybe                          (fromJust, fromMaybe)\nimport qualified Data.Text.Lazy                      as L\nimport           System.Exit                         (exitFailure)\nimport           System.IO                           (hClose, hPutStrLn, stderr)\n\nimport           Data.GraphViz\nimport qualified Data.GraphViz.Attributes.Colors.X11 as C\nimport qualified Data.GraphViz.Attributes.Complete   as A\nimport qualified Data.GraphViz.Attributes.HTML       as H\nimport qualified Data.GraphViz.Types.Generalised     as G\nimport           Data.GraphViz.Types.Monadic\n\nimport           Erd.Config\nimport           Erd.ER\nimport           Erd.Parse\nimport           Erd.Render                          (htmlAttr, htmlFont,\n                                                      recordAttr, withLabelFmt)\n\nmain :: IO ()\nmain = do\n  checkRequirements -- application may terminate here\n  conf <- configIO\n  er' <- uncurry loadER (cin conf)\n  case er' of\n    Left err -> do\n      hPutStrLn stderr err\n      exitFailure\n    Right er -> let erDot = dotER conf er\n                    toFile h = SB.hGetContents h >>= SB.hPut (snd $ cout conf)\n                    fmt = fromMaybe Pdf (outfmt conf)\n                 in graphvizWithHandle Dot erDot fmt toFile\n  hClose (snd $ cin conf)\n  hClose (snd $ cout conf)\n\n-- | Converts an entire ER-diagram from an ER file into a GraphViz graph.\ndotER :: Config -> ER -> G.DotGraph L.Text\ndotER conf er = graph' $ do\n  graphAttrs (graphTitle $ title er)\n  graphAttrs [ A.RankDir A.FromLeft\n             , A.Splines $ fromConfigOrDefault edgeType\n             ]\n  nodeAttrs nodeGlobalAttributes\n  edgeAttrs [ A.Color [A.toWC $ A.toColor C.Gray50] -- easier to read labels\n            , A.MinLen 2 -- give some breathing room\n            , A.Style [A.SItem (fromConfigOrDefault edgePattern) [] ]\n            ]\n  forM_ (entities er) $ \\e ->\n    node (name e) [entityFmt e]\n  forM_ (rels er) $ relToEdge (fromConfigOrDefault notation)\n    where\n      fromConfigOrDefault :: (Config -> Maybe a) -> a\n      fromConfigOrDefault opt = fromJust $ opt conf <|> opt defaultConfig\n      nodeGlobalAttributes\n        | fromConfigOrDefault dotentity = [shape Record, A.RankDir A.FromTop]\n        | otherwise = [shape PlainText] -- recommended for HTML labels\n      entityFmt\n        | fromConfigOrDefault dotentity = toLabel . dotEntity\n        | otherwise = toLabel . htmlEntity\n      relToEdge n r = edge (entity1 r) (entity2 r) (label:eAttr n)\n        where\n          optss = roptions r\n          labelOrXLabel =\n            case fromConfigOrDefault edgeType of\n              A.Ortho -> A.XLabel -- Graphivz recommends xlabels for ortho edges\n              _ -> A.Label\n          label =\n            labelOrXLabel . A.HtmlLabel . H.Text $ withLabelFmt \" %s \" optss []\n          (c1,c2) = (card1 r, card2 r)\n          eAttr UML = [A.TailLabel $ card2label c1\n                      ,A.HeadLabel $ card2label c2\n                      ]\n            where\n              card2label = A.HtmlLabel . H.Text . htmlFont optss . L.pack . show\n          eAttr IE = [A.Dir Both\n                     ,A.ArrowTail $ card2arr c1\n                     ,A.ArrowHead $ card2arr c2\n                     ]\n            where\n              card2arr ZeroOne  = A.AType [(A.openMod, A.DotArrow), (A.noMods, A.Tee)]\n              card2arr One      = A.AType [(A.noMods, A.Tee), (A.noMods, A.Tee)]\n              card2arr ZeroPlus = A.AType [(A.noMods, A.Crow), (A.openMod, A.DotArrow)]\n              card2arr OnePlus  = A.AType [(A.noMods, A.Crow), (A.noMods, A.Tee)]\n\n-- | Converts a single entity to an HTML label.\nhtmlEntity :: Entity -> H.Label\nhtmlEntity e = H.Table H.HTable\n                 { H.tableFontAttrs = Just $ optionsTo optToFont $ eoptions e\n                 , H.tableAttrs = optionsTo optToHtml (eoptions e)\n                 , H.tableRows = rows\n                 }\n  where rows = headerRow : map htmlAttr (attribs e)\n        headerRow = H.Cells [H.LabelCell [] $ H.Text text]\n        text = withLabelFmt \" [%s]\" (hoptions e) $ boldFont hname\n        hname = htmlFont (hoptions e) (name e)\n        boldFont s = [H.Format H.Bold s]\n\n-- | Converts a single entity to a plain Dot Label\ndotEntity :: Entity -> A.RecordFields\ndotEntity e =  A.FieldLabel ( name e ) : map recordAttr (attribs e)\n\n-- | Extracts and formats a graph title from the options given.\n-- The options should be title options from an ER value.\n-- If a title does not exist, an empty list is returned and `graphAttrs attrs`\n-- should be a no-op.\ngraphTitle :: Options -> [A.Attribute]\ngraphTitle topts =\n  let glabel = optionsTo optToLabel topts\n  in if null glabel then [] else\n       [ A.LabelJust A.JLeft\n       , A.LabelLoc A.VTop\n       , A.Label $ A.HtmlLabel $ H.Text $ htmlFont topts (head glabel)\n       ]\n\ncheckRequirements :: IO ()\ncheckRequirements = (isGraphvizInstalled >>= guard) <|> quitWithoutGraphviz msg\n  where\n    msg = \"GraphViz is not installed on your system.\\n\" ++\n          \"Please install it first, https://github.com/BurntSushi/erd\"\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/test/Spec.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/test/Spec.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 14,
              "homplexity_lines_of_code": 13,
              "code_quality_score": 94.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 13,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 1 1: module Main has 10 lines of code \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 10 1: function main has 1 lines of code \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 10 1: function main has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 12 1: type signature for tests has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 12 1: type signature for tests has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 13 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 13 1: function tests has 2 lines of code \nInfo:/tmp/project_91/static_refactored/test/Spec.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Spec.hs\" 13 1: function tests has branching depth of 0 \n"
              },
              "original_code": "module Main\n  (main)\nwhere\n\nimport           Test.Erd.Render             (testRender)\nimport           Test.Tasty\nimport           Test.Text.Parsec.Erd.Parser (testEr)\n\nmain :: IO ()\nmain = defaultMain $ testGroup \"Erd Tests\" tests\n\ntests :: [TestTree]\ntests = [testEr,\n         testRender]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/test/Spec.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Main\n  (main)\nwhere\n\nimport           Test.Erd.Render             (testRender)\nimport           Test.Tasty\nimport           Test.Text.Parsec.Erd.Parser (testEr)\n\nmain :: IO ()\nmain = defaultMain $ testGroup \"Erd Tests\" tests\n\ntests :: [TestTree]\ntests = [testEr,\n         testRender]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/test/Test/Erd/Render.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 25,
              "homplexity_lines_of_code": 26,
              "code_quality_score": 93.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 26,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 1 1: module Test.Erd.Render has 18 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 14 1: type signature for testRender has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 14 1: type signature for testRender has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 15 1: function testRender has 2 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 15 1: function testRender has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 15 1: function testRender has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 18 1: type signature for test01 has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 18 1: type signature for test01 has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 19 1: function test01 has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 19 1: function test01 has 6 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Erd/Render.hs\" 19 1: function test01 has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Erd.Render\n  (testRender)\nwhere\n\nimport qualified Erd.ER                        as ER\nimport           Erd.Render                    (htmlAttr)\n\nimport qualified Data.GraphViz.Attributes.HTML as H\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntestRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n                                                 ]\ntest01 :: Assertion\ntest01 = result @?= expected\n  where\n    inputF   = \"Field\"\n    input    = ER.Attribute inputF True False ER.defaultAttrOpts\n    result   = htmlAttr input\n    expected = H.Cells [H.LabelCell [H.Align H.HLeft]\n                        (H.Text [H.Format H.Underline [H.Font [] [H.Str inputF]]])]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Erd.Render\n  (testRender)\nwhere\n\nimport qualified Erd.ER                        as ER\nimport           Erd.Render                    (htmlAttr)\n\nimport qualified Data.GraphViz.Attributes.HTML as H\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntestRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n                                                 ]\ntest01 :: Assertion\ntest01 = result @?= expected\n  where\n    inputF   = \"Field\"\n    input    = ER.Attribute inputF True False ER.defaultAttrOpts\n    result   = htmlAttr input\n    expected = H.Cells [H.LabelCell [H.Align H.HLeft]\n                        (H.Text [H.Format H.Underline [H.Font [] [H.Str inputF]]])]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 282,
              "homplexity_lines_of_code": 246,
              "code_quality_score": 61.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 7
                },
                "homplexity_loc": 246,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 1 1: module Test.Text.Parsec.Erd.Parser has 137 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has 3 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has 2 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: type signature for testEr has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: type signature for testEr has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has 3 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 27 1: function testEr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: type signature for simpleText has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: type signature for simpleText has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has 1 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 34 1: function simpleText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: type signature for simpleResult has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: type signature for simpleResult has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has 15 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 64 1: function simpleResult has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: type signature for nfldbText has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: type signature for nfldbText has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has 1 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 81 1: function nfldbText has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 172 18: data ChunckAST has record fields count of 3 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for toAST has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for toAST has 2 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has 3 lines of code \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function toAST has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 182 1: type signature for nfldbResult has 1 arguments \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 182 1: type signature for nfldbResult has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has branching depth of 0 \nCritical:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has 84 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 183 1: function nfldbResult has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n\nmodule Test.Text.Parsec.Erd.Parser\n  (testEr\n  ) where\n\nimport           Data.GraphViz.Attributes.Colors (Color (..))\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.Map                        (fromList)\nimport qualified Data.Map                        as M\nimport           Data.Text                       (Text)\nimport           Data.Text.Lazy                  (fromStrict)\nimport           Erd.ER\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Text.Parsec                     (parse)\nimport           Text.Parsec.Erd.Parser          (AST (..), GlobalOptions (..),\n                                                  document)\nimport           Text.RawString.QQ               (r)\n\nparseDoc :: Text -> (GlobalOptions, [AST]) -> Assertion\nparseDoc input expect= Right expect `shouldBe` parse document \"\" (fromStrict input) where\n  shouldBe = assertEqual \"\"\n\ntestEr :: TestTree\ntestEr = testGroup \"Parse Er\" [\n  testCase \"Parse Simple case\" $ parseDoc simpleText simpleResult,\n  testCase \"Parse nfldb case\" $ parseDoc nfldbText nfldbResult\n                              ]\n\n\nsimpleText :: Text\nsimpleText = [r|\n# Entities are declared in '[' ... ']'. All attributes after the entity header\n# up until the end of the file (or the next entity declaration) correspond\n# to this entity.\n[Person]\n*name\nheight\nweight\n`birth date`\n+birth_place_id\n\n[`Birth Place`]\n*id\n`birth city`\n'birth state'\n\"birth country\"\n\n# Each relationship must be between exactly two entities, which need not\n# be distinct. Each entity in the relationship has exactly one of four\n# possible cardinalities:\n#\n# Cardinality    Syntax\n# 0 or 1         ?\n# exactly 1      1\n# 0 or more      *\n# 1 or more      +\nPerson *--1 `Birth Place`\n|]\n\nsimpleResult :: (GlobalOptions, [AST])\nsimpleResult = (opts, asts) where\n  opts = GlobalOptions M.empty M.empty M.empty M.empty\n  asts = [\n    E (Entity {name = \"Person\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"name\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"height\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"weight\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth date\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth_place_id\", pk = False, fk = True, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    E (Entity {name = \"Birth Place\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"id\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth city\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth state\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth country\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    R (Relation {entity1 = \"Person\", entity2 = \"Birth Place\", card1 = ZeroPlus , card2 = One, roptions = M.empty})]\n\nnfldbText :: Text\nnfldbText = [r|\ntitle {label: \"nfldb Entity-Relationship diagram (condensed)\", size: \"20\"}\n\n# Nice colors from Erwiz:\n# red #fcecec\n# blue #ececfc\n# green #d0e0d0\n# yellow #fbfbdb\n# orange #eee0a0\n\n# Entities\n\n[player] {bgcolor: \"#d0e0d0\"}\n  *player_id {label: \"varchar, not null\"}\n  full_name {label: \"varchar, null\"}\n  team {label: \"varchar, not null\"}\n  position {label: \"player_pos, not null\"}\n  status {label: \"player_status, not null\"}\n\n[team] {bgcolor: \"#d0e0d0\"}\n  *team_id {label: \"varchar, not null\"}\n  city {label: \"varchar, not null\"}\n  name {label: \"varchar, not null\"}\n\n[game] {bgcolor: \"#ececfc\"}\n  *gsis_id {label: \"gameid, not null\"}\n  start_time {label: \"utctime, not null\"}\n  week {label: \"usmallint, not null\"}\n  season_year {label: \"usmallint, not null\"}\n  season_type {label: \"season_phase, not null\"}\n  finished {label: \"boolean, not null\"}\n  home_team {label: \"varchar, not null\"}\n  home_score {label: \"usmallint, not null\"}\n  away_team {label: \"varchar, not null\"}\n  away_score {label: \"usmallint, not null\"}\n\n[drive] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *drive_id {label: \"usmallint, not null\"}\n  start_field {label: \"field_pos, null\"}\n  start_time {label: \"game_time, not null\"}\n  end_field {label: \"field_pos, null\"}\n  end_time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  pos_time {label: \"pos_period, null\"}\n\n[play] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *play_id {label: \"usmallint, not null\"}\n  time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  yardline {label: \"field_pos, null\"}\n  down {label: \"smallint, null\"}\n  yards_to_go {label: \"smallint, null\"}\n\n[play_player] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *+play_id {label: \"usmallint, not null\"}\n  *+player_id {label: \"varchar, not null\"}\n  team {label: \"varchar, not null\"}\n\n[meta] {bgcolor: \"#fcecec\"}\n  version {label: \"smallint, null\"}\n  season_type {label: \"season_phase, null\"}\n  season_year {label: \"usmallint, null\"}\n  week {label: \"usmallint, null\"}\n\n# Relationships\n\nplayer      *--1 team\ngame        *--1 team {label: \"home\"}\ngame        *--1 team {label: \"away\"}\ndrive       *--1 team\nplay        *--1 team\nplay_player *--1 team\n\ngame        1--* drive\ngame        1--* play\ngame        1--* play_player\n\ndrive       1--* play\ndrive       1--* play_player\n\nplay        1--* play_player\n\nplayer      1--* play_player\n|]\n\n\ndata ChunckAST = CE [Entity]\n    | CA [Attribute]\n    | CR [Relation]\n    deriving (Eq)\n\ntoAST :: ChunckAST -> [AST]\ntoAST (CE x) = map E x\ntoAST (CA x) = map A x\ntoAST (CR x) = map R x\n\nnfldbResult :: (GlobalOptions, [AST])\nnfldbResult = (opts, asts) where\n  opts = GlobalOptions {gtoptions = fromList [(\"label\",Label \"nfldb Entity-Relationship diagram (condensed)\"),(\"size\",FontSize 20.0)], ghoptions = M.empty, geoptions = M.empty, groptions = M.empty}\n  asts = concatMap toAST $ es:(attributes ++ [relations])\n  es = CE [\n    Entity {name = \"player\", attribs = [],\n      hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))],\n      eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]\n           }\n    ]\n  attributes = [\n    CA [\n        Attribute {field = \"player_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"full_name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"position\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_pos, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"status\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_status, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"team\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]}\n      ],\n    CA [\n        Attribute {field = \"team_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"city\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"game\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"utctime, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"finished\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"boolean, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"drive\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"pos_period, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yardline\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"down\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yards_to_go\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play_player\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"player_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n     ],\n     CE [\n        Entity {name = \"meta\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))]}\n       ],\n    CA [\n        Attribute {field = \"version\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ]\n    ]\n  relations = CR [\n     Relation {entity1 = \"player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"home\")]},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"away\")]},\n     Relation {entity1 = \"drive\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play_player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"drive\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"player\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty} ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n\nmodule Test.Text.Parsec.Erd.Parser\n  (testEr\n  ) where\n\nimport           Data.GraphViz.Attributes.Colors (Color (..))\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.Map                        (fromList)\nimport qualified Data.Map                        as M\nimport           Data.Text                       (Text)\nimport           Data.Text.Lazy                  (fromStrict)\nimport           Erd.ER\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Text.Parsec                     (parse)\nimport           Text.Parsec.Erd.Parser          (AST (..), GlobalOptions (..),\n                                                  document)\nimport           Text.RawString.QQ               (r)\n\nparseDoc :: Text -> (GlobalOptions, [AST]) -> Assertion\nparseDoc input expect= Right expect `shouldBe` parse document \"\" (fromStrict input) where\n  shouldBe = assertEqual \"\"\n\ntestEr :: TestTree\ntestEr = testGroup \"Parse Er\" [\n  testCase \"Parse Simple case\" $ parseDoc simpleText simpleResult,\n  testCase \"Parse nfldb case\" $ parseDoc nfldbText nfldbResult\n                              ]\n\n\nsimpleText :: Text\nsimpleText = [r|\n# Entities are declared in '[' ... ']'. All attributes after the entity header\n# up until the end of the file (or the next entity declaration) correspond\n# to this entity.\n[Person]\n*name\nheight\nweight\n`birth date`\n+birth_place_id\n\n[`Birth Place`]\n*id\n`birth city`\n'birth state'\n\"birth country\"\n\n# Each relationship must be between exactly two entities, which need not\n# be distinct. Each entity in the relationship has exactly one of four\n# possible cardinalities:\n#\n# Cardinality    Syntax\n# 0 or 1         ?\n# exactly 1      1\n# 0 or more      *\n# 1 or more      +\nPerson *--1 `Birth Place`\n|]\n\nsimpleResult :: (GlobalOptions, [AST])\nsimpleResult = (opts, asts) where\n  opts = GlobalOptions M.empty M.empty M.empty M.empty\n  asts = [\n    E (Entity {name = \"Person\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"name\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"height\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"weight\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth date\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth_place_id\", pk = False, fk = True, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    E (Entity {name = \"Birth Place\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"id\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth city\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth state\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth country\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    R (Relation {entity1 = \"Person\", entity2 = \"Birth Place\", card1 = ZeroPlus , card2 = One, roptions = M.empty})]\n\nnfldbText :: Text\nnfldbText = [r|\ntitle {label: \"nfldb Entity-Relationship diagram (condensed)\", size: \"20\"}\n\n# Nice colors from Erwiz:\n# red #fcecec\n# blue #ececfc\n# green #d0e0d0\n# yellow #fbfbdb\n# orange #eee0a0\n\n# Entities\n\n[player] {bgcolor: \"#d0e0d0\"}\n  *player_id {label: \"varchar, not null\"}\n  full_name {label: \"varchar, null\"}\n  team {label: \"varchar, not null\"}\n  position {label: \"player_pos, not null\"}\n  status {label: \"player_status, not null\"}\n\n[team] {bgcolor: \"#d0e0d0\"}\n  *team_id {label: \"varchar, not null\"}\n  city {label: \"varchar, not null\"}\n  name {label: \"varchar, not null\"}\n\n[game] {bgcolor: \"#ececfc\"}\n  *gsis_id {label: \"gameid, not null\"}\n  start_time {label: \"utctime, not null\"}\n  week {label: \"usmallint, not null\"}\n  season_year {label: \"usmallint, not null\"}\n  season_type {label: \"season_phase, not null\"}\n  finished {label: \"boolean, not null\"}\n  home_team {label: \"varchar, not null\"}\n  home_score {label: \"usmallint, not null\"}\n  away_team {label: \"varchar, not null\"}\n  away_score {label: \"usmallint, not null\"}\n\n[drive] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *drive_id {label: \"usmallint, not null\"}\n  start_field {label: \"field_pos, null\"}\n  start_time {label: \"game_time, not null\"}\n  end_field {label: \"field_pos, null\"}\n  end_time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  pos_time {label: \"pos_period, null\"}\n\n[play] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *play_id {label: \"usmallint, not null\"}\n  time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  yardline {label: \"field_pos, null\"}\n  down {label: \"smallint, null\"}\n  yards_to_go {label: \"smallint, null\"}\n\n[play_player] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *+play_id {label: \"usmallint, not null\"}\n  *+player_id {label: \"varchar, not null\"}\n  team {label: \"varchar, not null\"}\n\n[meta] {bgcolor: \"#fcecec\"}\n  version {label: \"smallint, null\"}\n  season_type {label: \"season_phase, null\"}\n  season_year {label: \"usmallint, null\"}\n  week {label: \"usmallint, null\"}\n\n# Relationships\n\nplayer      *--1 team\ngame        *--1 team {label: \"home\"}\ngame        *--1 team {label: \"away\"}\ndrive       *--1 team\nplay        *--1 team\nplay_player *--1 team\n\ngame        1--* drive\ngame        1--* play\ngame        1--* play_player\n\ndrive       1--* play\ndrive       1--* play_player\n\nplay        1--* play_player\n\nplayer      1--* play_player\n|]\n\n\ndata ChunckAST = CE [Entity]\n    | CA [Attribute]\n    | CR [Relation]\n    deriving (Eq)\n\ntoAST :: ChunckAST -> [AST]\ntoAST (CE x) = map E x\ntoAST (CA x) = map A x\ntoAST (CR x) = map R x\n\nnfldbResult :: (GlobalOptions, [AST])\nnfldbResult = (opts, asts) where\n  opts = GlobalOptions {gtoptions = fromList [(\"label\",Label \"nfldb Entity-Relationship diagram (condensed)\"),(\"size\",FontSize 20.0)], ghoptions = M.empty, geoptions = M.empty, groptions = M.empty}\n  asts = concatMap toAST $ es:(attributes ++ [relations])\n  es = CE [\n    Entity {name = \"player\", attribs = [],\n      hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))],\n      eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]\n           }\n    ]\n  attributes = [\n    CA [\n        Attribute {field = \"player_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"full_name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"position\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_pos, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"status\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_status, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"team\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]}\n      ],\n    CA [\n        Attribute {field = \"team_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"city\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"game\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"utctime, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"finished\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"boolean, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"drive\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"pos_period, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yardline\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"down\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yards_to_go\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play_player\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"player_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n     ],\n     CE [\n        Entity {name = \"meta\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))]}\n       ],\n    CA [\n        Attribute {field = \"version\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ]\n    ]\n  relations = CR [\n     Relation {entity1 = \"player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"home\")]},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"away\")]},\n     Relation {entity1 = \"drive\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play_player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"drive\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"player\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty} ]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/ER.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/src/Erd/ER.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.0769230769230769,
                "sum": 14
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 201,
              "homplexity_lines_of_code": 181,
              "code_quality_score": 53.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.0769230769230769,
                  "sum": 14
                },
                "homplexity_loc": 181,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 1 1: module Erd.ER has 130 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 24 11: data ER has record fields count of 3 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 32 15: data Entity has record fields count of 4 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 44 18: data Attribute has record fields count of 4 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 70 1: type signature for optionsTo has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 70 1: type signature for optionsTo has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has cyclomatic complexity of 1 \nCritical:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 75 15: data Option has record fields count of 11 must never reach 9\nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 92 1: type signature for optionByName has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 92 1: type signature for optionByName has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 93 1: function optionByName has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 93 1: function optionByName has 12 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 93 1: function optionByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 107 1: type signature for optionParse has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 107 1: type signature for optionParse has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 108 1: function optionParse has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 108 1: function optionParse has 5 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 108 1: function optionParse has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 115 1: type signature for optToFont has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 115 1: type signature for optToFont has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 116 1: function optToFont has 4 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 116 1: function optToFont has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 116 1: function optToFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 123 1: type signature for optToHtml has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 123 1: type signature for optToHtml has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has 8 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 135 1: type signature for optToLabel has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 135 1: type signature for optToLabel has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has 2 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 145 17: data Relation has record fields count of 3 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 152 20: data Cardinality has record fields count of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 165 1: type signature for cardByName has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 165 1: type signature for cardByName has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 166 1: function cardByName has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 166 1: function cardByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 166 1: function cardByName has 5 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has 2 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has 2 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has 6 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 196 1: function defaultRelOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 196 1: function defaultRelOpts has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 196 1: function defaultRelOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 198 1: type signature for defaultAttrOpts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 198 1: type signature for defaultAttrOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/ER.hs\" 199 1: function defaultAttrOpts has 2 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.ER\n  ( ER(..)\n  , Entity(..)\n  , Attribute(..)\n  , Options, mergeOpts, optionsTo\n  , Option(..), optionByName, optToFont, optToHtml, optToLabel\n  , Relation(..) , Cardinality(..), cardByName\n  , defaultAttrOpts, defaultTitleOpts, defaultEntityOpts, defaultHeaderOpts, defaultRelOpts\n  )\nwhere\n\nimport qualified Data.Map                        as M\nimport           Data.Maybe                      (mapMaybe)\nimport           Data.Text.Lazy\nimport           Data.Word                       (Word8)\nimport           Text.Printf                     (printf)\n\nimport           Data.GraphViz.Attributes.Colors (Color)\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.GraphViz.Parsing           (ParseDot, parse, runParser)\n\n-- | Represents a single schema.\ndata ER = ER\n    { entities :: [Entity]\n    , rels     :: [Relation]\n    , title    :: Options\n    }\n    deriving (Show, Eq)\n\n-- | Represents a single entity in a schema.\ndata Entity = Entity\n    { name     :: Text\n    , attribs  :: [Attribute]\n    , hoptions :: Options\n    , eoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Entity where\n  e1 `compare` e2 = name e1 `compare` name e2\n\n-- | Represents a single attribute in a particular entity.\ndata Attribute = Attribute\n    { field    :: Text\n    , pk       :: Bool\n    , fk       :: Bool\n    , aoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Attribute where\n  a1 `compare` a2 = field a1 `compare` field a2\n\n-- | Represents any number of options for an item in an ER diagram.\n-- An item may be the graph title, an entity, an entity header or a\n-- relationship between entities. Keys are options as specified in ER files.\n--\n-- Note that a set of options may include a label for any item.\ntype Options = M.Map String Option\n\n-- | Given two sets of options, merge the second into first, where elements\n-- in the first take precedence.\nmergeOpts :: Options -> Options -> Options\nmergeOpts opts1 opts2 = opts1 `M.union` opts2\n\n-- | Given a set of options and a selector function, return the list of\n-- only those options which matched. Examples of the selector function are\n-- `optToFont`, `optToHtml` and `optToLabel`.\noptionsTo :: (Option -> Maybe a) -> Options -> [a]\noptionsTo f = mapMaybe f . M.elems\n\n-- | A restricted subset of options in GraphViz that can be configured in\n-- an ER file.\ndata Option = Label String\n    | BgColor Color\n    | Color Color\n    | FontFace Text\n    | FontSize Double\n    | Border Word8\n    | BorderColor Color\n    | CellSpacing Word8\n    | CellBorder Word8\n    | CellPadding Word8\n    | TextAlignment H.Align\n    deriving (Show, Eq)\n\n-- | Given an option name and a string representation of its value,\n-- `optionByName` will attempt to parse the string as a value corresponding\n-- to the option. If the option doesn't exist or there was a problem parsing\n-- the value, an error is returned.\noptionByName :: String -> String -> Either String Option\noptionByName \"label\" = Right . Label\noptionByName \"color\" = optionParse Color\noptionByName \"bgcolor\" = optionParse BgColor\noptionByName \"size\" = optionParse FontSize\noptionByName \"font\" = optionParse FontFace\noptionByName \"border\" = optionParse Border\noptionByName \"border-color\" = optionParse BorderColor\noptionByName \"cellspacing\" = optionParse CellSpacing\noptionByName \"cellborder\" = optionParse CellBorder\noptionByName \"cellpadding\" = optionParse CellPadding\noptionByName \"text-alignment\" = optionParse TextAlignment\noptionByName unk = const (Left $ printf \"Option '%s' does not exist.\" unk)\n\n-- | A wrapper around the GraphViz's parser for any particular option.\noptionParse :: ParseDot a => (a -> Option) -> String -> Either String Option\noptionParse con s =\n  case fst $ runParser parse quoted of\n    Left err -> Left (printf \"%s (bad value '%s')\" err s)\n    Right a  -> Right (con a)\n  where quoted = \"\\\"\" `append` pack s `append` \"\\\"\"\n\n-- | Selects an option if and only if it corresponds to a font attribute.\noptToFont :: Option -> Maybe H.Attribute\noptToFont (Color c)    = Just $ H.Color c\noptToFont (FontFace s) = Just $ H.Face s\noptToFont (FontSize d) = Just $ H.PointSize d\noptToFont _            = Nothing\n\n-- | Selects an option if and only if it corresponds to an HTML attribute.\n-- In particular, for tables or table cells.\noptToHtml :: Option -> Maybe H.Attribute\noptToHtml (BgColor c)       = pure $ H.BGColor c\noptToHtml (Border w)        = pure $ H.Border w\noptToHtml (BorderColor c)   = pure $ H.Color c\noptToHtml (CellSpacing w)   = pure $ H.CellSpacing w\noptToHtml (CellBorder w)    = pure $ H.CellBorder w\noptToHtml (CellPadding w)   = pure $ H.CellPadding w\noptToHtml (TextAlignment x) = pure $ H.Align x\noptToHtml _                 = Nothing\n\n\n-- | Selects an option if and only if it corresponds to a label.\noptToLabel :: Option -> Maybe Text\noptToLabel (Label s) = Just $ pack s\noptToLabel _         = Nothing\n\n-- | Represents a relationship between exactly two entities. After parsing,\n-- each `rel` is guaranteed to correspond to an entity defined in the same\n-- ER file.\n--\n-- Each relationship has one of four cardinalities specified for both entities.\n-- Those cardinalities are: 0 or 1, exactly 1, 0 or more and 1 or more.\ndata Relation = Relation\n    { entity1, entity2 :: Text\n    , card1, card2     :: Cardinality\n    , roptions         :: Options\n    }\n    deriving (Show, Eq)\n\ndata Cardinality = ZeroOne\n    | One\n    | ZeroPlus\n    | OnePlus\n    deriving (Eq)\n\ninstance Show Cardinality where\n  show ZeroOne  = \"{0,1}\"\n  show One      = \"1\"\n  show ZeroPlus = \"0..N\"\n  show OnePlus  = \"1..N\"\n\n-- | Maps a string representation to a particular relationship cardinality.\ncardByName :: Char -> Maybe Cardinality\ncardByName '?' = Just ZeroOne\ncardByName '1' = Just One\ncardByName '*' = Just ZeroPlus\ncardByName '+' = Just OnePlus\ncardByName _   = Nothing\n\n-- | Hard-coded default options for all graph titles.\ndefaultTitleOpts :: Options\ndefaultTitleOpts = M.fromList\n  [ (\"size\", FontSize 30)\n  ]\n\n-- | Hard-coded default options for all entity headers.\ndefaultHeaderOpts :: Options\ndefaultHeaderOpts = M.fromList\n  [ (\"size\", FontSize 16)\n  ]\n\n-- | Hard-coded default options for all entities.\ndefaultEntityOpts :: Options\ndefaultEntityOpts = M.fromList\n  [ (\"border\", Border 0)\n  , (\"cellborder\", CellBorder 1)\n  , (\"cellspacing\", CellSpacing 0)\n  , (\"cellpadding\", CellPadding 4)\n  , (\"font\", FontFace \"Helvetica\")\n  ]\n\n-- | Hard-coded default options for all relationships.\ndefaultRelOpts :: Options\ndefaultRelOpts = M.empty\n\ndefaultAttrOpts :: Options\ndefaultAttrOpts = M.fromList\n  [ (\"text-alignment\", TextAlignment H.HLeft)\n  ]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/src/Erd/ER.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.ER\n  ( ER(..)\n  , Entity(..)\n  , Attribute(..)\n  , Options, mergeOpts, optionsTo\n  , Option(..), optionByName, optToFont, optToHtml, optToLabel\n  , Relation(..) , Cardinality(..), cardByName\n  , defaultAttrOpts, defaultTitleOpts, defaultEntityOpts, defaultHeaderOpts, defaultRelOpts\n  )\nwhere\n\nimport qualified Data.Map                        as M\nimport           Data.Maybe                      (mapMaybe)\nimport           Data.Text.Lazy\nimport           Data.Word                       (Word8)\nimport           Text.Printf                     (printf)\n\nimport           Data.GraphViz.Attributes.Colors (Color)\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.GraphViz.Parsing           (ParseDot, parse, runParser)\n\n-- | Represents a single schema.\ndata ER = ER\n    { entities :: [Entity]\n    , rels     :: [Relation]\n    , title    :: Options\n    }\n    deriving (Show, Eq)\n\n-- | Represents a single entity in a schema.\ndata Entity = Entity\n    { name     :: Text\n    , attribs  :: [Attribute]\n    , hoptions :: Options\n    , eoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Entity where\n  e1 `compare` e2 = name e1 `compare` name e2\n\n-- | Represents a single attribute in a particular entity.\ndata Attribute = Attribute\n    { field    :: Text\n    , pk       :: Bool\n    , fk       :: Bool\n    , aoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Attribute where\n  a1 `compare` a2 = field a1 `compare` field a2\n\n-- | Represents any number of options for an item in an ER diagram.\n-- An item may be the graph title, an entity, an entity header or a\n-- relationship between entities. Keys are options as specified in ER files.\n--\n-- Note that a set of options may include a label for any item.\ntype Options = M.Map String Option\n\n-- | Given two sets of options, merge the second into first, where elements\n-- in the first take precedence.\nmergeOpts :: Options -> Options -> Options\nmergeOpts opts1 opts2 = opts1 `M.union` opts2\n\n-- | Given a set of options and a selector function, return the list of\n-- only those options which matched. Examples of the selector function are\n-- `optToFont`, `optToHtml` and `optToLabel`.\noptionsTo :: (Option -> Maybe a) -> Options -> [a]\noptionsTo f = mapMaybe f . M.elems\n\n-- | A restricted subset of options in GraphViz that can be configured in\n-- an ER file.\ndata Option = Label String\n    | BgColor Color\n    | Color Color\n    | FontFace Text\n    | FontSize Double\n    | Border Word8\n    | BorderColor Color\n    | CellSpacing Word8\n    | CellBorder Word8\n    | CellPadding Word8\n    | TextAlignment H.Align\n    deriving (Show, Eq)\n\n-- | Given an option name and a string representation of its value,\n-- `optionByName` will attempt to parse the string as a value corresponding\n-- to the option. If the option doesn't exist or there was a problem parsing\n-- the value, an error is returned.\noptionByName :: String -> String -> Either String Option\noptionByName \"label\" = Right . Label\noptionByName \"color\" = optionParse Color\noptionByName \"bgcolor\" = optionParse BgColor\noptionByName \"size\" = optionParse FontSize\noptionByName \"font\" = optionParse FontFace\noptionByName \"border\" = optionParse Border\noptionByName \"border-color\" = optionParse BorderColor\noptionByName \"cellspacing\" = optionParse CellSpacing\noptionByName \"cellborder\" = optionParse CellBorder\noptionByName \"cellpadding\" = optionParse CellPadding\noptionByName \"text-alignment\" = optionParse TextAlignment\noptionByName unk = const (Left $ printf \"Option '%s' does not exist.\" unk)\n\n-- | A wrapper around the GraphViz's parser for any particular option.\noptionParse :: ParseDot a => (a -> Option) -> String -> Either String Option\noptionParse con s =\n  case fst $ runParser parse quoted of\n    Left err -> Left (printf \"%s (bad value '%s')\" err s)\n    Right a  -> Right (con a)\n  where quoted = \"\\\"\" `append` pack s `append` \"\\\"\"\n\n-- | Selects an option if and only if it corresponds to a font attribute.\noptToFont :: Option -> Maybe H.Attribute\noptToFont (Color c)    = Just $ H.Color c\noptToFont (FontFace s) = Just $ H.Face s\noptToFont (FontSize d) = Just $ H.PointSize d\noptToFont _            = Nothing\n\n-- | Selects an option if and only if it corresponds to an HTML attribute.\n-- In particular, for tables or table cells.\noptToHtml :: Option -> Maybe H.Attribute\noptToHtml (BgColor c)       = pure $ H.BGColor c\noptToHtml (Border w)        = pure $ H.Border w\noptToHtml (BorderColor c)   = pure $ H.Color c\noptToHtml (CellSpacing w)   = pure $ H.CellSpacing w\noptToHtml (CellBorder w)    = pure $ H.CellBorder w\noptToHtml (CellPadding w)   = pure $ H.CellPadding w\noptToHtml (TextAlignment x) = pure $ H.Align x\noptToHtml _                 = Nothing\n\n\n-- | Selects an option if and only if it corresponds to a label.\noptToLabel :: Option -> Maybe Text\noptToLabel (Label s) = Just $ pack s\noptToLabel _         = Nothing\n\n-- | Represents a relationship between exactly two entities. After parsing,\n-- each `rel` is guaranteed to correspond to an entity defined in the same\n-- ER file.\n--\n-- Each relationship has one of four cardinalities specified for both entities.\n-- Those cardinalities are: 0 or 1, exactly 1, 0 or more and 1 or more.\ndata Relation = Relation\n    { entity1, entity2 :: Text\n    , card1, card2     :: Cardinality\n    , roptions         :: Options\n    }\n    deriving (Show, Eq)\n\ndata Cardinality = ZeroOne\n    | One\n    | ZeroPlus\n    | OnePlus\n    deriving (Eq)\n\ninstance Show Cardinality where\n  show ZeroOne  = \"{0,1}\"\n  show One      = \"1\"\n  show ZeroPlus = \"0..N\"\n  show OnePlus  = \"1..N\"\n\n-- | Maps a string representation to a particular relationship cardinality.\ncardByName :: Char -> Maybe Cardinality\ncardByName '?' = Just ZeroOne\ncardByName '1' = Just One\ncardByName '*' = Just ZeroPlus\ncardByName '+' = Just OnePlus\ncardByName _   = Nothing\n\n-- | Hard-coded default options for all graph titles.\ndefaultTitleOpts :: Options\ndefaultTitleOpts = M.fromList\n  [ (\"size\", FontSize 30)\n  ]\n\n-- | Hard-coded default options for all entity headers.\ndefaultHeaderOpts :: Options\ndefaultHeaderOpts = M.fromList\n  [ (\"size\", FontSize 16)\n  ]\n\n-- | Hard-coded default options for all entities.\ndefaultEntityOpts :: Options\ndefaultEntityOpts = M.fromList\n  [ (\"border\", Border 0)\n  , (\"cellborder\", CellBorder 1)\n  , (\"cellspacing\", CellSpacing 0)\n  , (\"cellpadding\", CellPadding 4)\n  , (\"font\", FontFace \"Helvetica\")\n  ]\n\n-- | Hard-coded default options for all relationships.\ndefaultRelOpts :: Options\ndefaultRelOpts = M.empty\n\ndefaultAttrOpts :: Options\ndefaultAttrOpts = M.fromList\n  [ (\"text-alignment\", TextAlignment H.HLeft)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/Parse.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/src/Erd/Parse.hs",
              "cyclomatic_complexity": {
                "min": 3,
                "max": 6,
                "average": 4.5,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 88,
              "homplexity_lines_of_code": 123,
              "code_quality_score": 69.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 3,
                  "max": 6,
                  "average": 4.5,
                  "sum": 9
                },
                "homplexity_loc": 123,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 1 1: module Erd.Parse has 70 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 21 1: type signature for loadER has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 21 1: type signature for loadER has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 22 1: function loadER has 13 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 22 1: function loadER has cyclomatic complexity of 3 \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 22 1: function loadER has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 44 1: type signature for toER has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 44 1: type signature for toER has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 45 1: function toER has cyclomatic complexity of 6 \nWarning:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 45 1: function toER has 40 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_91/static_refactored/src/Erd/Parse.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Parse.hs\" 45 1: function toER has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.Parse\n  ( loadER\n  )\nwhere\n\nimport           Erd.ER\n\nimport           Control.Exception      (bracket_)\nimport           Control.Monad          (when,unless)\nimport           Data.List              (find)\nimport           Data.Maybe\nimport           Data.Text.Lazy         hiding (find, map, reverse)\nimport           Data.Text.Lazy.IO\nimport           System.IO              (Handle,hIsTerminalDevice,hSetEncoding,\n                                         hGetEncoding,utf8)\nimport           Text.Parsec\nimport           Text.Parsec.Erd.Parser (AST (..), GlobalOptions (..), document)\nimport           Text.Printf            (printf)\n\nloadER :: String -> Handle -> IO (Either String ER)\nloadER fpath f = do\n  Just initialEncoding <- hGetEncoding f\n  isTerminalDevice <- hIsTerminalDevice f\n  let setEncodingIfNeeded = unless isTerminalDevice . hSetEncoding f\n  bracket_\n    (setEncodingIfNeeded utf8)\n    (setEncodingIfNeeded initialEncoding)\n    (do\n      s <- hGetContents f\n      case parse (do { (opts, ast) <- document; return $ toER opts ast}) fpath s of\n        Left err           -> return $ Left $ show err\n        Right err@(Left _) -> return err\n        Right (Right er)   -> return $ Right er\n    )\n\n-- | Converts a list of syntactic categories in an entity-relationship\n-- description to an ER representation. If there was a problem with the\n-- conversion, an error is reported. This includes checking that each\n-- relationship contains only valid entity names.\n--\n-- This preserves the ordering of the syntactic elements in the original\n-- description.\ntoER :: GlobalOptions -> [AST] -> Either String ER\ntoER gopts = toER' (ER [] [] erTitle)\n  where erTitle = gtoptions gopts `mergeOpts` defaultTitleOpts\n\n        toER' :: ER -> [AST] -> Either String ER\n        toER' er [] = Right (reversed er) >>= validRels\n        toER' ER { entities = [] } (A a:_) =\n          let fieldName = show (field a)\n          in  Left $ printf \"Attribute '%s' comes before first entity.\" fieldName\n        toER' er@ER { entities = e':es } (A a:xs) = do\n          let e = e' { attribs = a:attribs e' }\n          toER' (er { entities = e:es }) xs\n        toER' er@ER { entities = es } (E e:xs) = do\n          let opts = eoptions e\n                     `mergeOpts` geoptions gopts\n                     `mergeOpts` defaultEntityOpts\n          let hopts = eoptions e\n                      `mergeOpts` ghoptions gopts\n                      `mergeOpts` defaultHeaderOpts\n          toER' (er { entities = e { eoptions = opts, hoptions = hopts }:es}) xs\n        toER' er@ER { rels = rs } (R r:xs) = do\n          let opts = roptions r\n                     `mergeOpts` groptions gopts\n                     `mergeOpts` defaultRelOpts\n          toER' (er { rels = r { roptions = opts }:rs }) xs\n\n        reversed :: ER -> ER\n        reversed er@ER { entities = es, rels = rs } =\n          let es' = map (\\e -> e { attribs = reverse (attribs e) }) es\n          in  er { entities = reverse es', rels = reverse rs }\n\n        validRels :: ER -> Either String ER\n        validRels er = validRels' (rels er) er\n\n        validRels' :: [Relation] -> ER -> Either String ER\n        validRels' [] er = return er\n        validRels' (r:_) er = do\n          let r1 = find (\\e -> name e == entity1 r) (entities er)\n          let r2 = find (\\e -> name e == entity2 r) (entities er)\n          let err getter = Left\n                             $ printf \"Unknown entity '%s' in relationship.\"\n                             $ unpack $ getter r\n          when (isNothing r1) (err entity1)\n          when (isNothing r2) (err entity2)\n          return er\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/src/Erd/Parse.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.Parse\n  ( loadER\n  )\nwhere\n\nimport           Erd.ER\n\nimport           Control.Exception      (bracket_)\nimport           Control.Monad          (when,unless)\nimport           Data.List              (find)\nimport           Data.Maybe\nimport           Data.Text.Lazy         hiding (find, map, reverse)\nimport           Data.Text.Lazy.IO\nimport           System.IO              (Handle,hIsTerminalDevice,hSetEncoding,\n                                         hGetEncoding,utf8)\nimport           Text.Parsec\nimport           Text.Parsec.Erd.Parser (AST (..), GlobalOptions (..), document)\nimport           Text.Printf            (printf)\n\nloadER :: String -> Handle -> IO (Either String ER)\nloadER fpath f = do\n  Just initialEncoding <- hGetEncoding f\n  isTerminalDevice <- hIsTerminalDevice f\n  let setEncodingIfNeeded = unless isTerminalDevice . hSetEncoding f\n  bracket_\n    (setEncodingIfNeeded utf8)\n    (setEncodingIfNeeded initialEncoding)\n    (do\n      s <- hGetContents f\n      case parse (do { (opts, ast) <- document; return $ toER opts ast}) fpath s of\n        Left err           -> return $ Left $ show err\n        Right err@(Left _) -> return err\n        Right (Right er)   -> return $ Right er\n    )\n\n-- | Converts a list of syntactic categories in an entity-relationship\n-- description to an ER representation. If there was a problem with the\n-- conversion, an error is reported. This includes checking that each\n-- relationship contains only valid entity names.\n--\n-- This preserves the ordering of the syntactic elements in the original\n-- description.\ntoER :: GlobalOptions -> [AST] -> Either String ER\ntoER gopts = toER' (ER [] [] erTitle)\n  where erTitle = gtoptions gopts `mergeOpts` defaultTitleOpts\n\n        toER' :: ER -> [AST] -> Either String ER\n        toER' er [] = Right (reversed er) >>= validRels\n        toER' ER { entities = [] } (A a:_) =\n          let fieldName = show (field a)\n          in  Left $ printf \"Attribute '%s' comes before first entity.\" fieldName\n        toER' er@ER { entities = e':es } (A a:xs) = do\n          let e = e' { attribs = a:attribs e' }\n          toER' (er { entities = e:es }) xs\n        toER' er@ER { entities = es } (E e:xs) = do\n          let opts = eoptions e\n                     `mergeOpts` geoptions gopts\n                     `mergeOpts` defaultEntityOpts\n          let hopts = eoptions e\n                      `mergeOpts` ghoptions gopts\n                      `mergeOpts` defaultHeaderOpts\n          toER' (er { entities = e { eoptions = opts, hoptions = hopts }:es}) xs\n        toER' er@ER { rels = rs } (R r:xs) = do\n          let opts = roptions r\n                     `mergeOpts` groptions gopts\n                     `mergeOpts` defaultRelOpts\n          toER' (er { rels = r { roptions = opts }:rs }) xs\n\n        reversed :: ER -> ER\n        reversed er@ER { entities = es, rels = rs } =\n          let es' = map (\\e -> e { attribs = reverse (attribs e) }) es\n          in  er { entities = reverse es', rels = reverse rs }\n\n        validRels :: ER -> Either String ER\n        validRels er = validRels' (rels er) er\n\n        validRels' :: [Relation] -> ER -> Either String ER\n        validRels' [] er = return er\n        validRels' (r:_) er = do\n          let r1 = find (\\e -> name e == entity1 r) (entities er)\n          let r2 = find (\\e -> name e == entity2 r) (entities er)\n          let err getter = Left\n                             $ printf \"Unknown entity '%s' in relationship.\"\n                             $ unpack $ getter r\n          when (isNothing r1) (err entity1)\n          when (isNothing r2) (err entity2)\n          return er\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/Render.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/src/Erd/Render.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.75,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 41,
              "homplexity_lines_of_code": 41,
              "code_quality_score": 81.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.75,
                  "sum": 7
                },
                "homplexity_loc": 41,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 1 1: module Erd.Render has 28 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has 7 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has cyclomatic complexity of 3 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 27 1: type signature for recordAttr has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 27 1: type signature for recordAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 31 1: type signature for htmlFont has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 31 1: type signature for htmlFont has 3 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 32 1: function htmlFont has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 32 1: function htmlFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 32 1: function htmlFont has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 37 1: type signature for withLabelFmt has 4 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 37 1: type signature for withLabelFmt has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 38 1: function withLabelFmt has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 38 1: function withLabelFmt has 4 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Render.hs\" 38 1: function withLabelFmt has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Erd.Render\n  (htmlAttr,\n   htmlFont,\n   recordAttr,\n   withLabelFmt\n  ) where\n\nimport qualified Erd.ER                            as ER\n\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Attributes.HTML     as H\nimport qualified Data.Text.Lazy                    as L\nimport           Text.Printf                       (printf)\n\n-- | Converts a single attribute to an HTML table row.\nhtmlAttr :: ER.Attribute -> H.Row\nhtmlAttr a = H.Cells [cell]\n  where cell    = H.LabelCell cellAttrs (H.Text $ withLabelFmt \" [%s]\" opts name)\n        name    = fkfmt $ pkfmt $ htmlFont opts (ER.field a)\n        pkfmt s = if ER.pk a then [H.Format H.Underline s] else s\n        fkfmt s = if ER.fk a then [H.Format H.Italics s] else s\n        opts    = ER.aoptions a\n        cellAttrs = ER.optionsTo ER.optToHtml opts\n-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a -- should change to add port support!\n-- | Formats an arbitrary string with the options given (using only font\n-- attributes).\nhtmlFont :: ER.Options -> L.Text -> H.Text\nhtmlFont opts s = [H.Font (ER.optionsTo ER.optToFont opts) [H.Str s]]\n\n-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\nwithLabelFmt :: String -> ER.Options -> H.Text -> H.Text\nwithLabelFmt fmt opts s =\n  case ER.optionsTo ER.optToLabel opts of\n    (x:_) -> s ++ htmlFont opts (L.pack $ printf fmt $ L.unpack x)\n    _     -> s\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/src/Erd/Render.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Erd.Render\n  (htmlAttr,\n   htmlFont,\n   recordAttr,\n   withLabelFmt\n  ) where\n\nimport qualified Erd.ER                            as ER\n\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Attributes.HTML     as H\nimport qualified Data.Text.Lazy                    as L\nimport           Text.Printf                       (printf)\n\n-- | Converts a single attribute to an HTML table row.\nhtmlAttr :: ER.Attribute -> H.Row\nhtmlAttr a = H.Cells [cell]\n  where cell    = H.LabelCell cellAttrs (H.Text $ withLabelFmt \" [%s]\" opts name)\n        name    = fkfmt $ pkfmt $ htmlFont opts (ER.field a)\n        pkfmt s = if ER.pk a then [H.Format H.Underline s] else s\n        fkfmt s = if ER.fk a then [H.Format H.Italics s] else s\n        opts    = ER.aoptions a\n        cellAttrs = ER.optionsTo ER.optToHtml opts\n-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a -- should change to add port support!\n-- | Formats an arbitrary string with the options given (using only font\n-- attributes).\nhtmlFont :: ER.Options -> L.Text -> H.Text\nhtmlFont opts s = [H.Font (ER.optionsTo ER.optToFont opts) [H.Str s]]\n\n-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\nwithLabelFmt :: String -> ER.Options -> H.Text -> H.Text\nwithLabelFmt fmt opts s =\n  case ER.optionsTo ER.optToLabel opts of\n    (x:_) -> s ++ htmlFont opts (L.pack $ printf fmt $ L.unpack x)\n    _     -> s\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/Config.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/src/Erd/Config.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 7,
                "average": 1.5217391304347827,
                "sum": 35
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 11,
              "lines_of_code": 335,
              "homplexity_lines_of_code": 446,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 7,
                  "average": 1.5217391304347827,
                  "sum": 35
                },
                "homplexity_loc": 446,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 1 1: module Erd.Config has 266 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 42 17: data Notation has record fields count of 0 \nWarning:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 46 15: data Config has record fields count of 8 should be less than 6\nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 58 19: data ConfigFile has record fields count of 5 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 68 1: type signature for emptyConfigFile has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 68 1: type signature for emptyConfigFile has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 69 1: function emptyConfigFile has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 69 1: function emptyConfigFile has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 69 1: function emptyConfigFile has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 82 1: type signature for defaultConfig has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 82 1: type signature for defaultConfig has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 83 1: function defaultConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 83 1: function defaultConfig has 9 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 83 1: function defaultConfig has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 94 1: type signature for defaultConfigFile has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 94 1: type signature for defaultConfigFile has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 95 1: function defaultConfigFile has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 95 1: function defaultConfigFile has 8 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 95 1: function defaultConfigFile has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 110 1: type signature for configIO has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 110 1: type signature for configIO has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 111 1: function configIO has branching depth of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 111 1: function configIO has 17 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 111 1: function configIO has cyclomatic complexity of 4 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 135 1: type signature for opts has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 135 1: type signature for opts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 136 1: function opts has cyclomatic complexity of 7 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 136 1: function opts has branching depth of 1 \nCritical:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 136 1: function opts has 87 lines of code this function exceeds 40 lines of code.\nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 232 1: type signature for toConfig has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 232 1: type signature for toConfig has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 233 1: function toConfig has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 233 1: function toConfig has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 233 1: function toConfig has 5 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 240 1: type signature for readGlobalConfigFile has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 240 1: type signature for readGlobalConfigFile has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has 5 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 241 1: function readGlobalConfigFile has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 249 1: type signature for readConfigFile has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 249 1: type signature for readConfigFile has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 250 1: function readConfigFile has branching depth of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 250 1: function readConfigFile has 6 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 250 1: function readConfigFile has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 258 1: type signature for fmts has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 258 1: type signature for fmts has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 259 1: function fmts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 259 1: function fmts has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 259 1: function fmts has 13 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 274 1: type signature for edges has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 274 1: type signature for edges has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 275 1: function edges has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 275 1: function edges has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 275 1: function edges has 6 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 283 1: type signature for valBool has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 283 1: type signature for valBool has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 284 1: function valBool has 3 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 284 1: function valBool has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 284 1: function valBool has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 288 1: type signature for edgePatterns has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 288 1: type signature for edgePatterns has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 289 1: function edgePatterns has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 289 1: function edgePatterns has 4 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 289 1: function edgePatterns has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 295 1: type signature for notations has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 295 1: type signature for notations has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 296 1: function notations has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 296 1: function notations has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 296 1: function notations has 3 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 304 1: type signature for takeExtension has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 304 1: type signature for takeExtension has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 305 1: function takeExtension has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 305 1: function takeExtension has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 305 1: function takeExtension has 2 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 308 1: type signature for toGraphFmt has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 308 1: type signature for toGraphFmt has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 309 1: function toGraphFmt has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 309 1: function toGraphFmt has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 309 1: function toGraphFmt has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 311 1: type signature for toEdgeG has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 311 1: type signature for toEdgeG has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 312 1: function toEdgeG has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 312 1: function toEdgeG has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 312 1: function toEdgeG has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 314 1: type signature for toEdgePattern has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 314 1: type signature for toEdgePattern has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 315 1: function toEdgePattern has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 315 1: function toEdgePattern has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 315 1: function toEdgePattern has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 317 1: type signature for toNotation has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 317 1: type signature for toNotation has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 318 1: function toNotation has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 318 1: function toNotation has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 318 1: function toNotation has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 320 1: type signature for usageExit has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 320 1: type signature for usageExit has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 321 1: function usageExit has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 321 1: function usageExit has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 321 1: function usageExit has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 323 1: type signature for usage has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 323 1: type signature for usage has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 324 1: function usage has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 324 1: function usage has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 324 1: function usage has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 326 1: type signature for erdVersion has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 326 1: type signature for erdVersion has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 327 1: function erdVersion has 3 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 327 1: function erdVersion has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 327 1: function erdVersion has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 331 1: type signature for ef has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 331 1: type signature for ef has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 332 1: function ef has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 332 1: function ef has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 332 1: function ef has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 334 1: type signature for strip has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 334 1: type signature for strip has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 335 1: function strip has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 335 1: function strip has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Erd/Config.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Erd/Config.hs\" 335 1: function strip has cyclomatic complexity of 1 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nmodule Erd.Config\n  ( Config(..)\n  , configIO\n  , defaultConfig\n  , defaultConfigFile\n  , Notation(..)\n  )\nwhere\n\nimport           Control.Exception                 (tryJust)\nimport           Control.Monad                     (guard)\nimport qualified Data.ByteString.Char8             as B\nimport           Data.Char                         (isSpace)\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Commands            as G\nimport           Data.List                         (dropWhileEnd, intercalate)\nimport qualified Data.Map                          as M\nimport           Data.Maybe                        (isNothing)\nimport           Data.Version                      (showVersion)\nimport           Data.Yaml                         (FromJSON (..), (.:?))\nimport qualified Data.Yaml                         as Y\nimport           Development.GitRev                (gitHash)\nimport           Paths_erd                         (version)\nimport qualified System.Console.GetOpt             as O\nimport           System.Directory                  (getHomeDirectory)\nimport           System.Environment                (getArgs)\nimport           System.Exit                       (exitFailure, exitSuccess)\nimport           System.FilePath                   ((</>))\nimport           System.IO                         (Handle, IOMode (..),\n                                                    openFile, stderr, stdin,\n                                                    stdout)\nimport           System.IO.Error                   (isDoesNotExistError)\nimport           Text.Printf                       (HPrintfType, hPrintf,\n                                                    printf)\nimport           Text.RawString.QQ\n\n-- | Notation style for relations.\ndata Notation = UML | IE\n  deriving Show\n\n-- | Config represents all information from command line flags.\ndata Config = Config\n    { cin         :: (String, Handle)\n    , cout        :: (String, Handle)\n    , outfmt      :: Maybe G.GraphvizOutput\n    , edgeType    :: Maybe A.EdgeType\n    , configFile  :: Maybe FilePath\n    , dotentity   :: Maybe Bool\n    , edgePattern :: Maybe A.StyleName\n    , notation    :: Maybe Notation\n    }\n\n-- | Represents fields that are stored in the configuration file.\ndata ConfigFile = ConfigFile\n    { cFmtOut      :: Maybe String\n    , cEdgeType    :: Maybe String\n    , cDotEntity   :: Maybe Bool\n    , cEdgePattern :: Maybe String\n    , cNotation    :: Maybe String\n    }\n    deriving Show\n\n-- | A ConfigFile with all fields initialized with Nothing.\nemptyConfigFile :: ConfigFile\nemptyConfigFile = ConfigFile Nothing Nothing Nothing Nothing Nothing\n\ninstance FromJSON ConfigFile where\n  parseJSON (Y.Object v) =\n    ConfigFile <$>\n    v .:? \"output-format\" <*>\n    v .:? \"edge-style\" <*>\n    v .:? \"dot-entity\" <*>\n    v .:? \"edge-pattern\" <*>\n    v .:? \"notation\"\n  parseJSON Y.Null = return emptyConfigFile\n  parseJSON _ = fail \"Incorrect configuration file.\"\n\ndefaultConfig :: Config\ndefaultConfig =\n  Config { cin = (\"<stdin>\", stdin)\n         , cout = (\"<stdout>\", stdout)\n         , outfmt = Nothing\n         , edgeType = Just A.SplineEdges\n         , configFile = Nothing\n         , dotentity = Just False\n         , edgePattern = Just A.Dashed\n         , notation = Just UML\n         }\n\ndefaultConfigFile :: B.ByteString\ndefaultConfigFile = B.unlines\n  [[r|# Erd (~/.erd.yaml) default configuration file.|],\n   B.append [r|output-format: pdf           # Supported formats: |] (defVals fmts),\n   B.append [r|edge-style: spline           # Supported values : |] (defVals edges),\n   B.append [r|dot-entity: false            # Supported values : |] (defVals valBool),\n   B.append [r|edge-pattern: dashed         # Supported values : |] (defVals edgePatterns),\n   B.append [r|notation: uml                # Supported values : |] (defVals notations)\n  ]\n  where\n    defVals = B.pack . unwords . M.keys\n\n-- | Creates a new Config value from command line options.\n-- If an output path is given and `--fmt` is omitted, then a format\n-- will be inferred from the output path extension.\n-- Failing all of that, PDF is used by default.\nconfigIO :: IO Config\nconfigIO = do\n  args <- getArgs\n  case O.getOpt O.Permute opts args of\n    (flags, [], []) -> do\n      conf <- foldl (\\c app -> app c) (return defaultConfig) flags\n      let outpath = fst (cout conf)\n      return $\n        if isNothing (outfmt conf) && outpath /= \"<stdout>\" then\n          conf { outfmt = toGraphFmt $ takeExtension outpath }\n        else\n          conf\n    (_, _, errs@(_:_)) -> do\n      ef \"Error(s) parsing flags:\\n\\t%s\\n\" $\n        intercalate \"\\n\\t\" $ map strip errs\n      exitFailure\n    (_, _, []) -> do\n      ef \"erd does not have any positional arguments.\\n\\n\"\n      usageExit\n\n-- | Order of processing command-line options is important to keep priority of\n-- configuration sources, in terms of increasing precedence.\n-- 1. Command-line options\n-- 2. Configuration file of arbitrary path, e.g. '-c\"/tmp/myconfig.yaml\"'\n-- 3. Configuration file: ~/.erd.yaml\nopts :: [O.OptDescr (IO Config -> IO Config)]\nopts =\n  [ O.Option \"c\" [\"config\"]\n      (O.OptArg (\\mf cIO -> cIO >>= \\c -> do\n                      globConfFile <- readGlobalConfigFile\n                      f <- readConfigFile mf\n                      case (f, globConfFile) of\n                        (Nothing, Nothing) ->      -- Config-file is desired, but unavailable.\n                          B.putStr defaultConfigFile >> return c\n                        (Nothing, Just x) -> -- Use global config-file from ~/.erd.yaml .\n                          return $ toConfig x\n                        (Just x, _) ->        -- Use user specified config-file.\n                          return $ toConfig x\n                    ) \"FILE\")\n      \"Configuration file.\"\n  , O.Option \"i\" [\"input\"]\n      (O.ReqArg (\\fpath cIO -> do\n                   c <- cIO\n                   i <- openFile fpath ReadMode\n                   return $ c {cin = (fpath, i)}\n                )\n                \"FILE\")\n      (\"When set, input will be read from the given file.\\n\"\n       ++ \"Otherwise, stdin will be used.\")\n  , O.Option \"o\" [\"output\"]\n      (O.ReqArg (\\fpath cIO -> do\n                    c <- cIO\n                    o <- openFile fpath WriteMode\n                    return $ c {cout = (fpath, o)}\n                )\n                \"FILE\")\n      (\"When set, output will be written to the given file.\\n\"\n       ++ \"Otherwise, stdout will be used.\\n\"\n       ++ \"If given and if --fmt is omitted, then the format will be\\n\"\n       ++ \"guessed from the file extension.\")\n  , O.Option \"h\" [\"help\"]\n      (O.NoArg $ const usageExit)\n      \"Show this usage message.\"\n  , O.Option \"f\" [\"fmt\"]\n      (O.ReqArg (\\fmt cIO -> do\n                    c <- cIO\n                    let mfmt = toGraphFmt fmt\n                    case mfmt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid output format.\\n\" fmt\n                        exitFailure\n                      Just gfmt -> return c {outfmt = Just gfmt}\n                )\n                \"FMT\")\n      (descriptionWithValuesList \"Force the output format to one of\" fmts)\n  , O.Option \"e\" [\"edge\"]\n      (O.ReqArg (\\edge cIO -> do\n                    c <- cIO\n                    let edgeG = toEdgeG edge\n                    case edgeG of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge.\\n\" edge\n                        exitFailure\n                      Just x -> return c {edgeType = Just x}\n                )\n                \"EDGE\")\n      (descriptionWithValuesList \"Select one type of edge\" edges)\n  , O.Option \"p\" [\"edge-pattern\"]\n      (O.ReqArg (\\epat cIO -> do\n                    c <- cIO\n                    case toEdgePattern epat of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge pattern.\\n\" epat\n                        exitFailure\n                      Just x -> return c {edgePattern = Just x}\n                )\n                \"PATTERN\")\n      (descriptionWithValuesList \"Select one of the edge patterns\" edgePatterns)\n  , O.Option \"n\" [\"notation\"]\n      (O.ReqArg (\\nt cIO -> do\n                    c <- cIO\n                    case toNotation nt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid notation style.\\n\" nt\n                        exitFailure\n                      Just x -> return c {notation = Just x}\n                )\n                \"NOTATION\")\n      (descriptionWithValuesList \"Select one of the notation styles\" notations)\n  , O.Option \"d\" [\"dot-entity\"]\n      (O.NoArg (\\cIO -> do\n                    c <- cIO\n                    return $ c { dotentity = Just True } ))\n      (\"When set, output will consist of regular dot tables instead of HTML tables.\\n\"\n      ++ \"Formatting will be disabled. Use only for further manual configuration.\")\n  , O.Option \"v\" [\"version\"]\n      (O.NoArg $ const erdVersion) \"Shows version of application and revision code.\"\n  ]\n  where\n    descriptionWithValuesList :: String -> M.Map String a -> String\n    descriptionWithValuesList txt m = printf (txt <> \":\\n%s.\") (intercalate \", \" $ M.keys m)\n\ntoConfig :: ConfigFile -> Config\ntoConfig c = defaultConfig {outfmt      = cFmtOut c >>= toGraphFmt,\n                            edgeType    = cEdgeType c >>= toEdgeG,\n                            dotentity   = cDotEntity c,\n                            edgePattern = cEdgePattern c >>= toEdgePattern,\n                            notation    = cNotation c >>= toNotation}\n\n-- | Reads and parses configuration file at default location: ~/.erd.yaml\nreadGlobalConfigFile :: IO (Maybe ConfigFile)\nreadGlobalConfigFile = do\n  mHome <- tryJust (guard . isDoesNotExistError) getHomeDirectory\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> readConfigFile $ Just (home </> \".erd.yaml\")\n\n-- | Reads and parses a configuration file, exceptions may come via\n-- AesonException.\nreadConfigFile :: Maybe FilePath -> IO (Maybe ConfigFile)\nreadConfigFile Nothing = return Nothing\nreadConfigFile (Just f) = do\n  mHome <- tryJust (guard . isDoesNotExistError) $ B.readFile f\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> Y.decodeThrow home\n\n-- | A subset of formats supported from GraphViz.\nfmts :: M.Map String G.GraphvizOutput\nfmts = M.fromList\n  [ (\"pdf\", G.Pdf)\n  , (\"svg\", G.Svg)\n  , (\"eps\", G.Eps)\n  , (\"bmp\", G.Bmp)\n  , (\"jpg\", G.Jpeg)\n  , (\"png\", G.Png)\n  , (\"gif\", G.Gif)\n  , (\"tiff\", G.Tiff)\n  , (\"dot\", G.Canon)\n  , (\"ps\", G.Ps)\n  , (\"ps2\", G.Ps2)\n  , (\"plain\", G.Plain)\n  ]\n\nedges :: M.Map String A.EdgeType\nedges = M.fromList\n  [ (\"spline\", A.SplineEdges)\n  , (\"ortho\", A.Ortho)\n  , (\"noedge\", A.NoEdges)\n  , (\"poly\", A.PolyLine)\n  , (\"compound\", A.CompoundEdge)\n  ]\n\nvalBool :: M.Map String Bool\nvalBool = M.fromList\n  [ (\"true\", True)\n  , (\"false\", False) ]\n\nedgePatterns :: M.Map String A.StyleName\nedgePatterns = M.fromList\n  [ (\"solid\", A.Solid)\n  , (\"dashed\", A.Dashed)\n  , (\"dotted\", A.Dotted)\n  ]\n\nnotations :: M.Map String Notation\nnotations = M.fromList\n  [ (\"uml\", UML)\n  , (\"ie\", IE)\n  ]\n\n-- | takeExtension returns the last extension from a file path, or the\n-- empty string if no extension was found. e.g., the extension of\n-- \"wat.pdf\" is \"pdf\".\ntakeExtension :: String -> String\ntakeExtension s = if null rest then \"\" else reverse ext\n  where (ext, rest) = span (/= '.') $ reverse s\n\ntoGraphFmt :: String -> Maybe G.GraphvizOutput\ntoGraphFmt = (`M.lookup` fmts)\n\ntoEdgeG :: String -> Maybe A.EdgeType\ntoEdgeG = (`M.lookup` edges)\n\ntoEdgePattern :: String -> Maybe A.StyleName\ntoEdgePattern = (`M.lookup` edgePatterns)\n\ntoNotation :: String -> Maybe Notation\ntoNotation = (`M.lookup` notations)\n\nusageExit :: IO a\nusageExit = usage >> exitFailure\n\nusage :: IO ()\nusage = hPrintf stderr \"%s\\n\" $ O.usageInfo \"Usage: erd [flags]\" opts\n\nerdVersion :: IO a\nerdVersion = do\n  hPrintf stdout \"erd-%s %s\\n\" (showVersion version) ($(gitHash) :: String)\n  exitSuccess\n\nef :: HPrintfType r => String -> r\nef = hPrintf stderr\n\nstrip :: String -> String\nstrip = dropWhile isSpace . dropWhileEnd isSpace\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/src/Erd/Config.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nmodule Erd.Config\n  ( Config(..)\n  , configIO\n  , defaultConfig\n  , defaultConfigFile\n  , Notation(..)\n  )\nwhere\n\nimport           Control.Exception                 (tryJust)\nimport           Control.Monad                     (guard)\nimport qualified Data.ByteString.Char8             as B\nimport           Data.Char                         (isSpace)\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Commands            as G\nimport           Data.List                         (dropWhileEnd, intercalate)\nimport qualified Data.Map                          as M\nimport           Data.Maybe                        (isNothing)\nimport           Data.Version                      (showVersion)\nimport           Data.Yaml                         (FromJSON (..), (.:?))\nimport qualified Data.Yaml                         as Y\nimport           Development.GitRev                (gitHash)\nimport           Paths_erd                         (version)\nimport qualified System.Console.GetOpt             as O\nimport           System.Directory                  (getHomeDirectory)\nimport           System.Environment                (getArgs)\nimport           System.Exit                       (exitFailure, exitSuccess)\nimport           System.FilePath                   ((</>))\nimport           System.IO                         (Handle, IOMode (..),\n                                                    openFile, stderr, stdin,\n                                                    stdout)\nimport           System.IO.Error                   (isDoesNotExistError)\nimport           Text.Printf                       (HPrintfType, hPrintf,\n                                                    printf)\nimport           Text.RawString.QQ\n\n-- | Notation style for relations.\ndata Notation = UML | IE\n  deriving Show\n\n-- | Config represents all information from command line flags.\ndata Config = Config\n    { cin         :: (String, Handle)\n    , cout        :: (String, Handle)\n    , outfmt      :: Maybe G.GraphvizOutput\n    , edgeType    :: Maybe A.EdgeType\n    , configFile  :: Maybe FilePath\n    , dotentity   :: Maybe Bool\n    , edgePattern :: Maybe A.StyleName\n    , notation    :: Maybe Notation\n    }\n\n-- | Represents fields that are stored in the configuration file.\ndata ConfigFile = ConfigFile\n    { cFmtOut      :: Maybe String\n    , cEdgeType    :: Maybe String\n    , cDotEntity   :: Maybe Bool\n    , cEdgePattern :: Maybe String\n    , cNotation    :: Maybe String\n    }\n    deriving Show\n\n-- | A ConfigFile with all fields initialized with Nothing.\nemptyConfigFile :: ConfigFile\nemptyConfigFile = ConfigFile Nothing Nothing Nothing Nothing Nothing\n\ninstance FromJSON ConfigFile where\n  parseJSON (Y.Object v) =\n    ConfigFile <$>\n    v .:? \"output-format\" <*>\n    v .:? \"edge-style\" <*>\n    v .:? \"dot-entity\" <*>\n    v .:? \"edge-pattern\" <*>\n    v .:? \"notation\"\n  parseJSON Y.Null = return emptyConfigFile\n  parseJSON _ = fail \"Incorrect configuration file.\"\n\ndefaultConfig :: Config\ndefaultConfig =\n  Config { cin = (\"<stdin>\", stdin)\n         , cout = (\"<stdout>\", stdout)\n         , outfmt = Nothing\n         , edgeType = Just A.SplineEdges\n         , configFile = Nothing\n         , dotentity = Just False\n         , edgePattern = Just A.Dashed\n         , notation = Just UML\n         }\n\ndefaultConfigFile :: B.ByteString\ndefaultConfigFile = B.unlines\n  [[r|# Erd (~/.erd.yaml) default configuration file.|],\n   B.append [r|output-format: pdf           # Supported formats: |] (defVals fmts),\n   B.append [r|edge-style: spline           # Supported values : |] (defVals edges),\n   B.append [r|dot-entity: false            # Supported values : |] (defVals valBool),\n   B.append [r|edge-pattern: dashed         # Supported values : |] (defVals edgePatterns),\n   B.append [r|notation: uml                # Supported values : |] (defVals notations)\n  ]\n  where\n    defVals = B.pack . unwords . M.keys\n\n-- | Creates a new Config value from command line options.\n-- If an output path is given and `--fmt` is omitted, then a format\n-- will be inferred from the output path extension.\n-- Failing all of that, PDF is used by default.\nconfigIO :: IO Config\nconfigIO = do\n  args <- getArgs\n  case O.getOpt O.Permute opts args of\n    (flags, [], []) -> do\n      conf <- foldl (\\c app -> app c) (return defaultConfig) flags\n      let outpath = fst (cout conf)\n      return $\n        if isNothing (outfmt conf) && outpath /= \"<stdout>\" then\n          conf { outfmt = toGraphFmt $ takeExtension outpath }\n        else\n          conf\n    (_, _, errs@(_:_)) -> do\n      ef \"Error(s) parsing flags:\\n\\t%s\\n\" $\n        intercalate \"\\n\\t\" $ map strip errs\n      exitFailure\n    (_, _, []) -> do\n      ef \"erd does not have any positional arguments.\\n\\n\"\n      usageExit\n\n-- | Order of processing command-line options is important to keep priority of\n-- configuration sources, in terms of increasing precedence.\n-- 1. Command-line options\n-- 2. Configuration file of arbitrary path, e.g. '-c\"/tmp/myconfig.yaml\"'\n-- 3. Configuration file: ~/.erd.yaml\nopts :: [O.OptDescr (IO Config -> IO Config)]\nopts =\n  [ O.Option \"c\" [\"config\"]\n      (O.OptArg (\\mf cIO -> cIO >>= \\c -> do\n                      globConfFile <- readGlobalConfigFile\n                      f <- readConfigFile mf\n                      case (f, globConfFile) of\n                        (Nothing, Nothing) ->      -- Config-file is desired, but unavailable.\n                          B.putStr defaultConfigFile >> return c\n                        (Nothing, Just x) -> -- Use global config-file from ~/.erd.yaml .\n                          return $ toConfig x\n                        (Just x, _) ->        -- Use user specified config-file.\n                          return $ toConfig x\n                    ) \"FILE\")\n      \"Configuration file.\"\n  , O.Option \"i\" [\"input\"]\n      (O.ReqArg (\\fpath cIO -> do\n                   c <- cIO\n                   i <- openFile fpath ReadMode\n                   return $ c {cin = (fpath, i)}\n                )\n                \"FILE\")\n      (\"When set, input will be read from the given file.\\n\"\n       ++ \"Otherwise, stdin will be used.\")\n  , O.Option \"o\" [\"output\"]\n      (O.ReqArg (\\fpath cIO -> do\n                    c <- cIO\n                    o <- openFile fpath WriteMode\n                    return $ c {cout = (fpath, o)}\n                )\n                \"FILE\")\n      (\"When set, output will be written to the given file.\\n\"\n       ++ \"Otherwise, stdout will be used.\\n\"\n       ++ \"If given and if --fmt is omitted, then the format will be\\n\"\n       ++ \"guessed from the file extension.\")\n  , O.Option \"h\" [\"help\"]\n      (O.NoArg $ const usageExit)\n      \"Show this usage message.\"\n  , O.Option \"f\" [\"fmt\"]\n      (O.ReqArg (\\fmt cIO -> do\n                    c <- cIO\n                    let mfmt = toGraphFmt fmt\n                    case mfmt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid output format.\\n\" fmt\n                        exitFailure\n                      Just gfmt -> return c {outfmt = Just gfmt}\n                )\n                \"FMT\")\n      (descriptionWithValuesList \"Force the output format to one of\" fmts)\n  , O.Option \"e\" [\"edge\"]\n      (O.ReqArg (\\edge cIO -> do\n                    c <- cIO\n                    let edgeG = toEdgeG edge\n                    case edgeG of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge.\\n\" edge\n                        exitFailure\n                      Just x -> return c {edgeType = Just x}\n                )\n                \"EDGE\")\n      (descriptionWithValuesList \"Select one type of edge\" edges)\n  , O.Option \"p\" [\"edge-pattern\"]\n      (O.ReqArg (\\epat cIO -> do\n                    c <- cIO\n                    case toEdgePattern epat of\n                      Nothing -> do\n                        ef \"'%s' is not a valid type of edge pattern.\\n\" epat\n                        exitFailure\n                      Just x -> return c {edgePattern = Just x}\n                )\n                \"PATTERN\")\n      (descriptionWithValuesList \"Select one of the edge patterns\" edgePatterns)\n  , O.Option \"n\" [\"notation\"]\n      (O.ReqArg (\\nt cIO -> do\n                    c <- cIO\n                    case toNotation nt of\n                      Nothing -> do\n                        ef \"'%s' is not a valid notation style.\\n\" nt\n                        exitFailure\n                      Just x -> return c {notation = Just x}\n                )\n                \"NOTATION\")\n      (descriptionWithValuesList \"Select one of the notation styles\" notations)\n  , O.Option \"d\" [\"dot-entity\"]\n      (O.NoArg (\\cIO -> do\n                    c <- cIO\n                    return $ c { dotentity = Just True } ))\n      (\"When set, output will consist of regular dot tables instead of HTML tables.\\n\"\n      ++ \"Formatting will be disabled. Use only for further manual configuration.\")\n  , O.Option \"v\" [\"version\"]\n      (O.NoArg $ const erdVersion) \"Shows version of application and revision code.\"\n  ]\n  where\n    descriptionWithValuesList :: String -> M.Map String a -> String\n    descriptionWithValuesList txt m = printf (txt <> \":\\n%s.\") (intercalate \", \" $ M.keys m)\n\ntoConfig :: ConfigFile -> Config\ntoConfig c = defaultConfig {outfmt      = cFmtOut c >>= toGraphFmt,\n                            edgeType    = cEdgeType c >>= toEdgeG,\n                            dotentity   = cDotEntity c,\n                            edgePattern = cEdgePattern c >>= toEdgePattern,\n                            notation    = cNotation c >>= toNotation}\n\n-- | Reads and parses configuration file at default location: ~/.erd.yaml\nreadGlobalConfigFile :: IO (Maybe ConfigFile)\nreadGlobalConfigFile = do\n  mHome <- tryJust (guard . isDoesNotExistError) getHomeDirectory\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> readConfigFile $ Just (home </> \".erd.yaml\")\n\n-- | Reads and parses a configuration file, exceptions may come via\n-- AesonException.\nreadConfigFile :: Maybe FilePath -> IO (Maybe ConfigFile)\nreadConfigFile Nothing = return Nothing\nreadConfigFile (Just f) = do\n  mHome <- tryJust (guard . isDoesNotExistError) $ B.readFile f\n  case mHome of\n    Left _     -> return Nothing\n    Right home -> Y.decodeThrow home\n\n-- | A subset of formats supported from GraphViz.\nfmts :: M.Map String G.GraphvizOutput\nfmts = M.fromList\n  [ (\"pdf\", G.Pdf)\n  , (\"svg\", G.Svg)\n  , (\"eps\", G.Eps)\n  , (\"bmp\", G.Bmp)\n  , (\"jpg\", G.Jpeg)\n  , (\"png\", G.Png)\n  , (\"gif\", G.Gif)\n  , (\"tiff\", G.Tiff)\n  , (\"dot\", G.Canon)\n  , (\"ps\", G.Ps)\n  , (\"ps2\", G.Ps2)\n  , (\"plain\", G.Plain)\n  ]\n\nedges :: M.Map String A.EdgeType\nedges = M.fromList\n  [ (\"spline\", A.SplineEdges)\n  , (\"ortho\", A.Ortho)\n  , (\"noedge\", A.NoEdges)\n  , (\"poly\", A.PolyLine)\n  , (\"compound\", A.CompoundEdge)\n  ]\n\nvalBool :: M.Map String Bool\nvalBool = M.fromList\n  [ (\"true\", True)\n  , (\"false\", False) ]\n\nedgePatterns :: M.Map String A.StyleName\nedgePatterns = M.fromList\n  [ (\"solid\", A.Solid)\n  , (\"dashed\", A.Dashed)\n  , (\"dotted\", A.Dotted)\n  ]\n\nnotations :: M.Map String Notation\nnotations = M.fromList\n  [ (\"uml\", UML)\n  , (\"ie\", IE)\n  ]\n\n-- | takeExtension returns the last extension from a file path, or the\n-- empty string if no extension was found. e.g., the extension of\n-- \"wat.pdf\" is \"pdf\".\ntakeExtension :: String -> String\ntakeExtension s = if null rest then \"\" else reverse ext\n  where (ext, rest) = span (/= '.') $ reverse s\n\ntoGraphFmt :: String -> Maybe G.GraphvizOutput\ntoGraphFmt = (`M.lookup` fmts)\n\ntoEdgeG :: String -> Maybe A.EdgeType\ntoEdgeG = (`M.lookup` edges)\n\ntoEdgePattern :: String -> Maybe A.StyleName\ntoEdgePattern = (`M.lookup` edgePatterns)\n\ntoNotation :: String -> Maybe Notation\ntoNotation = (`M.lookup` notations)\n\nusageExit :: IO a\nusageExit = usage >> exitFailure\n\nusage :: IO ()\nusage = hPrintf stderr \"%s\\n\" $ O.usageInfo \"Usage: erd [flags]\" opts\n\nerdVersion :: IO a\nerdVersion = do\n  hPrintf stdout \"erd-%s %s\\n\" (showVersion version) ($(gitHash) :: String)\n  exitSuccess\n\nef :: HPrintfType r => String -> r\nef = hPrintf stderr\n\nstrip :: String -> String\nstrip = dropWhile isSpace . dropWhileEnd isSpace\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs",
              "refactored_file_name": "/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 1.375,
                "sum": 22
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 162,
              "homplexity_lines_of_code": 231,
              "code_quality_score": 32.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 1.375,
                  "sum": 22
                },
                "homplexity_loc": 231,
                "homplexity_output": "Info:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 1 1: module Text.Parsec.Erd.Parser has 138 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 25 12: data AST has record fields count of 3 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 30 22: data GlobalOptions has record fields count of 4 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 38 1: type signature for emptyGlobalOptions has type constructor nesting of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 38 1: type signature for emptyGlobalOptions has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 39 1: function emptyGlobalOptions has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 41 1: type signature for document has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 41 1: type signature for document has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has 10 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 42 1: function document has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 53 1: type signature for entity has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 53 1: type signature for entity has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has 6 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 54 1: function entity has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 61 1: type signature for attr has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 61 1: type signature for attr has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has 9 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 62 1: function attr has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 72 1: type signature for rel has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 72 1: type signature for rel has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 73 1: function rel has 16 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 90 1: type signature for globalOptions has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 90 1: type signature for globalOptions has 2 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has 10 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 91 1: function globalOptions has cyclomatic complexity of 5 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 102 1: type signature for options has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 102 1: type signature for options has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has 6 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 103 1: function options has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 110 1: type signature for opt has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 110 1: type signature for opt has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has branching depth of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has 9 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 111 1: function opt has cyclomatic complexity of 2 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 121 1: type signature for comment has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 121 1: type signature for comment has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has 4 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 122 1: function comment has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 127 1: type signature for ident has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 127 1: type signature for ident has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has 5 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 128 1: function ident has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 134 1: type signature for identQuoted has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 134 1: type signature for identQuoted has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has 7 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 135 1: function identQuoted has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 143 1: type signature for identNoSpace has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 143 1: type signature for identNoSpace has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has 4 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 144 1: function identNoSpace has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 149 1: type signature for emptiness has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 149 1: type signature for emptiness has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 150 1: function emptiness has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 152 1: type signature for eolComment has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 152 1: type signature for eolComment has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 153 1: function eolComment has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 155 1: type signature for spacesNoNew has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 155 1: type signature for spacesNoNew has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has 1 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 156 1: function spacesNoNew has branching depth of 0 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 158 1: type signature for eol has type constructor nesting of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 158 1: type signature for eol has 1 arguments \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has cyclomatic complexity of 1 \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has 3 lines of code \nInfo:/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/static_refactored/src/Text/Parsec/Erd/Parser.hs\" 159 1: function eol has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Text.Parsec.Erd.Parser\n  ( AST(..),\n    GlobalOptions(..),\n    document,\n    globalOptions,\n    entity,\n    rel,\n    attr,\n    comment\n  ) where\n\nimport           Erd.ER\n\nimport           Control.Monad         (liftM2, void, when)\nimport           Data.Char             (isAlphaNum, isControl, isSpace)\nimport qualified Data.Map              as M\nimport           Data.Maybe\nimport           Data.Text.Lazy        hiding (elem)\nimport           Text.Parsec\nimport           Text.Parsec.Text.Lazy\nimport           Text.Printf           (printf)\n\ndata AST = E Entity\n    | A Attribute\n    | R Relation\n    deriving (Show, Eq)\n\ndata GlobalOptions = GlobalOptions\n    { gtoptions :: Options\n    , ghoptions :: Options\n    , geoptions :: Options\n    , groptions :: Options\n    }\n    deriving (Show, Eq)\n\nemptyGlobalOptions :: GlobalOptions\nemptyGlobalOptions = GlobalOptions M.empty M.empty M.empty M.empty\n\ndocument :: Parser (GlobalOptions, [AST])\ndocument = do skipMany (comment <|> blanks)\n              opts <- globalOptions emptyGlobalOptions\n              ast <-  catMaybes <$> manyTill top eof\n              return (opts, ast)\n  where top = (entity <?> \"entity declaration\")\n              <|> (try rel <?> \"relationship\") -- must come before attr\n              <|> (try attr <?> \"attribute\")\n              <|> (comment <?> \"comment\")\n              <|> blanks\n        blanks = many1 (space <?> \"whitespace\") >> return Nothing\n\nentity :: Parser (Maybe AST)\nentity = do n <- between (char '[') (char ']') ident\n            spacesNoNew\n            opts <- options\n            eolComment\n            return $ Just $ E Entity { name = n, attribs = [],\n                                       hoptions = opts, eoptions = opts }\n\nattr :: Parser (Maybe AST)\nattr = do\n  keys <- many $ oneOf \"*+ \\t\"\n  let (ispk, isfk) = ('*' `elem` keys, '+' `elem` keys)\n  n <- ident\n  opts <- options\n  eolComment\n  return\n    $ Just\n    $ A Attribute {field = n, pk = ispk, fk = isfk, aoptions = opts <> defaultAttrOpts}\n\nrel :: Parser (Maybe AST)\nrel = do\n  let ops = \"?1*+\"\n  e1 <- ident\n  op1 <- oneOf ops\n  _ <- string \"--\"\n  op2 <- oneOf ops\n  e2 <- ident\n  opts <- options\n  let getCard op =\n        case cardByName op of\n          Just t -> return t\n          Nothing -> unexpected (printf \"Cardinality '%s' does not exist.\" op)\n  t1 <- getCard op1\n  t2 <- getCard op2\n  return $ Just $ R Relation { entity1 = e1, entity2 = e2\n                             , card1 = t1, card2 = t2, roptions = opts }\n\nglobalOptions :: GlobalOptions -> Parser GlobalOptions\nglobalOptions gopts =\n  option gopts $ try $ do\n    n <- ident\n    opts <- options\n    case n of\n      \"title\"        -> emptiness >> globalOptions (gopts { gtoptions = opts})\n      \"header\"       -> emptiness >> globalOptions (gopts { ghoptions = opts})\n      \"entity\"       -> emptiness >> globalOptions (gopts { geoptions = opts})\n      \"relationship\" -> emptiness >> globalOptions (gopts { groptions = opts})\n      _ -> fail \"not a valid directive\"\n\noptions :: Parser (M.Map String Option)\noptions =\n  option M.empty\n    $ fmap M.fromList\n    $ try\n    $ between (char '{' >> emptiness) (emptiness >> char '}')\n    $ opt `sepEndBy` (emptiness >> char ',' >> emptiness)\n\nopt :: Parser (String, Option)\nopt = do\n  optName <- liftM2 (:) letter (manyTill (letter <|> char '-') (char ':'))\n          <?> \"option name\"\n  emptiness\n  value <- between (char '\"') (char '\"') (many $ noneOf \"\\\"\")\n           <?> \"option value\"\n  case optionByName optName value of\n    Left err -> fail err\n    Right o' -> emptiness >> return (optName, o')\n\ncomment :: Parser (Maybe AST)\ncomment = do\n  _ <- char '#'\n  _ <- manyTill anyChar $ try eol\n  return Nothing\n\nident :: Parser Text\nident = do\n  spacesNoNew\n  n <- identQuoted <|> identNoSpace\n  spacesNoNew\n  return n\n\nidentQuoted :: Parser Text\nidentQuoted = do\n  quote <- oneOf \"'\\\"`\"\n  let p = satisfy (\\c -> c /= quote && not (isControl c) )\n            <?> \"any character except \" ++ [quote] ++ \" or control characters\"\n  n <- fmap pack (many1 p)\n  _ <- char quote\n  return n\n\nidentNoSpace :: Parser Text\nidentNoSpace = do\n  let p = satisfy (\\c -> c == '_' || isAlphaNum c)\n            <?> \"letter, digit or underscore\"\n  fmap pack (many1 p)\n\nemptiness :: Parser ()\nemptiness = skipMany (void (many1 space) <|> eolComment)\n\neolComment :: Parser ()\neolComment = spacesNoNew >> (eol <|> void comment)\n\nspacesNoNew :: Parser ()\nspacesNoNew = skipMany $ satisfy $ \\c -> c /= '\\n' && c /= '\\r' && isSpace c\n\neol :: Parser ()\neol = eof <|> do\n  c <- oneOf \"\\n\\r\"\n  when (c == '\\r') $ optional $ char '\\n'\n\n",
              "suggestions": [
                {
                  "location": "/tmp/project_91/pre_refactor/src/Text/Parsec/Erd/Parser.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Text.Parsec.Erd.Parser\n  ( AST(..),\n    GlobalOptions(..),\n    document,\n    globalOptions,\n    entity,\n    rel,\n    attr,\n    comment\n  ) where\n\nimport           Erd.ER\n\nimport           Control.Monad         (liftM2, void, when)\nimport           Data.Char             (isAlphaNum, isControl, isSpace)\nimport qualified Data.Map              as M\nimport           Data.Maybe\nimport           Data.Text.Lazy        hiding (elem)\nimport           Text.Parsec\nimport           Text.Parsec.Text.Lazy\nimport           Text.Printf           (printf)\n\ndata AST = E Entity\n    | A Attribute\n    | R Relation\n    deriving (Show, Eq)\n\ndata GlobalOptions = GlobalOptions\n    { gtoptions :: Options\n    , ghoptions :: Options\n    , geoptions :: Options\n    , groptions :: Options\n    }\n    deriving (Show, Eq)\n\nemptyGlobalOptions :: GlobalOptions\nemptyGlobalOptions = GlobalOptions M.empty M.empty M.empty M.empty\n\ndocument :: Parser (GlobalOptions, [AST])\ndocument = do skipMany (comment <|> blanks)\n              opts <- globalOptions emptyGlobalOptions\n              ast <-  catMaybes <$> manyTill top eof\n              return (opts, ast)\n  where top = (entity <?> \"entity declaration\")\n              <|> (try rel <?> \"relationship\") -- must come before attr\n              <|> (try attr <?> \"attribute\")\n              <|> (comment <?> \"comment\")\n              <|> blanks\n        blanks = many1 (space <?> \"whitespace\") >> return Nothing\n\nentity :: Parser (Maybe AST)\nentity = do n <- between (char '[') (char ']') ident\n            spacesNoNew\n            opts <- options\n            eolComment\n            return $ Just $ E Entity { name = n, attribs = [],\n                                       hoptions = opts, eoptions = opts }\n\nattr :: Parser (Maybe AST)\nattr = do\n  keys <- many $ oneOf \"*+ \\t\"\n  let (ispk, isfk) = ('*' `elem` keys, '+' `elem` keys)\n  n <- ident\n  opts <- options\n  eolComment\n  return\n    $ Just\n    $ A Attribute {field = n, pk = ispk, fk = isfk, aoptions = opts <> defaultAttrOpts}\n\nrel :: Parser (Maybe AST)\nrel = do\n  let ops = \"?1*+\"\n  e1 <- ident\n  op1 <- oneOf ops\n  _ <- string \"--\"\n  op2 <- oneOf ops\n  e2 <- ident\n  opts <- options\n  let getCard op =\n        case cardByName op of\n          Just t -> return t\n          Nothing -> unexpected (printf \"Cardinality '%s' does not exist.\" op)\n  t1 <- getCard op1\n  t2 <- getCard op2\n  return $ Just $ R Relation { entity1 = e1, entity2 = e2\n                             , card1 = t1, card2 = t2, roptions = opts }\n\nglobalOptions :: GlobalOptions -> Parser GlobalOptions\nglobalOptions gopts =\n  option gopts $ try $ do\n    n <- ident\n    opts <- options\n    case n of\n      \"title\"        -> emptiness >> globalOptions (gopts { gtoptions = opts})\n      \"header\"       -> emptiness >> globalOptions (gopts { ghoptions = opts})\n      \"entity\"       -> emptiness >> globalOptions (gopts { geoptions = opts})\n      \"relationship\" -> emptiness >> globalOptions (gopts { groptions = opts})\n      _ -> fail \"not a valid directive\"\n\noptions :: Parser (M.Map String Option)\noptions =\n  option M.empty\n    $ fmap M.fromList\n    $ try\n    $ between (char '{' >> emptiness) (emptiness >> char '}')\n    $ opt `sepEndBy` (emptiness >> char ',' >> emptiness)\n\nopt :: Parser (String, Option)\nopt = do\n  optName <- liftM2 (:) letter (manyTill (letter <|> char '-') (char ':'))\n          <?> \"option name\"\n  emptiness\n  value <- between (char '\"') (char '\"') (many $ noneOf \"\\\"\")\n           <?> \"option value\"\n  case optionByName optName value of\n    Left err -> fail err\n    Right o' -> emptiness >> return (optName, o')\n\ncomment :: Parser (Maybe AST)\ncomment = do\n  _ <- char '#'\n  _ <- manyTill anyChar $ try eol\n  return Nothing\n\nident :: Parser Text\nident = do\n  spacesNoNew\n  n <- identQuoted <|> identNoSpace\n  spacesNoNew\n  return n\n\nidentQuoted :: Parser Text\nidentQuoted = do\n  quote <- oneOf \"'\\\"`\"\n  let p = satisfy (\\c -> c /= quote && not (isControl c) )\n            <?> \"any character except \" ++ [quote] ++ \" or control characters\"\n  n <- fmap pack (many1 p)\n  _ <- char quote\n  return n\n\nidentNoSpace :: Parser Text\nidentNoSpace = do\n  let p = satisfy (\\c -> c == '_' || isAlphaNum c)\n            <?> \"letter, digit or underscore\"\n  fmap pack (many1 p)\n\nemptiness :: Parser ()\nemptiness = skipMany (void (many1 space) <|> eolComment)\n\neolComment :: Parser ()\neolComment = spacesNoNew >> (eol <|> void comment)\n\nspacesNoNew :: Parser ()\nspacesNoNew = skipMany $ satisfy $ \\c -> c /= '\\n' && c /= '\\r' && isSpace c\n\neol :: Parser ()\neol = eof <|> do\n  c <- oneOf \"\\n\\r\"\n  when (c == '\\r') $ optional $ char '\\n'\n\n"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 5,
              "max": 13,
              "average": 8.4,
              "sum": 42
            },
            "hlint_suggestions": {
              "error": 1,
              "warning": 0,
              "suggestion": 0,
              "ignore": 0,
              "total": 1
            },
            "syntax_errors": 34,
            "lines_of_code": 675,
            "homplexity_lines_of_code": 649,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_91/pre_refactor/app/Main.hs",
              "refactored_file_name": "/tmp/project_91/hybrid_refactored/app/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 6,
                "average": 2.1666666666666665,
                "sum": 13
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 127,
              "homplexity_lines_of_code": 169,
              "code_quality_score": 57.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 6,
                  "average": 2.1666666666666665,
                  "sum": 13
                },
                "homplexity_loc": 169,
                "homplexity_output": "Info:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 1 1: module Main has 98 lines of code \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 28 1: type signature for main has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 28 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 29 1: function main has 14 lines of code \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 29 1: function main has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 29 1: function main has cyclomatic complexity of 2 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 45 1: type signature for dotER has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 45 1: type signature for dotER has type constructor nesting of 1 \nWarning:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 46 1: function dotER has 38 lines of code should be kept below 20 lines of code.\nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 46 1: function dotER has cyclomatic complexity of 6 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 46 1: function dotER has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 94 1: type signature for htmlEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 94 1: type signature for htmlEntity has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 95 1: function htmlEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 95 1: function htmlEntity has 9 lines of code \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 95 1: function htmlEntity has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 107 1: type signature for dotEntity has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 107 1: type signature for dotEntity has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 108 1: function dotEntity has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 108 1: function dotEntity has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 108 1: function dotEntity has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 114 1: type signature for graphTitle has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 114 1: type signature for graphTitle has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 115 1: function graphTitle has 6 lines of code \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 115 1: function graphTitle has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 115 1: function graphTitle has cyclomatic complexity of 2 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 123 1: type signature for checkRequirements has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 123 1: type signature for checkRequirements has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 124 1: function checkRequirements has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 124 1: function checkRequirements has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/app/Main.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/app/Main.hs\" 124 1: function checkRequirements has 3 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n  (main)\nwhere\n\nimport           Control.Applicative                 ((<|>))\nimport           Control.Monad                       (forM_, guard)\nimport qualified Data.ByteString                     as SB\nimport           Data.Maybe                          (fromJust, fromMaybe)\nimport qualified Data.Text.Lazy                      as L\nimport           System.Exit                         (exitFailure)\nimport           System.IO                           (hClose, hPutStrLn, stderr)\n\nimport           Data.GraphViz\nimport qualified Data.GraphViz.Attributes.Colors.X11 as C\nimport qualified Data.GraphViz.Attributes.Complete   as A\nimport qualified Data.GraphViz.Attributes.HTML       as H\nimport qualified Data.GraphViz.Types.Generalised     as G\nimport           Data.GraphViz.Types.Monadic\n\nimport           Erd.Config\nimport           Erd.ER\nimport           Erd.Parse\nimport           Erd.Render                          (htmlAttr, htmlFont,\n                                                      recordAttr, withLabelFmt)\n\nmain :: IO ()\nmain = do\n  checkRequirements -- application may terminate here\n  conf <- configIO\n  er' <- uncurry loadER (cin conf)\n  case er' of\n    Left err -> do\n      hPutStrLn stderr err\n      exitFailure\n    Right er -> let erDot = dotER conf er\n                    toFile h = SB.hGetContents h >>= SB.hPut (snd $ cout conf)\n                    fmt = fromMaybe Pdf (outfmt conf)\n                 in graphvizWithHandle Dot erDot fmt toFile\n  hClose (snd $ cin conf)\n  hClose (snd $ cout conf)\n\n-- | Converts an entire ER-diagram from an ER file into a GraphViz graph.\ndotER :: Config -> ER -> G.DotGraph L.Text\ndotER conf er = graph' $ do\n  graphAttrs (graphTitle $ title er)\n  graphAttrs [ A.RankDir A.FromLeft\n             , A.Splines $ fromConfigOrDefault edgeType\n             ]\n  nodeAttrs nodeGlobalAttributes\n  edgeAttrs [ A.Color [A.toWC $ A.toColor C.Gray50] -- easier to read labels\n            , A.MinLen 2 -- give some breathing room\n            , A.Style [A.SItem (fromConfigOrDefault edgePattern) [] ]\n            ]\n  forM_ (entities er) $ \\e ->\n    node (name e) [entityFmt e]\n  forM_ (rels er) $ relToEdge (fromConfigOrDefault notation)\n    where\n      fromConfigOrDefault :: (Config -> Maybe a) -> a\n      fromConfigOrDefault opt = fromJust $ opt conf <|> opt defaultConfig\n      nodeGlobalAttributes\n        | fromConfigOrDefault dotentity = [shape Record, A.RankDir A.FromTop]\n        | otherwise = [shape PlainText] -- recommended for HTML labels\n      entityFmt\n        | fromConfigOrDefault dotentity = toLabel . dotEntity\n        | otherwise = toLabel . htmlEntity\n      relToEdge n r = edge (entity1 r) (entity2 r) (label:eAttr n)\n        where\n          optss = roptions r\n          labelOrXLabel =\n            case fromConfigOrDefault edgeType of\n              A.Ortho -> A.XLabel -- Graphivz recommends xlabels for ortho edges\n              _ -> A.Label\n          label =\n            labelOrXLabel . A.HtmlLabel . H.Text $ withLabelFmt \" %s \" optss []\n          (c1,c2) = (card1 r, card2 r)\n          eAttr UML = [A.TailLabel $ card2label c1\n                      ,A.HeadLabel $ card2label c2\n                      ]\n            where\n              card2label = A.HtmlLabel . H.Text . htmlFont optss . L.pack . show\n          eAttr IE = [A.Dir Both\n                     ,A.ArrowTail $ card2arr c1\n                     ,A.ArrowHead $ card2arr c2\n                     ]\n            where\n              card2arr ZeroOne  = A.AType [(A.openMod, A.DotArrow), (A.noMods, A.Tee)]\n              card2arr One      = A.AType [(A.noMods, A.Tee), (A.noMods, A.Tee)]\n              card2arr ZeroPlus = A.AType [(A.noMods, A.Crow), (A.openMod, A.DotArrow)]\n              card2arr OnePlus  = A.AType [(A.noMods, A.Crow), (A.noMods, A.Tee)]\n\n-- | Converts a single entity to an HTML label.\nhtmlEntity :: Entity -> H.Label\nhtmlEntity e = H.Table H.HTable\n                 { H.tableFontAttrs = Just $ optionsTo optToFont $ eoptions e\n                 , H.tableAttrs = optionsTo optToHtml (eoptions e)\n                 , H.tableRows = rows\n                 }\n  where rows = headerRow : map htmlAttr (attribs e)\n        headerRow = H.Cells [H.LabelCell [] $ H.Text text]\n        text = withLabelFmt \" [%s]\" (hoptions e) $ boldFont hname\n        hname = htmlFont (hoptions e) (name e)\n        boldFont s = [H.Format H.Bold s]\n\n-- | Converts a single entity to a plain Dot Label\ndotEntity :: Entity -> A.RecordFields\ndotEntity e =  A.FieldLabel ( name e ) : map recordAttr (attribs e)\n\n-- | Extracts and formats a graph title from the options given.\n-- The options should be title options from an ER value.\n-- If a title does not exist, an empty list is returned and `graphAttrs attrs`\n-- should be a no-op.\ngraphTitle :: Options -> [A.Attribute]\ngraphTitle topts =\n  let glabel = optionsTo optToLabel topts\n  in if null glabel then [] else\n       [ A.LabelJust A.JLeft\n       , A.LabelLoc A.VTop\n       , A.Label $ A.HtmlLabel $ H.Text $ htmlFont topts (head glabel)\n       ]\n\ncheckRequirements :: IO ()\ncheckRequirements = (isGraphvizInstalled >>= guard) <|> quitWithoutGraphviz msg\n  where\n    msg = \"GraphViz is not installed on your system.\\n\" ++\n          \"Please install it first, https://github.com/BurntSushi/erd\"\n",
              "suggestions": [
                {
                  "target_snippet": "fromJust $ opt conf <|> opt defaultConfig",
                  "refactored_suggestion": "fromMaybe (opt defaultConfig) (opt conf)",
                  "confidence": 0.9,
                  "justification": "Using `fromMaybe` instead of `fromJust` improves code safety by avoiding potential runtime errors if the `opt conf` results in `Nothing`."
                },
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- This part appears to be placeholder or incomplete, removing this snippet improves clarity",
                  "confidence": 0.8,
                  "justification": "The given part (`-- Manual candidate snippet`) does not serve any valid purpose and appears to be left as a placeholder for further development."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n  (main)\nwhere\n\nimport           Control.Applicative                 ((<|>))\nimport           Control.Monad                       (forM_, guard)\nimport qualified Data.ByteString                     as SB\nimport           Data.Maybe                          (fromJust, fromMaybe)\nimport qualified Data.Text.Lazy                      as L\nimport           System.Exit                         (exitFailure)\nimport           System.IO                           (hClose, hPutStrLn, stderr)\n\nimport           Data.GraphViz\nimport qualified Data.GraphViz.Attributes.Colors.X11 as C\nimport qualified Data.GraphViz.Attributes.Complete   as A\nimport qualified Data.GraphViz.Attributes.HTML       as H\nimport qualified Data.GraphViz.Types.Generalised     as G\nimport           Data.GraphViz.Types.Monadic\n\nimport           Erd.Config\nimport           Erd.ER\nimport           Erd.Parse\nimport           Erd.Render                          (htmlAttr, htmlFont,\n                                                      recordAttr, withLabelFmt)\n\nmain :: IO ()\nmain = do\n  checkRequirements -- application may terminate here\n  conf <- configIO\n  er' <- uncurry loadER (cin conf)\n  case er' of\n    Left err -> do\n      hPutStrLn stderr err\n      exitFailure\n    Right er -> let erDot = dotER conf er\n                    toFile h = SB.hGetContents h >>= SB.hPut (snd $ cout conf)\n                    fmt = fromMaybe Pdf (outfmt conf)\n                 in graphvizWithHandle Dot erDot fmt toFile\n  hClose (snd $ cin conf)\n  hClose (snd $ cout conf)\n\n-- | Converts an entire ER-diagram from an ER file into a GraphViz graph.\ndotER :: Config -> ER -> G.DotGraph L.Text\ndotER conf er = graph' $ do\n  graphAttrs (graphTitle $ title er)\n  graphAttrs [ A.RankDir A.FromLeft\n             , A.Splines $ fromConfigOrDefault edgeType\n             ]\n  nodeAttrs nodeGlobalAttributes\n  edgeAttrs [ A.Color [A.toWC $ A.toColor C.Gray50] -- easier to read labels\n            , A.MinLen 2 -- give some breathing room\n            , A.Style [A.SItem (fromConfigOrDefault edgePattern) [] ]\n            ]\n  forM_ (entities er) $ \\e ->\n    node (name e) [entityFmt e]\n  forM_ (rels er) $ relToEdge (fromConfigOrDefault notation)\n    where\n      fromConfigOrDefault :: (Config -> Maybe a) -> a\n      fromConfigOrDefault opt = fromMaybe (opt defaultConfig) (opt conf)\n      nodeGlobalAttributes\n        | fromConfigOrDefault dotentity = [shape Record, A.RankDir A.FromTop]\n        | otherwise = [shape PlainText] -- recommended for HTML labels\n      entityFmt\n        | fromConfigOrDefault dotentity = toLabel . dotEntity\n        | otherwise = toLabel . htmlEntity\n      relToEdge n r = edge (entity1 r) (entity2 r) (label:eAttr n)\n        where\n          optss = roptions r\n          labelOrXLabel =\n            case fromConfigOrDefault edgeType of\n              A.Ortho -> A.XLabel -- Graphivz recommends xlabels for ortho edges\n              _ -> A.Label\n          label =\n            labelOrXLabel . A.HtmlLabel . H.Text $ withLabelFmt \" %s \" optss []\n          (c1,c2) = (card1 r, card2 r)\n          eAttr UML = [A.TailLabel $ card2label c1\n                      ,A.HeadLabel $ card2label c2\n                      ]\n            where\n              card2label = A.HtmlLabel . H.Text . htmlFont optss . L.pack . show\n          eAttr IE = [A.Dir Both\n                     ,A.ArrowTail $ card2arr c1\n                     ,A.ArrowHead $ card2arr c2\n                     ]\n            where\n              card2arr ZeroOne  = A.AType [(A.openMod, A.DotArrow), (A.noMods, A.Tee)]\n              card2arr One      = A.AType [(A.noMods, A.Tee), (A.noMods, A.Tee)]\n              card2arr ZeroPlus = A.AType [(A.noMods, A.Crow), (A.openMod, A.DotArrow)]\n              card2arr OnePlus  = A.AType [(A.noMods, A.Crow), (A.noMods, A.Tee)]\n\n-- | Converts a single entity to an HTML label.\nhtmlEntity :: Entity -> H.Label\nhtmlEntity e = H.Table H.HTable\n                 { H.tableFontAttrs = Just $ optionsTo optToFont $ eoptions e\n                 , H.tableAttrs = optionsTo optToHtml (eoptions e)\n                 , H.tableRows = rows\n                 }\n  where rows = headerRow : map htmlAttr (attribs e)\n        headerRow = H.Cells [H.LabelCell [] $ H.Text text]\n        text = withLabelFmt \" [%s]\" (hoptions e) $ boldFont hname\n        hname = htmlFont (hoptions e) (name e)\n        boldFont s = [H.Format H.Bold s]\n\n-- | Converts a single entity to a plain Dot Label\ndotEntity :: Entity -> A.RecordFields\ndotEntity e =  A.FieldLabel ( name e ) : map recordAttr (attribs e)\n\n-- | Extracts and formats a graph title from the options given.\n-- The options should be title options from an ER value.\n-- If a title does not exist, an empty list is returned and `graphAttrs attrs`\n-- should be a no-op.\ngraphTitle :: Options -> [A.Attribute]\ngraphTitle topts =\n  let glabel = optionsTo optToLabel topts\n  in if null glabel then [] else\n       [ A.LabelJust A.JLeft\n       , A.LabelLoc A.VTop\n       , A.Label $ A.HtmlLabel $ H.Text $ htmlFont topts (head glabel)\n       ]\n\ncheckRequirements :: IO ()\ncheckRequirements = (isGraphvizInstalled >>= guard) <|> quitWithoutGraphviz msg\n  where\n    msg = \"GraphViz is not installed on your system.\\n\" ++\n          \"Please install it first, https://github.com/BurntSushi/erd\"\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/test/Test/Erd/Render.hs",
              "refactored_file_name": "/tmp/project_91/hybrid_refactored/test/Test/Erd/Render.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 25,
              "homplexity_lines_of_code": 25,
              "code_quality_score": 93.5,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1,
                  "sum": 2
                },
                "homplexity_loc": 25,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"testRender\": 1,\n    \"test01\": 1,\n    \"min\": 1,\n    \"max\": 1,\n    \"average\": 1,\n    \"sum\": 2\n  },\n  \"homplexity_loc\": 25,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Erd.Render\n  (testRender)\nwhere\n\nimport qualified Erd.ER                        as ER\nimport           Erd.Render                    (htmlAttr)\n\nimport qualified Data.GraphViz.Attributes.HTML as H\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntestRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n                                                 ]\ntest01 :: Assertion\ntest01 = result @?= expected\n  where\n    inputF   = \"Field\"\n    input    = ER.Attribute inputF True False ER.defaultAttrOpts\n    result   = htmlAttr input\n    expected = H.Cells [H.LabelCell [H.Align H.HLeft]\n                        (H.Text [H.Format H.Underline [H.Font [] [H.Str inputF]]])]\n",
              "suggestions": [
                {
                  "target_snippet": "testRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n                                                 ]",
                  "refactored_suggestion": "testRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n]",
                  "confidence": 0.95,
                  "justification": "The trailing white space and unnecessary newline before the closing bracket can be removed for better readability and cleaner code formatting."
                },
                {
                  "target_snippet": "-- reason",
                  "refactored_suggestion": "-- There is no dead or unused code detected in the provided file. All code elements are in active use.",
                  "confidence": 1.0,
                  "justification": "No part of the code appears to be unused or unnecessary. Each piece supports the primary function of converting `ER.Attribute` into an HTML attribute and its associated test case."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Erd.Render\n  (testRender)\nwhere\n\nimport qualified Erd.ER                        as ER\nimport           Erd.Render                    (htmlAttr)\n\nimport qualified Data.GraphViz.Attributes.HTML as H\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntestRender :: TestTree\ntestRender = testGroup \"Test of main-module\" [\n  testCase \"Transform Erd field-attribute to HTML of GraphViz.\" test01\n]\ntest01 :: Assertion\ntest01 = result @?= expected\n  where\n    inputF   = \"Field\"\n    input    = ER.Attribute inputF True False ER.defaultAttrOpts\n    result   = htmlAttr input\n    expected = H.Cells [H.LabelCell [H.Align H.HLeft]\n                        (H.Text [H.Format H.Underline [H.Font [] [H.Str inputF]]])]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/test/Test/Text/Parsec/Erd/Parser.hs",
              "refactored_file_name": "/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 6
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 277,
              "homplexity_lines_of_code": 233,
              "code_quality_score": 64.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 6
                },
                "homplexity_loc": 233,
                "homplexity_output": "Info:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 1 1: module Test.Text.Parsec.Erd.Parser has 128 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 22 1: type signature for parseDoc has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 23 1: function parseDoc has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 25 1: type signature for testEr has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 25 1: type signature for testEr has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: function testEr has 3 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: function testEr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 26 1: function testEr has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 32 1: type signature for simpleText has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 32 1: type signature for simpleText has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: function simpleText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: function simpleText has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 33 1: function simpleText has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 62 1: type signature for simpleResult has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 62 1: type signature for simpleResult has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: function simpleResult has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: function simpleResult has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 63 1: function simpleResult has 15 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 79 1: type signature for nfldbText has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 79 1: type signature for nfldbText has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: function nfldbText has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: function nfldbText has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 80 1: function nfldbText has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for nfldbResult has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 177 1: type signature for nfldbResult has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function nfldbResult has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function nfldbResult has branching depth of 0 \nCritical:/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/test/Test/Text/Parsec/Erd/Parser.hs\" 178 1: function nfldbResult has 84 lines of code this function exceeds 40 lines of code.\n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n\nmodule Test.Text.Parsec.Erd.Parser\n  (testEr\n  ) where\n\nimport           Data.GraphViz.Attributes.Colors (Color (..))\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.Map                        (fromList)\nimport qualified Data.Map                        as M\nimport           Data.Text                       (Text)\nimport           Data.Text.Lazy                  (fromStrict)\nimport           Erd.ER\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Text.Parsec                     (parse)\nimport           Text.Parsec.Erd.Parser          (AST (..), GlobalOptions (..),\n                                                  document)\nimport           Text.RawString.QQ               (r)\n\nparseDoc :: Text -> (GlobalOptions, [AST]) -> Assertion\nparseDoc input expect= Right expect `shouldBe` parse document \"\" (fromStrict input) where\n  shouldBe = assertEqual \"\"\n\ntestEr :: TestTree\ntestEr = testGroup \"Parse Er\" [\n  testCase \"Parse Simple case\" $ parseDoc simpleText simpleResult,\n  testCase \"Parse nfldb case\" $ parseDoc nfldbText nfldbResult\n                              ]\n\n\nsimpleText :: Text\nsimpleText = [r|\n# Entities are declared in '[' ... ']'. All attributes after the entity header\n# up until the end of the file (or the next entity declaration) correspond\n# to this entity.\n[Person]\n*name\nheight\nweight\n`birth date`\n+birth_place_id\n\n[`Birth Place`]\n*id\n`birth city`\n'birth state'\n\"birth country\"\n\n# Each relationship must be between exactly two entities, which need not\n# be distinct. Each entity in the relationship has exactly one of four\n# possible cardinalities:\n#\n# Cardinality    Syntax\n# 0 or 1         ?\n# exactly 1      1\n# 0 or more      *\n# 1 or more      +\nPerson *--1 `Birth Place`\n|]\n\nsimpleResult :: (GlobalOptions, [AST])\nsimpleResult = (opts, asts) where\n  opts = GlobalOptions M.empty M.empty M.empty M.empty\n  asts = [\n    E (Entity {name = \"Person\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"name\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"height\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"weight\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth date\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth_place_id\", pk = False, fk = True, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    E (Entity {name = \"Birth Place\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"id\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth city\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth state\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth country\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    R (Relation {entity1 = \"Person\", entity2 = \"Birth Place\", card1 = ZeroPlus , card2 = One, roptions = M.empty})]\n\nnfldbText :: Text\nnfldbText = [r|\ntitle {label: \"nfldb Entity-Relationship diagram (condensed)\", size: \"20\"}\n\n# Nice colors from Erwiz:\n# red #fcecec\n# blue #ececfc\n# green #d0e0d0\n# yellow #fbfbdb\n# orange #eee0a0\n\n# Entities\n\n[player] {bgcolor: \"#d0e0d0\"}\n  *player_id {label: \"varchar, not null\"}\n  full_name {label: \"varchar, null\"}\n  team {label: \"varchar, not null\"}\n  position {label: \"player_pos, not null\"}\n  status {label: \"player_status, not null\"}\n\n[team] {bgcolor: \"#d0e0d0\"}\n  *team_id {label: \"varchar, not null\"}\n  city {label: \"varchar, not null\"}\n  name {label: \"varchar, not null\"}\n\n[game] {bgcolor: \"#ececfc\"}\n  *gsis_id {label: \"gameid, not null\"}\n  start_time {label: \"utctime, not null\"}\n  week {label: \"usmallint, not null\"}\n  season_year {label: \"usmallint, not null\"}\n  season_type {label: \"season_phase, not null\"}\n  finished {label: \"boolean, not null\"}\n  home_team {label: \"varchar, not null\"}\n  home_score {label: \"usmallint, not null\"}\n  away_team {label: \"varchar, not null\"}\n  away_score {label: \"usmallint, not null\"}\n\n[drive] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *drive_id {label: \"usmallint, not null\"}\n  start_field {label: \"field_pos, null\"}\n  start_time {label: \"game_time, not null\"}\n  end_field {label: \"field_pos, null\"}\n  end_time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  pos_time {label: \"pos_period, null\"}\n\n[play] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *play_id {label: \"usmallint, not null\"}\n  time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  yardline {label: \"field_pos, null\"}\n  down {label: \"smallint, null\"}\n  yards_to_go {label: \"smallint, null\"}\n\n[play_player] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *+play_id {label: \"usmallint, not null\"}\n  *+player_id {label: \"varchar, not null\"}\n  team {label: \"varchar, not null\"}\n\n[meta] {bgcolor: \"#fcecec\"}\n  version {label: \"smallint, null\"}\n  season_type {label: \"season_phase, null\"}\n  season_year {label: \"usmallint, null\"}\n  week {label: \"usmallint, null\"}\n\n# Relationships\n\nplayer      *--1 team\ngame        *--1 team {label: \"home\"}\ngame        *--1 team {label: \"away\"}\ndrive       *--1 team\nplay        *--1 team\nplay_player *--1 team\n\ngame        1--* drive\ngame        1--* play\ngame        1--* play_player\n\ndrive       1--* play\ndrive       1--* play_player\n\nplay        1--* play_player\n\nplayer      1--* play_player\n|]\n\n\ndata ChunckAST = CE [Entity]\n    | CA [Attribute]\n    | CR [Relation]\n    deriving (Eq)\n\ntoAST :: ChunckAST -> [AST]\ntoAST (CE x) = map E x\ntoAST (CA x) = map A x\ntoAST (CR x) = map R x\n\nnfldbResult :: (GlobalOptions, [AST])\nnfldbResult = (opts, asts) where\n  opts = GlobalOptions {gtoptions = fromList [(\"label\",Label \"nfldb Entity-Relationship diagram (condensed)\"),(\"size\",FontSize 20.0)], ghoptions = M.empty, geoptions = M.empty, groptions = M.empty}\n  asts = concatMap toAST $ es:(attributes ++ [relations])\n  es = CE [\n    Entity {name = \"player\", attribs = [],\n      hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))],\n      eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]\n           }\n    ]\n  attributes = [\n    CA [\n        Attribute {field = \"player_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"full_name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"position\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_pos, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"status\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_status, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"team\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]}\n      ],\n    CA [\n        Attribute {field = \"team_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"city\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"game\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"utctime, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"finished\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"boolean, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"drive\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"pos_period, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yardline\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"down\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yards_to_go\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play_player\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"player_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n     ],\n     CE [\n        Entity {name = \"meta\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))]}\n       ],\n    CA [\n        Attribute {field = \"version\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ]\n    ]\n  relations = CR [\n     Relation {entity1 = \"player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"home\")]},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"away\")]},\n     Relation {entity1 = \"drive\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play_player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"drive\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"player\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty} ]\n",
              "suggestions": [
                {
                  "target_snippet": "parseDoc input expect= Right expect `shouldBe` parse document \"\" (fromStrict input) where\n  shouldBe = assertEqual \"\"",
                  "refactored_suggestion": "parseDoc input expect = Right expect @?= parse document \"\" (fromStrict input)",
                  "confidence": 0.9,
                  "justification": "Using the `@?=` operator for assertion from `Test.Tasty.HUnit` simplifies the `parseDoc` function, removes the redundant `shouldBe` definition, and improves readability."
                },
                {
                  "target_snippet": "data ChunckAST = CE [Entity]\n    | CA [Attribute]\n    | CR [Relation]\n    deriving (Eq)",
                  "refactored_suggestion": "-- Removed unused ChunckAST data type.\n-- Reason: ChunckAST is defined but never used in the code, and removing it declutters the codebase for better maintainability.",
                  "confidence": 1.0,
                  "justification": "The `ChunckAST` type and associated `toAST` function are not used anywhere in the code. Removing dead/unneeded code enhances maintainability and reduces cognitive overhead."
                },
                {
                  "target_snippet": "toAST :: ChunckAST -> [AST]\ntoAST (CE x) = map E x\ntoAST (CA x) = map A x\ntoAST (CR x) = map R x",
                  "refactored_suggestion": "-- Removed unused toAST function.\n-- Reason: toAST is dependent on the ChunckAST data type, which is unused in the codebase, and thus the function has no effect.",
                  "confidence": 1.0,
                  "justification": "The `toAST` function is only used to manipulate the unused `ChunckAST`. Keeping it in the code without the relevant data type produces unclean and unmaintainable code."
                },
                {
                  "target_snippet": "Found\n-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- No action needed as no refinements or corrections are specified in this suggestion.",
                  "confidence": 0.0,
                  "justification": "The provided manual candidate snippet does not mention any actual improvement or precise refactoring suggestion and hence does not warrant any changes."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes       #-}\n\nmodule Test.Text.Parsec.Erd.Parser\n  (testEr\n  ) where\n\nimport           Data.GraphViz.Attributes.Colors (Color (..))\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.Map                        (fromList)\nimport qualified Data.Map                        as M\nimport           Data.Text                       (Text)\nimport           Data.Text.Lazy                  (fromStrict)\nimport           Erd.ER\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Text.Parsec                     (parse)\nimport           Text.Parsec.Erd.Parser          (AST (..), GlobalOptions (..),\n                                                  document)\nimport           Text.RawString.QQ               (r)\n\nparseDoc :: Text -> (GlobalOptions, [AST]) -> Assertion\nparseDoc input expect = Right expect @?= parse document \"\" (fromStrict input)\n\ntestEr :: TestTree\ntestEr = testGroup \"Parse Er\" [\n  testCase \"Parse Simple case\" $ parseDoc simpleText simpleResult,\n  testCase \"Parse nfldb case\" $ parseDoc nfldbText nfldbResult\n                              ]\n\n\nsimpleText :: Text\nsimpleText = [r|\n# Entities are declared in '[' ... ']'. All attributes after the entity header\n# up until the end of the file (or the next entity declaration) correspond\n# to this entity.\n[Person]\n*name\nheight\nweight\n`birth date`\n+birth_place_id\n\n[`Birth Place`]\n*id\n`birth city`\n'birth state'\n\"birth country\"\n\n# Each relationship must be between exactly two entities, which need not\n# be distinct. Each entity in the relationship has exactly one of four\n# possible cardinalities:\n#\n# Cardinality    Syntax\n# 0 or 1         ?\n# exactly 1      1\n# 0 or more      *\n# 1 or more      +\nPerson *--1 `Birth Place`\n|]\n\nsimpleResult :: (GlobalOptions, [AST])\nsimpleResult = (opts, asts) where\n  opts = GlobalOptions M.empty M.empty M.empty M.empty\n  asts = [\n    E (Entity {name = \"Person\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"name\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"height\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"weight\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth date\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth_place_id\", pk = False, fk = True, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    E (Entity {name = \"Birth Place\", attribs = [], hoptions = M.empty, eoptions = M.empty}),\n    A (Attribute {field = \"id\", pk = True, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth city\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth state\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    A (Attribute {field = \"birth country\", pk = False, fk = False, aoptions = fromList [(\"text-alignment\",TextAlignment H.HLeft)]}),\n    R (Relation {entity1 = \"Person\", entity2 = \"Birth Place\", card1 = ZeroPlus , card2 = One, roptions = M.empty})]\n\nnfldbText :: Text\nnfldbText = [r|\ntitle {label: \"nfldb Entity-Relationship diagram (condensed)\", size: \"20\"}\n\n# Nice colors from Erwiz:\n# red #fcecec\n# blue #ececfc\n# green #d0e0d0\n# yellow #fbfbdb\n# orange #eee0a0\n\n# Entities\n\n[player] {bgcolor: \"#d0e0d0\"}\n  *player_id {label: \"varchar, not null\"}\n  full_name {label: \"varchar, null\"}\n  team {label: \"varchar, not null\"}\n  position {label: \"player_pos, not null\"}\n  status {label: \"player_status, not null\"}\n\n[team] {bgcolor: \"#d0e0d0\"}\n  *team_id {label: \"varchar, not null\"}\n  city {label: \"varchar, not null\"}\n  name {label: \"varchar, not null\"}\n\n[game] {bgcolor: \"#ececfc\"}\n  *gsis_id {label: \"gameid, not null\"}\n  start_time {label: \"utctime, not null\"}\n  week {label: \"usmallint, not null\"}\n  season_year {label: \"usmallint, not null\"}\n  season_type {label: \"season_phase, not null\"}\n  finished {label: \"boolean, not null\"}\n  home_team {label: \"varchar, not null\"}\n  home_score {label: \"usmallint, not null\"}\n  away_team {label: \"varchar, not null\"}\n  away_score {label: \"usmallint, not null\"}\n\n[drive] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *drive_id {label: \"usmallint, not null\"}\n  start_field {label: \"field_pos, null\"}\n  start_time {label: \"game_time, not null\"}\n  end_field {label: \"field_pos, null\"}\n  end_time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  pos_time {label: \"pos_period, null\"}\n\n[play] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *play_id {label: \"usmallint, not null\"}\n  time {label: \"game_time, not null\"}\n  pos_team {label: \"varchar, not null\"}\n  yardline {label: \"field_pos, null\"}\n  down {label: \"smallint, null\"}\n  yards_to_go {label: \"smallint, null\"}\n\n[play_player] {bgcolor: \"#ececfc\"}\n  *+gsis_id {label: \"gameid, not null\"}\n  *+drive_id {label: \"usmallint, not null\"}\n  *+play_id {label: \"usmallint, not null\"}\n  *+player_id {label: \"varchar, not null\"}\n  team {label: \"varchar, not null\"}\n\n[meta] {bgcolor: \"#fcecec\"}\n  version {label: \"smallint, null\"}\n  season_type {label: \"season_phase, null\"}\n  season_year {label: \"usmallint, null\"}\n  week {label: \"usmallint, null\"}\n\n# Relationships\n\nplayer      *--1 team\ngame        *--1 team {label: \"home\"}\ngame        *--1 team {label: \"away\"}\ndrive       *--1 team\nplay        *--1 team\nplay_player *--1 team\n\ngame        1--* drive\ngame        1--* play\ngame        1--* play_player\n\ndrive       1--* play\ndrive       1--* play_player\n\nplay        1--* play_player\n\nplayer      1--* play_player\n|]\n\n\n-- Removed unused ChunckAST data type.\n-- Reason: ChunckAST is defined but never used in the code, and removing it declutters the codebase for better maintainability.\n\n-- Removed unused toAST function.\n-- Reason: toAST is dependent on the ChunckAST data type, which is unused in the codebase, and thus the function has no effect.\n\nnfldbResult :: (GlobalOptions, [AST])\nnfldbResult = (opts, asts) where\n  opts = GlobalOptions {gtoptions = fromList [(\"label\",Label \"nfldb Entity-Relationship diagram (condensed)\"),(\"size\",FontSize 20.0)], ghoptions = M.empty, geoptions = M.empty, groptions = M.empty}\n  asts = concatMap toAST $ es:(attributes ++ [relations])\n  es = CE [\n    Entity {name = \"player\", attribs = [],\n      hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))],\n      eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]\n           }\n    ]\n  attributes = [\n    CA [\n        Attribute {field = \"player_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"full_name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"position\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_pos, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"status\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"player_status, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"team\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 208, green = 224, blue = 208}))]}\n      ],\n    CA [\n        Attribute {field = \"team_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"city\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"name\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"game\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"utctime, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"finished\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"boolean, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"home_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"away_score\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"drive\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"start_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_field\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"end_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"pos_period, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"time\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"game_time, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"pos_team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yardline\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"field_pos, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"down\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"yards_to_go\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ],\n    CE [\n        Entity {name = \"play_player\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 236, green = 236, blue = 252}))]}\n      ],\n    CA [\n        Attribute {field = \"gsis_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"gameid, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"drive_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"play_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"usmallint, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"player_id\", pk = True, fk = True, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"team\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"varchar, not null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n     ],\n     CE [\n        Entity {name = \"meta\", attribs = [], hoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))], eoptions = fromList [(\"bgcolor\",BgColor (RGB {red = 252, green = 236, blue = 236}))]}\n       ],\n    CA [\n        Attribute {field = \"version\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"smallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_type\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"season_phase, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"season_year\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]},\n        Attribute {field = \"week\", pk = False, fk = False, aoptions = fromList [(\"label\",Label \"usmallint, null\"),(\"text-alignment\",TextAlignment H.HLeft)]}\n      ]\n    ]\n  relations = CR [\n     Relation {entity1 = \"player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"home\")]},\n     Relation {entity1 = \"game\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = fromList [(\"label\",Label \"away\")]},\n     Relation {entity1 = \"drive\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"play_player\", entity2 = \"team\", card1 = ZeroPlus, card2 = One, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"drive\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"game\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"drive\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"play\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty},\n     Relation {entity1 = \"player\", entity2 = \"play_player\", card1 = One, card2 = ZeroPlus, roptions = M.empty} ]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/ER.hs",
              "refactored_file_name": "/tmp/project_91/hybrid_refactored/src/Erd/ER.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 2,
                "average": 1.0769230769230769,
                "sum": 14
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 5,
              "lines_of_code": 202,
              "homplexity_lines_of_code": 181,
              "code_quality_score": 53.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 2,
                  "average": 1.0769230769230769,
                  "sum": 14
                },
                "homplexity_loc": 181,
                "homplexity_output": "Info:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 1 1: module Erd.ER has 130 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 24 11: data ER has record fields count of 3 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 32 15: data Entity has record fields count of 4 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 44 18: data Attribute has record fields count of 4 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 64 1: type signature for mergeOpts has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 65 1: function mergeOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 70 1: type signature for optionsTo has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 70 1: type signature for optionsTo has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 71 1: function optionsTo has cyclomatic complexity of 1 \nCritical:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 75 15: data Option has record fields count of 11 must never reach 9\nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 92 1: type signature for optionByName has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 92 1: type signature for optionByName has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 93 1: function optionByName has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 93 1: function optionByName has 12 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 93 1: function optionByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 107 1: type signature for optionParse has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 107 1: type signature for optionParse has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 108 1: function optionParse has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 108 1: function optionParse has 5 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 108 1: function optionParse has cyclomatic complexity of 2 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 115 1: type signature for optToFont has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 115 1: type signature for optToFont has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 116 1: function optToFont has 4 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 116 1: function optToFont has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 116 1: function optToFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 123 1: type signature for optToHtml has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 123 1: type signature for optToHtml has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has 8 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 124 1: function optToHtml has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 135 1: type signature for optToLabel has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 135 1: type signature for optToLabel has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has 2 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 136 1: function optToLabel has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 145 17: data Relation has record fields count of 3 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 152 20: data Cardinality has record fields count of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 165 1: type signature for cardByName has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 165 1: type signature for cardByName has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 166 1: function cardByName has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 166 1: function cardByName has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 166 1: function cardByName has 5 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 173 1: type signature for defaultTitleOpts has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has 2 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 174 1: function defaultTitleOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 179 1: type signature for defaultHeaderOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has 2 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 180 1: function defaultHeaderOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 185 1: type signature for defaultEntityOpts has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has 6 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 186 1: function defaultEntityOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 195 1: type signature for defaultRelOpts has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 197 1: function defaultRelOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 197 1: function defaultRelOpts has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 197 1: function defaultRelOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 199 1: type signature for defaultAttrOpts has 1 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 199 1: type signature for defaultAttrOpts has type constructor nesting of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 200 1: function defaultAttrOpts has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 200 1: function defaultAttrOpts has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/ER.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/ER.hs\" 200 1: function defaultAttrOpts has 2 lines of code \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.ER\n  ( ER(..)\n  , Entity(..)\n  , Attribute(..)\n  , Options, mergeOpts, optionsTo\n  , Option(..), optionByName, optToFont, optToHtml, optToLabel\n  , Relation(..) , Cardinality(..), cardByName\n  , defaultAttrOpts, defaultTitleOpts, defaultEntityOpts, defaultHeaderOpts, defaultRelOpts\n  )\nwhere\n\nimport qualified Data.Map                        as M\nimport           Data.Maybe                      (mapMaybe)\nimport           Data.Text.Lazy\nimport           Data.Word                       (Word8)\nimport           Text.Printf                     (printf)\n\nimport           Data.GraphViz.Attributes.Colors (Color)\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.GraphViz.Parsing           (ParseDot, parse, runParser)\n\n-- | Represents a single schema.\ndata ER = ER\n    { entities :: [Entity]\n    , rels     :: [Relation]\n    , title    :: Options\n    }\n    deriving (Show, Eq)\n\n-- | Represents a single entity in a schema.\ndata Entity = Entity\n    { name     :: Text\n    , attribs  :: [Attribute]\n    , hoptions :: Options\n    , eoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Entity where\n  e1 `compare` e2 = name e1 `compare` name e2\n\n-- | Represents a single attribute in a particular entity.\ndata Attribute = Attribute\n    { field    :: Text\n    , pk       :: Bool\n    , fk       :: Bool\n    , aoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Attribute where\n  a1 `compare` a2 = field a1 `compare` field a2\n\n-- | Represents any number of options for an item in an ER diagram.\n-- An item may be the graph title, an entity, an entity header or a\n-- relationship between entities. Keys are options as specified in ER files.\n--\n-- Note that a set of options may include a label for any item.\ntype Options = M.Map String Option\n\n-- | Given two sets of options, merge the second into first, where elements\n-- in the first take precedence.\nmergeOpts :: Options -> Options -> Options\nmergeOpts opts1 opts2 = opts1 `M.union` opts2\n\n-- | Given a set of options and a selector function, return the list of\n-- only those options which matched. Examples of the selector function are\n-- `optToFont`, `optToHtml` and `optToLabel`.\noptionsTo :: (Option -> Maybe a) -> Options -> [a]\noptionsTo f = mapMaybe f . M.elems\n\n-- | A restricted subset of options in GraphViz that can be configured in\n-- an ER file.\ndata Option = Label String\n    | BgColor Color\n    | Color Color\n    | FontFace Text\n    | FontSize Double\n    | Border Word8\n    | BorderColor Color\n    | CellSpacing Word8\n    | CellBorder Word8\n    | CellPadding Word8\n    | TextAlignment H.Align\n    deriving (Show, Eq)\n\n-- | Given an option name and a string representation of its value,\n-- `optionByName` will attempt to parse the string as a value corresponding\n-- to the option. If the option doesn't exist or there was a problem parsing\n-- the value, an error is returned.\noptionByName :: String -> String -> Either String Option\noptionByName \"label\" = Right . Label\noptionByName \"color\" = optionParse Color\noptionByName \"bgcolor\" = optionParse BgColor\noptionByName \"size\" = optionParse FontSize\noptionByName \"font\" = optionParse FontFace\noptionByName \"border\" = optionParse Border\noptionByName \"border-color\" = optionParse BorderColor\noptionByName \"cellspacing\" = optionParse CellSpacing\noptionByName \"cellborder\" = optionParse CellBorder\noptionByName \"cellpadding\" = optionParse CellPadding\noptionByName \"text-alignment\" = optionParse TextAlignment\noptionByName unk = const (Left $ printf \"Option '%s' does not exist.\" unk)\n\n-- | A wrapper around the GraphViz's parser for any particular option.\noptionParse :: ParseDot a => (a -> Option) -> String -> Either String Option\noptionParse con s =\n  case fst $ runParser parse quoted of\n    Left err -> Left (printf \"%s (bad value '%s')\" err s)\n    Right a  -> Right (con a)\n  where quoted = \"\\\"\" `append` pack s `append` \"\\\"\"\n\n-- | Selects an option if and only if it corresponds to a font attribute.\noptToFont :: Option -> Maybe H.Attribute\noptToFont (Color c)    = Just $ H.Color c\noptToFont (FontFace s) = Just $ H.Face s\noptToFont (FontSize d) = Just $ H.PointSize d\noptToFont _            = Nothing\n\n-- | Selects an option if and only if it corresponds to an HTML attribute.\n-- In particular, for tables or table cells.\noptToHtml :: Option -> Maybe H.Attribute\noptToHtml (BgColor c)       = pure $ H.BGColor c\noptToHtml (Border w)        = pure $ H.Border w\noptToHtml (BorderColor c)   = pure $ H.Color c\noptToHtml (CellSpacing w)   = pure $ H.CellSpacing w\noptToHtml (CellBorder w)    = pure $ H.CellBorder w\noptToHtml (CellPadding w)   = pure $ H.CellPadding w\noptToHtml (TextAlignment x) = pure $ H.Align x\noptToHtml _                 = Nothing\n\n\n-- | Selects an option if and only if it corresponds to a label.\noptToLabel :: Option -> Maybe Text\noptToLabel (Label s) = Just $ pack s\noptToLabel _         = Nothing\n\n-- | Represents a relationship between exactly two entities. After parsing,\n-- each `rel` is guaranteed to correspond to an entity defined in the same\n-- ER file.\n--\n-- Each relationship has one of four cardinalities specified for both entities.\n-- Those cardinalities are: 0 or 1, exactly 1, 0 or more and 1 or more.\ndata Relation = Relation\n    { entity1, entity2 :: Text\n    , card1, card2     :: Cardinality\n    , roptions         :: Options\n    }\n    deriving (Show, Eq)\n\ndata Cardinality = ZeroOne\n    | One\n    | ZeroPlus\n    | OnePlus\n    deriving (Eq)\n\ninstance Show Cardinality where\n  show ZeroOne  = \"{0,1}\"\n  show One      = \"1\"\n  show ZeroPlus = \"0..N\"\n  show OnePlus  = \"1..N\"\n\n-- | Maps a string representation to a particular relationship cardinality.\ncardByName :: Char -> Maybe Cardinality\ncardByName '?' = Just ZeroOne\ncardByName '1' = Just One\ncardByName '*' = Just ZeroPlus\ncardByName '+' = Just OnePlus\ncardByName _   = Nothing\n\n-- | Hard-coded default options for all graph titles.\ndefaultTitleOpts :: Options\ndefaultTitleOpts = M.fromList\n  [ (\"size\", FontSize 30)\n  ]\n\n-- | Hard-coded default options for all entity headers.\ndefaultHeaderOpts :: Options\ndefaultHeaderOpts = M.fromList\n  [ (\"size\", FontSize 16)\n  ]\n\n-- | Hard-coded default options for all entities.\ndefaultEntityOpts :: Options\ndefaultEntityOpts = M.fromList\n  [ (\"border\", Border 0)\n  , (\"cellborder\", CellBorder 1)\n  , (\"cellspacing\", CellSpacing 0)\n  , (\"cellpadding\", CellPadding 4)\n  , (\"font\", FontFace \"Helvetica\")\n  ]\n\n-- | Hard-coded default options for all relationships.\ndefaultRelOpts :: Options\ndefaultRelOpts = M.empty\n\ndefaultAttrOpts :: Options\ndefaultAttrOpts = M.fromList\n  [ (\"text-alignment\", TextAlignment H.HLeft)\n  ]\n",
              "suggestions": [
                {
                  "target_snippet": "-- Manual candidate snippet\nPerhaps",
                  "refactored_suggestion": "-- Removed as there are no suggestions in this section and it appears to be placeholder comments",
                  "confidence": 1.0,
                  "justification": "The snippet given does not add any functional value and appears to be a stub or placeholder comment. Removing this makes the code cleaner and more professional."
                },
                {
                  "target_snippet": "optionByName unk = const (Left $ printf \"Option '%s' does not exist.\" unk)",
                  "refactored_suggestion": "optionByName unk = const (Left $ printf \"Unsupported option '%s'.\" unk)",
                  "confidence": 0.9,
                  "justification": "The original error message could be reworded for better clarity. The updated error message uses 'Unsupported option' for improved user understanding while maintaining the original functionality."
                },
                {
                  "target_snippet": "defaultRelOpts = M.empty",
                  "refactored_suggestion": "-- defaultRelOpts is defined as an empty map. Consider removing if not used actively.\ndefaultRelOpts = M.empty",
                  "confidence": 0.8,
                  "justification": "The empty map `defaultRelOpts` is defined, but its usage is not evident within the current scope of the module. If unused, consider removing it for cleaner code."
                },
                {
                  "target_snippet": "instance Ord Attribute where\n  a1 `compare` a2 = field a1 `compare` field a2",
                  "refactored_suggestion": "instance Ord Attribute where\n  compare = comparing field",
                  "confidence": 1.0,
                  "justification": "The `compare` implementation can be simplified by using `comparing` from `Data.Ord`. This makes the code cleaner and easier to read."
                },
                {
                  "target_snippet": "instance Ord Entity where\n  e1 `compare` e2 = name e1 `compare` name e2",
                  "refactored_suggestion": "instance Ord Entity where\n  compare = comparing name",
                  "confidence": 1.0,
                  "justification": "The `compare` implementation can be simplified by using `comparing` from `Data.Ord`. This leads to more concise and readable code."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\nmodule Erd.ER\n  ( ER(..)\n  , Entity(..)\n  , Attribute(..)\n  , Options, mergeOpts, optionsTo\n  , Option(..), optionByName, optToFont, optToHtml, optToLabel\n  , Relation(..) , Cardinality(..), cardByName\n  , defaultAttrOpts, defaultTitleOpts, defaultEntityOpts, defaultHeaderOpts, defaultRelOpts\n  )\nwhere\n\nimport qualified Data.Map                        as M\nimport           Data.Maybe                      (mapMaybe)\nimport           Data.Text.Lazy\nimport           Data.Word                       (Word8)\nimport           Text.Printf                     (printf)\n\nimport           Data.GraphViz.Attributes.Colors (Color)\nimport qualified Data.GraphViz.Attributes.HTML   as H\nimport           Data.GraphViz.Parsing           (ParseDot, parse, runParser)\n\n-- | Represents a single schema.\ndata ER = ER\n    { entities :: [Entity]\n    , rels     :: [Relation]\n    , title    :: Options\n    }\n    deriving (Show, Eq)\n\n-- | Represents a single entity in a schema.\ndata Entity = Entity\n    { name     :: Text\n    , attribs  :: [Attribute]\n    , hoptions :: Options\n    , eoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Entity where\n  compare = comparing name\n\n-- | Represents a single attribute in a particular entity.\ndata Attribute = Attribute\n    { field    :: Text\n    , pk       :: Bool\n    , fk       :: Bool\n    , aoptions :: Options\n    }\n    deriving (Show, Eq)\n\ninstance Ord Attribute where\n  compare = comparing field\n\n-- | Represents any number of options for an item in an ER diagram.\n-- An item may be the graph title, an entity, an entity header or a\n-- relationship between entities. Keys are options as specified in ER files.\n--\n-- Note that a set of options may include a label for any item.\ntype Options = M.Map String Option\n\n-- | Given two sets of options, merge the second into first, where elements\n-- in the first take precedence.\nmergeOpts :: Options -> Options -> Options\nmergeOpts opts1 opts2 = opts1 `M.union` opts2\n\n-- | Given a set of options and a selector function, return the list of\n-- only those options which matched. Examples of the selector function are\n-- `optToFont`, `optToHtml` and `optToLabel`.\noptionsTo :: (Option -> Maybe a) -> Options -> [a]\noptionsTo f = mapMaybe f . M.elems\n\n-- | A restricted subset of options in GraphViz that can be configured in\n-- an ER file.\ndata Option = Label String\n    | BgColor Color\n    | Color Color\n    | FontFace Text\n    | FontSize Double\n    | Border Word8\n    | BorderColor Color\n    | CellSpacing Word8\n    | CellBorder Word8\n    | CellPadding Word8\n    | TextAlignment H.Align\n    deriving (Show, Eq)\n\n-- | Given an option name and a string representation of its value,\n-- `optionByName` will attempt to parse the string as a value corresponding\n-- to the option. If the option doesn't exist or there was a problem parsing\n-- the value, an error is returned.\noptionByName :: String -> String -> Either String Option\noptionByName \"label\" = Right . Label\noptionByName \"color\" = optionParse Color\noptionByName \"bgcolor\" = optionParse BgColor\noptionByName \"size\" = optionParse FontSize\noptionByName \"font\" = optionParse FontFace\noptionByName \"border\" = optionParse Border\noptionByName \"border-color\" = optionParse BorderColor\noptionByName \"cellspacing\" = optionParse CellSpacing\noptionByName \"cellborder\" = optionParse CellBorder\noptionByName \"cellpadding\" = optionParse CellPadding\noptionByName \"text-alignment\" = optionParse TextAlignment\noptionByName unk = const (Left $ printf \"Unsupported option '%s'.\" unk)\n\n-- | A wrapper around the GraphViz's parser for any particular option.\noptionParse :: ParseDot a => (a -> Option) -> String -> Either String Option\noptionParse con s =\n  case fst $ runParser parse quoted of\n    Left err -> Left (printf \"%s (bad value '%s')\" err s)\n    Right a  -> Right (con a)\n  where quoted = \"\\\"\" `append` pack s `append` \"\\\"\"\n\n-- | Selects an option if and only if it corresponds to a font attribute.\noptToFont :: Option -> Maybe H.Attribute\noptToFont (Color c)    = Just $ H.Color c\noptToFont (FontFace s) = Just $ H.Face s\noptToFont (FontSize d) = Just $ H.PointSize d\noptToFont _            = Nothing\n\n-- | Selects an option if and only if it corresponds to an HTML attribute.\n-- In particular, for tables or table cells.\noptToHtml :: Option -> Maybe H.Attribute\noptToHtml (BgColor c)       = pure $ H.BGColor c\noptToHtml (Border w)        = pure $ H.Border w\noptToHtml (BorderColor c)   = pure $ H.Color c\noptToHtml (CellSpacing w)   = pure $ H.CellSpacing w\noptToHtml (CellBorder w)    = pure $ H.CellBorder w\noptToHtml (CellPadding w)   = pure $ H.CellPadding w\noptToHtml (TextAlignment x) = pure $ H.Align x\noptToHtml _                 = Nothing\n\n\n-- | Selects an option if and only if it corresponds to a label.\noptToLabel :: Option -> Maybe Text\noptToLabel (Label s) = Just $ pack s\noptToLabel _         = Nothing\n\n-- | Represents a relationship between exactly two entities. After parsing,\n-- each `rel` is guaranteed to correspond to an entity defined in the same\n-- ER file.\n--\n-- Each relationship has one of four cardinalities specified for both entities.\n-- Those cardinalities are: 0 or 1, exactly 1, 0 or more and 1 or more.\ndata Relation = Relation\n    { entity1, entity2 :: Text\n    , card1, card2     :: Cardinality\n    , roptions         :: Options\n    }\n    deriving (Show, Eq)\n\ndata Cardinality = ZeroOne\n    | One\n    | ZeroPlus\n    | OnePlus\n    deriving (Eq)\n\ninstance Show Cardinality where\n  show ZeroOne  = \"{0,1}\"\n  show One      = \"1\"\n  show ZeroPlus = \"0..N\"\n  show OnePlus  = \"1..N\"\n\n-- | Maps a string representation to a particular relationship cardinality.\ncardByName :: Char -> Maybe Cardinality\ncardByName '?' = Just ZeroOne\ncardByName '1' = Just One\ncardByName '*' = Just ZeroPlus\ncardByName '+' = Just OnePlus\ncardByName _   = Nothing\n\n-- | Hard-coded default options for all graph titles.\ndefaultTitleOpts :: Options\ndefaultTitleOpts = M.fromList\n  [ (\"size\", FontSize 30)\n  ]\n\n-- | Hard-coded default options for all entity headers.\ndefaultHeaderOpts :: Options\ndefaultHeaderOpts = M.fromList\n  [ (\"size\", FontSize 16)\n  ]\n\n-- | Hard-coded default options for all entities.\ndefaultEntityOpts :: Options\ndefaultEntityOpts = M.fromList\n  [ (\"border\", Border 0)\n  , (\"cellborder\", CellBorder 1)\n  , (\"cellspacing\", CellSpacing 0)\n  , (\"cellpadding\", CellPadding 4)\n  , (\"font\", FontFace \"Helvetica\")\n  ]\n\n-- | Hard-coded default options for all relationships.\ndefaultRelOpts :: Options\n-- defaultRelOpts is defined as an empty map. Consider removing if not used actively.\ndefaultRelOpts = M.empty\n\ndefaultAttrOpts :: Options\ndefaultAttrOpts = M.fromList\n  [ (\"text-alignment\", TextAlignment H.HLeft)\n  ]\n"
            },
            {
              "file_name": "/tmp/project_91/pre_refactor/src/Erd/Render.hs",
              "refactored_file_name": "/tmp/project_91/hybrid_refactored/src/Erd/Render.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 1.75,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 4,
              "lines_of_code": 44,
              "homplexity_lines_of_code": 41,
              "code_quality_score": 81.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 1.75,
                  "sum": 7
                },
                "homplexity_loc": 41,
                "homplexity_output": "Info:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 1 1: module Erd.Render has 28 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 18 1: type signature for htmlAttr has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has branching depth of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has 7 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 19 1: function htmlAttr has cyclomatic complexity of 3 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 27 1: type signature for recordAttr has 2 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 27 1: type signature for recordAttr has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 28 1: function recordAttr has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 32 1: type signature for htmlFont has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 32 1: type signature for htmlFont has 3 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 33 1: function htmlFont has 1 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 33 1: function htmlFont has cyclomatic complexity of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 33 1: function htmlFont has branching depth of 0 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 40 1: type signature for withLabelFmt has 4 arguments \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 40 1: type signature for withLabelFmt has type constructor nesting of 1 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 41 1: function withLabelFmt has cyclomatic complexity of 2 \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 41 1: function withLabelFmt has 4 lines of code \nInfo:/tmp/project_91/hybrid_refactored/src/Erd/Render.hs:SrcLoc \"/tmp/project_91/hybrid_refactored/src/Erd/Render.hs\" 41 1: function withLabelFmt has branching depth of 1 \n"
              },
              "original_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Erd.Render\n  (htmlAttr,\n   htmlFont,\n   recordAttr,\n   withLabelFmt\n  ) where\n\nimport qualified Erd.ER                            as ER\n\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Attributes.HTML     as H\nimport qualified Data.Text.Lazy                    as L\nimport           Text.Printf                       (printf)\n\n-- | Converts a single attribute to an HTML table row.\nhtmlAttr :: ER.Attribute -> H.Row\nhtmlAttr a = H.Cells [cell]\n  where cell    = H.LabelCell cellAttrs (H.Text $ withLabelFmt \" [%s]\" opts name)\n        name    = fkfmt $ pkfmt $ htmlFont opts (ER.field a)\n        pkfmt s = if ER.pk a then [H.Format H.Underline s] else s\n        fkfmt s = if ER.fk a then [H.Format H.Italics s] else s\n        opts    = ER.aoptions a\n        cellAttrs = ER.optionsTo ER.optToHtml opts\n-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a -- should change to add port support!\n-- | Formats an arbitrary string with the options given (using only font\n-- attributes).\nhtmlFont :: ER.Options -> L.Text -> H.Text\nhtmlFont opts s = [H.Font (ER.optionsTo ER.optToFont opts) [H.Str s]]\n\n-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\nwithLabelFmt :: String -> ER.Options -> H.Text -> H.Text\nwithLabelFmt fmt opts s =\n  case ER.optionsTo ER.optToLabel opts of\n    (x:_) -> s ++ htmlFont opts (L.pack $ printf fmt $ L.unpack x)\n    _     -> s\n",
              "suggestions": [
                {
                  "target_snippet": "-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a -- should change to add port support!",
                  "refactored_suggestion": "-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a\n-- reason: The comment indicating 'should change to add port support!' suggests a TODO that has not been implemented. If this comment is outdated or not actionable, it has to be removed to avoid confusion.",
                  "confidence": 0.8,
                  "justification": "The comment does not provide any actionable or currently implemented support for 'port support'. It is better either to specify actionable steps or simply remove the outdated comment to improve code readability and maintainability."
                },
                {
                  "target_snippet": "'htmlAttr' function",
                  "refactored_suggestion": "Replace recursive conditional checks for 'pkfmt' and 'fkfmt' with a single list of 'H.Format' or a fold that applies these transformations.",
                  "confidence": 0.7,
                  "justification": "The 'htmlAttr' definition could potentially be simplified by creating a more concise transformation chain. Eliminating multiple nested conditionals improves readability and reduces cognitive load for future developers."
                },
                {
                  "target_snippet": "-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)",
                  "refactored_suggestion": "-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\n\n-- Consider adding type-level strictness annotations to optimize performance on handling ER attributes.",
                  "confidence": 0.6,
                  "justification": "Adding Haskell type-level annotations creates guarantees scheme preventing unexpected errors."
                }
              ],
              "refactored_code": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Erd.Render\n  (htmlAttr,\n   htmlFont,\n   recordAttr,\n   withLabelFmt\n  ) where\n\nimport qualified Erd.ER                            as ER\n\nimport qualified Data.GraphViz.Attributes.Complete as A\nimport qualified Data.GraphViz.Attributes.HTML     as H\nimport qualified Data.Text.Lazy                    as L\nimport           Text.Printf                       (printf)\n\n-- | Converts a single attribute to an HTML table row.\nhtmlAttr :: ER.Attribute -> H.Row\nhtmlAttr a = H.Cells [cell]\n  where cell    = H.LabelCell cellAttrs (H.Text $ withLabelFmt \" [%s]\" opts name)\n        name    = fkfmt $ pkfmt $ htmlFont opts (ER.field a)\n        pkfmt s = if ER.pk a then [H.Format H.Underline s] else s\n        fkfmt s = if ER.fk a then [H.Format H.Italics s] else s\n        opts    = ER.aoptions a\n        cellAttrs = ER.optionsTo ER.optToHtml opts\n-- | Converts a single attribute to a RecordField ( an element of a dot table )\nrecordAttr :: ER.Attribute -> A.RecordField\nrecordAttr a = A.FieldLabel $ ER.field a\n-- reason: The comment indicating 'should change to add port support!' suggests a TODO that has not been implemented. If this comment is outdated or not actionable, it has to be removed to avoid confusion.\n-- | Formats an arbitrary string with the options given (using only font\n-- attributes).\nhtmlFont :: ER.Options -> L.Text -> H.Text\nhtmlFont opts s = [H.Font (ER.optionsTo ER.optToFont opts) [H.Str s]]\n\n-- | Formats HTML text with a label. The format string given should be\n-- in `Data.Text.printf` style. (Only font options are used from the options\n-- given.)\n\n-- Consider adding type-level strictness annotations to optimize performance on handling ER attributes.\nwithLabelFmt :: String -> ER.Options -> H.Text -> H.Text\nwithLabelFmt fmt opts s =\n  case ER.optionsTo ER.optToLabel opts of\n    (x:_) -> s ++ htmlFont opts (L.pack $ printf fmt $ L.unpack x)\n    _     -> s\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}