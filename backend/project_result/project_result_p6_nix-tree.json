{
  "project_name": "ProjectName",
  "analysis": {
    "pre_refactor": {
      "overall": {
        "cyclomatic_complexity": {
          "min": 8,
          "max": 65,
          "average": 24.875,
          "sum": 199
        },
        "hlint_suggestions": {
          "error": 0,
          "warning": 7,
          "suggestion": 8,
          "ignore": 0,
          "total": 15
        },
        "syntax_errors": 37,
        "lines_of_code": 1619,
        "homplexity_lines_of_code": 1623,
        "code_quality_score": 0,
        "test_coverage": 80,
        "performance": {
          "memory_usage": "161.9MB",
          "runtime": "1 × 10⁹ ns/iteration"
        },
        "security_vulnerabilities": 2
      },
      "files": [
        {
          "file_name": "/tmp/project_92/pre_refactor/test/Test.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 1
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 2,
            "suggestion": 0,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 3,
          "lines_of_code": 12,
          "homplexity_lines_of_code": 12,
          "code_quality_score": 96.8,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 1
            },
            "homplexity_loc": 12,
            "homplexity_output": "Info:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 1 1: module Main has 9 lines of code \nInfo:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 10 1: function main has 3 lines of code \nInfo:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_92/pre_refactor/test/Test.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test.hs\" 10 1: function main has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Main where\n\nimport Hedgehog\nimport Hedgehog.Main\nimport qualified Test.Data.InvertedIndex\n\nmain :: IO ()\nmain =\n  defaultMain . map checkParallel $\n    [Test.Data.InvertedIndex.tests]\n",
          "suggestions": [
            {
              "module": [
                "Main"
              ],
              "decl": [],
              "severity": "Warning",
              "hint": "Unused LANGUAGE pragma",
              "file": "/tmp/project_92/pre_refactor/test/Test.hs",
              "startLine": 1,
              "startColumn": 1,
              "endLine": 1,
              "endColumn": 33,
              "from": "{-# LANGUAGE TemplateHaskell #-}",
              "to": "",
              "note": [],
              "refactorings": "[ModifyComment {pos = SrcSpan {startLine = 1, startCol = 1, endLine = 1, endCol = 33}, newComment = \"\"}]"
            },
            {
              "module": [
                "Main"
              ],
              "decl": [
                "main"
              ],
              "severity": "Warning",
              "hint": "Evaluate",
              "file": "/tmp/project_92/pre_refactor/test/Test.hs",
              "startLine": 11,
              "startColumn": 3,
              "endLine": 12,
              "endColumn": 36,
              "from": "defaultMain . map checkParallel $ [Test.Data.InvertedIndex.tests]",
              "to": "defaultMain [checkParallel Test.Data.InvertedIndex.tests]",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 11, startCol = 3, endLine = 12, endCol = 36}, subts = [(\"a\",SrcSpan {startLine = 12, startCol = 6, endLine = 12, endCol = 35}),(\"f\",SrcSpan {startLine = 11, startCol = 21, endLine = 11, endCol = 34})], orig = \"defaultMain [f a]\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/test/Test.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/test/Test.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/test/Test.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 1,
            "average": 1.0,
            "sum": 2
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 2,
            "ignore": 0,
            "total": 3
          },
          "syntax_errors": 6,
          "lines_of_code": 39,
          "homplexity_lines_of_code": 50,
          "code_quality_score": 91.0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 1,
              "average": 1.0,
              "sum": 2
            },
            "homplexity_loc": 50,
            "homplexity_output": "Info:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 1 1: module Test.Data.InvertedIndex has 30 lines of code \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 12 1: type signature for prop_inverted_index has type constructor nesting of 0 \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 12 1: type signature for prop_inverted_index has 1 arguments \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has 19 lines of code \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has cyclomatic complexity of 1 \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has branching depth of 0 \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 38 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 38 1: type signature for tests has 1 arguments \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 39 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 39 1: function tests has 1 lines of code \nInfo:/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs\" 39 1: function tests has branching depth of 0 \n"
          },
          "original_code": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Test.Data.InvertedIndex (tests) where\n\nimport Data.InvertedIndex\nimport qualified Data.Map as Map\nimport qualified Data.Text as Text\nimport Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\n\nprop_inverted_index :: Property\nprop_inverted_index = withDiscards 10000 . withTests 10000 . property $ do\n  haystack <-\n    forAll $\n      Gen.map\n        (Range.linear 0 100)\n        ( (,)\n            <$> Gen.text (Range.linear 0 10) Gen.alphaNum\n            <*> Gen.int (Range.linear 0 100)\n        )\n\n  needle <-\n    forAll $\n      (Gen.text (Range.linear 0 5) Gen.alphaNum)\n\n  let ii = iiFromList (Map.toList haystack)\n  annotateShow ii\n\n  let expected =\n        haystack\n          & Map.filterWithKey\n            (\\t _ -> Text.toLower needle `Text.isInfixOf` Text.toLower t)\n      actual = iiSearch needle ii\n\n  expected === actual\n\ntests :: Group\ntests = $$(discover)\n",
          "suggestions": [
            {
              "module": [
                "Test.Data.InvertedIndex"
              ],
              "decl": [
                "prop_inverted_index"
              ],
              "severity": "Suggestion",
              "hint": "Redundant $",
              "file": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
              "startLine": 24,
              "startColumn": 12,
              "endLine": 24,
              "endColumn": 13,
              "from": "forAll $ (Gen.text (Range.linear 0 5) Gen.alphaNum)",
              "to": "forAll (Gen.text (Range.linear 0 5) Gen.alphaNum)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 24, startCol = 5, endLine = 25, endCol = 49}, subts = [(\"a\",SrcSpan {startLine = 24, startCol = 5, endLine = 24, endCol = 11}),(\"b\",SrcSpan {startLine = 25, startCol = 7, endLine = 25, endCol = 49})], orig = \"a b\"}]"
            },
            {
              "module": [
                "Test.Data.InvertedIndex"
              ],
              "decl": [
                "prop_inverted_index"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
              "startLine": 25,
              "startColumn": 7,
              "endLine": 25,
              "endColumn": 49,
              "from": "forAll $ (Gen.text (Range.linear 0 5) Gen.alphaNum)",
              "to": "forAll $ Gen.text (Range.linear 0 5) Gen.alphaNum",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 25, startCol = 7, endLine = 25, endCol = 49}, subts = [(\"x\",SrcSpan {startLine = 25, startCol = 8, endLine = 25, endCol = 48})], orig = \"x\"}]"
            },
            {
              "module": [
                "Test.Data.InvertedIndex"
              ],
              "decl": [
                "tests"
              ],
              "severity": "Warning",
              "hint": "Redundant bracket",
              "file": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
              "startLine": 39,
              "startColumn": 11,
              "endLine": 39,
              "endColumn": 21,
              "from": "(discover)",
              "to": "discover",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 39, startCol = 11, endLine = 39, endCol = 21}, subts = [(\"x\",SrcSpan {startLine = 39, startCol = 12, endLine = 39, endCol = 20})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/test/Test/Data/InvertedIndex.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/test/Test/Data/InvertedIndex.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/NixTree/App.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 35,
            "average": 3,
            "sum": 90
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 2,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 2,
          "lines_of_code": 622,
          "homplexity_lines_of_code": 622,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 35,
              "average": 3,
              "sum": 90
            },
            "homplexity_loc": 622,
            "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"succCycle\": 2,\n    \"run\": 1,\n    \"renderList\": 4,\n    \"compareBySortOrder\": 3,\n    \"yankToClipboard\": 2,\n    \"timePassedSinceSortOrderChange\": 1,\n    \"renderMainScreen\": 2,\n    \"renderInfoPane\": 4,\n    \"renderModal\": 1,\n    \"helpText\": 1,\n    \"helpNotice\": 1,\n    \"renderNotice\": 1,\n    \"renderWhyDependsModal\": 1,\n    \"showWhyDepends\": 1,\n    \"renderSearchModal\": 1,\n    \"showAndUpdateSearch\": 1,\n    \"move\": 1,\n    \"moveF\": 1,\n    \"moveLeft\": 2,\n    \"moveRight\": 2,\n    \"repopulateNextPane\": 1,\n    \"sortPane\": 1,\n    \"sortPanes\": 1,\n    \"selectedPath\": 1,\n    \"selectedPaths\": 2,\n    \"selectPath\": 3,\n    \"mkList\": 1,\n    \"prettySize\": 5,\n    \"app.appDraw\": 4,\n    \"app.appChooseCursor\": 1,\n    \"app.appHandleEvent\": 35,\n    \"app.appStartEvent\": 1,\n    \"app.appAttrMap\": 1,\n    \"min\": 1,\n    \"max\": 35,\n    \"average\": 2.73,\n    \"sum\": 90\n  },\n  \"homplexity_loc\": 622,\n  \"homplexity_output\": \"\"\n}"
          },
          "original_code": "module NixTree.App (run, helpText) where\n\nimport qualified Brick as B\nimport qualified Brick.BChan as B\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Center as B\nimport qualified Brick.Widgets.List as B\nimport Control.Concurrent\nimport Data.InvertedIndex\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map as Map\nimport qualified Data.Sequence as S\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Graphics.Vty as V\nimport Lens.Micro (Traversal', _Just)\nimport qualified NixTree.Clipboard as Clipboard\nimport NixTree.PathStats\nimport qualified System.Clock as Clock\nimport qualified System.HrfSize as HRF\n\nsortOrderChangeHighlightPeriod :: Clock.TimeSpec\nsortOrderChangeHighlightPeriod = Clock.TimeSpec 0 (500 * 1_000_000)\n\ndata Event\n  = EventTick Clock.TimeSpec\n\ndata Widgets\n  = WidgetPrevPane\n  | WidgetCurrPane\n  | WidgetNextPane\n  | WidgetWhyDepends\n  | WidgetSearch\n  | WidgetWhyDependsViewport\n  deriving (Show, Eq, Ord)\n\ndata Notice = Notice Text Text\n\ndata Modal s\n  = ModalNotice Notice\n  | ModalWhyDepends (B.GenericList Widgets Seq (NonEmpty Path))\n  | ModalSearch Text Text (B.GenericList Widgets Seq Path)\n\nsuccCycle :: forall a. (Bounded a, Enum a) => a -> a\nsuccCycle a\n  | fromEnum a == fromEnum (maxBound @a) = minBound\n  | otherwise = succ a\n\ndata AppEnv s = AppEnv\n  { aeActualStoreEnv :: StoreEnv PathStats,\n    aeInvertedIndex :: InvertedIndex Path,\n    aePrevPane :: List,\n    aeCurrPane :: List,\n    aeNextPane :: List,\n    aeParents :: [List],\n    aeOpenModal :: Maybe (Modal s),\n    aeSortOrder :: SortOrder,\n    aeSortOrderLastChanged :: Clock.TimeSpec,\n    aeCurrTime :: Clock.TimeSpec\n  }\n\ntype Path = StorePath StoreName PathStats\n\ntype List = B.GenericList Widgets Seq Path\n\ndata SortOrder\n  = SortOrderAlphabetical\n  | SortOrderClosureSize\n  | SortOrderAddedSize\n  deriving (Show, Eq, Enum, Bounded)\n\nB.suffixLenses ''AppEnv\n\n_ModalWhyDepends :: Traversal' (Modal s) (B.GenericList Widgets Seq (NonEmpty Path))\n_ModalWhyDepends f m = case m of\n  ModalWhyDepends l -> ModalWhyDepends <$> f l\n  _ -> pure m\n\ncompareBySortOrder :: SortOrder -> Path -> Path -> Ordering\ncompareBySortOrder SortOrderAlphabetical = compare `on` T.toLower . storeNameToShortText . spName\ncompareBySortOrder SortOrderClosureSize = compare `on` Down . psTotalSize . spPayload\ncompareBySortOrder SortOrderAddedSize = compare `on` Down . psAddedSize . spPayload\n\nattrTerminal, attrUnderlined :: B.AttrName\nattrTerminal = B.attrName \"terminal\"\nattrUnderlined = B.attrName \"underlined\"\n\nrun :: StoreEnv PathStats -> IO ()\nrun env = do\n  -- Create the inverted index, and start evaluating it in the background\n  let ii = iiFromList . toList . fmap (\\sp -> (storeNameToText (spName sp), sp)) $ seAll env\n  _ <- forkIO $ evaluateNF_ ii\n\n  -- Initial state\n  let getTime = Clock.getTime Clock.Monotonic\n  currTime <- getTime\n  let defaultSortOrder = SortOrderClosureSize\n\n  let appEnv =\n        AppEnv\n          { aeActualStoreEnv =\n              env,\n            aeInvertedIndex =\n              ii,\n            aePrevPane =\n              B.list WidgetPrevPane S.empty 0,\n            aeCurrPane =\n              B.list\n                WidgetCurrPane\n                (S.fromList . sortBy (compareBySortOrder defaultSortOrder) . NE.toList $ seGetRoots env)\n                0,\n            aeNextPane =\n              B.list WidgetNextPane S.empty 0,\n            aeParents =\n              [],\n            aeOpenModal =\n              Nothing,\n            aeSortOrder =\n              defaultSortOrder,\n            aeSortOrderLastChanged =\n              Clock.TimeSpec 0 0,\n            aeCurrTime =\n              currTime\n          }\n          & repopulateNextPane\n\n  -- Create a channel that's fed by current time\n  chan <- B.newBChan 10\n  void . forkIO $\n    forever $ do\n      threadDelay (100 * 1000)\n      t <- getTime\n      _ <- B.writeBChanNonBlocking chan (EventTick t)\n      return ()\n\n  -- And run the application\n  (_, vty) <- B.customMainWithDefaultVty (Just chan) app appEnv\n  V.shutdown vty\n\n  return ()\n\nrenderList ::\n  Maybe SortOrder ->\n  Bool ->\n  List ->\n  B.Widget Widgets\nrenderList highlightSort =\n  B.renderList\n    ( \\_\n       StorePath\n         { spName,\n           spPayload = PathStats {psTotalSize, psAddedSize, psDisambiguationChars},\n           spRefs,\n           spSignatures\n         } ->\n          let color =\n                if null spRefs\n                  then B.withAttr attrTerminal\n                  else identity\n           in color $\n                B.hBox\n                  [ if null spSignatures\n                      then B.txt \"  \"\n                      else B.txt \"\u2713 \",\n                    B.txt (storeNameToShortTextWithDisambiguation psDisambiguationChars spName)\n                      & underlineWhen SortOrderAlphabetical\n                      & B.padRight (B.Pad 1)\n                      & B.padRight B.Max,\n                    if null spRefs\n                      then\n                        B.txt (prettySize psTotalSize)\n                          & underlineWhen SortOrderClosureSize\n                          & underlineWhen SortOrderAddedSize\n                      else\n                        B.hBox\n                          [ B.txt (prettySize psTotalSize)\n                              & underlineWhen SortOrderClosureSize,\n                            B.txt \" (\",\n                            B.txt (prettySize psAddedSize)\n                              & underlineWhen SortOrderAddedSize,\n                            B.txt \")\"\n                          ]\n                  ]\n    )\n  where\n    underlineWhen so =\n      if Just so == highlightSort\n        then B.withDefAttr attrUnderlined\n        else identity\n\napp :: B.App (AppEnv s) Event Widgets\napp =\n  B.App\n    { B.appDraw = \\env@AppEnv {aeOpenModal} ->\n        [ case aeOpenModal of\n            Nothing -> B.emptyWidget\n            Just (ModalWhyDepends l) -> renderWhyDependsModal l\n            Just (ModalSearch l r xs) -> renderSearchModal l r xs\n            Just (ModalNotice notice) -> renderNotice notice,\n          renderMainScreen env\n        ],\n      B.appChooseCursor = \\_ _ -> Nothing,\n      B.appHandleEvent = \\e -> do\n        s <- get\n        case (e, aeOpenModal s) of\n          -- main screen\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                B.halt\n          (B.VtyEvent (V.EvKey (V.KChar '?') []), Nothing) ->\n            put s {aeOpenModal = Just (ModalNotice helpNotice)}\n          (B.VtyEvent (V.EvKey (V.KChar 'w') []), Nothing) -> do\n            B.hScrollToBeginning (B.viewportScroll WidgetWhyDependsViewport)\n            modify showWhyDepends\n          (B.VtyEvent (V.EvKey (V.KChar '/') []), Nothing) ->\n            modify $ showAndUpdateSearch \"\" \"\"\n          (B.VtyEvent (V.EvKey (V.KChar 'y') []), Nothing) -> do\n            liftIO (yankToClipboard $ spName (selectedPath s))\n              >>= \\case\n                Right () -> return ()\n                Left n -> put s {aeOpenModal = Just (ModalNotice n)}\n          (B.VtyEvent (V.EvKey (V.KChar 's') []), Nothing) ->\n            put $\n              s\n                { aeSortOrder = succCycle (aeSortOrder s),\n                  aeSortOrderLastChanged = aeCurrTime s\n                }\n                & sortPanes\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                modify moveLeft\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                move B.listMoveDown\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                move B.listMoveUp\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                modify moveRight\n          (B.VtyEvent (V.EvKey V.KPageUp []), Nothing) ->\n            moveF B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Nothing) ->\n            moveF B.listMovePageDown\n          -- why-depends modal\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) (-1)\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveDown l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveUp l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) 1\n          (B.VtyEvent (V.EvKey V.KPageUp []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageDown\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalWhyDepends l)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement l of\n                  Nothing -> put closed\n                  Just (_, path) -> put $ selectPath path closed\n          -- search modal\n          (B.VtyEvent (V.EvKey V.KEsc []), Just (ModalSearch {})) ->\n            put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveDown xs)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveUp xs)}\n          (B.VtyEvent (V.EvKey V.KLeft []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (T.dropEnd 1 l) (T.takeEnd 1 l <> r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey V.KRight []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (l <> T.take 1 r) (T.drop 1 r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey (V.KChar c) []), Just (ModalSearch l r _))\n            | c `Set.member` allowedSearchChars ->\n                modify (showAndUpdateSearch (l <> T.singleton c) r)\n          (B.VtyEvent (V.EvKey V.KBS []), Just (ModalSearch l r _)) ->\n            modify (showAndUpdateSearch (T.dropEnd 1 l) r)\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalSearch _ _ xs)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement xs of\n                  Nothing -> put closed\n                  Just (_, path) ->\n                    put $\n                      selectPath\n                        (shortestPathTo (aeActualStoreEnv s) (spName path))\n                        closed\n          -- notices\n          (B.VtyEvent (V.EvKey k []), Just (ModalNotice _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          -- handle our events\n          (B.AppEvent (EventTick t), _) ->\n            let new = s {aeCurrTime = t}\n             in do\n                  put new\n                  unless (timePassedSinceSortOrderChange new <= sum (replicate 2 sortOrderChangeHighlightPeriod)) B.continueWithoutRedraw\n          -- ignore otherwise\n          _ ->\n            return (),\n      B.appStartEvent = return (),\n      B.appAttrMap = \\_ ->\n        B.attrMap\n          V.defAttr\n          [ (B.listSelectedFocusedAttr, V.currentAttr `V.withStyle` V.reverseVideo),\n            (attrTerminal, B.fg V.blue),\n            (attrUnderlined, V.currentAttr `V.withStyle` V.underline)\n          ]\n    }\n  where\n    allowedSearchChars :: Set Char\n    allowedSearchChars =\n      Set.fromList\n        ( mconcat\n            [ ['a' .. 'z'],\n              ['A' .. 'Z'],\n              ['0' .. '9'],\n              \"+-.=?_\"\n            ]\n        )\n\nyankToClipboard :: StoreName -> IO (Either Notice ())\nyankToClipboard p =\n  Clipboard.copy (toText $ storeNameToPath p)\n    <&> \\case\n      Right () -> Right ()\n      Left errs ->\n        Left $\n          Notice\n            \"Error\"\n            ( T.intercalate \"\\n\" $\n                \"Cannot copy to clipboard: \"\n                  : map (\"  \" <>) errs\n                  ++ [\"Please report this as a bug.\"]\n            )\n\ntimePassedSinceSortOrderChange :: AppEnv s -> Clock.TimeSpec\ntimePassedSinceSortOrderChange env = Clock.diffTimeSpec (aeCurrTime env) (aeSortOrderLastChanged env)\n\nrenderMainScreen :: AppEnv s -> B.Widget Widgets\nrenderMainScreen env@AppEnv {aePrevPane, aeCurrPane, aeNextPane} =\n  (B.joinBorders . B.border)\n    ( B.hBox\n        [ renderList Nothing True aePrevPane,\n          B.vBorder,\n          renderList shouldHighlightSortOrder True aeCurrPane,\n          B.vBorder,\n          renderList Nothing False aeNextPane\n        ]\n    )\n    B.<=> renderInfoPane env\n  where\n    shouldHighlightSortOrder =\n      if timePassedSinceSortOrderChange env < sortOrderChangeHighlightPeriod\n        then Just (aeSortOrder env)\n        else Nothing\n\nrenderInfoPane :: AppEnv s -> B.Widget Widgets\nrenderInfoPane env =\n  let selected = selectedPath env\n      immediateParents = psImmediateParents $ spPayload selected\n      signatures = spSignatures selected\n   in B.vBox\n        [ let (f, s) = storeNameToSplitShortText (spName selected)\n           in B.txt f B.<+> underlineWhen SortOrderAlphabetical (B.txt s),\n          [ B.txt $ \"NAR Size: \" <> prettySize (spSize selected),\n            underlineWhen SortOrderClosureSize . B.txt $ \"Closure Size: \" <> prettySize (psTotalSize $ spPayload selected),\n            underlineWhen SortOrderAddedSize . B.txt $ \"Added Size: \" <> prettySize (psAddedSize $ spPayload selected)\n          ]\n            & intersperse (B.txt \" | \")\n            & B.hBox,\n          B.txt $\n            \"Signatures: \"\n              <> if null signatures\n                then \"\u2717\"\n                else\n                  ( signatures\n                      & map npsKeyName\n                      & T.intercalate \", \"\n                  ),\n          B.txt $\n            if null immediateParents\n              then \"Immediate Parents: -\"\n              else\n                \"Immediate Parents (\"\n                  <> T.pack (show $ length immediateParents)\n                  <> \"): \"\n                  <> T.intercalate \", \" (map storeNameToShortText immediateParents)\n        ]\n  where\n    underlineWhen so =\n      if so == aeSortOrder env\n        then B.withAttr attrUnderlined\n        else identity\n\nrenderModal :: Text -> B.Widget a -> B.Widget a\nrenderModal title widget =\n  widget\n    & B.borderWithLabel (B.txt title)\n    & B.hLimitPercent 90\n    & B.vLimitPercent 60\n    & B.centerLayer\n\nhelpText :: Text\nhelpText =\n  T.intercalate\n    \"\\n\"\n    [ \"hjkl/Arrow Keys : Navigate\",\n      \"w               : Open why-depends modal\",\n      \"/               : Open search modal\",\n      \"s               : Change sort order\",\n      \"y               : Yank selected path to clipboard\",\n      \"?               : Show help\",\n      \"q/Esc           : Quit / close modal\"\n    ]\n\nhelpNotice :: Notice\nhelpNotice = Notice \"Help\" helpText\n\nrenderNotice :: Notice -> B.Widget a\nrenderNotice (Notice title txt) = renderModal title (B.txt txt)\n\nrenderWhyDependsModal ::\n  B.GenericList Widgets Seq (NonEmpty Path) ->\n  B.Widget Widgets\nrenderWhyDependsModal l =\n  B.renderList renderDepends True l\n    & B.hLimitPercent 100 -- This limit seems pointless, but otherwise render list takes infinite\n    -- amount of horizontal space and 'viewport' below complains.\n    & B.viewport WidgetWhyDependsViewport B.Horizontal\n    & renderModal \"why-depends\"\n  where\n    renderDepends _ =\n      B.txt . pathsToText\n    pathsToText xs =\n      xs\n        & NE.toList\n        & fmap (storeNameToShortText . spName)\n        & T.intercalate \" \u2192 \"\n\nshowWhyDepends :: AppEnv s -> AppEnv s\nshowWhyDepends env@AppEnv {aeActualStoreEnv} =\n  env\n    { aeOpenModal =\n        Just . ModalWhyDepends $\n          let selected = selectedPath env\n              route = selectedPaths env\n              xs = S.fromList $ whyDepends aeActualStoreEnv (spName selected)\n           in B.list WidgetWhyDepends xs 1\n                & B.listMoveTo\n                  (fromMaybe 0 $ ((==) `on` fmap spName) route `S.findIndexL` xs)\n    }\n\nrenderSearchModal :: Text -> Text -> B.GenericList Widgets Seq Path -> B.Widget Widgets\nrenderSearchModal left right l =\n  renderModal \"Search\" window\n  where\n    window =\n      B.txt left\n        B.<+> B.txt \"|\"\n        B.<+> B.txt right\n        B.<=> B.hBorder\n        B.<=> renderList Nothing True l\n\nshowAndUpdateSearch :: Text -> Text -> AppEnv s -> AppEnv s\nshowAndUpdateSearch left right env@AppEnv {aeInvertedIndex} =\n  env {aeOpenModal = Just $ ModalSearch left right results}\n  where\n    results =\n      let xs =\n            iiSearch (left <> right) aeInvertedIndex\n              & Map.elems\n              & S.fromList\n       in B.list WidgetSearch xs 1\n\nmove :: (List -> List) -> B.EventM n (AppEnv s) ()\nmove = moveF . modify\n\nmoveF :: B.EventM n List () -> B.EventM n (AppEnv s) ()\nmoveF f = do\n  B.zoom aeCurrPaneL f\n  modify repopulateNextPane\n\nmoveLeft :: AppEnv s -> AppEnv s\nmoveLeft env@AppEnv {aeParents = []} = env\nmoveLeft env@AppEnv {aePrevPane, aeCurrPane, aeParents = parent : grandparents} =\n  env\n    { aeParents = grandparents,\n      aePrevPane = parent,\n      aeCurrPane = aePrevPane {B.listName = WidgetCurrPane},\n      aeNextPane = aeCurrPane {B.listName = WidgetNextPane}\n    }\n\nmoveRight :: AppEnv s -> AppEnv s\nmoveRight env@AppEnv {aePrevPane, aeCurrPane, aeNextPane, aeParents}\n  | null (B.listElements aeNextPane) = env\n  | otherwise =\n      env\n        { aePrevPane = aeCurrPane {B.listName = WidgetPrevPane},\n          aeCurrPane = aeNextPane {B.listName = WidgetCurrPane},\n          aeParents = aePrevPane : aeParents\n        }\n        & repopulateNextPane\n\nrepopulateNextPane :: AppEnv s -> AppEnv s\nrepopulateNextPane env@AppEnv {aeActualStoreEnv, aeNextPane, aeSortOrder} =\n  let ref = selectedPath env\n   in env\n        { aeNextPane =\n            B.listReplace\n              ( S.sortBy (compareBySortOrder aeSortOrder)\n                  . S.fromList\n                  . map (seLookup aeActualStoreEnv)\n                  $ spRefs ref\n              )\n              (Just 0)\n              aeNextPane\n        }\n\nsortPane :: SortOrder -> List -> List\nsortPane so l =\n  let selected = B.listSelectedElement l\n      elems =\n        B.listElements l\n          & S.sortBy (compareBySortOrder so)\n      name = B.getName l\n   in mkList so name elems (snd <$> selected)\n\nsortPanes :: AppEnv s -> AppEnv s\nsortPanes env@AppEnv {aeParents, aePrevPane, aeCurrPane, aeNextPane, aeSortOrder} =\n  env\n    { aeCurrPane = sortPane aeSortOrder aeCurrPane,\n      aeNextPane = sortPane aeSortOrder aeNextPane,\n      aeParents = sortPane aeSortOrder <$> aeParents,\n      aePrevPane = sortPane aeSortOrder aePrevPane\n    }\n\nselectedPath :: AppEnv s -> Path\nselectedPath = NE.head . selectedPaths\n\nselectedPaths :: AppEnv s -> NonEmpty Path\nselectedPaths AppEnv {aePrevPane, aeCurrPane, aeParents} =\n  let parents =\n        mapMaybe\n          (fmap snd . B.listSelectedElement)\n          (aePrevPane : aeParents)\n   in case B.listSelectedElement aeCurrPane of\n        Nothing -> error \"invariant violation: no selected element\"\n        Just (_, p) -> p :| parents\n\nselectPath :: NonEmpty Path -> AppEnv s -> AppEnv s\nselectPath path env\n  | (spName <$> path) == (spName <$> selectedPaths env) =\n      env\nselectPath path env@AppEnv {aeActualStoreEnv} =\n  let root :| children = NE.reverse path\n      lists =\n        NE.scanl\n          ( \\(_, prev) curr ->\n              ( map (seLookup aeActualStoreEnv) $\n                  spRefs prev,\n                curr\n              )\n          )\n          (NE.toList (seGetRoots aeActualStoreEnv), root)\n          children\n          & NE.reverse\n          & fmap (\\(possible, selected) -> mkList (aeSortOrder env) WidgetPrevPane (S.fromList possible) (Just selected))\n          & (<> (emptyPane :| []))\n   in case lists of\n        (curr :| prevs) ->\n          let (prev, parents) = case prevs of\n                [] -> (emptyPane, [])\n                p : ps -> (p, ps)\n           in env\n                { aeParents = parents,\n                  aePrevPane = prev,\n                  aeCurrPane = curr {B.listName = WidgetCurrPane}\n                }\n                & repopulateNextPane\n  where\n    emptyPane =\n      B.list WidgetPrevPane S.empty 0\n\nmkList ::\n  SortOrder ->\n  n ->\n  Seq Path ->\n  Maybe Path ->\n  B.GenericList n Seq Path\nmkList sortOrder name possible selected =\n  let contents = S.sortBy (compareBySortOrder sortOrder) possible\n   in B.list name contents 1\n        & B.listMoveTo\n          (fromMaybe 0 $ selected >>= \\s -> ((==) `on` spName) s `S.findIndexL` contents)\n\n-- Utils\n\nprettySize :: Int -> T.Text\nprettySize size = case HRF.convertSize $ fromIntegral size of\n  HRF.Bytes d -> T.pack (show d)\n  HRF.KiB d -> T.pack (show d) <> \" KiB\"\n  HRF.MiB d -> T.pack (show d) <> \" MiB\"\n  HRF.GiB d -> T.pack (show d) <> \" GiB\"\n  HRF.TiB d -> T.pack (show d) <> \" TiB\"\n",
          "suggestions": [
            {
              "module": [
                "NixTree.App"
              ],
              "decl": [
                "Event"
              ],
              "severity": "Suggestion",
              "hint": "Use newtype instead of data",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/App.hs",
              "startLine": 25,
              "startColumn": 1,
              "endLine": 26,
              "endColumn": 29,
              "from": "data Event = EventTick Clock.TimeSpec",
              "to": "newtype Event = EventTick Clock.TimeSpec",
              "note": [
                "decreases laziness"
              ],
              "refactorings": "[]"
            },
            {
              "module": [
                "NixTree.App"
              ],
              "decl": [
                "renderInfoPane"
              ],
              "severity": "Suggestion",
              "hint": "Redundant bracket",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/App.hs",
              "startLine": 394,
              "startColumn": 19,
              "endLine": 397,
              "endColumn": 20,
              "from": "if null signatures then\n    \"\u2717\"\nelse\n    (signatures & map npsKeyName & T.intercalate \", \")",
              "to": "if null signatures then\n    \"\u2717\"\nelse\n    signatures & map npsKeyName & T.intercalate \", \"",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 394, startCol = 19, endLine = 397, endCol = 20}, subts = [(\"x\",SrcSpan {startLine = 394, startCol = 21, endLine = 396, endCol = 43})], orig = \"x\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/NixTree/App.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/NixTree/App.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/NixTree/App.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 3,
            "sum": 9
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 1,
            "suggestion": 1,
            "ignore": 0,
            "total": 2
          },
          "syntax_errors": 3,
          "lines_of_code": 45,
          "homplexity_lines_of_code": 45,
          "code_quality_score": 77.5,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 3,
              "sum": 9
            },
            "homplexity_loc": 45,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runCmd\": 5,\n        \"copy\": 1,\n        \"go\": 3,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 3,\n        \"sum\": 9\n    },\n    \"homplexity_loc\": 45,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "module NixTree.Clipboard\n  ( copy,\n  )\nwhere\n\nimport Control.Exception (try)\nimport System.Exit\nimport qualified System.Process.Typed as P\nimport System.Timeout\n\ncmds :: [(FilePath, [String])]\ncmds =\n  [ (\"xsel\", [\"-i\", \"-b\"]),\n    (\"xclip\", [\"-selection\", \"clipboard\"]),\n    (\"wl-copy\", []),\n    (\"pbcopy\", [])\n  ]\n\nrunCmd :: Text -> (FilePath, [String]) -> IO (Either Text ())\nrunCmd txt (cmd, args) =\n  P.proc (toString cmd) (map toString args)\n    & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n    & P.runProcess\n    & timeout 1_000_000\n    & try\n    <&> \\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e)) ->\n        Left $ \"failed with exit code \" <> show e\n      Right Nothing ->\n        Left $ \"timed out\"\n      Left (ex :: SomeException) ->\n        Left $ \"failed with exception: \" <> show ex\n    <&> \\case\n      Right () -> Right ()\n      Left err -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")\n\ncopy :: Text -> IO (Either [Text] ())\ncopy txt = go cmds []\n  where\n    go [] errs = return $ Left errs\n    go (x : xs) errs =\n      runCmd txt x >>= \\case\n        Right () -> return $ Right ()\n        Left err -> go xs (err : errs)\n",
          "suggestions": [
            {
              "module": [
                "NixTree.Clipboard"
              ],
              "decl": [
                "runCmd"
              ],
              "severity": "Warning",
              "hint": "Functor law",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
              "startLine": 21,
              "startColumn": 3,
              "endLine": 36,
              "endColumn": 77,
              "from": "P.proc (toString cmd) (map toString args)\n  & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n  & P.runProcess\n  & timeout 1_000_000\n  & try\n  <&>\n    \\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e))\n        -> Left $ \"failed with exit code \" <> show e\n      Right Nothing -> Left $ \"timed out\"\n      Left (ex :: SomeException)\n        -> Left $ \"failed with exception: \" <> show ex\n  <&>\n    \\case\n      Right () -> Right ()\n      Left err\n        -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")",
              "to": "(P.proc (toString cmd) (map toString args)\n   & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n   & P.runProcess\n   & timeout 1_000_000\n   & try)\n  <&>\n    (\\case\n       Right () -> Right ()\n       Left err\n         -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\"))\n      . (\\case\n           Right (Just ExitSuccess) -> Right ()\n           Right (Just (ExitFailure e))\n             -> Left $ \"failed with exit code \" <> show e\n           Right Nothing -> Left $ \"timed out\"\n           Left (ex :: SomeException)\n             -> Left $ \"failed with exception: \" <> show ex)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 21, startCol = 3, endLine = 36, endCol = 77}, subts = [(\"f\",SrcSpan {startLine = 34, startCol = 9, endLine = 36, endCol = 77}),(\"g\",SrcSpan {startLine = 26, startCol = 9, endLine = 33, endCol = 52}),(\"x\",SrcSpan {startLine = 21, startCol = 3, endLine = 25, endCol = 10})], orig = \"(x) <&> (f) . (g)\"}]"
            },
            {
              "module": [
                "NixTree.Clipboard"
              ],
              "decl": [
                "runCmd"
              ],
              "severity": "Suggestion",
              "hint": "Redundant $",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
              "startLine": 31,
              "startColumn": 14,
              "endLine": 31,
              "endColumn": 15,
              "from": "Left $ \"timed out\"",
              "to": "Left \"timed out\"",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 31, startCol = 9, endLine = 31, endCol = 27}, subts = [(\"a\",SrcSpan {startLine = 31, startCol = 9, endLine = 31, endCol = 13}),(\"b\",SrcSpan {startLine = 31, startCol = 16, endLine = 31, endCol = 27})], orig = \"a b\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/NixTree/Clipboard.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/NixTree/Clipboard.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/NixTree/Clipboard.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Main.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 5,
            "average": 2,
            "sum": 14
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 8,
          "lines_of_code": 161,
          "homplexity_lines_of_code": 161,
          "code_quality_score": 55.9,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 5,
              "average": 2,
              "sum": 14
            },
            "homplexity_loc": 161,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"version\": 1,\n        \"optsParser\": 1,\n        \"parser\": 1,\n        \"keybindingsHelp\": 1,\n        \"showAndFail\": 1,\n        \"isValidRoot\": 2,\n        \"main\": 5,\n        \"chunks\": 2,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 1.75,\n        \"sum\": 14\n    },\n    \"homplexity_loc\": 161,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "{-# LANGUAGE CPP #-}\n\nmodule Main where\n\nimport Control.Concurrent.Async\nimport Control.Exception (evaluate)\nimport NixTree.App\nimport NixTree.PathStats\nimport qualified Options.Applicative as Opts\nimport qualified Options.Applicative.Help.Pretty as Opts\nimport System.Directory (XdgDirectory (XdgState), doesDirectoryExist, getHomeDirectory, getXdgDirectory, pathIsSymbolicLink)\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((</>))\nimport System.IO (hPutStrLn)\nimport System.ProgressBar hiding (msg)\n\nversion :: Text\nversion = VERSION_nix_tree\n\ndata Opts = Opts\n  { oInstallables :: [Installable],\n    oStore :: Maybe String,\n    oFile :: Maybe FilePath,\n    oVersion :: Bool,\n    oDerivation :: Bool,\n    oImpure :: Bool,\n    oDot :: Bool\n  }\n\noptsParser :: Opts.ParserInfo Opts\noptsParser =\n  Opts.info (parser <**> Opts.helper) $\n    mconcat\n      [ Opts.progDesc \"Interactively browse dependency graphs of Nix derivations.\",\n        Opts.fullDesc,\n        Opts.footerDoc (Just keybindingsHelp)\n      ]\n  where\n    parser :: Opts.Parser Opts\n    parser =\n      Opts\n        <$> many\n          ( Installable\n              <$> Opts.strArgument @Text\n                ( Opts.metavar \"INSTALLABLE\"\n                    <> Opts.helpDoc\n                      ( Just $\n                          Opts.vsep\n                            [ \"A store path or a flake reference.\",\n                              \"Paths default to \\\"~/.nix-profile\\\" and \\\"/var/run/current-system\\\"\"\n                            ]\n                      )\n                )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"store\"\n                  <> Opts.metavar \"STORE\"\n                  <> Opts.helpDoc\n                    ( Just $\n                        Opts.vsep\n                          [ \"The URL of the Nix store, e.g. \\\"daemon\\\" or \\\"https://cache.nixos.org\\\"\",\n                            \"See \\\"nix help-stores\\\" for supported store types and settings.\"\n                          ]\n                    )\n              )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"file\"\n                  <> Opts.metavar \"FILE\"\n                  <> Opts.helpDoc\n                    ( Just $ Opts.vsep [\"Interpret installables as attribute paths relative to the Nix expression stored in file.\"]\n                    )\n              )\n          )\n        <*> Opts.switch (Opts.long \"version\" <> Opts.help \"Show the nix-tree version\")\n        <*> Opts.switch (Opts.long \"derivation\" <> Opts.help \"Operate on the store derivation rather than its outputs\")\n        <*> Opts.switch (Opts.long \"impure\" <> Opts.help \"Allow access to mutable paths and repositories\")\n        <*> Opts.switch (Opts.long \"dot\" <> Opts.help \"Print the dependency graph in dot format\")\n\n    keybindingsHelp :: Opts.Doc\n    keybindingsHelp =\n      Opts.vsep\n        [ \"Keybindings:\",\n          Opts.indent 2 . Opts.vsep $ map Opts.pretty (lines helpText)\n        ]\n\nshowAndFail :: Text -> IO a\nshowAndFail msg = do\n  hPutStrLn stderr . toString $ \"Error: \" <> msg\n  exitWith (ExitFailure 1)\n\nisValidRoot :: FilePath -> IO Bool\nisValidRoot path = do\n  isExistingDirectory <- doesDirectoryExist path\n  if isExistingDirectory\n    then -- We need to check that it's a symlink (presumably to nix store),\n    -- because if it is just a directory, nix will try to interpret it as a flake.\n    -- We do doesDirectoryExist before pathIsSymbolicLink,\n    -- because the latter will fail if the path does not exist.\n      pathIsSymbolicLink path\n    else return False\n\nmain :: IO ()\nmain = do\n  opts <-\n    Opts.customExecParser\n      (Opts.prefs $ Opts.columns 120)\n      optsParser\n\n  when (opts & oVersion) $ do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess\n\n  installables <- case opts & oInstallables of\n    p : ps ->\n      return $ p :| ps\n    [] -> do\n      home <- getHomeDirectory\n      nixXdgDirectory <- getXdgDirectory XdgState \"nix/profile\"\n      homeManagerDirectory <- getXdgDirectory XdgState \"nix/profiles/home-manager\"\n      roots <-\n        filterM\n          isValidRoot\n          [ home </> \".nix-profile\",\n            nixXdgDirectory,\n            homeManagerDirectory,\n            \"/var/run/current-system\"\n          ]\n      case roots of\n        [] -> showAndFail \"No store path given.\"\n        p : ps -> return . fmap (Installable . toText) $ p :| ps\n\n  let seo =\n        StoreEnvOptions\n          { seoIsDerivation = opts & oDerivation,\n            seoIsImpure = opts & oImpure,\n            seoStoreURL = opts & oStore,\n            seoFile = opts & oFile\n          }\n\n  withStoreEnv seo installables $ \\env' -> do\n    let env = calculatePathStats env'\n        allPaths = seAll env\n\n    bar <- newProgressBar defStyle {stylePostfix = exact} 4 (Progress 0 (length allPaths) ())\n    allPaths\n      & toList\n      & chunks 50\n      & mapConcurrently_ (mapM_ (\\p -> evaluate (rnf p) >> incProgress bar 1))\n\n    if opts & oDot\n      then putTextLn $ storeEnvToDot env\n      else run env\n\nchunks :: Int -> [a] -> [[a]]\nchunks _ [] = []\nchunks n xs =\n  let (ys, zs) = splitAt n xs\n   in ys : chunks n zs\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/NixTree/Main.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/NixTree/Main.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/NixTree/Main.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 3,
            "average": 2,
            "sum": 17
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 3,
            "suggestion": 3,
            "ignore": 0,
            "total": 6
          },
          "syntax_errors": 2,
          "lines_of_code": 219,
          "homplexity_lines_of_code": 219,
          "code_quality_score": 44.1,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 3,
              "average": 2,
              "sum": 17
            },
            "homplexity_loc": 219,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"mkIntermediateEnv\": 2,\n        \"mkFinalEnv\": 3,\n        \"calculatePathStats\": 1,\n        \"shortestPathTo\": 3,\n        \"whyDepends\": 2,\n        \"mkTreeish\": 1,\n        \"treeishSize\": 1,\n        \"capTreeish\": 2,\n        \"treeishToList\": 2,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 1.8888888888888888,\n        \"sum\": 17\n    },\n    \"homplexity_loc\": 219,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "module NixTree.PathStats\n  ( PathStats (..),\n    calculatePathStats,\n    whyDepends,\n    shortestPathTo,\n    module NixTree.StorePath,\n  )\nwhere\n\nimport Data.List (minimumBy)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map.Lazy as M\nimport qualified Data.Set as S\nimport NixTree.StorePath\n\ndata IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }\n\ndata PathStats = PathStats\n  { psTotalSize :: !Int,\n    psAddedSize :: !Int,\n    psImmediateParents :: [StoreName],\n    psDisambiguationChars :: !Int\n  }\n  deriving (Show, Generic, NFData)\n\nmkIntermediateEnv ::\n  (StoreName -> Bool) ->\n  StoreEnv () ->\n  StoreEnv IntermediatePathStats\nmkIntermediateEnv env =\n  seBottomUp $ \\curr ->\n    IntermediatePathStats\n      { ipsAllRefs =\n          M.unions\n            ( M.fromList\n                [ (spName, void sp)\n                  | sp@StorePath {spName} <- spRefs curr,\n                    env spName\n                ]\n                : map (ipsAllRefs . spPayload) (spRefs curr)\n            )\n      }\n\nmkFinalEnv :: StoreEnv IntermediatePathStats -> StoreEnv PathStats\nmkFinalEnv env =\n  let totalSize = calculateEnvSize env\n      immediateParents = calculateImmediateParents (sePaths env)\n      disambiguationChars = seDisambiguationChars env\n   in flip seBottomUp env $ \\StorePath {spName, spSize, spPayload} ->\n        let filteredSize =\n              seFetchRefs env (/= spName) (seRoots env)\n                & calculateRefsSize\n            addedSize = totalSize - filteredSize\n         in PathStats\n              { psTotalSize =\n                  spSize\n                    + calculateRefsSize (ipsAllRefs spPayload),\n                psAddedSize = addedSize,\n                psImmediateParents =\n                  maybe [] S.toList $ M.lookup spName immediateParents,\n                psDisambiguationChars =\n                  M.lookup spName disambiguationChars\n                    & maybe 0 id\n              }\n  where\n    calculateEnvSize :: StoreEnv IntermediatePathStats -> Int\n    calculateEnvSize e =\n      seGetRoots e\n        & toList\n        & map\n          ( \\sp@StorePath {spName, spPayload} ->\n              M.insert\n                spName\n                (void sp)\n                (ipsAllRefs spPayload)\n          )\n        & M.unions\n        & calculateRefsSize\n    calculateRefsSize :: (Functor f, Foldable f) => f (StorePath a b) -> Int\n    calculateRefsSize = sum . fmap spSize\n    calculateImmediateParents ::\n      (Foldable f) =>\n      f (StorePath StoreName b) ->\n      M.Map StoreName (S.Set StoreName)\n    calculateImmediateParents =\n      foldl'\n        ( \\m StorePath {spName, spRefs} ->\n            M.unionWith\n              (<>)\n              m\n              (M.fromList (map (,S.singleton spName) spRefs))\n        )\n        M.empty\n\n    seShortNames :: StoreEnv a -> M.Map Text [StoreName]\n    seShortNames env =\n      let paths = seAll env & toList\n       in foldl'\n            ( \\m StorePath {spName} ->\n                let (_, shortName) = storeNameToSplitShortText spName\n                 in M.alter\n                      ( \\case\n                          Nothing -> Just [spName]\n                          Just xs -> Just (spName : xs)\n                      )\n                      shortName\n                      m\n            )\n            M.empty\n            paths\n\n    seDisambiguationChars :: StoreEnv a -> M.Map StoreName Int\n    seDisambiguationChars env =\n      M.toList (seShortNames env)\n        & map snd\n        & concatMap\n          ( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          )\n        & M.fromList\n\n    disambiguate :: [StoreName] -> Int\n    disambiguate xs = go 0\n      where\n        go n =\n          if isGood n\n            then n\n            else go (n + 2)\n\n        isGood n =\n          xs\n            & map (storeNameToShortTextWithDisambiguation n)\n            & allUnique\n\n        allUnique xx =\n          let unique = S.fromList xx\n           in length unique == length xx\n\ncalculatePathStats :: StoreEnv () -> StoreEnv PathStats\ncalculatePathStats = mkFinalEnv . mkIntermediateEnv (const True)\n\n-- TODO: This can be precomputed.\nshortestPathTo :: StoreEnv a -> StoreName -> NonEmpty (StorePath StoreName a)\nshortestPathTo env name =\n  seBottomUp\n    ( \\curr ->\n        let currOut = curr {spRefs = spName <$> spRefs curr}\n         in if spName curr == name\n              then Just (1 :: Int, currOut :| [])\n              else\n                mapMaybe spPayload (spRefs curr)\n                  & \\case\n                    [] -> Nothing\n                    xs -> case minimumBy (comparing fst) xs of\n                      (c, p) -> Just (c + 1, currOut NE.<| p)\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & minimumBy (comparing fst)\n    & snd\n    & NE.reverse\n\n-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node contains a set of paths which represent\n-- the why-depends output from that node down. The set of paths is represented as a \"Treeish\" object,\n-- which is a trie-like structure.\nwhyDepends :: forall a. StoreEnv a -> StoreName -> [NonEmpty (StorePath StoreName a)]\nwhyDepends env name =\n  seBottomUp @_ @(Maybe (Treeish (StorePath StoreName a)))\n    ( \\curr ->\n        if spName curr == name\n          then Just $ mkTreeish (curr {spRefs = map spName (spRefs curr)}) []\n          else\n            mapMaybe spPayload (spRefs curr)\n              & NE.nonEmpty\n              <&> NE.toList\n              <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})\n              <&> capTreeish 1_000_000\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & take 10000\n    & concatMap treeishToList\n\n-- A trie-like structure which also caches the size.\ndata Treeish a = Treeish Int a [Treeish a]\n\nmkTreeish :: a -> [Treeish a] -> Treeish a\nmkTreeish a ts = Treeish (1 + sum (map (\\(Treeish i _ _) -> i) ts)) a ts\n\ntreeishSize :: Treeish a -> Int\ntreeishSize (Treeish i _ _) = i\n\ncapTreeish :: Int -> Treeish a -> Treeish a\ncapTreeish cap (Treeish i a ts)\n  | i <= cap = Treeish i a ts\n  | otherwise = Treeish cap a (go cap ts)\n  where\n    go _ [] = []\n    go remaining (x : xs) =\n      let x' = capTreeish remaining x\n          remaining' = remaining - treeishSize x'\n       in if remaining > 0\n            then x' : go remaining' xs\n            else [x']\n\ntreeishToList :: Treeish a -> [NonEmpty a]\ntreeishToList (Treeish _ a []) = [a :| []]\ntreeishToList (Treeish _ a xs) = map (a NE.<|) (concatMap treeishToList xs)\n",
          "suggestions": [
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "IntermediatePathStats"
              ],
              "severity": "Suggestion",
              "hint": "Use newtype instead of data",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 16,
              "startColumn": 1,
              "endLine": 18,
              "endColumn": 4,
              "from": "data IntermediatePathStats\n  = IntermediatePathStats {ipsAllRefs :: M.Map StoreName (StorePath StoreName ())}",
              "to": "newtype IntermediatePathStats\n  = IntermediatePathStats {ipsAllRefs :: M.Map StoreName (StorePath StoreName ())}",
              "note": [
                "decreases laziness"
              ],
              "refactorings": "[]"
            },
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "mkFinalEnv"
              ],
              "severity": "Warning",
              "hint": "Use fromMaybe",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 65,
              "startColumn": 23,
              "endLine": 65,
              "endColumn": 33,
              "from": "maybe 0 id",
              "to": "Data.Maybe.fromMaybe 0",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 65, startCol = 23, endLine = 65, endCol = 33}, subts = [(\"x\",SrcSpan {startLine = 65, startCol = 29, endLine = 65, endCol = 30})], orig = \"Data.Maybe.fromMaybe x\"}]"
            },
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "mkFinalEnv"
              ],
              "severity": "Suggestion",
              "hint": "Fuse concatMap/map",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 116,
              "startColumn": 7,
              "endLine": 122,
              "endColumn": 12,
              "from": "M.toList (seShortNames env) & map snd\n  & concatMap\n      (\\ xs -> let chrs = disambiguate xs in map (\\ x -> (x, chrs)) xs)",
              "to": "concatMap\n  ((\\ xs -> let chrs = disambiguate xs in map (\\ x -> (x, chrs)) xs)\n     . snd)\n  (M.toList (seShortNames env))",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 116, startCol = 7, endLine = 122, endCol = 12}, subts = [(\"f\",SrcSpan {startLine = 119, startCol = 11, endLine = 122, endCol = 12}),(\"g\",SrcSpan {startLine = 117, startCol = 15, endLine = 117, endCol = 18}),(\"x\",SrcSpan {startLine = 116, startCol = 7, endLine = 116, endCol = 34})], orig = \"concatMap (f . g) (x)\"}]"
            },
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "mkFinalEnv"
              ],
              "severity": "Suggestion",
              "hint": "Use tuple-section",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 121,
              "startColumn": 24,
              "endLine": 121,
              "endColumn": 39,
              "from": "\\ x -> (x, chrs)",
              "to": "(, chrs)",
              "note": [
                "may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file"
              ],
              "refactorings": "[]"
            },
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "whyDepends"
              ],
              "severity": "Warning",
              "hint": "Functor law",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 181,
              "startColumn": 13,
              "endLine": 184,
              "endColumn": 71,
              "from": "mapMaybe spPayload (spRefs curr) & NE.nonEmpty <&> NE.toList\n  <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})",
              "to": "((mapMaybe spPayload (spRefs curr) & NE.nonEmpty)\n   <&>\n     mkTreeish (curr {spRefs = map spName (spRefs curr)}) . NE.toList)",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 181, startCol = 13, endLine = 184, endCol = 71}, subts = [(\"f\",SrcSpan {startLine = 184, startCol = 19, endLine = 184, endCol = 71}),(\"g\",SrcSpan {startLine = 183, startCol = 19, endLine = 183, endCol = 28}),(\"x\",SrcSpan {startLine = 181, startCol = 13, endLine = 182, endCol = 28})], orig = \"((x) <&> f . g)\"}]"
            },
            {
              "module": [
                "NixTree.PathStats"
              ],
              "decl": [
                "whyDepends"
              ],
              "severity": "Warning",
              "hint": "Functor law",
              "file": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "startLine": 181,
              "startColumn": 13,
              "endLine": 185,
              "endColumn": 39,
              "from": "mapMaybe spPayload (spRefs curr) & NE.nonEmpty <&> NE.toList\n  <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})\n  <&> capTreeish 1_000_000",
              "to": "(mapMaybe spPayload (spRefs curr) & NE.nonEmpty <&> NE.toList)\n  <&>\n    capTreeish 1_000_000\n      . mkTreeish (curr {spRefs = map spName (spRefs curr)})",
              "note": [],
              "refactorings": "[Replace {rtype = Expr, pos = SrcSpan {startLine = 181, startCol = 13, endLine = 185, endCol = 39}, subts = [(\"f\",SrcSpan {startLine = 185, startCol = 19, endLine = 185, endCol = 39}),(\"g\",SrcSpan {startLine = 184, startCol = 19, endLine = 184, endCol = 71}),(\"x\",SrcSpan {startLine = 181, startCol = 13, endLine = 183, endCol = 28})], orig = \"(x) <&> f . g\"}]"
            }
          ],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/NixTree/PathStats.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/NixTree/PathStats.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/NixTree/PathStats.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/NixTree/StorePath.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 11,
            "average": 3,
            "sum": 54
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 12,
          "lines_of_code": 445,
          "homplexity_lines_of_code": 438,
          "code_quality_score": 0,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 11,
              "average": 3,
              "sum": 54
            },
            "homplexity_loc": 438,
            "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"mkNixStore\": 2,\n    \"unNixStore\": 2,\n    \"getStoreDir\": 3,\n    \"mkStoreName\": 3,\n    \"storeNameToText\": 1,\n    \"storeNameToPath\": 1,\n    \"storeNameToShortText\": 1,\n    \"storeNameToShortTextWithDisambiguation\": 2,\n    \"storeNameToSplitShortText\": 2,\n    \"getNixVersion\": 4,\n    \"getPathInfo\": 11,\n    \"withStoreEnv\": 2,\n    \"seLookup\": 2,\n    \"seAll\": 2,\n    \"seGetRoots\": 1,\n    \"seFetchRefs\": 3,\n    \"seBottomUp\": 1,\n    \"storeEnvToDot\": 1,\n    \"parse2_18\": 4,\n    \"parse2_19\": 3,\n    \"parseJSON_NixPathOutput\": 3,\n    \"min\": 1,\n    \"max\": 11,\n    \"average\": 2.57,\n    \"sum\": 54\n  },\n  \"homplexity_loc\": 438,\n  \"homplexity_output\": \"\"\n}"
          },
          "original_code": "module NixTree.StorePath\n  ( StoreName (..),\n    storeNameToPath,\n    storeNameToText,\n    storeNameToShortText,\n    storeNameToSplitShortText,\n    storeNameToShortTextWithDisambiguation,\n    NixPathSignature (..),\n    StorePath (..),\n    Installable (..),\n    StoreEnv (..),\n    StoreEnvOptions (..),\n    withStoreEnv,\n    seLookup,\n    seAll,\n    seGetRoots,\n    seBottomUp,\n    seFetchRefs,\n    mkStoreName,\n    storeEnvToDot,\n  )\nwhere\n\nimport Data.Aeson (FromJSON (..), Value (..), decode, eitherDecode, (.!=), (.:), (.:?))\nimport qualified Data.Aeson.Key as K\nimport qualified Data.Aeson.KeyMap as KM\nimport Data.Aeson.Types (Parser)\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashSet as HS\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Dot\nimport System.FilePath.Posix (addTrailingPathSeparator, splitDirectories, (</>))\nimport System.IO (hPutStrLn)\nimport System.Process.Typed (proc, readProcessStdout_)\n\n-- Technically these both are filepaths. However, most people use the default \"/nix/store\",\n-- hence special casing it speeds things up.\ndata NixStore\n  = NixStore\n  | NixStoreCustom FilePath\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkNixStore :: FilePath -> NixStore\nmkNixStore i' =\n  let i = addTrailingPathSeparator i'\n   in if i == \"/nix/store/\" then NixStore else NixStoreCustom i\n\nunNixStore :: NixStore -> FilePath\nunNixStore NixStore = \"/nix/store/\"\nunNixStore (NixStoreCustom fp) = fp\n\ngetStoreDir :: Maybe FilePath -> IO NixStore\ngetStoreDir seoNixStore = do\n  let prog = \"nix-instantiate\"\n      args =\n        [\"--eval\", \"--expr\", \"(builtins.storeDir)\", \"--json\"]\n          ++ ( case seoNixStore of\n                 Nothing -> []\n                 Just url -> [\"--option\", \"store\", url]\n             )\n  out <-\n    readProcessStdout_ (proc prog args)\n      <&> fmap mkNixStore\n      . decode @FilePath\n  case out of\n    Nothing -> fail $ \"Error interpreting output of: \" ++ show (prog, args)\n    Just p -> return p\n\n--------------------------------------------------------------------------------\n\ndata StoreName = StoreName NixStore Text\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkStoreName :: NixStore -> FilePath -> Maybe StoreName\nmkStoreName ns path = do\n  let ps = unNixStore ns\n  guard $ ps `isPrefixOf` path\n  let ds = splitDirectories (drop (length ps) path)\n  sn <- listToMaybe ds\n  return $ StoreName ns (toText sn)\n\nstoreNameToText :: StoreName -> Text\nstoreNameToText (StoreName _ n) = n\n\nstoreNameToPath :: StoreName -> FilePath\nstoreNameToPath (StoreName ns sn) = unNixStore ns </> toString sn\n\nstoreNameToShortText :: StoreName -> Text\nstoreNameToShortText = snd . storeNameToSplitShortText\n\nstoreNameToShortTextWithDisambiguation :: Int -> StoreName -> Text\nstoreNameToShortTextWithDisambiguation 0 sn = storeNameToShortText sn\nstoreNameToShortTextWithDisambiguation n (StoreName ns sn) =\n  let (f, s) = storeNameToSplitShortText (StoreName ns sn)\n   in T.take n f <> \"...-\" <> s\n\nstoreNameToSplitShortText :: StoreName -> (Text, Text)\nstoreNameToSplitShortText txt =\n  case T.span (/= '-') $ storeNameToText txt of\n    (f, s) | Just (c, s'') <- T.uncons s -> (T.snoc f c, s'')\n    e -> e\n\n--------------------------------------------------------------------------------\n\ndata NixVersion\n  = NixOlder\n  | Nix2_4\n  | NixNewer\n  | NixUnknown\n  deriving (Show, Eq, Ord)\n\ngetNixVersion :: IO NixVersion\ngetNixVersion = do\n  out <- decodeUtf8 . BL.toStrict <$> readProcessStdout_ (proc \"nix\" [\"--version\"])\n\n  -- Parses strings like:\n  --  nix (Nix) 2.6.0pre20211217_6e6e998\n  --  nix (Nix) 2.5.1\n  return . fromMaybe NixUnknown $ do\n    -- get the last space delimited part\n    ver <-\n      out\n        & T.splitOn \" \"\n        & viaNonEmpty last\n\n    -- split by \".\", take the first two, and convert them to numbers\n    (major, minor) <- do\n      (maT, miT) <- case T.splitOn \".\" ver of\n        p1 : p2 : _ -> Just (p1, p2)\n        _ -> Nothing\n      ma <- readMaybe @Natural (toString maT)\n      mi <- readMaybe @Natural (toString miT)\n      return (ma, mi)\n\n    -- map it to the sum\n    return $ case compare (major, minor) (2, 4) of\n      LT -> NixOlder\n      EQ -> Nix2_4\n      GT -> NixNewer\n\n--------------------------------------------------------------------------------\n\ndata StorePath ref payload = StorePath\n  { spName :: StoreName,\n    spSize :: Int,\n    spRefs :: [ref],\n    spPayload :: payload,\n    spSignatures :: [NixPathSignature]\n  }\n  deriving (Show, Eq, Ord, Functor, Generic)\n\ninstance (NFData a, NFData b) => NFData (StorePath a b)\n\nnewtype Installable = Installable {installableToText :: Text}\n\n--------------------------------------------------------------------------------\n\ndata PathInfoOptions = PathInfoOptions\n  { pioIsRecursive :: Bool,\n    pioIsDerivation :: Bool,\n    pioIsImpure :: Bool,\n    pioStoreURL :: Maybe FilePath,\n    pioFile :: Maybe FilePath\n  }\n\ngetPathInfo :: NixStore -> NixVersion -> PathInfoOptions -> NonEmpty Installable -> IO (NonEmpty (StorePath StoreName ()))\ngetPathInfo nixStore nixVersion options names = do\n  infos <-\n    eitherDecode @NixPathOutput\n      <$> readProcessStdout_\n        ( proc\n            \"nix\"\n            ( [\"path-info\", \"--json\"]\n                ++ [\"--impure\" | options & pioIsImpure]\n                ++ [\"--recursive\" | options & pioIsRecursive]\n                ++ [\"--derivation\" | (options & pioIsDerivation) && nixVersion >= Nix2_4]\n                ++ ( case options & pioStoreURL of\n                       Nothing -> []\n                       Just url -> [\"--store\", url]\n                   )\n                ++ ( case options & pioFile of\n                       Nothing -> []\n                       Just file -> [\"--file\", file]\n                   )\n                ++ (if nixVersion >= Nix2_4 then [\"--extra-experimental-features\", \"nix-command flakes\"] else [])\n                ++ map (toString . installableToText) (toList names)\n            )\n        )\n      >>= either (\\e -> fail $ \"Failed parsing nix path-info output: \" ++ show e) return\n      >>= mapM assertValidInfo . npoResults\n      >>= maybe (fail \"invariant violation: getPathInfo returned []\") return . nonEmpty\n\n  mapM infoToStorePath infos\n  where\n    infoToStorePath NixPathInfo {npiPath, npiNarSize, npiReferences, npiSignatures} = do\n      name <- mkStoreNameIO npiPath\n      refs <- filter (/= name) <$> mapM mkStoreNameIO npiReferences\n      return $\n        StorePath\n          { spName = name,\n            spRefs = refs,\n            spSize = npiNarSize,\n            spSignatures = npiSignatures,\n            spPayload = ()\n          }\n    mkStoreNameIO p =\n      maybe\n        (fail $ \"Failed parsing Nix store path: \" ++ show p)\n        return\n        (mkStoreName nixStore p)\n\n    assertValidInfo (NixPathInfoValid pathinfo) = return pathinfo\n    assertValidInfo (NixPathInfoInvalid path) =\n      fail $ \"Invalid path: \" ++ path ++ \". Make sure that it is built, or pass '--derivation' if you want to work on the derivation.\"\n\n--------------------------------------------------------------------------------\n\ndata StoreEnv payload = StoreEnv\n  { sePaths :: HashMap StoreName (StorePath StoreName payload),\n    seRoots :: NonEmpty StoreName\n  }\n  deriving (Functor, Generic, NFData)\n\ndata StoreEnvOptions = StoreEnvOptions\n  { seoIsDerivation :: Bool,\n    seoIsImpure :: Bool,\n    seoStoreURL :: Maybe String,\n    seoFile :: Maybe String\n  }\n\nwithStoreEnv ::\n  forall m a.\n  (MonadIO m) =>\n  StoreEnvOptions ->\n  NonEmpty Installable ->\n  (StoreEnv () -> m a) ->\n  m a\nwithStoreEnv StoreEnvOptions {seoIsDerivation, seoIsImpure, seoStoreURL, seoFile} names cb = do\n  nixStore <- liftIO $ getStoreDir seoStoreURL\n\n  -- See: https://github.com/utdemir/nix-tree/issues/12\n  nixVersion <- liftIO getNixVersion\n\n  when (seoIsDerivation && nixVersion < Nix2_4) $\n    liftIO $\n      hPutStrLn stderr \"Warning: --derivation flag is ignored on Nix versions older than 2.4.\"\n\n  roots <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = False, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        names\n\n  paths <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = True, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        (Installable . toText . storeNameToPath . spName <$> roots)\n\n  let env =\n        StoreEnv\n          ( paths\n              & toList\n              & map (\\p@StorePath {spName} -> (spName, p))\n              & HM.fromList\n          )\n          (roots <&> spName)\n  cb env\n\nseLookup :: StoreEnv a -> StoreName -> StorePath StoreName a\nseLookup StoreEnv {sePaths} name =\n  fromMaybe\n    (error $ \"invariant violation, StoreName not found: \" <> show name)\n    (HM.lookup name sePaths)\n\nseAll :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseAll StoreEnv {sePaths} = case HM.elems sePaths of\n  [] -> error \"invariant violation: no paths\"\n  (x : xs) -> x :| xs\n\nseGetRoots :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseGetRoots env@StoreEnv {seRoots} =\n  fmap (seLookup env) seRoots\n\nseFetchRefs ::\n  StoreEnv a ->\n  (StoreName -> Bool) ->\n  NonEmpty StoreName ->\n  [StorePath StoreName a]\nseFetchRefs env predicate =\n  fst\n    . foldl'\n      (\\(acc, visited) name -> go acc visited name)\n      ([], HS.empty)\n  where\n    go acc visited name\n      | HS.member name visited = (acc, visited)\n      | not (predicate name) = (acc, visited)\n      | otherwise =\n          let sp@StorePath {spRefs} = seLookup env name\n           in foldl'\n                (\\(acc', visited') name' -> go acc' visited' name')\n                (sp : acc, HS.insert name visited)\n                spRefs\n\nseBottomUp ::\n  forall a b.\n  (StorePath (StorePath StoreName b) a -> b) ->\n  StoreEnv a ->\n  StoreEnv b\nseBottomUp f StoreEnv {sePaths, seRoots} =\n  StoreEnv\n    { sePaths = snd $ execState (mapM_ go seRoots) (sePaths, HM.empty),\n      seRoots\n    }\n  where\n    unsafeLookup k m =\n      fromMaybe\n        (error $ \"invariant violation: name doesn't exists: \" <> show k)\n        (HM.lookup k m)\n    go ::\n      StoreName ->\n      State\n        ( HashMap StoreName (StorePath StoreName a),\n          HashMap StoreName (StorePath StoreName b)\n        )\n        (StorePath StoreName b)\n    go name = do\n      processed <- gets snd\n      case name `HM.lookup` processed of\n        Just sp -> return sp\n        Nothing -> do\n          sp@StorePath {spName, spRefs} <- unsafeLookup name <$> gets fst\n          refs <- mapM go spRefs\n          let new = sp {spPayload = f sp {spRefs = refs}}\n          modify $ bimap (HM.delete spName) (HM.insert spName new)\n          return new\n\n--------------------------------------------------------------------------------\n\nstoreEnvToDot :: StoreEnv a -> Text\nstoreEnvToDot env =\n  seBottomUp go env\n    & seGetRoots\n    & toList\n    & map spPayload\n    & mconcat\n    & render\n  where\n    go sp =\n      fromList [Set.singleton (spName sp, spName ref) <> spPayload ref | ref <- spRefs sp]\n        & mconcat\n\n    render :: Set (StoreName, StoreName) -> Text\n    render edges =\n      Dot.DotGraph\n        Dot.Strict\n        Dot.Directed\n        Nothing\n        [ Dot.StatementEdge\n            ( Dot.EdgeStatement\n                (Dot.ListTwo (Dot.EdgeNode (mkNodeId from)) (Dot.EdgeNode (mkNodeId to)) [])\n                []\n            )\n          | (from, to) <- toList edges\n        ]\n        & Dot.encode\n\n    mkNodeId :: StoreName -> Dot.NodeId\n    mkNodeId = fromString . toString . storeNameToShortText\n\n--------------------------------------------------------------------------------\n\ndata NixPathInfo = NixPathInfo\n  { npiPath :: FilePath,\n    npiNarSize :: Int,\n    npiReferences :: [FilePath],\n    npiSignatures :: [NixPathSignature]\n  }\n\ndata NixPathSignature = NixPathSignature\n  { npsKeyName :: Text,\n    npsSignature :: Text\n  }\n  deriving (Show, Eq, Ord, NFData, Generic)\n\ninstance FromJSON NixPathSignature where\n  parseJSON (String t) =\n    case T.splitOn \":\" t of\n      [key, sig]\n        | not (T.null key) && not (T.null sig) ->\n            return $ NixPathSignature key sig\n      _ -> fail \"Expecting a string in the form of 'key:sig'.\"\n  parseJSON _ = fail \"Expecting a string.\"\n\ndata NixPathInfoResult\n  = NixPathInfoValid NixPathInfo\n  | NixPathInfoInvalid FilePath\n\nparse2_18 :: Value -> Parser NixPathInfoResult\nparse2_18 (Object obj) =\n  ( NixPathInfoValid\n      <$> ( NixPathInfo\n              <$> obj .: \"path\"\n              <*> obj .: \"narSize\"\n              <*> obj .: \"references\"\n              <*> (obj .:? \"signatures\" .!= [])\n          )\n  )\n    <|> ( do\n            path <- obj .: \"path\"\n            valid <- obj .: \"valid\"\n            guard (not valid)\n            return $ NixPathInfoInvalid path\n        )\nparse2_18 _ = fail \"Expecting an object.\"\n\nparse2_19 :: (FilePath, Value) -> Parser NixPathInfoResult\nparse2_19 (path, Object obj) =\n  NixPathInfoValid\n    <$> ( NixPathInfo\n            path\n            <$> obj .: \"narSize\"\n            <*> obj .: \"references\"\n            <*> (obj .:? \"signatures\" .!= [])\n        )\nparse2_19 (path, Null) = return $ NixPathInfoInvalid path\nparse2_19 (_, _) = fail \"Expecting an object or null\"\n\nnewtype NixPathOutput = NixPathOutput\n  { npoResults :: [NixPathInfoResult]\n  }\n\ninstance FromJSON NixPathOutput where\n  parseJSON (Array a) = NixPathOutput <$> mapM parse2_18 (toList a)\n  parseJSON (Object o) = NixPathOutput <$> mapM (parse2_19 . first K.toString) (KM.toList o)\n  parseJSON _ = fail \"Expecting an array (nix<=2.18) or an object with mapping from path to info (nix>=2.19).\"\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/NixTree/StorePath.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/NixTree/StorePath.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/NixTree/StorePath.hs"
          }
        },
        {
          "file_name": "/tmp/project_92/pre_refactor/src/Data/InvertedIndex.hs",
          "cyclomatic_complexity": {
            "min": 1,
            "max": 4,
            "average": 2,
            "sum": 12
          },
          "hlint_suggestions": {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "ignore": 0,
            "total": 0
          },
          "syntax_errors": 1,
          "lines_of_code": 76,
          "homplexity_lines_of_code": 76,
          "code_quality_score": 68.4,
          "test_coverage": 80,
          "performance": {
            "memory_usage": "10MB",
            "runtime": "0.5s"
          },
          "security_vulnerabilities": 0,
          "homplexity_analysis": {
            "cyclomatic_complexity": {
              "min": 1,
              "max": 4,
              "average": 2,
              "sum": 12
            },
            "homplexity_loc": 76,
            "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"iiInsert\": 1,\n        \"iiFromList\": 1,\n        \"setToMap\": 1,\n        \"unigramsOf\": 1,\n        \"bigramsOf\": 2,\n        \"trigramsOf\": 2,\n        \"iiSearch\": 4,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 1.7142857142857142,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 76,\n    \"homplexity_output\": \"\"\n}"
          },
          "original_code": "module Data.InvertedIndex\n  ( InvertedIndex,\n    iiFromList,\n    iiInsert,\n    iiSearch,\n  )\nwhere\n\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport qualified Data.Text as Text\n\ndata InvertedIndex a = InvertedIndex\n  { iiElems :: Map Text a,\n    iiUnigrams :: Map Char (Set Text),\n    iiBigrams :: Map (Char, Char) (Set Text),\n    iiTrigrams :: Map (Char, Char, Char) (Set Text)\n  }\n  deriving (Generic, Show)\n\ninstance (NFData a) => NFData (InvertedIndex a)\n\niiInsert :: Text -> a -> InvertedIndex a -> InvertedIndex a\niiInsert txt val InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams} =\n  InvertedIndex\n    { iiElems = Map.insert txt val iiElems,\n      iiUnigrams = combine iiUnigrams (unigramsOf txt),\n      iiBigrams = combine iiBigrams (bigramsOf txt),\n      iiTrigrams = combine iiTrigrams (trigramsOf txt)\n    }\n  where\n    combine orig chrs =\n      Map.unionWith\n        (<>)\n        orig\n        (setToMap (Set.singleton txt) chrs)\n\niiFromList :: (Foldable f) => f (Text, a) -> InvertedIndex a\niiFromList =\n  foldl'\n    (flip (uncurry iiInsert))\n    (InvertedIndex Map.empty Map.empty Map.empty Map.empty)\n\nsetToMap :: v -> Set k -> Map k v\nsetToMap v = Map.fromDistinctAscList . map (,v) . Set.toAscList\n\nunigramsOf :: Text -> Set Char\nunigramsOf = Set.fromList . Text.unpack . Text.toLower\n\nbigramsOf :: Text -> Set (Char, Char)\nbigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2) -> Set.fromList $ zip p1 p2\n  _ -> Set.empty\n\ntrigramsOf :: Text -> Set (Char, Char, Char)\ntrigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2@(_ : p3)) -> Set.fromList $ zip3 p1 p2 p3\n  _ -> Set.empty\n\niiSearch :: forall a. Text -> InvertedIndex a -> Map Text a\niiSearch txt InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams}\n  | Text.length txt == 0 = iiElems\n  | Text.length txt == 1 = using unigramsOf iiUnigrams\n  | Text.length txt == 2 = using bigramsOf iiBigrams\n  | otherwise = using trigramsOf iiTrigrams\n  where\n    lowerTxt = Text.toLower txt\n    using :: (Ord c) => (Text -> Set c) -> Map c (Set Text) -> Map Text a\n    using getGrams m =\n      Map.intersection m (setToMap () (getGrams txt))\n        & Map.elems\n        & \\case\n          [] -> Set.empty\n          x : xs -> foldl' Set.intersection x xs\n        & Set.filter (\\t -> lowerTxt `Text.isInfixOf` Text.toLower t)\n        & Map.restrictKeys iiElems\n",
          "suggestions": [],
          "refactored_code": {
            "static_refactored_file": "/tmp/project_92/static_refactored/src/Data/InvertedIndex.hs",
            "llm_only_refactored_file": "/tmp/project_92/llm_only_refactored/src/Data/InvertedIndex.hs",
            "hybrid_refactored_file": "/tmp/project_92/hybrid_refactored/src/Data/InvertedIndex.hs"
          }
        }
      ]
    },
    "post_refactor": {
      "static": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 8,
              "max": 64,
              "average": 25.0,
              "sum": 200
            },
            "hlint_suggestions": {
              "error": 0,
              "warning": 1,
              "suggestion": 4,
              "ignore": 0,
              "total": 5
            },
            "syntax_errors": 37,
            "lines_of_code": 1609,
            "homplexity_lines_of_code": 1620,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "150MB",
              "runtime": "2.3s"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_92/pre_refactor/test/Test.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/test/Test.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 1
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 3,
              "lines_of_code": 11,
              "homplexity_lines_of_code": 9,
              "code_quality_score": 97.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 1
                },
                "homplexity_loc": 9,
                "homplexity_output": "Info:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 3 1: module Main has 7 lines of code \nInfo:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 9 1: type signature for main has type constructor nesting of 1 \nInfo:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 9 1: type signature for main has 1 arguments \nInfo:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 10 1: function main has 2 lines of code \nInfo:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 10 1: function main has cyclomatic complexity of 1 \nInfo:/tmp/project_92/static_refactored/test/Test.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test.hs\" 10 1: function main has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Main where\n\nimport Hedgehog\nimport Hedgehog.Main\nimport qualified Test.Data.InvertedIndex\n\nmain :: IO ()\nmain =\n  defaultMain . map checkParallel $\n    [Test.Data.InvertedIndex.tests]\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/test/Test.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "\n\nmodule Main where\n\nimport Hedgehog\nimport Hedgehog.Main\nimport qualified Test.Data.InvertedIndex\n\nmain :: IO ()\nmain =\n  defaultMain [checkParallel Test.Data.InvertedIndex.tests]\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 1,
                "average": 1.0,
                "sum": 2
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 6,
              "lines_of_code": 38,
              "homplexity_lines_of_code": 48,
              "code_quality_score": 91.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 1,
                  "average": 1.0,
                  "sum": 2
                },
                "homplexity_loc": 48,
                "homplexity_output": "Info:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 1 1: module Test.Data.InvertedIndex has 29 lines of code \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 12 1: type signature for prop_inverted_index has type constructor nesting of 0 \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 12 1: type signature for prop_inverted_index has 1 arguments \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has 18 lines of code \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has cyclomatic complexity of 1 \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 13 1: function prop_inverted_index has branching depth of 0 \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 37 1: type signature for tests has type constructor nesting of 0 \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 37 1: type signature for tests has 1 arguments \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 38 1: function tests has cyclomatic complexity of 1 \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 38 1: function tests has 1 lines of code \nInfo:/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs:SrcLoc \"/tmp/project_92/static_refactored/test/Test/Data/InvertedIndex.hs\" 38 1: function tests has branching depth of 0 \n"
              },
              "original_code": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Test.Data.InvertedIndex (tests) where\n\nimport Data.InvertedIndex\nimport qualified Data.Map as Map\nimport qualified Data.Text as Text\nimport Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\n\nprop_inverted_index :: Property\nprop_inverted_index = withDiscards 10000 . withTests 10000 . property $ do\n  haystack <-\n    forAll $\n      Gen.map\n        (Range.linear 0 100)\n        ( (,)\n            <$> Gen.text (Range.linear 0 10) Gen.alphaNum\n            <*> Gen.int (Range.linear 0 100)\n        )\n\n  needle <-\n    forAll $\n      (Gen.text (Range.linear 0 5) Gen.alphaNum)\n\n  let ii = iiFromList (Map.toList haystack)\n  annotateShow ii\n\n  let expected =\n        haystack\n          & Map.filterWithKey\n            (\\t _ -> Text.toLower needle `Text.isInfixOf` Text.toLower t)\n      actual = iiSearch needle ii\n\n  expected === actual\n\ntests :: Group\ntests = $$(discover)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/test/Test/Data/InvertedIndex.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE TemplateHaskell #-}\n\nmodule Test.Data.InvertedIndex (tests) where\n\nimport Data.InvertedIndex\nimport qualified Data.Map as Map\nimport qualified Data.Text as Text\nimport Hedgehog\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\n\nprop_inverted_index :: Property\nprop_inverted_index = withDiscards 10000 . withTests 10000 . property $ do\n  haystack <-\n    forAll $\n      Gen.map\n        (Range.linear 0 100)\n        ( (,)\n            <$> Gen.text (Range.linear 0 10) Gen.alphaNum\n            <*> Gen.int (Range.linear 0 100)\n        )\n\n  needle <-\n    forAll (Gen.text (Range.linear 0 5) Gen.alphaNum)\n\n  let ii = iiFromList (Map.toList haystack)\n  annotateShow ii\n\n  let expected =\n        haystack\n          & Map.filterWithKey\n            (\\t _ -> Text.toLower needle `Text.isInfixOf` Text.toLower t)\n      actual = iiSearch needle ii\n\n  expected === actual\n\ntests :: Group\ntests = $$discover\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/App.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/NixTree/App.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 34,
                "average": 3,
                "sum": 81
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 2,
              "lines_of_code": 621,
              "homplexity_lines_of_code": 621,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 34,
                  "average": 3,
                  "sum": 81
                },
                "homplexity_loc": 621,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"succCycle\": 2,\n    \"compareBySortOrder\": 3,\n    \"run\": 1,\n    \"renderList\": 4,\n    \"app\": 34,\n    \"yankToClipboard\": 2,\n    \"timePassedSinceSortOrderChange\": 1,\n    \"renderMainScreen\": 2,\n    \"renderInfoPane\": 4,\n    \"renderModal\": 1,\n    \"helpText\": 1,\n    \"renderNotice\": 1,\n    \"renderWhyDependsModal\": 1,\n    \"showWhyDepends\": 1,\n    \"renderSearchModal\": 1,\n    \"showAndUpdateSearch\": 1,\n    \"move\": 1,\n    \"moveF\": 1,\n    \"moveLeft\": 2,\n    \"moveRight\": 2,\n    \"repopulateNextPane\": 1,\n    \"sortPane\": 1,\n    \"sortPanes\": 1,\n    \"selectedPath\": 1,\n    \"selectedPaths\": 2,\n    \"selectPath\": 3,\n    \"mkList\": 1,\n    \"prettySize\": 5,\n    \"min\": 1,\n    \"max\": 34,\n    \"average\": 2.89,\n    \"sum\": 81\n  },\n  \"homplexity_loc\": 621,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.App (run, helpText) where\n\nimport qualified Brick as B\nimport qualified Brick.BChan as B\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Center as B\nimport qualified Brick.Widgets.List as B\nimport Control.Concurrent\nimport Data.InvertedIndex\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map as Map\nimport qualified Data.Sequence as S\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Graphics.Vty as V\nimport Lens.Micro (Traversal', _Just)\nimport qualified NixTree.Clipboard as Clipboard\nimport NixTree.PathStats\nimport qualified System.Clock as Clock\nimport qualified System.HrfSize as HRF\n\nsortOrderChangeHighlightPeriod :: Clock.TimeSpec\nsortOrderChangeHighlightPeriod = Clock.TimeSpec 0 (500 * 1_000_000)\n\ndata Event\n  = EventTick Clock.TimeSpec\n\ndata Widgets\n  = WidgetPrevPane\n  | WidgetCurrPane\n  | WidgetNextPane\n  | WidgetWhyDepends\n  | WidgetSearch\n  | WidgetWhyDependsViewport\n  deriving (Show, Eq, Ord)\n\ndata Notice = Notice Text Text\n\ndata Modal s\n  = ModalNotice Notice\n  | ModalWhyDepends (B.GenericList Widgets Seq (NonEmpty Path))\n  | ModalSearch Text Text (B.GenericList Widgets Seq Path)\n\nsuccCycle :: forall a. (Bounded a, Enum a) => a -> a\nsuccCycle a\n  | fromEnum a == fromEnum (maxBound @a) = minBound\n  | otherwise = succ a\n\ndata AppEnv s = AppEnv\n  { aeActualStoreEnv :: StoreEnv PathStats,\n    aeInvertedIndex :: InvertedIndex Path,\n    aePrevPane :: List,\n    aeCurrPane :: List,\n    aeNextPane :: List,\n    aeParents :: [List],\n    aeOpenModal :: Maybe (Modal s),\n    aeSortOrder :: SortOrder,\n    aeSortOrderLastChanged :: Clock.TimeSpec,\n    aeCurrTime :: Clock.TimeSpec\n  }\n\ntype Path = StorePath StoreName PathStats\n\ntype List = B.GenericList Widgets Seq Path\n\ndata SortOrder\n  = SortOrderAlphabetical\n  | SortOrderClosureSize\n  | SortOrderAddedSize\n  deriving (Show, Eq, Enum, Bounded)\n\nB.suffixLenses ''AppEnv\n\n_ModalWhyDepends :: Traversal' (Modal s) (B.GenericList Widgets Seq (NonEmpty Path))\n_ModalWhyDepends f m = case m of\n  ModalWhyDepends l -> ModalWhyDepends <$> f l\n  _ -> pure m\n\ncompareBySortOrder :: SortOrder -> Path -> Path -> Ordering\ncompareBySortOrder SortOrderAlphabetical = compare `on` T.toLower . storeNameToShortText . spName\ncompareBySortOrder SortOrderClosureSize = compare `on` Down . psTotalSize . spPayload\ncompareBySortOrder SortOrderAddedSize = compare `on` Down . psAddedSize . spPayload\n\nattrTerminal, attrUnderlined :: B.AttrName\nattrTerminal = B.attrName \"terminal\"\nattrUnderlined = B.attrName \"underlined\"\n\nrun :: StoreEnv PathStats -> IO ()\nrun env = do\n  -- Create the inverted index, and start evaluating it in the background\n  let ii = iiFromList . toList . fmap (\\sp -> (storeNameToText (spName sp), sp)) $ seAll env\n  _ <- forkIO $ evaluateNF_ ii\n\n  -- Initial state\n  let getTime = Clock.getTime Clock.Monotonic\n  currTime <- getTime\n  let defaultSortOrder = SortOrderClosureSize\n\n  let appEnv =\n        AppEnv\n          { aeActualStoreEnv =\n              env,\n            aeInvertedIndex =\n              ii,\n            aePrevPane =\n              B.list WidgetPrevPane S.empty 0,\n            aeCurrPane =\n              B.list\n                WidgetCurrPane\n                (S.fromList . sortBy (compareBySortOrder defaultSortOrder) . NE.toList $ seGetRoots env)\n                0,\n            aeNextPane =\n              B.list WidgetNextPane S.empty 0,\n            aeParents =\n              [],\n            aeOpenModal =\n              Nothing,\n            aeSortOrder =\n              defaultSortOrder,\n            aeSortOrderLastChanged =\n              Clock.TimeSpec 0 0,\n            aeCurrTime =\n              currTime\n          }\n          & repopulateNextPane\n\n  -- Create a channel that's fed by current time\n  chan <- B.newBChan 10\n  void . forkIO $\n    forever $ do\n      threadDelay (100 * 1000)\n      t <- getTime\n      _ <- B.writeBChanNonBlocking chan (EventTick t)\n      return ()\n\n  -- And run the application\n  (_, vty) <- B.customMainWithDefaultVty (Just chan) app appEnv\n  V.shutdown vty\n\n  return ()\n\nrenderList ::\n  Maybe SortOrder ->\n  Bool ->\n  List ->\n  B.Widget Widgets\nrenderList highlightSort =\n  B.renderList\n    ( \\_\n       StorePath\n         { spName,\n           spPayload = PathStats {psTotalSize, psAddedSize, psDisambiguationChars},\n           spRefs,\n           spSignatures\n         } ->\n          let color =\n                if null spRefs\n                  then B.withAttr attrTerminal\n                  else identity\n           in color $\n                B.hBox\n                  [ if null spSignatures\n                      then B.txt \"  \"\n                      else B.txt \"\u2713 \",\n                    B.txt (storeNameToShortTextWithDisambiguation psDisambiguationChars spName)\n                      & underlineWhen SortOrderAlphabetical\n                      & B.padRight (B.Pad 1)\n                      & B.padRight B.Max,\n                    if null spRefs\n                      then\n                        B.txt (prettySize psTotalSize)\n                          & underlineWhen SortOrderClosureSize\n                          & underlineWhen SortOrderAddedSize\n                      else\n                        B.hBox\n                          [ B.txt (prettySize psTotalSize)\n                              & underlineWhen SortOrderClosureSize,\n                            B.txt \" (\",\n                            B.txt (prettySize psAddedSize)\n                              & underlineWhen SortOrderAddedSize,\n                            B.txt \")\"\n                          ]\n                  ]\n    )\n  where\n    underlineWhen so =\n      if Just so == highlightSort\n        then B.withDefAttr attrUnderlined\n        else identity\n\napp :: B.App (AppEnv s) Event Widgets\napp =\n  B.App\n    { B.appDraw = \\env@AppEnv {aeOpenModal} ->\n        [ case aeOpenModal of\n            Nothing -> B.emptyWidget\n            Just (ModalWhyDepends l) -> renderWhyDependsModal l\n            Just (ModalSearch l r xs) -> renderSearchModal l r xs\n            Just (ModalNotice notice) -> renderNotice notice,\n          renderMainScreen env\n        ],\n      B.appChooseCursor = \\_ _ -> Nothing,\n      B.appHandleEvent = \\e -> do\n        s <- get\n        case (e, aeOpenModal s) of\n          -- main screen\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                B.halt\n          (B.VtyEvent (V.EvKey (V.KChar '?') []), Nothing) ->\n            put s {aeOpenModal = Just (ModalNotice helpNotice)}\n          (B.VtyEvent (V.EvKey (V.KChar 'w') []), Nothing) -> do\n            B.hScrollToBeginning (B.viewportScroll WidgetWhyDependsViewport)\n            modify showWhyDepends\n          (B.VtyEvent (V.EvKey (V.KChar '/') []), Nothing) ->\n            modify $ showAndUpdateSearch \"\" \"\"\n          (B.VtyEvent (V.EvKey (V.KChar 'y') []), Nothing) -> do\n            liftIO (yankToClipboard $ spName (selectedPath s))\n              >>= \\case\n                Right () -> return ()\n                Left n -> put s {aeOpenModal = Just (ModalNotice n)}\n          (B.VtyEvent (V.EvKey (V.KChar 's') []), Nothing) ->\n            put $\n              s\n                { aeSortOrder = succCycle (aeSortOrder s),\n                  aeSortOrderLastChanged = aeCurrTime s\n                }\n                & sortPanes\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                modify moveLeft\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                move B.listMoveDown\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                move B.listMoveUp\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                modify moveRight\n          (B.VtyEvent (V.EvKey V.KPageUp []), Nothing) ->\n            moveF B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Nothing) ->\n            moveF B.listMovePageDown\n          -- why-depends modal\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) (-1)\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveDown l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveUp l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) 1\n          (B.VtyEvent (V.EvKey V.KPageUp []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageDown\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalWhyDepends l)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement l of\n                  Nothing -> put closed\n                  Just (_, path) -> put $ selectPath path closed\n          -- search modal\n          (B.VtyEvent (V.EvKey V.KEsc []), Just (ModalSearch {})) ->\n            put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveDown xs)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveUp xs)}\n          (B.VtyEvent (V.EvKey V.KLeft []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (T.dropEnd 1 l) (T.takeEnd 1 l <> r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey V.KRight []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (l <> T.take 1 r) (T.drop 1 r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey (V.KChar c) []), Just (ModalSearch l r _))\n            | c `Set.member` allowedSearchChars ->\n                modify (showAndUpdateSearch (l <> T.singleton c) r)\n          (B.VtyEvent (V.EvKey V.KBS []), Just (ModalSearch l r _)) ->\n            modify (showAndUpdateSearch (T.dropEnd 1 l) r)\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalSearch _ _ xs)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement xs of\n                  Nothing -> put closed\n                  Just (_, path) ->\n                    put $\n                      selectPath\n                        (shortestPathTo (aeActualStoreEnv s) (spName path))\n                        closed\n          -- notices\n          (B.VtyEvent (V.EvKey k []), Just (ModalNotice _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          -- handle our events\n          (B.AppEvent (EventTick t), _) ->\n            let new = s {aeCurrTime = t}\n             in do\n                  put new\n                  unless (timePassedSinceSortOrderChange new <= sum (replicate 2 sortOrderChangeHighlightPeriod)) B.continueWithoutRedraw\n          -- ignore otherwise\n          _ ->\n            return (),\n      B.appStartEvent = return (),\n      B.appAttrMap = \\_ ->\n        B.attrMap\n          V.defAttr\n          [ (B.listSelectedFocusedAttr, V.currentAttr `V.withStyle` V.reverseVideo),\n            (attrTerminal, B.fg V.blue),\n            (attrUnderlined, V.currentAttr `V.withStyle` V.underline)\n          ]\n    }\n  where\n    allowedSearchChars :: Set Char\n    allowedSearchChars =\n      Set.fromList\n        ( mconcat\n            [ ['a' .. 'z'],\n              ['A' .. 'Z'],\n              ['0' .. '9'],\n              \"+-.=?_\"\n            ]\n        )\n\nyankToClipboard :: StoreName -> IO (Either Notice ())\nyankToClipboard p =\n  Clipboard.copy (toText $ storeNameToPath p)\n    <&> \\case\n      Right () -> Right ()\n      Left errs ->\n        Left $\n          Notice\n            \"Error\"\n            ( T.intercalate \"\\n\" $\n                \"Cannot copy to clipboard: \"\n                  : map (\"  \" <>) errs\n                  ++ [\"Please report this as a bug.\"]\n            )\n\ntimePassedSinceSortOrderChange :: AppEnv s -> Clock.TimeSpec\ntimePassedSinceSortOrderChange env = Clock.diffTimeSpec (aeCurrTime env) (aeSortOrderLastChanged env)\n\nrenderMainScreen :: AppEnv s -> B.Widget Widgets\nrenderMainScreen env@AppEnv {aePrevPane, aeCurrPane, aeNextPane} =\n  (B.joinBorders . B.border)\n    ( B.hBox\n        [ renderList Nothing True aePrevPane,\n          B.vBorder,\n          renderList shouldHighlightSortOrder True aeCurrPane,\n          B.vBorder,\n          renderList Nothing False aeNextPane\n        ]\n    )\n    B.<=> renderInfoPane env\n  where\n    shouldHighlightSortOrder =\n      if timePassedSinceSortOrderChange env < sortOrderChangeHighlightPeriod\n        then Just (aeSortOrder env)\n        else Nothing\n\nrenderInfoPane :: AppEnv s -> B.Widget Widgets\nrenderInfoPane env =\n  let selected = selectedPath env\n      immediateParents = psImmediateParents $ spPayload selected\n      signatures = spSignatures selected\n   in B.vBox\n        [ let (f, s) = storeNameToSplitShortText (spName selected)\n           in B.txt f B.<+> underlineWhen SortOrderAlphabetical (B.txt s),\n          [ B.txt $ \"NAR Size: \" <> prettySize (spSize selected),\n            underlineWhen SortOrderClosureSize . B.txt $ \"Closure Size: \" <> prettySize (psTotalSize $ spPayload selected),\n            underlineWhen SortOrderAddedSize . B.txt $ \"Added Size: \" <> prettySize (psAddedSize $ spPayload selected)\n          ]\n            & intersperse (B.txt \" | \")\n            & B.hBox,\n          B.txt $\n            \"Signatures: \"\n              <> if null signatures\n                then \"\u2717\"\n                else\n                  ( signatures\n                      & map npsKeyName\n                      & T.intercalate \", \"\n                  ),\n          B.txt $\n            if null immediateParents\n              then \"Immediate Parents: -\"\n              else\n                \"Immediate Parents (\"\n                  <> T.pack (show $ length immediateParents)\n                  <> \"): \"\n                  <> T.intercalate \", \" (map storeNameToShortText immediateParents)\n        ]\n  where\n    underlineWhen so =\n      if so == aeSortOrder env\n        then B.withAttr attrUnderlined\n        else identity\n\nrenderModal :: Text -> B.Widget a -> B.Widget a\nrenderModal title widget =\n  widget\n    & B.borderWithLabel (B.txt title)\n    & B.hLimitPercent 90\n    & B.vLimitPercent 60\n    & B.centerLayer\n\nhelpText :: Text\nhelpText =\n  T.intercalate\n    \"\\n\"\n    [ \"hjkl/Arrow Keys : Navigate\",\n      \"w               : Open why-depends modal\",\n      \"/               : Open search modal\",\n      \"s               : Change sort order\",\n      \"y               : Yank selected path to clipboard\",\n      \"?               : Show help\",\n      \"q/Esc           : Quit / close modal\"\n    ]\n\nhelpNotice :: Notice\nhelpNotice = Notice \"Help\" helpText\n\nrenderNotice :: Notice -> B.Widget a\nrenderNotice (Notice title txt) = renderModal title (B.txt txt)\n\nrenderWhyDependsModal ::\n  B.GenericList Widgets Seq (NonEmpty Path) ->\n  B.Widget Widgets\nrenderWhyDependsModal l =\n  B.renderList renderDepends True l\n    & B.hLimitPercent 100 -- This limit seems pointless, but otherwise render list takes infinite\n    -- amount of horizontal space and 'viewport' below complains.\n    & B.viewport WidgetWhyDependsViewport B.Horizontal\n    & renderModal \"why-depends\"\n  where\n    renderDepends _ =\n      B.txt . pathsToText\n    pathsToText xs =\n      xs\n        & NE.toList\n        & fmap (storeNameToShortText . spName)\n        & T.intercalate \" \u2192 \"\n\nshowWhyDepends :: AppEnv s -> AppEnv s\nshowWhyDepends env@AppEnv {aeActualStoreEnv} =\n  env\n    { aeOpenModal =\n        Just . ModalWhyDepends $\n          let selected = selectedPath env\n              route = selectedPaths env\n              xs = S.fromList $ whyDepends aeActualStoreEnv (spName selected)\n           in B.list WidgetWhyDepends xs 1\n                & B.listMoveTo\n                  (fromMaybe 0 $ ((==) `on` fmap spName) route `S.findIndexL` xs)\n    }\n\nrenderSearchModal :: Text -> Text -> B.GenericList Widgets Seq Path -> B.Widget Widgets\nrenderSearchModal left right l =\n  renderModal \"Search\" window\n  where\n    window =\n      B.txt left\n        B.<+> B.txt \"|\"\n        B.<+> B.txt right\n        B.<=> B.hBorder\n        B.<=> renderList Nothing True l\n\nshowAndUpdateSearch :: Text -> Text -> AppEnv s -> AppEnv s\nshowAndUpdateSearch left right env@AppEnv {aeInvertedIndex} =\n  env {aeOpenModal = Just $ ModalSearch left right results}\n  where\n    results =\n      let xs =\n            iiSearch (left <> right) aeInvertedIndex\n              & Map.elems\n              & S.fromList\n       in B.list WidgetSearch xs 1\n\nmove :: (List -> List) -> B.EventM n (AppEnv s) ()\nmove = moveF . modify\n\nmoveF :: B.EventM n List () -> B.EventM n (AppEnv s) ()\nmoveF f = do\n  B.zoom aeCurrPaneL f\n  modify repopulateNextPane\n\nmoveLeft :: AppEnv s -> AppEnv s\nmoveLeft env@AppEnv {aeParents = []} = env\nmoveLeft env@AppEnv {aePrevPane, aeCurrPane, aeParents = parent : grandparents} =\n  env\n    { aeParents = grandparents,\n      aePrevPane = parent,\n      aeCurrPane = aePrevPane {B.listName = WidgetCurrPane},\n      aeNextPane = aeCurrPane {B.listName = WidgetNextPane}\n    }\n\nmoveRight :: AppEnv s -> AppEnv s\nmoveRight env@AppEnv {aePrevPane, aeCurrPane, aeNextPane, aeParents}\n  | null (B.listElements aeNextPane) = env\n  | otherwise =\n      env\n        { aePrevPane = aeCurrPane {B.listName = WidgetPrevPane},\n          aeCurrPane = aeNextPane {B.listName = WidgetCurrPane},\n          aeParents = aePrevPane : aeParents\n        }\n        & repopulateNextPane\n\nrepopulateNextPane :: AppEnv s -> AppEnv s\nrepopulateNextPane env@AppEnv {aeActualStoreEnv, aeNextPane, aeSortOrder} =\n  let ref = selectedPath env\n   in env\n        { aeNextPane =\n            B.listReplace\n              ( S.sortBy (compareBySortOrder aeSortOrder)\n                  . S.fromList\n                  . map (seLookup aeActualStoreEnv)\n                  $ spRefs ref\n              )\n              (Just 0)\n              aeNextPane\n        }\n\nsortPane :: SortOrder -> List -> List\nsortPane so l =\n  let selected = B.listSelectedElement l\n      elems =\n        B.listElements l\n          & S.sortBy (compareBySortOrder so)\n      name = B.getName l\n   in mkList so name elems (snd <$> selected)\n\nsortPanes :: AppEnv s -> AppEnv s\nsortPanes env@AppEnv {aeParents, aePrevPane, aeCurrPane, aeNextPane, aeSortOrder} =\n  env\n    { aeCurrPane = sortPane aeSortOrder aeCurrPane,\n      aeNextPane = sortPane aeSortOrder aeNextPane,\n      aeParents = sortPane aeSortOrder <$> aeParents,\n      aePrevPane = sortPane aeSortOrder aePrevPane\n    }\n\nselectedPath :: AppEnv s -> Path\nselectedPath = NE.head . selectedPaths\n\nselectedPaths :: AppEnv s -> NonEmpty Path\nselectedPaths AppEnv {aePrevPane, aeCurrPane, aeParents} =\n  let parents =\n        mapMaybe\n          (fmap snd . B.listSelectedElement)\n          (aePrevPane : aeParents)\n   in case B.listSelectedElement aeCurrPane of\n        Nothing -> error \"invariant violation: no selected element\"\n        Just (_, p) -> p :| parents\n\nselectPath :: NonEmpty Path -> AppEnv s -> AppEnv s\nselectPath path env\n  | (spName <$> path) == (spName <$> selectedPaths env) =\n      env\nselectPath path env@AppEnv {aeActualStoreEnv} =\n  let root :| children = NE.reverse path\n      lists =\n        NE.scanl\n          ( \\(_, prev) curr ->\n              ( map (seLookup aeActualStoreEnv) $\n                  spRefs prev,\n                curr\n              )\n          )\n          (NE.toList (seGetRoots aeActualStoreEnv), root)\n          children\n          & NE.reverse\n          & fmap (\\(possible, selected) -> mkList (aeSortOrder env) WidgetPrevPane (S.fromList possible) (Just selected))\n          & (<> (emptyPane :| []))\n   in case lists of\n        (curr :| prevs) ->\n          let (prev, parents) = case prevs of\n                [] -> (emptyPane, [])\n                p : ps -> (p, ps)\n           in env\n                { aeParents = parents,\n                  aePrevPane = prev,\n                  aeCurrPane = curr {B.listName = WidgetCurrPane}\n                }\n                & repopulateNextPane\n  where\n    emptyPane =\n      B.list WidgetPrevPane S.empty 0\n\nmkList ::\n  SortOrder ->\n  n ->\n  Seq Path ->\n  Maybe Path ->\n  B.GenericList n Seq Path\nmkList sortOrder name possible selected =\n  let contents = S.sortBy (compareBySortOrder sortOrder) possible\n   in B.list name contents 1\n        & B.listMoveTo\n          (fromMaybe 0 $ selected >>= \\s -> ((==) `on` spName) s `S.findIndexL` contents)\n\n-- Utils\n\nprettySize :: Int -> T.Text\nprettySize size = case HRF.convertSize $ fromIntegral size of\n  HRF.Bytes d -> T.pack (show d)\n  HRF.KiB d -> T.pack (show d) <> \" KiB\"\n  HRF.MiB d -> T.pack (show d) <> \" MiB\"\n  HRF.GiB d -> T.pack (show d) <> \" GiB\"\n  HRF.TiB d -> T.pack (show d) <> \" TiB\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/App.hs:(25,1)-(26,28)",
                  "suggestion_title": "Use newtype instead of data",
                  "found_block": [
                    "  data Event = EventTick Clock.TimeSpec"
                  ],
                  "perhaps_block": [
                    "  newtype Event = EventTick Clock.TimeSpec",
                    "Note: decreases laziness"
                  ]
                }
              ],
              "refactored_code": "module NixTree.App (run, helpText) where\n\nimport qualified Brick as B\nimport qualified Brick.BChan as B\nimport qualified Brick.Widgets.Border as B\nimport qualified Brick.Widgets.Center as B\nimport qualified Brick.Widgets.List as B\nimport Control.Concurrent\nimport Data.InvertedIndex\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map as Map\nimport qualified Data.Sequence as S\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Graphics.Vty as V\nimport Lens.Micro (Traversal', _Just)\nimport qualified NixTree.Clipboard as Clipboard\nimport NixTree.PathStats\nimport qualified System.Clock as Clock\nimport qualified System.HrfSize as HRF\n\nsortOrderChangeHighlightPeriod :: Clock.TimeSpec\nsortOrderChangeHighlightPeriod = Clock.TimeSpec 0 (500 * 1_000_000)\n\ndata Event\n  = EventTick Clock.TimeSpec\n\ndata Widgets\n  = WidgetPrevPane\n  | WidgetCurrPane\n  | WidgetNextPane\n  | WidgetWhyDepends\n  | WidgetSearch\n  | WidgetWhyDependsViewport\n  deriving (Show, Eq, Ord)\n\ndata Notice = Notice Text Text\n\ndata Modal s\n  = ModalNotice Notice\n  | ModalWhyDepends (B.GenericList Widgets Seq (NonEmpty Path))\n  | ModalSearch Text Text (B.GenericList Widgets Seq Path)\n\nsuccCycle :: forall a. (Bounded a, Enum a) => a -> a\nsuccCycle a\n  | fromEnum a == fromEnum (maxBound @a) = minBound\n  | otherwise = succ a\n\ndata AppEnv s = AppEnv\n  { aeActualStoreEnv :: StoreEnv PathStats,\n    aeInvertedIndex :: InvertedIndex Path,\n    aePrevPane :: List,\n    aeCurrPane :: List,\n    aeNextPane :: List,\n    aeParents :: [List],\n    aeOpenModal :: Maybe (Modal s),\n    aeSortOrder :: SortOrder,\n    aeSortOrderLastChanged :: Clock.TimeSpec,\n    aeCurrTime :: Clock.TimeSpec\n  }\n\ntype Path = StorePath StoreName PathStats\n\ntype List = B.GenericList Widgets Seq Path\n\ndata SortOrder\n  = SortOrderAlphabetical\n  | SortOrderClosureSize\n  | SortOrderAddedSize\n  deriving (Show, Eq, Enum, Bounded)\n\nB.suffixLenses ''AppEnv\n\n_ModalWhyDepends :: Traversal' (Modal s) (B.GenericList Widgets Seq (NonEmpty Path))\n_ModalWhyDepends f m = case m of\n  ModalWhyDepends l -> ModalWhyDepends <$> f l\n  _ -> pure m\n\ncompareBySortOrder :: SortOrder -> Path -> Path -> Ordering\ncompareBySortOrder SortOrderAlphabetical = compare `on` T.toLower . storeNameToShortText . spName\ncompareBySortOrder SortOrderClosureSize = compare `on` Down . psTotalSize . spPayload\ncompareBySortOrder SortOrderAddedSize = compare `on` Down . psAddedSize . spPayload\n\nattrTerminal, attrUnderlined :: B.AttrName\nattrTerminal = B.attrName \"terminal\"\nattrUnderlined = B.attrName \"underlined\"\n\nrun :: StoreEnv PathStats -> IO ()\nrun env = do\n  -- Create the inverted index, and start evaluating it in the background\n  let ii = iiFromList . toList . fmap (\\sp -> (storeNameToText (spName sp), sp)) $ seAll env\n  _ <- forkIO $ evaluateNF_ ii\n\n  -- Initial state\n  let getTime = Clock.getTime Clock.Monotonic\n  currTime <- getTime\n  let defaultSortOrder = SortOrderClosureSize\n\n  let appEnv =\n        AppEnv\n          { aeActualStoreEnv =\n              env,\n            aeInvertedIndex =\n              ii,\n            aePrevPane =\n              B.list WidgetPrevPane S.empty 0,\n            aeCurrPane =\n              B.list\n                WidgetCurrPane\n                (S.fromList . sortBy (compareBySortOrder defaultSortOrder) . NE.toList $ seGetRoots env)\n                0,\n            aeNextPane =\n              B.list WidgetNextPane S.empty 0,\n            aeParents =\n              [],\n            aeOpenModal =\n              Nothing,\n            aeSortOrder =\n              defaultSortOrder,\n            aeSortOrderLastChanged =\n              Clock.TimeSpec 0 0,\n            aeCurrTime =\n              currTime\n          }\n          & repopulateNextPane\n\n  -- Create a channel that's fed by current time\n  chan <- B.newBChan 10\n  void . forkIO $\n    forever $ do\n      threadDelay (100 * 1000)\n      t <- getTime\n      _ <- B.writeBChanNonBlocking chan (EventTick t)\n      return ()\n\n  -- And run the application\n  (_, vty) <- B.customMainWithDefaultVty (Just chan) app appEnv\n  V.shutdown vty\n\n  return ()\n\nrenderList ::\n  Maybe SortOrder ->\n  Bool ->\n  List ->\n  B.Widget Widgets\nrenderList highlightSort =\n  B.renderList\n    ( \\_\n       StorePath\n         { spName,\n           spPayload = PathStats {psTotalSize, psAddedSize, psDisambiguationChars},\n           spRefs,\n           spSignatures\n         } ->\n          let color =\n                if null spRefs\n                  then B.withAttr attrTerminal\n                  else identity\n           in color $\n                B.hBox\n                  [ if null spSignatures\n                      then B.txt \"  \"\n                      else B.txt \"\u2713 \",\n                    B.txt (storeNameToShortTextWithDisambiguation psDisambiguationChars spName)\n                      & underlineWhen SortOrderAlphabetical\n                      & B.padRight (B.Pad 1)\n                      & B.padRight B.Max,\n                    if null spRefs\n                      then\n                        B.txt (prettySize psTotalSize)\n                          & underlineWhen SortOrderClosureSize\n                          & underlineWhen SortOrderAddedSize\n                      else\n                        B.hBox\n                          [ B.txt (prettySize psTotalSize)\n                              & underlineWhen SortOrderClosureSize,\n                            B.txt \" (\",\n                            B.txt (prettySize psAddedSize)\n                              & underlineWhen SortOrderAddedSize,\n                            B.txt \")\"\n                          ]\n                  ]\n    )\n  where\n    underlineWhen so =\n      if Just so == highlightSort\n        then B.withDefAttr attrUnderlined\n        else identity\n\napp :: B.App (AppEnv s) Event Widgets\napp =\n  B.App\n    { B.appDraw = \\env@AppEnv {aeOpenModal} ->\n        [ case aeOpenModal of\n            Nothing -> B.emptyWidget\n            Just (ModalWhyDepends l) -> renderWhyDependsModal l\n            Just (ModalSearch l r xs) -> renderSearchModal l r xs\n            Just (ModalNotice notice) -> renderNotice notice,\n          renderMainScreen env\n        ],\n      B.appChooseCursor = \\_ _ -> Nothing,\n      B.appHandleEvent = \\e -> do\n        s <- get\n        case (e, aeOpenModal s) of\n          -- main screen\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                B.halt\n          (B.VtyEvent (V.EvKey (V.KChar '?') []), Nothing) ->\n            put s {aeOpenModal = Just (ModalNotice helpNotice)}\n          (B.VtyEvent (V.EvKey (V.KChar 'w') []), Nothing) -> do\n            B.hScrollToBeginning (B.viewportScroll WidgetWhyDependsViewport)\n            modify showWhyDepends\n          (B.VtyEvent (V.EvKey (V.KChar '/') []), Nothing) ->\n            modify $ showAndUpdateSearch \"\" \"\"\n          (B.VtyEvent (V.EvKey (V.KChar 'y') []), Nothing) -> do\n            liftIO (yankToClipboard $ spName (selectedPath s))\n              >>= \\case\n                Right () -> return ()\n                Left n -> put s {aeOpenModal = Just (ModalNotice n)}\n          (B.VtyEvent (V.EvKey (V.KChar 's') []), Nothing) ->\n            put $\n              s\n                { aeSortOrder = succCycle (aeSortOrder s),\n                  aeSortOrderLastChanged = aeCurrTime s\n                }\n                & sortPanes\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                modify moveLeft\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                move B.listMoveDown\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                move B.listMoveUp\n          (B.VtyEvent (V.EvKey k []), Nothing)\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                modify moveRight\n          (B.VtyEvent (V.EvKey V.KPageUp []), Nothing) ->\n            moveF B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Nothing) ->\n            moveF B.listMovePageDown\n          -- why-depends modal\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'h', V.KLeft] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) (-1)\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'j', V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveDown l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends l))\n            | k `elem` [V.KChar 'k', V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalWhyDepends (B.listMoveUp l)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalWhyDepends _))\n            | k `elem` [V.KChar 'l', V.KRight] ->\n                B.hScrollBy (B.viewportScroll WidgetWhyDependsViewport) 1\n          (B.VtyEvent (V.EvKey V.KPageUp []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageUp\n          (B.VtyEvent (V.EvKey V.KPageDown []), Just (ModalWhyDepends _)) ->\n            B.zoom (aeOpenModalL . _Just . _ModalWhyDepends) B.listMovePageDown\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalWhyDepends l)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement l of\n                  Nothing -> put closed\n                  Just (_, path) -> put $ selectPath path closed\n          -- search modal\n          (B.VtyEvent (V.EvKey V.KEsc []), Just (ModalSearch {})) ->\n            put s {aeOpenModal = Nothing}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KDown, V.KChar '\\t'] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveDown xs)}\n          (B.VtyEvent (V.EvKey k []), Just (ModalSearch l r xs))\n            | k `elem` [V.KUp, V.KBackTab] ->\n                put s {aeOpenModal = Just $ ModalSearch l r (B.listMoveUp xs)}\n          (B.VtyEvent (V.EvKey V.KLeft []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (T.dropEnd 1 l) (T.takeEnd 1 l <> r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey V.KRight []), Just (ModalSearch l r xs)) ->\n            put\n              s\n                { aeOpenModal =\n                    Just $ ModalSearch (l <> T.take 1 r) (T.drop 1 r) (B.listMoveUp xs)\n                }\n          (B.VtyEvent (V.EvKey (V.KChar c) []), Just (ModalSearch l r _))\n            | c `Set.member` allowedSearchChars ->\n                modify (showAndUpdateSearch (l <> T.singleton c) r)\n          (B.VtyEvent (V.EvKey V.KBS []), Just (ModalSearch l r _)) ->\n            modify (showAndUpdateSearch (T.dropEnd 1 l) r)\n          (B.VtyEvent (V.EvKey V.KEnter []), Just (ModalSearch _ _ xs)) ->\n            let closed = s {aeOpenModal = Nothing}\n             in case B.listSelectedElement xs of\n                  Nothing -> put closed\n                  Just (_, path) ->\n                    put $\n                      selectPath\n                        (shortestPathTo (aeActualStoreEnv s) (spName path))\n                        closed\n          -- notices\n          (B.VtyEvent (V.EvKey k []), Just (ModalNotice _))\n            | k `elem` [V.KChar 'q', V.KEsc] ->\n                put s {aeOpenModal = Nothing}\n          -- handle our events\n          (B.AppEvent (EventTick t), _) ->\n            let new = s {aeCurrTime = t}\n             in do\n                  put new\n                  unless (timePassedSinceSortOrderChange new <= sum (replicate 2 sortOrderChangeHighlightPeriod)) B.continueWithoutRedraw\n          -- ignore otherwise\n          _ ->\n            return (),\n      B.appStartEvent = return (),\n      B.appAttrMap = \\_ ->\n        B.attrMap\n          V.defAttr\n          [ (B.listSelectedFocusedAttr, V.currentAttr `V.withStyle` V.reverseVideo),\n            (attrTerminal, B.fg V.blue),\n            (attrUnderlined, V.currentAttr `V.withStyle` V.underline)\n          ]\n    }\n  where\n    allowedSearchChars :: Set Char\n    allowedSearchChars =\n      Set.fromList\n        ( mconcat\n            [ ['a' .. 'z'],\n              ['A' .. 'Z'],\n              ['0' .. '9'],\n              \"+-.=?_\"\n            ]\n        )\n\nyankToClipboard :: StoreName -> IO (Either Notice ())\nyankToClipboard p =\n  Clipboard.copy (toText $ storeNameToPath p)\n    <&> \\case\n      Right () -> Right ()\n      Left errs ->\n        Left $\n          Notice\n            \"Error\"\n            ( T.intercalate \"\\n\" $\n                \"Cannot copy to clipboard: \"\n                  : map (\"  \" <>) errs\n                  ++ [\"Please report this as a bug.\"]\n            )\n\ntimePassedSinceSortOrderChange :: AppEnv s -> Clock.TimeSpec\ntimePassedSinceSortOrderChange env = Clock.diffTimeSpec (aeCurrTime env) (aeSortOrderLastChanged env)\n\nrenderMainScreen :: AppEnv s -> B.Widget Widgets\nrenderMainScreen env@AppEnv {aePrevPane, aeCurrPane, aeNextPane} =\n  (B.joinBorders . B.border)\n    ( B.hBox\n        [ renderList Nothing True aePrevPane,\n          B.vBorder,\n          renderList shouldHighlightSortOrder True aeCurrPane,\n          B.vBorder,\n          renderList Nothing False aeNextPane\n        ]\n    )\n    B.<=> renderInfoPane env\n  where\n    shouldHighlightSortOrder =\n      if timePassedSinceSortOrderChange env < sortOrderChangeHighlightPeriod\n        then Just (aeSortOrder env)\n        else Nothing\n\nrenderInfoPane :: AppEnv s -> B.Widget Widgets\nrenderInfoPane env =\n  let selected = selectedPath env\n      immediateParents = psImmediateParents $ spPayload selected\n      signatures = spSignatures selected\n   in B.vBox\n        [ let (f, s) = storeNameToSplitShortText (spName selected)\n           in B.txt f B.<+> underlineWhen SortOrderAlphabetical (B.txt s),\n          [ B.txt $ \"NAR Size: \" <> prettySize (spSize selected),\n            underlineWhen SortOrderClosureSize . B.txt $ \"Closure Size: \" <> prettySize (psTotalSize $ spPayload selected),\n            underlineWhen SortOrderAddedSize . B.txt $ \"Added Size: \" <> prettySize (psAddedSize $ spPayload selected)\n          ]\n            & intersperse (B.txt \" | \")\n            & B.hBox,\n          B.txt $\n            \"Signatures: \"\n              <> if null signatures\n                then \"\u2717\"\n                else\n                  signatures\n                      & map npsKeyName\n                      & T.intercalate \", \",\n          B.txt $\n            if null immediateParents\n              then \"Immediate Parents: -\"\n              else\n                \"Immediate Parents (\"\n                  <> T.pack (show $ length immediateParents)\n                  <> \"): \"\n                  <> T.intercalate \", \" (map storeNameToShortText immediateParents)\n        ]\n  where\n    underlineWhen so =\n      if so == aeSortOrder env\n        then B.withAttr attrUnderlined\n        else identity\n\nrenderModal :: Text -> B.Widget a -> B.Widget a\nrenderModal title widget =\n  widget\n    & B.borderWithLabel (B.txt title)\n    & B.hLimitPercent 90\n    & B.vLimitPercent 60\n    & B.centerLayer\n\nhelpText :: Text\nhelpText =\n  T.intercalate\n    \"\\n\"\n    [ \"hjkl/Arrow Keys : Navigate\",\n      \"w               : Open why-depends modal\",\n      \"/               : Open search modal\",\n      \"s               : Change sort order\",\n      \"y               : Yank selected path to clipboard\",\n      \"?               : Show help\",\n      \"q/Esc           : Quit / close modal\"\n    ]\n\nhelpNotice :: Notice\nhelpNotice = Notice \"Help\" helpText\n\nrenderNotice :: Notice -> B.Widget a\nrenderNotice (Notice title txt) = renderModal title (B.txt txt)\n\nrenderWhyDependsModal ::\n  B.GenericList Widgets Seq (NonEmpty Path) ->\n  B.Widget Widgets\nrenderWhyDependsModal l =\n  B.renderList renderDepends True l\n    & B.hLimitPercent 100 -- This limit seems pointless, but otherwise render list takes infinite\n    -- amount of horizontal space and 'viewport' below complains.\n    & B.viewport WidgetWhyDependsViewport B.Horizontal\n    & renderModal \"why-depends\"\n  where\n    renderDepends _ =\n      B.txt . pathsToText\n    pathsToText xs =\n      xs\n        & NE.toList\n        & fmap (storeNameToShortText . spName)\n        & T.intercalate \" \u2192 \"\n\nshowWhyDepends :: AppEnv s -> AppEnv s\nshowWhyDepends env@AppEnv {aeActualStoreEnv} =\n  env\n    { aeOpenModal =\n        Just . ModalWhyDepends $\n          let selected = selectedPath env\n              route = selectedPaths env\n              xs = S.fromList $ whyDepends aeActualStoreEnv (spName selected)\n           in B.list WidgetWhyDepends xs 1\n                & B.listMoveTo\n                  (fromMaybe 0 $ ((==) `on` fmap spName) route `S.findIndexL` xs)\n    }\n\nrenderSearchModal :: Text -> Text -> B.GenericList Widgets Seq Path -> B.Widget Widgets\nrenderSearchModal left right l =\n  renderModal \"Search\" window\n  where\n    window =\n      B.txt left\n        B.<+> B.txt \"|\"\n        B.<+> B.txt right\n        B.<=> B.hBorder\n        B.<=> renderList Nothing True l\n\nshowAndUpdateSearch :: Text -> Text -> AppEnv s -> AppEnv s\nshowAndUpdateSearch left right env@AppEnv {aeInvertedIndex} =\n  env {aeOpenModal = Just $ ModalSearch left right results}\n  where\n    results =\n      let xs =\n            iiSearch (left <> right) aeInvertedIndex\n              & Map.elems\n              & S.fromList\n       in B.list WidgetSearch xs 1\n\nmove :: (List -> List) -> B.EventM n (AppEnv s) ()\nmove = moveF . modify\n\nmoveF :: B.EventM n List () -> B.EventM n (AppEnv s) ()\nmoveF f = do\n  B.zoom aeCurrPaneL f\n  modify repopulateNextPane\n\nmoveLeft :: AppEnv s -> AppEnv s\nmoveLeft env@AppEnv {aeParents = []} = env\nmoveLeft env@AppEnv {aePrevPane, aeCurrPane, aeParents = parent : grandparents} =\n  env\n    { aeParents = grandparents,\n      aePrevPane = parent,\n      aeCurrPane = aePrevPane {B.listName = WidgetCurrPane},\n      aeNextPane = aeCurrPane {B.listName = WidgetNextPane}\n    }\n\nmoveRight :: AppEnv s -> AppEnv s\nmoveRight env@AppEnv {aePrevPane, aeCurrPane, aeNextPane, aeParents}\n  | null (B.listElements aeNextPane) = env\n  | otherwise =\n      env\n        { aePrevPane = aeCurrPane {B.listName = WidgetPrevPane},\n          aeCurrPane = aeNextPane {B.listName = WidgetCurrPane},\n          aeParents = aePrevPane : aeParents\n        }\n        & repopulateNextPane\n\nrepopulateNextPane :: AppEnv s -> AppEnv s\nrepopulateNextPane env@AppEnv {aeActualStoreEnv, aeNextPane, aeSortOrder} =\n  let ref = selectedPath env\n   in env\n        { aeNextPane =\n            B.listReplace\n              ( S.sortBy (compareBySortOrder aeSortOrder)\n                  . S.fromList\n                  . map (seLookup aeActualStoreEnv)\n                  $ spRefs ref\n              )\n              (Just 0)\n              aeNextPane\n        }\n\nsortPane :: SortOrder -> List -> List\nsortPane so l =\n  let selected = B.listSelectedElement l\n      elems =\n        B.listElements l\n          & S.sortBy (compareBySortOrder so)\n      name = B.getName l\n   in mkList so name elems (snd <$> selected)\n\nsortPanes :: AppEnv s -> AppEnv s\nsortPanes env@AppEnv {aeParents, aePrevPane, aeCurrPane, aeNextPane, aeSortOrder} =\n  env\n    { aeCurrPane = sortPane aeSortOrder aeCurrPane,\n      aeNextPane = sortPane aeSortOrder aeNextPane,\n      aeParents = sortPane aeSortOrder <$> aeParents,\n      aePrevPane = sortPane aeSortOrder aePrevPane\n    }\n\nselectedPath :: AppEnv s -> Path\nselectedPath = NE.head . selectedPaths\n\nselectedPaths :: AppEnv s -> NonEmpty Path\nselectedPaths AppEnv {aePrevPane, aeCurrPane, aeParents} =\n  let parents =\n        mapMaybe\n          (fmap snd . B.listSelectedElement)\n          (aePrevPane : aeParents)\n   in case B.listSelectedElement aeCurrPane of\n        Nothing -> error \"invariant violation: no selected element\"\n        Just (_, p) -> p :| parents\n\nselectPath :: NonEmpty Path -> AppEnv s -> AppEnv s\nselectPath path env\n  | (spName <$> path) == (spName <$> selectedPaths env) =\n      env\nselectPath path env@AppEnv {aeActualStoreEnv} =\n  let root :| children = NE.reverse path\n      lists =\n        NE.scanl\n          ( \\(_, prev) curr ->\n              ( map (seLookup aeActualStoreEnv) $\n                  spRefs prev,\n                curr\n              )\n          )\n          (NE.toList (seGetRoots aeActualStoreEnv), root)\n          children\n          & NE.reverse\n          & fmap (\\(possible, selected) -> mkList (aeSortOrder env) WidgetPrevPane (S.fromList possible) (Just selected))\n          & (<> (emptyPane :| []))\n   in case lists of\n        (curr :| prevs) ->\n          let (prev, parents) = case prevs of\n                [] -> (emptyPane, [])\n                p : ps -> (p, ps)\n           in env\n                { aeParents = parents,\n                  aePrevPane = prev,\n                  aeCurrPane = curr {B.listName = WidgetCurrPane}\n                }\n                & repopulateNextPane\n  where\n    emptyPane =\n      B.list WidgetPrevPane S.empty 0\n\nmkList ::\n  SortOrder ->\n  n ->\n  Seq Path ->\n  Maybe Path ->\n  B.GenericList n Seq Path\nmkList sortOrder name possible selected =\n  let contents = S.sortBy (compareBySortOrder sortOrder) possible\n   in B.list name contents 1\n        & B.listMoveTo\n          (fromMaybe 0 $ selected >>= \\s -> ((==) `on` spName) s `S.findIndexL` contents)\n\n-- Utils\n\nprettySize :: Int -> T.Text\nprettySize size = case HRF.convertSize $ fromIntegral size of\n  HRF.Bytes d -> T.pack (show d)\n  HRF.KiB d -> T.pack (show d) <> \" KiB\"\n  HRF.MiB d -> T.pack (show d) <> \" MiB\"\n  HRF.GiB d -> T.pack (show d) <> \" GiB\"\n  HRF.TiB d -> T.pack (show d) <> \" TiB\"\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/NixTree/Clipboard.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 3,
                "sum": 9
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 1,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 3,
              "lines_of_code": 43,
              "homplexity_lines_of_code": 43,
              "code_quality_score": 77.7,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 3,
                  "sum": 9
                },
                "homplexity_loc": 43,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"copy\": 1,\n        \"runCmd\": 5,\n        \"go\": 3,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 3,\n        \"sum\": 9\n    },\n    \"homplexity_loc\": 43,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.Clipboard\n  ( copy,\n  )\nwhere\n\nimport Control.Exception (try)\nimport System.Exit\nimport qualified System.Process.Typed as P\nimport System.Timeout\n\ncmds :: [(FilePath, [String])]\ncmds =\n  [ (\"xsel\", [\"-i\", \"-b\"]),\n    (\"xclip\", [\"-selection\", \"clipboard\"]),\n    (\"wl-copy\", []),\n    (\"pbcopy\", [])\n  ]\n\nrunCmd :: Text -> (FilePath, [String]) -> IO (Either Text ())\nrunCmd txt (cmd, args) =\n  P.proc (toString cmd) (map toString args)\n    & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n    & P.runProcess\n    & timeout 1_000_000\n    & try\n    <&> \\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e)) ->\n        Left $ \"failed with exit code \" <> show e\n      Right Nothing ->\n        Left $ \"timed out\"\n      Left (ex :: SomeException) ->\n        Left $ \"failed with exception: \" <> show ex\n    <&> \\case\n      Right () -> Right ()\n      Left err -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")\n\ncopy :: Text -> IO (Either [Text] ())\ncopy txt = go cmds []\n  where\n    go [] errs = return $ Left errs\n    go (x : xs) errs =\n      runCmd txt x >>= \\case\n        Right () -> return $ Right ()\n        Left err -> go xs (err : errs)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module NixTree.Clipboard\n  ( copy,\n  )\nwhere\n\nimport Control.Exception (try)\nimport System.Exit\nimport qualified System.Process.Typed as P\nimport System.Timeout\n\ncmds :: [(FilePath, [String])]\ncmds =\n  [ (\"xsel\", [\"-i\", \"-b\"]),\n    (\"xclip\", [\"-selection\", \"clipboard\"]),\n    (\"wl-copy\", []),\n    (\"pbcopy\", [])\n  ]\n\nrunCmd :: Text -> (FilePath, [String]) -> IO (Either Text ())\nrunCmd txt (cmd, args) =\n  (P.proc (toString cmd) (map toString args)\n    & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n    & P.runProcess\n    & timeout 1_000_000\n    & try) <&> (\\case\n      Right () -> Right ()\n      Left err -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")) . (\\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e)) ->\n        Left $ \"failed with exit code \" <> show e\n      Right Nothing ->\n        Left $ \"timed out\"\n      Left (ex :: SomeException) ->\n        Left $ \"failed with exception: \" <> show ex)\n\ncopy :: Text -> IO (Either [Text] ())\ncopy txt = go cmds []\n  where\n    go [] errs = return $ Left errs\n    go (x : xs) errs =\n      runCmd txt x >>= \\case\n        Right () -> return $ Right ()\n        Left err -> go xs (err : errs)\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Main.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/NixTree/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 5,
                "average": 2,
                "sum": 14
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 161,
              "homplexity_lines_of_code": 161,
              "code_quality_score": 55.9,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 5,
                  "average": 2,
                  "sum": 14
                },
                "homplexity_loc": 161,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"version\": 1,\n        \"optsParser\": 1,\n        \"parser\": 1,\n        \"keybindingsHelp\": 1,\n        \"showAndFail\": 1,\n        \"isValidRoot\": 2,\n        \"main\": 5,\n        \"chunks\": 2,\n        \"min\": 1,\n        \"max\": 5,\n        \"average\": 1.75,\n        \"sum\": 14\n    },\n    \"homplexity_loc\": 161,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n\nmodule Main where\n\nimport Control.Concurrent.Async\nimport Control.Exception (evaluate)\nimport NixTree.App\nimport NixTree.PathStats\nimport qualified Options.Applicative as Opts\nimport qualified Options.Applicative.Help.Pretty as Opts\nimport System.Directory (XdgDirectory (XdgState), doesDirectoryExist, getHomeDirectory, getXdgDirectory, pathIsSymbolicLink)\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((</>))\nimport System.IO (hPutStrLn)\nimport System.ProgressBar hiding (msg)\n\nversion :: Text\nversion = VERSION_nix_tree\n\ndata Opts = Opts\n  { oInstallables :: [Installable],\n    oStore :: Maybe String,\n    oFile :: Maybe FilePath,\n    oVersion :: Bool,\n    oDerivation :: Bool,\n    oImpure :: Bool,\n    oDot :: Bool\n  }\n\noptsParser :: Opts.ParserInfo Opts\noptsParser =\n  Opts.info (parser <**> Opts.helper) $\n    mconcat\n      [ Opts.progDesc \"Interactively browse dependency graphs of Nix derivations.\",\n        Opts.fullDesc,\n        Opts.footerDoc (Just keybindingsHelp)\n      ]\n  where\n    parser :: Opts.Parser Opts\n    parser =\n      Opts\n        <$> many\n          ( Installable\n              <$> Opts.strArgument @Text\n                ( Opts.metavar \"INSTALLABLE\"\n                    <> Opts.helpDoc\n                      ( Just $\n                          Opts.vsep\n                            [ \"A store path or a flake reference.\",\n                              \"Paths default to \\\"~/.nix-profile\\\" and \\\"/var/run/current-system\\\"\"\n                            ]\n                      )\n                )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"store\"\n                  <> Opts.metavar \"STORE\"\n                  <> Opts.helpDoc\n                    ( Just $\n                        Opts.vsep\n                          [ \"The URL of the Nix store, e.g. \\\"daemon\\\" or \\\"https://cache.nixos.org\\\"\",\n                            \"See \\\"nix help-stores\\\" for supported store types and settings.\"\n                          ]\n                    )\n              )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"file\"\n                  <> Opts.metavar \"FILE\"\n                  <> Opts.helpDoc\n                    ( Just $ Opts.vsep [\"Interpret installables as attribute paths relative to the Nix expression stored in file.\"]\n                    )\n              )\n          )\n        <*> Opts.switch (Opts.long \"version\" <> Opts.help \"Show the nix-tree version\")\n        <*> Opts.switch (Opts.long \"derivation\" <> Opts.help \"Operate on the store derivation rather than its outputs\")\n        <*> Opts.switch (Opts.long \"impure\" <> Opts.help \"Allow access to mutable paths and repositories\")\n        <*> Opts.switch (Opts.long \"dot\" <> Opts.help \"Print the dependency graph in dot format\")\n\n    keybindingsHelp :: Opts.Doc\n    keybindingsHelp =\n      Opts.vsep\n        [ \"Keybindings:\",\n          Opts.indent 2 . Opts.vsep $ map Opts.pretty (lines helpText)\n        ]\n\nshowAndFail :: Text -> IO a\nshowAndFail msg = do\n  hPutStrLn stderr . toString $ \"Error: \" <> msg\n  exitWith (ExitFailure 1)\n\nisValidRoot :: FilePath -> IO Bool\nisValidRoot path = do\n  isExistingDirectory <- doesDirectoryExist path\n  if isExistingDirectory\n    then -- We need to check that it's a symlink (presumably to nix store),\n    -- because if it is just a directory, nix will try to interpret it as a flake.\n    -- We do doesDirectoryExist before pathIsSymbolicLink,\n    -- because the latter will fail if the path does not exist.\n      pathIsSymbolicLink path\n    else return False\n\nmain :: IO ()\nmain = do\n  opts <-\n    Opts.customExecParser\n      (Opts.prefs $ Opts.columns 120)\n      optsParser\n\n  when (opts & oVersion) $ do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess\n\n  installables <- case opts & oInstallables of\n    p : ps ->\n      return $ p :| ps\n    [] -> do\n      home <- getHomeDirectory\n      nixXdgDirectory <- getXdgDirectory XdgState \"nix/profile\"\n      homeManagerDirectory <- getXdgDirectory XdgState \"nix/profiles/home-manager\"\n      roots <-\n        filterM\n          isValidRoot\n          [ home </> \".nix-profile\",\n            nixXdgDirectory,\n            homeManagerDirectory,\n            \"/var/run/current-system\"\n          ]\n      case roots of\n        [] -> showAndFail \"No store path given.\"\n        p : ps -> return . fmap (Installable . toText) $ p :| ps\n\n  let seo =\n        StoreEnvOptions\n          { seoIsDerivation = opts & oDerivation,\n            seoIsImpure = opts & oImpure,\n            seoStoreURL = opts & oStore,\n            seoFile = opts & oFile\n          }\n\n  withStoreEnv seo installables $ \\env' -> do\n    let env = calculatePathStats env'\n        allPaths = seAll env\n\n    bar <- newProgressBar defStyle {stylePostfix = exact} 4 (Progress 0 (length allPaths) ())\n    allPaths\n      & toList\n      & chunks 50\n      & mapConcurrently_ (mapM_ (\\p -> evaluate (rnf p) >> incProgress bar 1))\n\n    if opts & oDot\n      then putTextLn $ storeEnvToDot env\n      else run env\n\nchunks :: Int -> [a] -> [[a]]\nchunks _ [] = []\nchunks n xs =\n  let (ys, zs) = splitAt n xs\n   in ys : chunks n zs\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/Main.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n\nmodule Main where\n\nimport Control.Concurrent.Async\nimport Control.Exception (evaluate)\nimport NixTree.App\nimport NixTree.PathStats\nimport qualified Options.Applicative as Opts\nimport qualified Options.Applicative.Help.Pretty as Opts\nimport System.Directory (XdgDirectory (XdgState), doesDirectoryExist, getHomeDirectory, getXdgDirectory, pathIsSymbolicLink)\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((</>))\nimport System.IO (hPutStrLn)\nimport System.ProgressBar hiding (msg)\n\nversion :: Text\nversion = VERSION_nix_tree\n\ndata Opts = Opts\n  { oInstallables :: [Installable],\n    oStore :: Maybe String,\n    oFile :: Maybe FilePath,\n    oVersion :: Bool,\n    oDerivation :: Bool,\n    oImpure :: Bool,\n    oDot :: Bool\n  }\n\noptsParser :: Opts.ParserInfo Opts\noptsParser =\n  Opts.info (parser <**> Opts.helper) $\n    mconcat\n      [ Opts.progDesc \"Interactively browse dependency graphs of Nix derivations.\",\n        Opts.fullDesc,\n        Opts.footerDoc (Just keybindingsHelp)\n      ]\n  where\n    parser :: Opts.Parser Opts\n    parser =\n      Opts\n        <$> many\n          ( Installable\n              <$> Opts.strArgument @Text\n                ( Opts.metavar \"INSTALLABLE\"\n                    <> Opts.helpDoc\n                      ( Just $\n                          Opts.vsep\n                            [ \"A store path or a flake reference.\",\n                              \"Paths default to \\\"~/.nix-profile\\\" and \\\"/var/run/current-system\\\"\"\n                            ]\n                      )\n                )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"store\"\n                  <> Opts.metavar \"STORE\"\n                  <> Opts.helpDoc\n                    ( Just $\n                        Opts.vsep\n                          [ \"The URL of the Nix store, e.g. \\\"daemon\\\" or \\\"https://cache.nixos.org\\\"\",\n                            \"See \\\"nix help-stores\\\" for supported store types and settings.\"\n                          ]\n                    )\n              )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"file\"\n                  <> Opts.metavar \"FILE\"\n                  <> Opts.helpDoc\n                    ( Just $ Opts.vsep [\"Interpret installables as attribute paths relative to the Nix expression stored in file.\"]\n                    )\n              )\n          )\n        <*> Opts.switch (Opts.long \"version\" <> Opts.help \"Show the nix-tree version\")\n        <*> Opts.switch (Opts.long \"derivation\" <> Opts.help \"Operate on the store derivation rather than its outputs\")\n        <*> Opts.switch (Opts.long \"impure\" <> Opts.help \"Allow access to mutable paths and repositories\")\n        <*> Opts.switch (Opts.long \"dot\" <> Opts.help \"Print the dependency graph in dot format\")\n\n    keybindingsHelp :: Opts.Doc\n    keybindingsHelp =\n      Opts.vsep\n        [ \"Keybindings:\",\n          Opts.indent 2 . Opts.vsep $ map Opts.pretty (lines helpText)\n        ]\n\nshowAndFail :: Text -> IO a\nshowAndFail msg = do\n  hPutStrLn stderr . toString $ \"Error: \" <> msg\n  exitWith (ExitFailure 1)\n\nisValidRoot :: FilePath -> IO Bool\nisValidRoot path = do\n  isExistingDirectory <- doesDirectoryExist path\n  if isExistingDirectory\n    then -- We need to check that it's a symlink (presumably to nix store),\n    -- because if it is just a directory, nix will try to interpret it as a flake.\n    -- We do doesDirectoryExist before pathIsSymbolicLink,\n    -- because the latter will fail if the path does not exist.\n      pathIsSymbolicLink path\n    else return False\n\nmain :: IO ()\nmain = do\n  opts <-\n    Opts.customExecParser\n      (Opts.prefs $ Opts.columns 120)\n      optsParser\n\n  when (opts & oVersion) $ do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess\n\n  installables <- case opts & oInstallables of\n    p : ps ->\n      return $ p :| ps\n    [] -> do\n      home <- getHomeDirectory\n      nixXdgDirectory <- getXdgDirectory XdgState \"nix/profile\"\n      homeManagerDirectory <- getXdgDirectory XdgState \"nix/profiles/home-manager\"\n      roots <-\n        filterM\n          isValidRoot\n          [ home </> \".nix-profile\",\n            nixXdgDirectory,\n            homeManagerDirectory,\n            \"/var/run/current-system\"\n          ]\n      case roots of\n        [] -> showAndFail \"No store path given.\"\n        p : ps -> return . fmap (Installable . toText) $ p :| ps\n\n  let seo =\n        StoreEnvOptions\n          { seoIsDerivation = opts & oDerivation,\n            seoIsImpure = opts & oImpure,\n            seoStoreURL = opts & oStore,\n            seoFile = opts & oFile\n          }\n\n  withStoreEnv seo installables $ \\env' -> do\n    let env = calculatePathStats env'\n        allPaths = seAll env\n\n    bar <- newProgressBar defStyle {stylePostfix = exact} 4 (Progress 0 (length allPaths) ())\n    allPaths\n      & toList\n      & chunks 50\n      & mapConcurrently_ (mapM_ (\\p -> evaluate (rnf p) >> incProgress bar 1))\n\n    if opts & oDot\n      then putTextLn $ storeEnvToDot env\n      else run env\n\nchunks :: Int -> [a] -> [[a]]\nchunks _ [] = []\nchunks n xs =\n  let (ys, zs) = splitAt n xs\n   in ys : chunks n zs\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/NixTree/PathStats.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 2,
                "sum": 29
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 1,
                "suggestion": 2,
                "ignore": 0,
                "total": 3
              },
              "syntax_errors": 2,
              "lines_of_code": 214,
              "homplexity_lines_of_code": 216,
              "code_quality_score": 20.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 2,
                  "sum": 29
                },
                "homplexity_loc": 216,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"mkIntermediateEnv\": 2,\n    \"mkFinalEnv\": 1,\n    \"mkFinalEnv.calculateEnvSize\": 1,\n    \"mkFinalEnv.calculateRefsSize\": 1,\n    \"mkFinalEnv.calculateImmediateParents\": 1,\n    \"mkFinalEnv.seShortNames\": 2,\n    \"mkFinalEnv.seDisambiguationChars\": 1,\n    \"mkFinalEnv.disambiguate\": 1,\n    \"mkFinalEnv.disambiguate.go\": 2,\n    \"mkFinalEnv.disambiguate.isGood\": 1,\n    \"mkFinalEnv.disambiguate.allUnique\": 1,\n    \"calculatePathStats\": 1,\n    \"shortestPathTo\": 3,\n    \"whyDepends\": 2,\n    \"mkTreeish\": 1,\n    \"treeishSize\": 1,\n    \"capTreeish\": 2,\n    \"capTreeish.go\": 3,\n    \"treeishToList\": 2,\n    \"min\": 1,\n    \"max\": 3,\n    \"average\": 1.5263157894736842,\n    \"sum\": 29\n  },\n  \"homplexity_loc\": 216,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.PathStats\n  ( PathStats (..),\n    calculatePathStats,\n    whyDepends,\n    shortestPathTo,\n    module NixTree.StorePath,\n  )\nwhere\n\nimport Data.List (minimumBy)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map.Lazy as M\nimport qualified Data.Set as S\nimport NixTree.StorePath\n\ndata IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }\n\ndata PathStats = PathStats\n  { psTotalSize :: !Int,\n    psAddedSize :: !Int,\n    psImmediateParents :: [StoreName],\n    psDisambiguationChars :: !Int\n  }\n  deriving (Show, Generic, NFData)\n\nmkIntermediateEnv ::\n  (StoreName -> Bool) ->\n  StoreEnv () ->\n  StoreEnv IntermediatePathStats\nmkIntermediateEnv env =\n  seBottomUp $ \\curr ->\n    IntermediatePathStats\n      { ipsAllRefs =\n          M.unions\n            ( M.fromList\n                [ (spName, void sp)\n                  | sp@StorePath {spName} <- spRefs curr,\n                    env spName\n                ]\n                : map (ipsAllRefs . spPayload) (spRefs curr)\n            )\n      }\n\nmkFinalEnv :: StoreEnv IntermediatePathStats -> StoreEnv PathStats\nmkFinalEnv env =\n  let totalSize = calculateEnvSize env\n      immediateParents = calculateImmediateParents (sePaths env)\n      disambiguationChars = seDisambiguationChars env\n   in flip seBottomUp env $ \\StorePath {spName, spSize, spPayload} ->\n        let filteredSize =\n              seFetchRefs env (/= spName) (seRoots env)\n                & calculateRefsSize\n            addedSize = totalSize - filteredSize\n         in PathStats\n              { psTotalSize =\n                  spSize\n                    + calculateRefsSize (ipsAllRefs spPayload),\n                psAddedSize = addedSize,\n                psImmediateParents =\n                  maybe [] S.toList $ M.lookup spName immediateParents,\n                psDisambiguationChars =\n                  M.lookup spName disambiguationChars\n                    & maybe 0 id\n              }\n  where\n    calculateEnvSize :: StoreEnv IntermediatePathStats -> Int\n    calculateEnvSize e =\n      seGetRoots e\n        & toList\n        & map\n          ( \\sp@StorePath {spName, spPayload} ->\n              M.insert\n                spName\n                (void sp)\n                (ipsAllRefs spPayload)\n          )\n        & M.unions\n        & calculateRefsSize\n    calculateRefsSize :: (Functor f, Foldable f) => f (StorePath a b) -> Int\n    calculateRefsSize = sum . fmap spSize\n    calculateImmediateParents ::\n      (Foldable f) =>\n      f (StorePath StoreName b) ->\n      M.Map StoreName (S.Set StoreName)\n    calculateImmediateParents =\n      foldl'\n        ( \\m StorePath {spName, spRefs} ->\n            M.unionWith\n              (<>)\n              m\n              (M.fromList (map (,S.singleton spName) spRefs))\n        )\n        M.empty\n\n    seShortNames :: StoreEnv a -> M.Map Text [StoreName]\n    seShortNames env =\n      let paths = seAll env & toList\n       in foldl'\n            ( \\m StorePath {spName} ->\n                let (_, shortName) = storeNameToSplitShortText spName\n                 in M.alter\n                      ( \\case\n                          Nothing -> Just [spName]\n                          Just xs -> Just (spName : xs)\n                      )\n                      shortName\n                      m\n            )\n            M.empty\n            paths\n\n    seDisambiguationChars :: StoreEnv a -> M.Map StoreName Int\n    seDisambiguationChars env =\n      M.toList (seShortNames env)\n        & map snd\n        & concatMap\n          ( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          )\n        & M.fromList\n\n    disambiguate :: [StoreName] -> Int\n    disambiguate xs = go 0\n      where\n        go n =\n          if isGood n\n            then n\n            else go (n + 2)\n\n        isGood n =\n          xs\n            & map (storeNameToShortTextWithDisambiguation n)\n            & allUnique\n\n        allUnique xx =\n          let unique = S.fromList xx\n           in length unique == length xx\n\ncalculatePathStats :: StoreEnv () -> StoreEnv PathStats\ncalculatePathStats = mkFinalEnv . mkIntermediateEnv (const True)\n\n-- TODO: This can be precomputed.\nshortestPathTo :: StoreEnv a -> StoreName -> NonEmpty (StorePath StoreName a)\nshortestPathTo env name =\n  seBottomUp\n    ( \\curr ->\n        let currOut = curr {spRefs = spName <$> spRefs curr}\n         in if spName curr == name\n              then Just (1 :: Int, currOut :| [])\n              else\n                mapMaybe spPayload (spRefs curr)\n                  & \\case\n                    [] -> Nothing\n                    xs -> case minimumBy (comparing fst) xs of\n                      (c, p) -> Just (c + 1, currOut NE.<| p)\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & minimumBy (comparing fst)\n    & snd\n    & NE.reverse\n\n-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node contains a set of paths which represent\n-- the why-depends output from that node down. The set of paths is represented as a \"Treeish\" object,\n-- which is a trie-like structure.\nwhyDepends :: forall a. StoreEnv a -> StoreName -> [NonEmpty (StorePath StoreName a)]\nwhyDepends env name =\n  seBottomUp @_ @(Maybe (Treeish (StorePath StoreName a)))\n    ( \\curr ->\n        if spName curr == name\n          then Just $ mkTreeish (curr {spRefs = map spName (spRefs curr)}) []\n          else\n            mapMaybe spPayload (spRefs curr)\n              & NE.nonEmpty\n              <&> NE.toList\n              <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})\n              <&> capTreeish 1_000_000\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & take 10000\n    & concatMap treeishToList\n\n-- A trie-like structure which also caches the size.\ndata Treeish a = Treeish Int a [Treeish a]\n\nmkTreeish :: a -> [Treeish a] -> Treeish a\nmkTreeish a ts = Treeish (1 + sum (map (\\(Treeish i _ _) -> i) ts)) a ts\n\ntreeishSize :: Treeish a -> Int\ntreeishSize (Treeish i _ _) = i\n\ncapTreeish :: Int -> Treeish a -> Treeish a\ncapTreeish cap (Treeish i a ts)\n  | i <= cap = Treeish i a ts\n  | otherwise = Treeish cap a (go cap ts)\n  where\n    go _ [] = []\n    go remaining (x : xs) =\n      let x' = capTreeish remaining x\n          remaining' = remaining - treeishSize x'\n       in if remaining > 0\n            then x' : go remaining' xs\n            else [x']\n\ntreeishToList :: Treeish a -> [NonEmpty a]\ntreeishToList (Treeish _ a []) = [a :| []]\ntreeishToList (Treeish _ a xs) = map (a NE.<|) (concatMap treeishToList xs)\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs:(16,1)-(18,3)",
                  "suggestion_title": "Use newtype instead of data",
                  "found_block": [
                    "  data IntermediatePathStats",
                    "    = IntermediatePathStats {ipsAllRefs :: M.Map StoreName (StorePath StoreName ())}"
                  ],
                  "perhaps_block": [
                    "  newtype IntermediatePathStats",
                    "    = IntermediatePathStats {ipsAllRefs :: M.Map StoreName (StorePath StoreName ())}",
                    "Note: decreases laziness"
                  ]
                },
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs:(116,7)-(122,11)",
                  "suggestion_title": "Fuse concatMap/map",
                  "found_block": [
                    "  M.toList (seShortNames env) & map snd",
                    "    & concatMap",
                    "        (\\ xs -> let chrs = disambiguate xs in map (\\ x -> (x, chrs)) xs)"
                  ],
                  "perhaps_block": [
                    "  concatMap",
                    "    ((\\ xs -> let chrs = disambiguate xs in map (\\ x -> (x, chrs)) xs)",
                    "       . snd)",
                    "    (M.toList (seShortNames env))"
                  ]
                }
              ],
              "refactored_code": "module NixTree.PathStats\n  ( PathStats (..),\n    calculatePathStats,\n    whyDepends,\n    shortestPathTo,\n    module NixTree.StorePath,\n  )\nwhere\n\nimport Data.List (minimumBy)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map.Lazy as M\nimport qualified Data.Set as S\nimport NixTree.StorePath\n\ndata IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }\n\ndata PathStats = PathStats\n  { psTotalSize :: !Int,\n    psAddedSize :: !Int,\n    psImmediateParents :: [StoreName],\n    psDisambiguationChars :: !Int\n  }\n  deriving (Show, Generic, NFData)\n\nmkIntermediateEnv ::\n  (StoreName -> Bool) ->\n  StoreEnv () ->\n  StoreEnv IntermediatePathStats\nmkIntermediateEnv env =\n  seBottomUp $ \\curr ->\n    IntermediatePathStats\n      { ipsAllRefs =\n          M.unions\n            ( M.fromList\n                [ (spName, void sp)\n                  | sp@StorePath {spName} <- spRefs curr,\n                    env spName\n                ]\n                : map (ipsAllRefs . spPayload) (spRefs curr)\n            )\n      }\n\nmkFinalEnv :: StoreEnv IntermediatePathStats -> StoreEnv PathStats\nmkFinalEnv env =\n  let totalSize = calculateEnvSize env\n      immediateParents = calculateImmediateParents (sePaths env)\n      disambiguationChars = seDisambiguationChars env\n   in flip seBottomUp env $ \\StorePath {spName, spSize, spPayload} ->\n        let filteredSize =\n              seFetchRefs env (/= spName) (seRoots env)\n                & calculateRefsSize\n            addedSize = totalSize - filteredSize\n         in PathStats\n              { psTotalSize =\n                  spSize\n                    + calculateRefsSize (ipsAllRefs spPayload),\n                psAddedSize = addedSize,\n                psImmediateParents =\n                  maybe [] S.toList $ M.lookup spName immediateParents,\n                psDisambiguationChars =\n                  M.lookup spName disambiguationChars\n                    & Data.Maybe.fromMaybe 0\n              }\n  where\n    calculateEnvSize :: StoreEnv IntermediatePathStats -> Int\n    calculateEnvSize e =\n      seGetRoots e\n        & toList\n        & map\n          ( \\sp@StorePath {spName, spPayload} ->\n              M.insert\n                spName\n                (void sp)\n                (ipsAllRefs spPayload)\n          )\n        & M.unions\n        & calculateRefsSize\n    calculateRefsSize :: (Functor f, Foldable f) => f (StorePath a b) -> Int\n    calculateRefsSize = sum . fmap spSize\n    calculateImmediateParents ::\n      (Foldable f) =>\n      f (StorePath StoreName b) ->\n      M.Map StoreName (S.Set StoreName)\n    calculateImmediateParents =\n      foldl'\n        ( \\m StorePath {spName, spRefs} ->\n            M.unionWith\n              (<>)\n              m\n              (M.fromList (map (,S.singleton spName) spRefs))\n        )\n        M.empty\n\n    seShortNames :: StoreEnv a -> M.Map Text [StoreName]\n    seShortNames env =\n      let paths = seAll env & toList\n       in foldl'\n            ( \\m StorePath {spName} ->\n                let (_, shortName) = storeNameToSplitShortText spName\n                 in M.alter\n                      ( \\case\n                          Nothing -> Just [spName]\n                          Just xs -> Just (spName : xs)\n                      )\n                      shortName\n                      m\n            )\n            M.empty\n            paths\n\n    seDisambiguationChars :: StoreEnv a -> M.Map StoreName Int\n    seDisambiguationChars env =\n      concatMap (( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          ) . snd) (M.toList (seShortNames env))\n        & M.fromList\n\n    disambiguate :: [StoreName] -> Int\n    disambiguate xs = go 0\n      where\n        go n =\n          if isGood n\n            then n\n            else go (n + 2)\n\n        isGood n =\n          xs\n            & map (storeNameToShortTextWithDisambiguation n)\n            & allUnique\n\n        allUnique xx =\n          let unique = S.fromList xx\n           in length unique == length xx\n\ncalculatePathStats :: StoreEnv () -> StoreEnv PathStats\ncalculatePathStats = mkFinalEnv . mkIntermediateEnv (const True)\n\n-- TODO: This can be precomputed.\nshortestPathTo :: StoreEnv a -> StoreName -> NonEmpty (StorePath StoreName a)\nshortestPathTo env name =\n  seBottomUp\n    ( \\curr ->\n        let currOut = curr {spRefs = spName <$> spRefs curr}\n         in if spName curr == name\n              then Just (1 :: Int, currOut :| [])\n              else\n                mapMaybe spPayload (spRefs curr)\n                  & \\case\n                    [] -> Nothing\n                    xs -> case minimumBy (comparing fst) xs of\n                      (c, p) -> Just (c + 1, currOut NE.<| p)\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & minimumBy (comparing fst)\n    & snd\n    & NE.reverse\n\n-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node contains a set of paths which represent\n-- the why-depends output from that node down. The set of paths is represented as a \"Treeish\" object,\n-- which is a trie-like structure.\nwhyDepends :: forall a. StoreEnv a -> StoreName -> [NonEmpty (StorePath StoreName a)]\nwhyDepends env name =\n  seBottomUp @_ @(Maybe (Treeish (StorePath StoreName a)))\n    ( \\curr ->\n        if spName curr == name\n          then Just $ mkTreeish (curr {spRefs = map spName (spRefs curr)}) []\n          else\n            (mapMaybe spPayload (spRefs curr)\n              & NE.nonEmpty\n              <&> NE.toList) <&> capTreeish 1_000_000 . mkTreeish (curr {spRefs = map spName (spRefs curr)})\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & take 10000\n    & concatMap treeishToList\n\n-- A trie-like structure which also caches the size.\ndata Treeish a = Treeish Int a [Treeish a]\n\nmkTreeish :: a -> [Treeish a] -> Treeish a\nmkTreeish a ts = Treeish (1 + sum (map (\\(Treeish i _ _) -> i) ts)) a ts\n\ntreeishSize :: Treeish a -> Int\ntreeishSize (Treeish i _ _) = i\n\ncapTreeish :: Int -> Treeish a -> Treeish a\ncapTreeish cap (Treeish i a ts)\n  | i <= cap = Treeish i a ts\n  | otherwise = Treeish cap a (go cap ts)\n  where\n    go _ [] = []\n    go remaining (x : xs) =\n      let x' = capTreeish remaining x\n          remaining' = remaining - treeishSize x'\n       in if remaining > 0\n            then x' : go remaining' xs\n            else [x']\n\ntreeishToList :: Treeish a -> [NonEmpty a]\ntreeishToList (Treeish _ a []) = [a :| []]\ntreeishToList (Treeish _ a xs) = map (a NE.<|) (concatMap treeishToList xs)\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/StorePath.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/NixTree/StorePath.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 11,
                "average": 3,
                "sum": 52
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 12,
              "lines_of_code": 445,
              "homplexity_lines_of_code": 446,
              "code_quality_score": 0,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 11,
                  "average": 3,
                  "sum": 52
                },
                "homplexity_loc": 446,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"mkNixStore\": 2,\n    \"unNixStore\": 2,\n    \"getStoreDir\": 3,\n    \"mkStoreName\": 3,\n    \"storeNameToText\": 1,\n    \"storeNameToPath\": 1,\n    \"storeNameToShortText\": 1,\n    \"storeNameToShortTextWithDisambiguation\": 2,\n    \"storeNameToSplitShortText\": 2,\n    \"getNixVersion\": 4,\n    \"getPathInfo\": 11,\n    \"withStoreEnv\": 2,\n    \"seLookup\": 2,\n    \"seAll\": 2,\n    \"seGetRoots\": 1,\n    \"seFetchRefs\": 3,\n    \"seBottomUp\": 2,\n    \"storeEnvToDot\": 1,\n    \"parse2_18\": 4,\n    \"parse2_19\": 3,\n    \"min\": 1,\n    \"max\": 11,\n    \"average\": 2.6,\n    \"sum\": 52\n  },\n  \"homplexity_loc\": 446,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.StorePath\n  ( StoreName (..),\n    storeNameToPath,\n    storeNameToText,\n    storeNameToShortText,\n    storeNameToSplitShortText,\n    storeNameToShortTextWithDisambiguation,\n    NixPathSignature (..),\n    StorePath (..),\n    Installable (..),\n    StoreEnv (..),\n    StoreEnvOptions (..),\n    withStoreEnv,\n    seLookup,\n    seAll,\n    seGetRoots,\n    seBottomUp,\n    seFetchRefs,\n    mkStoreName,\n    storeEnvToDot,\n  )\nwhere\n\nimport Data.Aeson (FromJSON (..), Value (..), decode, eitherDecode, (.!=), (.:), (.:?))\nimport qualified Data.Aeson.Key as K\nimport qualified Data.Aeson.KeyMap as KM\nimport Data.Aeson.Types (Parser)\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashSet as HS\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Dot\nimport System.FilePath.Posix (addTrailingPathSeparator, splitDirectories, (</>))\nimport System.IO (hPutStrLn)\nimport System.Process.Typed (proc, readProcessStdout_)\n\n-- Technically these both are filepaths. However, most people use the default \"/nix/store\",\n-- hence special casing it speeds things up.\ndata NixStore\n  = NixStore\n  | NixStoreCustom FilePath\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkNixStore :: FilePath -> NixStore\nmkNixStore i' =\n  let i = addTrailingPathSeparator i'\n   in if i == \"/nix/store/\" then NixStore else NixStoreCustom i\n\nunNixStore :: NixStore -> FilePath\nunNixStore NixStore = \"/nix/store/\"\nunNixStore (NixStoreCustom fp) = fp\n\ngetStoreDir :: Maybe FilePath -> IO NixStore\ngetStoreDir seoNixStore = do\n  let prog = \"nix-instantiate\"\n      args =\n        [\"--eval\", \"--expr\", \"(builtins.storeDir)\", \"--json\"]\n          ++ ( case seoNixStore of\n                 Nothing -> []\n                 Just url -> [\"--option\", \"store\", url]\n             )\n  out <-\n    readProcessStdout_ (proc prog args)\n      <&> fmap mkNixStore\n      . decode @FilePath\n  case out of\n    Nothing -> fail $ \"Error interpreting output of: \" ++ show (prog, args)\n    Just p -> return p\n\n--------------------------------------------------------------------------------\n\ndata StoreName = StoreName NixStore Text\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkStoreName :: NixStore -> FilePath -> Maybe StoreName\nmkStoreName ns path = do\n  let ps = unNixStore ns\n  guard $ ps `isPrefixOf` path\n  let ds = splitDirectories (drop (length ps) path)\n  sn <- listToMaybe ds\n  return $ StoreName ns (toText sn)\n\nstoreNameToText :: StoreName -> Text\nstoreNameToText (StoreName _ n) = n\n\nstoreNameToPath :: StoreName -> FilePath\nstoreNameToPath (StoreName ns sn) = unNixStore ns </> toString sn\n\nstoreNameToShortText :: StoreName -> Text\nstoreNameToShortText = snd . storeNameToSplitShortText\n\nstoreNameToShortTextWithDisambiguation :: Int -> StoreName -> Text\nstoreNameToShortTextWithDisambiguation 0 sn = storeNameToShortText sn\nstoreNameToShortTextWithDisambiguation n (StoreName ns sn) =\n  let (f, s) = storeNameToSplitShortText (StoreName ns sn)\n   in T.take n f <> \"...-\" <> s\n\nstoreNameToSplitShortText :: StoreName -> (Text, Text)\nstoreNameToSplitShortText txt =\n  case T.span (/= '-') $ storeNameToText txt of\n    (f, s) | Just (c, s'') <- T.uncons s -> (T.snoc f c, s'')\n    e -> e\n\n--------------------------------------------------------------------------------\n\ndata NixVersion\n  = NixOlder\n  | Nix2_4\n  | NixNewer\n  | NixUnknown\n  deriving (Show, Eq, Ord)\n\ngetNixVersion :: IO NixVersion\ngetNixVersion = do\n  out <- decodeUtf8 . BL.toStrict <$> readProcessStdout_ (proc \"nix\" [\"--version\"])\n\n  -- Parses strings like:\n  --  nix (Nix) 2.6.0pre20211217_6e6e998\n  --  nix (Nix) 2.5.1\n  return . fromMaybe NixUnknown $ do\n    -- get the last space delimited part\n    ver <-\n      out\n        & T.splitOn \" \"\n        & viaNonEmpty last\n\n    -- split by \".\", take the first two, and convert them to numbers\n    (major, minor) <- do\n      (maT, miT) <- case T.splitOn \".\" ver of\n        p1 : p2 : _ -> Just (p1, p2)\n        _ -> Nothing\n      ma <- readMaybe @Natural (toString maT)\n      mi <- readMaybe @Natural (toString miT)\n      return (ma, mi)\n\n    -- map it to the sum\n    return $ case compare (major, minor) (2, 4) of\n      LT -> NixOlder\n      EQ -> Nix2_4\n      GT -> NixNewer\n\n--------------------------------------------------------------------------------\n\ndata StorePath ref payload = StorePath\n  { spName :: StoreName,\n    spSize :: Int,\n    spRefs :: [ref],\n    spPayload :: payload,\n    spSignatures :: [NixPathSignature]\n  }\n  deriving (Show, Eq, Ord, Functor, Generic)\n\ninstance (NFData a, NFData b) => NFData (StorePath a b)\n\nnewtype Installable = Installable {installableToText :: Text}\n\n--------------------------------------------------------------------------------\n\ndata PathInfoOptions = PathInfoOptions\n  { pioIsRecursive :: Bool,\n    pioIsDerivation :: Bool,\n    pioIsImpure :: Bool,\n    pioStoreURL :: Maybe FilePath,\n    pioFile :: Maybe FilePath\n  }\n\ngetPathInfo :: NixStore -> NixVersion -> PathInfoOptions -> NonEmpty Installable -> IO (NonEmpty (StorePath StoreName ()))\ngetPathInfo nixStore nixVersion options names = do\n  infos <-\n    eitherDecode @NixPathOutput\n      <$> readProcessStdout_\n        ( proc\n            \"nix\"\n            ( [\"path-info\", \"--json\"]\n                ++ [\"--impure\" | options & pioIsImpure]\n                ++ [\"--recursive\" | options & pioIsRecursive]\n                ++ [\"--derivation\" | (options & pioIsDerivation) && nixVersion >= Nix2_4]\n                ++ ( case options & pioStoreURL of\n                       Nothing -> []\n                       Just url -> [\"--store\", url]\n                   )\n                ++ ( case options & pioFile of\n                       Nothing -> []\n                       Just file -> [\"--file\", file]\n                   )\n                ++ (if nixVersion >= Nix2_4 then [\"--extra-experimental-features\", \"nix-command flakes\"] else [])\n                ++ map (toString . installableToText) (toList names)\n            )\n        )\n      >>= either (\\e -> fail $ \"Failed parsing nix path-info output: \" ++ show e) return\n      >>= mapM assertValidInfo . npoResults\n      >>= maybe (fail \"invariant violation: getPathInfo returned []\") return . nonEmpty\n\n  mapM infoToStorePath infos\n  where\n    infoToStorePath NixPathInfo {npiPath, npiNarSize, npiReferences, npiSignatures} = do\n      name <- mkStoreNameIO npiPath\n      refs <- filter (/= name) <$> mapM mkStoreNameIO npiReferences\n      return $\n        StorePath\n          { spName = name,\n            spRefs = refs,\n            spSize = npiNarSize,\n            spSignatures = npiSignatures,\n            spPayload = ()\n          }\n    mkStoreNameIO p =\n      maybe\n        (fail $ \"Failed parsing Nix store path: \" ++ show p)\n        return\n        (mkStoreName nixStore p)\n\n    assertValidInfo (NixPathInfoValid pathinfo) = return pathinfo\n    assertValidInfo (NixPathInfoInvalid path) =\n      fail $ \"Invalid path: \" ++ path ++ \". Make sure that it is built, or pass '--derivation' if you want to work on the derivation.\"\n\n--------------------------------------------------------------------------------\n\ndata StoreEnv payload = StoreEnv\n  { sePaths :: HashMap StoreName (StorePath StoreName payload),\n    seRoots :: NonEmpty StoreName\n  }\n  deriving (Functor, Generic, NFData)\n\ndata StoreEnvOptions = StoreEnvOptions\n  { seoIsDerivation :: Bool,\n    seoIsImpure :: Bool,\n    seoStoreURL :: Maybe String,\n    seoFile :: Maybe String\n  }\n\nwithStoreEnv ::\n  forall m a.\n  (MonadIO m) =>\n  StoreEnvOptions ->\n  NonEmpty Installable ->\n  (StoreEnv () -> m a) ->\n  m a\nwithStoreEnv StoreEnvOptions {seoIsDerivation, seoIsImpure, seoStoreURL, seoFile} names cb = do\n  nixStore <- liftIO $ getStoreDir seoStoreURL\n\n  -- See: https://github.com/utdemir/nix-tree/issues/12\n  nixVersion <- liftIO getNixVersion\n\n  when (seoIsDerivation && nixVersion < Nix2_4) $\n    liftIO $\n      hPutStrLn stderr \"Warning: --derivation flag is ignored on Nix versions older than 2.4.\"\n\n  roots <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = False, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        names\n\n  paths <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = True, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        (Installable . toText . storeNameToPath . spName <$> roots)\n\n  let env =\n        StoreEnv\n          ( paths\n              & toList\n              & map (\\p@StorePath {spName} -> (spName, p))\n              & HM.fromList\n          )\n          (roots <&> spName)\n  cb env\n\nseLookup :: StoreEnv a -> StoreName -> StorePath StoreName a\nseLookup StoreEnv {sePaths} name =\n  fromMaybe\n    (error $ \"invariant violation, StoreName not found: \" <> show name)\n    (HM.lookup name sePaths)\n\nseAll :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseAll StoreEnv {sePaths} = case HM.elems sePaths of\n  [] -> error \"invariant violation: no paths\"\n  (x : xs) -> x :| xs\n\nseGetRoots :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseGetRoots env@StoreEnv {seRoots} =\n  fmap (seLookup env) seRoots\n\nseFetchRefs ::\n  StoreEnv a ->\n  (StoreName -> Bool) ->\n  NonEmpty StoreName ->\n  [StorePath StoreName a]\nseFetchRefs env predicate =\n  fst\n    . foldl'\n      (\\(acc, visited) name -> go acc visited name)\n      ([], HS.empty)\n  where\n    go acc visited name\n      | HS.member name visited = (acc, visited)\n      | not (predicate name) = (acc, visited)\n      | otherwise =\n          let sp@StorePath {spRefs} = seLookup env name\n           in foldl'\n                (\\(acc', visited') name' -> go acc' visited' name')\n                (sp : acc, HS.insert name visited)\n                spRefs\n\nseBottomUp ::\n  forall a b.\n  (StorePath (StorePath StoreName b) a -> b) ->\n  StoreEnv a ->\n  StoreEnv b\nseBottomUp f StoreEnv {sePaths, seRoots} =\n  StoreEnv\n    { sePaths = snd $ execState (mapM_ go seRoots) (sePaths, HM.empty),\n      seRoots\n    }\n  where\n    unsafeLookup k m =\n      fromMaybe\n        (error $ \"invariant violation: name doesn't exists: \" <> show k)\n        (HM.lookup k m)\n    go ::\n      StoreName ->\n      State\n        ( HashMap StoreName (StorePath StoreName a),\n          HashMap StoreName (StorePath StoreName b)\n        )\n        (StorePath StoreName b)\n    go name = do\n      processed <- gets snd\n      case name `HM.lookup` processed of\n        Just sp -> return sp\n        Nothing -> do\n          sp@StorePath {spName, spRefs} <- unsafeLookup name <$> gets fst\n          refs <- mapM go spRefs\n          let new = sp {spPayload = f sp {spRefs = refs}}\n          modify $ bimap (HM.delete spName) (HM.insert spName new)\n          return new\n\n--------------------------------------------------------------------------------\n\nstoreEnvToDot :: StoreEnv a -> Text\nstoreEnvToDot env =\n  seBottomUp go env\n    & seGetRoots\n    & toList\n    & map spPayload\n    & mconcat\n    & render\n  where\n    go sp =\n      fromList [Set.singleton (spName sp, spName ref) <> spPayload ref | ref <- spRefs sp]\n        & mconcat\n\n    render :: Set (StoreName, StoreName) -> Text\n    render edges =\n      Dot.DotGraph\n        Dot.Strict\n        Dot.Directed\n        Nothing\n        [ Dot.StatementEdge\n            ( Dot.EdgeStatement\n                (Dot.ListTwo (Dot.EdgeNode (mkNodeId from)) (Dot.EdgeNode (mkNodeId to)) [])\n                []\n            )\n          | (from, to) <- toList edges\n        ]\n        & Dot.encode\n\n    mkNodeId :: StoreName -> Dot.NodeId\n    mkNodeId = fromString . toString . storeNameToShortText\n\n--------------------------------------------------------------------------------\n\ndata NixPathInfo = NixPathInfo\n  { npiPath :: FilePath,\n    npiNarSize :: Int,\n    npiReferences :: [FilePath],\n    npiSignatures :: [NixPathSignature]\n  }\n\ndata NixPathSignature = NixPathSignature\n  { npsKeyName :: Text,\n    npsSignature :: Text\n  }\n  deriving (Show, Eq, Ord, NFData, Generic)\n\ninstance FromJSON NixPathSignature where\n  parseJSON (String t) =\n    case T.splitOn \":\" t of\n      [key, sig]\n        | not (T.null key) && not (T.null sig) ->\n            return $ NixPathSignature key sig\n      _ -> fail \"Expecting a string in the form of 'key:sig'.\"\n  parseJSON _ = fail \"Expecting a string.\"\n\ndata NixPathInfoResult\n  = NixPathInfoValid NixPathInfo\n  | NixPathInfoInvalid FilePath\n\nparse2_18 :: Value -> Parser NixPathInfoResult\nparse2_18 (Object obj) =\n  ( NixPathInfoValid\n      <$> ( NixPathInfo\n              <$> obj .: \"path\"\n              <*> obj .: \"narSize\"\n              <*> obj .: \"references\"\n              <*> (obj .:? \"signatures\" .!= [])\n          )\n  )\n    <|> ( do\n            path <- obj .: \"path\"\n            valid <- obj .: \"valid\"\n            guard (not valid)\n            return $ NixPathInfoInvalid path\n        )\nparse2_18 _ = fail \"Expecting an object.\"\n\nparse2_19 :: (FilePath, Value) -> Parser NixPathInfoResult\nparse2_19 (path, Object obj) =\n  NixPathInfoValid\n    <$> ( NixPathInfo\n            path\n            <$> obj .: \"narSize\"\n            <*> obj .: \"references\"\n            <*> (obj .:? \"signatures\" .!= [])\n        )\nparse2_19 (path, Null) = return $ NixPathInfoInvalid path\nparse2_19 (_, _) = fail \"Expecting an object or null\"\n\nnewtype NixPathOutput = NixPathOutput\n  { npoResults :: [NixPathInfoResult]\n  }\n\ninstance FromJSON NixPathOutput where\n  parseJSON (Array a) = NixPathOutput <$> mapM parse2_18 (toList a)\n  parseJSON (Object o) = NixPathOutput <$> mapM (parse2_19 . first K.toString) (KM.toList o)\n  parseJSON _ = fail \"Expecting an array (nix<=2.18) or an object with mapping from path to info (nix>=2.19).\"\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/NixTree/StorePath.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module NixTree.StorePath\n  ( StoreName (..),\n    storeNameToPath,\n    storeNameToText,\n    storeNameToShortText,\n    storeNameToSplitShortText,\n    storeNameToShortTextWithDisambiguation,\n    NixPathSignature (..),\n    StorePath (..),\n    Installable (..),\n    StoreEnv (..),\n    StoreEnvOptions (..),\n    withStoreEnv,\n    seLookup,\n    seAll,\n    seGetRoots,\n    seBottomUp,\n    seFetchRefs,\n    mkStoreName,\n    storeEnvToDot,\n  )\nwhere\n\nimport Data.Aeson (FromJSON (..), Value (..), decode, eitherDecode, (.!=), (.:), (.:?))\nimport qualified Data.Aeson.Key as K\nimport qualified Data.Aeson.KeyMap as KM\nimport Data.Aeson.Types (Parser)\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashSet as HS\nimport qualified Data.Set as Set\nimport qualified Data.Text as T\nimport qualified Dot\nimport System.FilePath.Posix (addTrailingPathSeparator, splitDirectories, (</>))\nimport System.IO (hPutStrLn)\nimport System.Process.Typed (proc, readProcessStdout_)\n\n-- Technically these both are filepaths. However, most people use the default \"/nix/store\",\n-- hence special casing it speeds things up.\ndata NixStore\n  = NixStore\n  | NixStoreCustom FilePath\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkNixStore :: FilePath -> NixStore\nmkNixStore i' =\n  let i = addTrailingPathSeparator i'\n   in if i == \"/nix/store/\" then NixStore else NixStoreCustom i\n\nunNixStore :: NixStore -> FilePath\nunNixStore NixStore = \"/nix/store/\"\nunNixStore (NixStoreCustom fp) = fp\n\ngetStoreDir :: Maybe FilePath -> IO NixStore\ngetStoreDir seoNixStore = do\n  let prog = \"nix-instantiate\"\n      args =\n        [\"--eval\", \"--expr\", \"(builtins.storeDir)\", \"--json\"]\n          ++ ( case seoNixStore of\n                 Nothing -> []\n                 Just url -> [\"--option\", \"store\", url]\n             )\n  out <-\n    readProcessStdout_ (proc prog args)\n      <&> fmap mkNixStore\n      . decode @FilePath\n  case out of\n    Nothing -> fail $ \"Error interpreting output of: \" ++ show (prog, args)\n    Just p -> return p\n\n--------------------------------------------------------------------------------\n\ndata StoreName = StoreName NixStore Text\n  deriving stock (Show, Eq, Ord, Generic)\n  deriving anyclass (NFData, Hashable)\n\nmkStoreName :: NixStore -> FilePath -> Maybe StoreName\nmkStoreName ns path = do\n  let ps = unNixStore ns\n  guard $ ps `isPrefixOf` path\n  let ds = splitDirectories (drop (length ps) path)\n  sn <- listToMaybe ds\n  return $ StoreName ns (toText sn)\n\nstoreNameToText :: StoreName -> Text\nstoreNameToText (StoreName _ n) = n\n\nstoreNameToPath :: StoreName -> FilePath\nstoreNameToPath (StoreName ns sn) = unNixStore ns </> toString sn\n\nstoreNameToShortText :: StoreName -> Text\nstoreNameToShortText = snd . storeNameToSplitShortText\n\nstoreNameToShortTextWithDisambiguation :: Int -> StoreName -> Text\nstoreNameToShortTextWithDisambiguation 0 sn = storeNameToShortText sn\nstoreNameToShortTextWithDisambiguation n (StoreName ns sn) =\n  let (f, s) = storeNameToSplitShortText (StoreName ns sn)\n   in T.take n f <> \"...-\" <> s\n\nstoreNameToSplitShortText :: StoreName -> (Text, Text)\nstoreNameToSplitShortText txt =\n  case T.span (/= '-') $ storeNameToText txt of\n    (f, s) | Just (c, s'') <- T.uncons s -> (T.snoc f c, s'')\n    e -> e\n\n--------------------------------------------------------------------------------\n\ndata NixVersion\n  = NixOlder\n  | Nix2_4\n  | NixNewer\n  | NixUnknown\n  deriving (Show, Eq, Ord)\n\ngetNixVersion :: IO NixVersion\ngetNixVersion = do\n  out <- decodeUtf8 . BL.toStrict <$> readProcessStdout_ (proc \"nix\" [\"--version\"])\n\n  -- Parses strings like:\n  --  nix (Nix) 2.6.0pre20211217_6e6e998\n  --  nix (Nix) 2.5.1\n  return . fromMaybe NixUnknown $ do\n    -- get the last space delimited part\n    ver <-\n      out\n        & T.splitOn \" \"\n        & viaNonEmpty last\n\n    -- split by \".\", take the first two, and convert them to numbers\n    (major, minor) <- do\n      (maT, miT) <- case T.splitOn \".\" ver of\n        p1 : p2 : _ -> Just (p1, p2)\n        _ -> Nothing\n      ma <- readMaybe @Natural (toString maT)\n      mi <- readMaybe @Natural (toString miT)\n      return (ma, mi)\n\n    -- map it to the sum\n    return $ case compare (major, minor) (2, 4) of\n      LT -> NixOlder\n      EQ -> Nix2_4\n      GT -> NixNewer\n\n--------------------------------------------------------------------------------\n\ndata StorePath ref payload = StorePath\n  { spName :: StoreName,\n    spSize :: Int,\n    spRefs :: [ref],\n    spPayload :: payload,\n    spSignatures :: [NixPathSignature]\n  }\n  deriving (Show, Eq, Ord, Functor, Generic)\n\ninstance (NFData a, NFData b) => NFData (StorePath a b)\n\nnewtype Installable = Installable {installableToText :: Text}\n\n--------------------------------------------------------------------------------\n\ndata PathInfoOptions = PathInfoOptions\n  { pioIsRecursive :: Bool,\n    pioIsDerivation :: Bool,\n    pioIsImpure :: Bool,\n    pioStoreURL :: Maybe FilePath,\n    pioFile :: Maybe FilePath\n  }\n\ngetPathInfo :: NixStore -> NixVersion -> PathInfoOptions -> NonEmpty Installable -> IO (NonEmpty (StorePath StoreName ()))\ngetPathInfo nixStore nixVersion options names = do\n  infos <-\n    eitherDecode @NixPathOutput\n      <$> readProcessStdout_\n        ( proc\n            \"nix\"\n            ( [\"path-info\", \"--json\"]\n                ++ [\"--impure\" | options & pioIsImpure]\n                ++ [\"--recursive\" | options & pioIsRecursive]\n                ++ [\"--derivation\" | (options & pioIsDerivation) && nixVersion >= Nix2_4]\n                ++ ( case options & pioStoreURL of\n                       Nothing -> []\n                       Just url -> [\"--store\", url]\n                   )\n                ++ ( case options & pioFile of\n                       Nothing -> []\n                       Just file -> [\"--file\", file]\n                   )\n                ++ (if nixVersion >= Nix2_4 then [\"--extra-experimental-features\", \"nix-command flakes\"] else [])\n                ++ map (toString . installableToText) (toList names)\n            )\n        )\n      >>= either (\\e -> fail $ \"Failed parsing nix path-info output: \" ++ show e) return\n      >>= mapM assertValidInfo . npoResults\n      >>= maybe (fail \"invariant violation: getPathInfo returned []\") return . nonEmpty\n\n  mapM infoToStorePath infos\n  where\n    infoToStorePath NixPathInfo {npiPath, npiNarSize, npiReferences, npiSignatures} = do\n      name <- mkStoreNameIO npiPath\n      refs <- filter (/= name) <$> mapM mkStoreNameIO npiReferences\n      return $\n        StorePath\n          { spName = name,\n            spRefs = refs,\n            spSize = npiNarSize,\n            spSignatures = npiSignatures,\n            spPayload = ()\n          }\n    mkStoreNameIO p =\n      maybe\n        (fail $ \"Failed parsing Nix store path: \" ++ show p)\n        return\n        (mkStoreName nixStore p)\n\n    assertValidInfo (NixPathInfoValid pathinfo) = return pathinfo\n    assertValidInfo (NixPathInfoInvalid path) =\n      fail $ \"Invalid path: \" ++ path ++ \". Make sure that it is built, or pass '--derivation' if you want to work on the derivation.\"\n\n--------------------------------------------------------------------------------\n\ndata StoreEnv payload = StoreEnv\n  { sePaths :: HashMap StoreName (StorePath StoreName payload),\n    seRoots :: NonEmpty StoreName\n  }\n  deriving (Functor, Generic, NFData)\n\ndata StoreEnvOptions = StoreEnvOptions\n  { seoIsDerivation :: Bool,\n    seoIsImpure :: Bool,\n    seoStoreURL :: Maybe String,\n    seoFile :: Maybe String\n  }\n\nwithStoreEnv ::\n  forall m a.\n  (MonadIO m) =>\n  StoreEnvOptions ->\n  NonEmpty Installable ->\n  (StoreEnv () -> m a) ->\n  m a\nwithStoreEnv StoreEnvOptions {seoIsDerivation, seoIsImpure, seoStoreURL, seoFile} names cb = do\n  nixStore <- liftIO $ getStoreDir seoStoreURL\n\n  -- See: https://github.com/utdemir/nix-tree/issues/12\n  nixVersion <- liftIO getNixVersion\n\n  when (seoIsDerivation && nixVersion < Nix2_4) $\n    liftIO $\n      hPutStrLn stderr \"Warning: --derivation flag is ignored on Nix versions older than 2.4.\"\n\n  roots <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = False, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        names\n\n  paths <-\n    liftIO $\n      getPathInfo\n        nixStore\n        nixVersion\n        (PathInfoOptions {pioIsDerivation = seoIsDerivation, pioIsRecursive = True, pioIsImpure = seoIsImpure, pioStoreURL = seoStoreURL, pioFile = seoFile})\n        (Installable . toText . storeNameToPath . spName <$> roots)\n\n  let env =\n        StoreEnv\n          ( paths\n              & toList\n              & map (\\p@StorePath {spName} -> (spName, p))\n              & HM.fromList\n          )\n          (roots <&> spName)\n  cb env\n\nseLookup :: StoreEnv a -> StoreName -> StorePath StoreName a\nseLookup StoreEnv {sePaths} name =\n  fromMaybe\n    (error $ \"invariant violation, StoreName not found: \" <> show name)\n    (HM.lookup name sePaths)\n\nseAll :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseAll StoreEnv {sePaths} = case HM.elems sePaths of\n  [] -> error \"invariant violation: no paths\"\n  (x : xs) -> x :| xs\n\nseGetRoots :: StoreEnv a -> NonEmpty (StorePath StoreName a)\nseGetRoots env@StoreEnv {seRoots} =\n  fmap (seLookup env) seRoots\n\nseFetchRefs ::\n  StoreEnv a ->\n  (StoreName -> Bool) ->\n  NonEmpty StoreName ->\n  [StorePath StoreName a]\nseFetchRefs env predicate =\n  fst\n    . foldl'\n      (\\(acc, visited) name -> go acc visited name)\n      ([], HS.empty)\n  where\n    go acc visited name\n      | HS.member name visited = (acc, visited)\n      | not (predicate name) = (acc, visited)\n      | otherwise =\n          let sp@StorePath {spRefs} = seLookup env name\n           in foldl'\n                (\\(acc', visited') name' -> go acc' visited' name')\n                (sp : acc, HS.insert name visited)\n                spRefs\n\nseBottomUp ::\n  forall a b.\n  (StorePath (StorePath StoreName b) a -> b) ->\n  StoreEnv a ->\n  StoreEnv b\nseBottomUp f StoreEnv {sePaths, seRoots} =\n  StoreEnv\n    { sePaths = snd $ execState (mapM_ go seRoots) (sePaths, HM.empty),\n      seRoots\n    }\n  where\n    unsafeLookup k m =\n      fromMaybe\n        (error $ \"invariant violation: name doesn't exists: \" <> show k)\n        (HM.lookup k m)\n    go ::\n      StoreName ->\n      State\n        ( HashMap StoreName (StorePath StoreName a),\n          HashMap StoreName (StorePath StoreName b)\n        )\n        (StorePath StoreName b)\n    go name = do\n      processed <- gets snd\n      case name `HM.lookup` processed of\n        Just sp -> return sp\n        Nothing -> do\n          sp@StorePath {spName, spRefs} <- unsafeLookup name <$> gets fst\n          refs <- mapM go spRefs\n          let new = sp {spPayload = f sp {spRefs = refs}}\n          modify $ bimap (HM.delete spName) (HM.insert spName new)\n          return new\n\n--------------------------------------------------------------------------------\n\nstoreEnvToDot :: StoreEnv a -> Text\nstoreEnvToDot env =\n  seBottomUp go env\n    & seGetRoots\n    & toList\n    & map spPayload\n    & mconcat\n    & render\n  where\n    go sp =\n      fromList [Set.singleton (spName sp, spName ref) <> spPayload ref | ref <- spRefs sp]\n        & mconcat\n\n    render :: Set (StoreName, StoreName) -> Text\n    render edges =\n      Dot.DotGraph\n        Dot.Strict\n        Dot.Directed\n        Nothing\n        [ Dot.StatementEdge\n            ( Dot.EdgeStatement\n                (Dot.ListTwo (Dot.EdgeNode (mkNodeId from)) (Dot.EdgeNode (mkNodeId to)) [])\n                []\n            )\n          | (from, to) <- toList edges\n        ]\n        & Dot.encode\n\n    mkNodeId :: StoreName -> Dot.NodeId\n    mkNodeId = fromString . toString . storeNameToShortText\n\n--------------------------------------------------------------------------------\n\ndata NixPathInfo = NixPathInfo\n  { npiPath :: FilePath,\n    npiNarSize :: Int,\n    npiReferences :: [FilePath],\n    npiSignatures :: [NixPathSignature]\n  }\n\ndata NixPathSignature = NixPathSignature\n  { npsKeyName :: Text,\n    npsSignature :: Text\n  }\n  deriving (Show, Eq, Ord, NFData, Generic)\n\ninstance FromJSON NixPathSignature where\n  parseJSON (String t) =\n    case T.splitOn \":\" t of\n      [key, sig]\n        | not (T.null key) && not (T.null sig) ->\n            return $ NixPathSignature key sig\n      _ -> fail \"Expecting a string in the form of 'key:sig'.\"\n  parseJSON _ = fail \"Expecting a string.\"\n\ndata NixPathInfoResult\n  = NixPathInfoValid NixPathInfo\n  | NixPathInfoInvalid FilePath\n\nparse2_18 :: Value -> Parser NixPathInfoResult\nparse2_18 (Object obj) =\n  ( NixPathInfoValid\n      <$> ( NixPathInfo\n              <$> obj .: \"path\"\n              <*> obj .: \"narSize\"\n              <*> obj .: \"references\"\n              <*> (obj .:? \"signatures\" .!= [])\n          )\n  )\n    <|> ( do\n            path <- obj .: \"path\"\n            valid <- obj .: \"valid\"\n            guard (not valid)\n            return $ NixPathInfoInvalid path\n        )\nparse2_18 _ = fail \"Expecting an object.\"\n\nparse2_19 :: (FilePath, Value) -> Parser NixPathInfoResult\nparse2_19 (path, Object obj) =\n  NixPathInfoValid\n    <$> ( NixPathInfo\n            path\n            <$> obj .: \"narSize\"\n            <*> obj .: \"references\"\n            <*> (obj .:? \"signatures\" .!= [])\n        )\nparse2_19 (path, Null) = return $ NixPathInfoInvalid path\nparse2_19 (_, _) = fail \"Expecting an object or null\"\n\nnewtype NixPathOutput = NixPathOutput\n  { npoResults :: [NixPathInfoResult]\n  }\n\ninstance FromJSON NixPathOutput where\n  parseJSON (Array a) = NixPathOutput <$> mapM parse2_18 (toList a)\n  parseJSON (Object o) = NixPathOutput <$> mapM (parse2_19 . first K.toString) (KM.toList o)\n  parseJSON _ = fail \"Expecting an array (nix<=2.18) or an object with mapping from path to info (nix>=2.19).\"\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/Data/InvertedIndex.hs",
              "refactored_file_name": "/tmp/project_92/static_refactored/src/Data/InvertedIndex.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 1,
              "lines_of_code": 76,
              "homplexity_lines_of_code": 76,
              "code_quality_score": 68.4,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 12
                },
                "homplexity_loc": 76,
                "homplexity_output": "{\n  \"cyclomatic_complexity\": {\n    \"iiInsert\": 1,\n    \"iiFromList\": 1,\n    \"setToMap\": 1,\n    \"unigramsOf\": 1,\n    \"bigramsOf\": 2,\n    \"trigramsOf\": 2,\n    \"iiSearch\": 4,\n    \"min\": 1,\n    \"max\": 4,\n    \"average\": 1.7142857142857142,\n    \"sum\": 12\n  },\n  \"homplexity_loc\": 76,\n  \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module Data.InvertedIndex\n  ( InvertedIndex,\n    iiFromList,\n    iiInsert,\n    iiSearch,\n  )\nwhere\n\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport qualified Data.Text as Text\n\ndata InvertedIndex a = InvertedIndex\n  { iiElems :: Map Text a,\n    iiUnigrams :: Map Char (Set Text),\n    iiBigrams :: Map (Char, Char) (Set Text),\n    iiTrigrams :: Map (Char, Char, Char) (Set Text)\n  }\n  deriving (Generic, Show)\n\ninstance (NFData a) => NFData (InvertedIndex a)\n\niiInsert :: Text -> a -> InvertedIndex a -> InvertedIndex a\niiInsert txt val InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams} =\n  InvertedIndex\n    { iiElems = Map.insert txt val iiElems,\n      iiUnigrams = combine iiUnigrams (unigramsOf txt),\n      iiBigrams = combine iiBigrams (bigramsOf txt),\n      iiTrigrams = combine iiTrigrams (trigramsOf txt)\n    }\n  where\n    combine orig chrs =\n      Map.unionWith\n        (<>)\n        orig\n        (setToMap (Set.singleton txt) chrs)\n\niiFromList :: (Foldable f) => f (Text, a) -> InvertedIndex a\niiFromList =\n  foldl'\n    (flip (uncurry iiInsert))\n    (InvertedIndex Map.empty Map.empty Map.empty Map.empty)\n\nsetToMap :: v -> Set k -> Map k v\nsetToMap v = Map.fromDistinctAscList . map (,v) . Set.toAscList\n\nunigramsOf :: Text -> Set Char\nunigramsOf = Set.fromList . Text.unpack . Text.toLower\n\nbigramsOf :: Text -> Set (Char, Char)\nbigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2) -> Set.fromList $ zip p1 p2\n  _ -> Set.empty\n\ntrigramsOf :: Text -> Set (Char, Char, Char)\ntrigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2@(_ : p3)) -> Set.fromList $ zip3 p1 p2 p3\n  _ -> Set.empty\n\niiSearch :: forall a. Text -> InvertedIndex a -> Map Text a\niiSearch txt InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams}\n  | Text.length txt == 0 = iiElems\n  | Text.length txt == 1 = using unigramsOf iiUnigrams\n  | Text.length txt == 2 = using bigramsOf iiBigrams\n  | otherwise = using trigramsOf iiTrigrams\n  where\n    lowerTxt = Text.toLower txt\n    using :: (Ord c) => (Text -> Set c) -> Map c (Set Text) -> Map Text a\n    using getGrams m =\n      Map.intersection m (setToMap () (getGrams txt))\n        & Map.elems\n        & \\case\n          [] -> Set.empty\n          x : xs -> foldl' Set.intersection x xs\n        & Set.filter (\\t -> lowerTxt `Text.isInfixOf` Text.toLower t)\n        & Map.restrictKeys iiElems\n",
              "suggestions": [
                {
                  "location": "/tmp/project_92/pre_refactor/src/Data/InvertedIndex.hs",
                  "suggestion_title": "No suggestions",
                  "found_block": [
                    "-- Manual candidate snippet"
                  ],
                  "perhaps_block": []
                }
              ],
              "refactored_code": "module Data.InvertedIndex\n  ( InvertedIndex,\n    iiFromList,\n    iiInsert,\n    iiSearch,\n  )\nwhere\n\nimport qualified Data.Map as Map\nimport qualified Data.Set as Set\nimport qualified Data.Text as Text\n\ndata InvertedIndex a = InvertedIndex\n  { iiElems :: Map Text a,\n    iiUnigrams :: Map Char (Set Text),\n    iiBigrams :: Map (Char, Char) (Set Text),\n    iiTrigrams :: Map (Char, Char, Char) (Set Text)\n  }\n  deriving (Generic, Show)\n\ninstance (NFData a) => NFData (InvertedIndex a)\n\niiInsert :: Text -> a -> InvertedIndex a -> InvertedIndex a\niiInsert txt val InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams} =\n  InvertedIndex\n    { iiElems = Map.insert txt val iiElems,\n      iiUnigrams = combine iiUnigrams (unigramsOf txt),\n      iiBigrams = combine iiBigrams (bigramsOf txt),\n      iiTrigrams = combine iiTrigrams (trigramsOf txt)\n    }\n  where\n    combine orig chrs =\n      Map.unionWith\n        (<>)\n        orig\n        (setToMap (Set.singleton txt) chrs)\n\niiFromList :: (Foldable f) => f (Text, a) -> InvertedIndex a\niiFromList =\n  foldl'\n    (flip (uncurry iiInsert))\n    (InvertedIndex Map.empty Map.empty Map.empty Map.empty)\n\nsetToMap :: v -> Set k -> Map k v\nsetToMap v = Map.fromDistinctAscList . map (,v) . Set.toAscList\n\nunigramsOf :: Text -> Set Char\nunigramsOf = Set.fromList . Text.unpack . Text.toLower\n\nbigramsOf :: Text -> Set (Char, Char)\nbigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2) -> Set.fromList $ zip p1 p2\n  _ -> Set.empty\n\ntrigramsOf :: Text -> Set (Char, Char, Char)\ntrigramsOf txt = case Text.unpack (Text.toLower txt) of\n  p1@(_ : p2@(_ : p3)) -> Set.fromList $ zip3 p1 p2 p3\n  _ -> Set.empty\n\niiSearch :: forall a. Text -> InvertedIndex a -> Map Text a\niiSearch txt InvertedIndex {iiElems, iiUnigrams, iiBigrams, iiTrigrams}\n  | Text.length txt == 0 = iiElems\n  | Text.length txt == 1 = using unigramsOf iiUnigrams\n  | Text.length txt == 2 = using bigramsOf iiBigrams\n  | otherwise = using trigramsOf iiTrigrams\n  where\n    lowerTxt = Text.toLower txt\n    using :: (Ord c) => (Text -> Set c) -> Map c (Set Text) -> Map Text a\n    using getGrams m =\n      Map.intersection m (setToMap () (getGrams txt))\n        & Map.elems\n        & \\case\n          [] -> Set.empty\n          x : xs -> foldl' Set.intersection x xs\n        & Set.filter (\\t -> lowerTxt `Text.isInfixOf` Text.toLower t)\n        & Map.restrictKeys iiElems\n"
            }
          ]
        },
        "chain_of_thought": {}
      },
      "llm_only": {
        "zero_shot": {},
        "one_shot": {},
        "chain_of_thought": {}
      },
      "hybrid": {
        "zero_shot": {},
        "one_shot": {
          "overall": {
            "cyclomatic_complexity": {
              "min": 4,
              "max": 12,
              "average": 11.333333333333334,
              "sum": 34
            },
            "hlint_suggestions": {
              "error": 2,
              "warning": 0,
              "suggestion": 0,
              "ignore": 0,
              "total": 2
            },
            "syntax_errors": 11,
            "lines_of_code": 409,
            "homplexity_lines_of_code": 409,
            "code_quality_score": 0,
            "test_coverage": 80,
            "performance": {
              "memory_usage": "160.9MB",
              "runtime": "0.998 × 10⁹ ns/iteration"
            },
            "security_vulnerabilities": 2
          },
          "files": [
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Clipboard.hs",
              "refactored_file_name": "/tmp/project_92/hybrid_refactored/src/NixTree/Clipboard.hs",
              "cyclomatic_complexity": {
                "min": 2,
                "max": 5,
                "average": 4,
                "sum": 7
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 1,
              "lines_of_code": 39,
              "homplexity_lines_of_code": 39,
              "code_quality_score": 82.1,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 2,
                  "max": 5,
                  "average": 4,
                  "sum": 7
                },
                "homplexity_loc": 39,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"runCmd\": 5,\n        \"copy\": 2,\n        \"min\": 2,\n        \"max\": 5,\n        \"average\": 3.5,\n        \"sum\": 7\n    },\n    \"homplexity_loc\": 39,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.Clipboard\n  ( copy,\n  )\nwhere\n\nimport Control.Exception (try)\nimport System.Exit\nimport qualified System.Process.Typed as P\nimport System.Timeout\n\ncmds :: [(FilePath, [String])]\ncmds =\n  [ (\"xsel\", [\"-i\", \"-b\"]),\n    (\"xclip\", [\"-selection\", \"clipboard\"]),\n    (\"wl-copy\", []),\n    (\"pbcopy\", [])\n  ]\n\nrunCmd :: Text -> (FilePath, [String]) -> IO (Either Text ())\nrunCmd txt (cmd, args) =\n  P.proc (toString cmd) (map toString args)\n    & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n    & P.runProcess\n    & timeout 1_000_000\n    & try\n    <&> \\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e)) ->\n        Left $ \"failed with exit code \" <> show e\n      Right Nothing ->\n        Left $ \"timed out\"\n      Left (ex :: SomeException) ->\n        Left $ \"failed with exception: \" <> show ex\n    <&> \\case\n      Right () -> Right ()\n      Left err -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")\n\ncopy :: Text -> IO (Either [Text] ())\ncopy txt = go cmds []\n  where\n    go [] errs = return $ Left errs\n    go (x : xs) errs =\n      runCmd txt x >>= \\case\n        Right () -> return $ Right ()\n        Left err -> go xs (err : errs)\n",
              "suggestions": [
                {
                  "target_snippet": "copy txt = go cmds []\n  where\n    go [] errs = return $ Left errs\n    go (x : xs) errs =\n      runCmd txt x >>= \\case\n        Right () -> return $ Right ()\n        Left err -> go xs (err : errs)",
                  "refactored_suggestion": "copy txt = foldrM (\\x errs -> either (const $ return (Left (err : errs))) (const $ return (Right ())) =<< runCmd txt x) [] cmds",
                  "confidence": 0.8,
                  "justification": "The `go` function defined inside `copy` can be refactored into a more concise and cleaner implementation using `foldrM`. This avoids explicit recursion and makes the intent more readable for developers familiar with monadic combinators."
                },
                {
                  "target_snippet": "\"pbcopy\", []",
                  "refactored_suggestion": "-- reason: dead code, this command is specific for the macOS, if this is not on a cross-platform application, it can be safely removed.",
                  "confidence": 0.6,
                  "justification": "`pbcopy` might be unnecessary and specific to macOS. If this is not required for cross-platform compatibility or specific macOS implementations, it can be safely removed to clean up the list of commands, reducing cognitive overhead when maintaining the code."
                },
                {
                  "target_snippet": "& timeout 1_000_000",
                  "refactored_suggestion": "& timeout 1_000_000 :: Maybe (Either SomeException ExitCode)",
                  "confidence": 1.0,
                  "justification": "Adding a type signature clarifies exactly what type the operation `timeout` will return. This explicitness helps downstream developers understand its behavior better and avoids potential type-ambiguity issues."
                }
              ],
              "refactored_code": "module NixTree.Clipboard\n  ( copy,\n  )\nwhere\n\nimport Control.Exception (try)\nimport System.Exit\nimport qualified System.Process.Typed as P\nimport System.Timeout\n\ncmds :: [(FilePath, [String])]\ncmds =\n  [ (\"xsel\", [\"-i\", \"-b\"]),\n    (\"xclip\", [\"-selection\", \"clipboard\"]),\n    (\"wl-copy\", []),\n    (-- reason: dead code, this command is specific for the macOS, if this is not on a cross-platform application, it can be safely removed.)\n  ]\n\nrunCmd :: Text -> (FilePath, [String]) -> IO (Either Text ())\nrunCmd txt (cmd, args) =\n  P.proc (toString cmd) (map toString args)\n    & P.setStdin (P.byteStringInput $ encodeUtf8 txt)\n    & P.runProcess\n    & timeout 1_000_000 :: Maybe (Either SomeException ExitCode)\n    & try\n    <&> \\case\n      Right (Just ExitSuccess) -> Right ()\n      Right (Just (ExitFailure e)) ->\n        Left $ \"failed with exit code \" <> show e\n      Right Nothing ->\n        Left $ \"timed out\"\n      Left (ex :: SomeException) ->\n        Left $ \"failed with exception: \" <> show ex\n    <&> \\case\n      Right () -> Right ()\n      Left err -> Left (\"Running \" <> show (cmd, args) <> \" \" <> err <> \".\")\n\ncopy :: Text -> IO (Either [Text] ())\ncopy txt = foldrM (\\x errs -> either (const $ return (Left (err : errs))) (const $ return (Right ())) =<< runCmd txt x) [] cmds\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/Main.hs",
              "refactored_file_name": "/tmp/project_92/hybrid_refactored/src/NixTree/Main.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 4,
                "average": 2,
                "sum": 12
              },
              "hlint_suggestions": {
                "error": 0,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 0
              },
              "syntax_errors": 8,
              "lines_of_code": 158,
              "homplexity_lines_of_code": 158,
              "code_quality_score": 60.2,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 4,
                  "average": 2,
                  "sum": 12
                },
                "homplexity_loc": 158,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"version\": 1,\n        \"optsParser\": 1,\n        \"parser\": 1,\n        \"keybindingsHelp\": 1,\n        \"showAndFail\": 1,\n        \"isValidRoot\": 2,\n        \"main\": 4,\n        \"chunks\": 1,\n        \"min\": 1,\n        \"max\": 4,\n        \"average\": 1.5,\n        \"sum\": 12\n    },\n    \"homplexity_loc\": 158,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "{-# LANGUAGE CPP #-}\n\nmodule Main where\n\nimport Control.Concurrent.Async\nimport Control.Exception (evaluate)\nimport NixTree.App\nimport NixTree.PathStats\nimport qualified Options.Applicative as Opts\nimport qualified Options.Applicative.Help.Pretty as Opts\nimport System.Directory (XdgDirectory (XdgState), doesDirectoryExist, getHomeDirectory, getXdgDirectory, pathIsSymbolicLink)\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((</>))\nimport System.IO (hPutStrLn)\nimport System.ProgressBar hiding (msg)\n\nversion :: Text\nversion = VERSION_nix_tree\n\ndata Opts = Opts\n  { oInstallables :: [Installable],\n    oStore :: Maybe String,\n    oFile :: Maybe FilePath,\n    oVersion :: Bool,\n    oDerivation :: Bool,\n    oImpure :: Bool,\n    oDot :: Bool\n  }\n\noptsParser :: Opts.ParserInfo Opts\noptsParser =\n  Opts.info (parser <**> Opts.helper) $\n    mconcat\n      [ Opts.progDesc \"Interactively browse dependency graphs of Nix derivations.\",\n        Opts.fullDesc,\n        Opts.footerDoc (Just keybindingsHelp)\n      ]\n  where\n    parser :: Opts.Parser Opts\n    parser =\n      Opts\n        <$> many\n          ( Installable\n              <$> Opts.strArgument @Text\n                ( Opts.metavar \"INSTALLABLE\"\n                    <> Opts.helpDoc\n                      ( Just $\n                          Opts.vsep\n                            [ \"A store path or a flake reference.\",\n                              \"Paths default to \\\"~/.nix-profile\\\" and \\\"/var/run/current-system\\\"\"\n                            ]\n                      )\n                )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"store\"\n                  <> Opts.metavar \"STORE\"\n                  <> Opts.helpDoc\n                    ( Just $\n                        Opts.vsep\n                          [ \"The URL of the Nix store, e.g. \\\"daemon\\\" or \\\"https://cache.nixos.org\\\"\",\n                            \"See \\\"nix help-stores\\\" for supported store types and settings.\"\n                          ]\n                    )\n              )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"file\"\n                  <> Opts.metavar \"FILE\"\n                  <> Opts.helpDoc\n                    ( Just $ Opts.vsep [\"Interpret installables as attribute paths relative to the Nix expression stored in file.\"]\n                    )\n              )\n          )\n        <*> Opts.switch (Opts.long \"version\" <> Opts.help \"Show the nix-tree version\")\n        <*> Opts.switch (Opts.long \"derivation\" <> Opts.help \"Operate on the store derivation rather than its outputs\")\n        <*> Opts.switch (Opts.long \"impure\" <> Opts.help \"Allow access to mutable paths and repositories\")\n        <*> Opts.switch (Opts.long \"dot\" <> Opts.help \"Print the dependency graph in dot format\")\n\n    keybindingsHelp :: Opts.Doc\n    keybindingsHelp =\n      Opts.vsep\n        [ \"Keybindings:\",\n          Opts.indent 2 . Opts.vsep $ map Opts.pretty (lines helpText)\n        ]\n\nshowAndFail :: Text -> IO a\nshowAndFail msg = do\n  hPutStrLn stderr . toString $ \"Error: \" <> msg\n  exitWith (ExitFailure 1)\n\nisValidRoot :: FilePath -> IO Bool\nisValidRoot path = do\n  isExistingDirectory <- doesDirectoryExist path\n  if isExistingDirectory\n    then -- We need to check that it's a symlink (presumably to nix store),\n    -- because if it is just a directory, nix will try to interpret it as a flake.\n    -- We do doesDirectoryExist before pathIsSymbolicLink,\n    -- because the latter will fail if the path does not exist.\n      pathIsSymbolicLink path\n    else return False\n\nmain :: IO ()\nmain = do\n  opts <-\n    Opts.customExecParser\n      (Opts.prefs $ Opts.columns 120)\n      optsParser\n\n  when (opts & oVersion) $ do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess\n\n  installables <- case opts & oInstallables of\n    p : ps ->\n      return $ p :| ps\n    [] -> do\n      home <- getHomeDirectory\n      nixXdgDirectory <- getXdgDirectory XdgState \"nix/profile\"\n      homeManagerDirectory <- getXdgDirectory XdgState \"nix/profiles/home-manager\"\n      roots <-\n        filterM\n          isValidRoot\n          [ home </> \".nix-profile\",\n            nixXdgDirectory,\n            homeManagerDirectory,\n            \"/var/run/current-system\"\n          ]\n      case roots of\n        [] -> showAndFail \"No store path given.\"\n        p : ps -> return . fmap (Installable . toText) $ p :| ps\n\n  let seo =\n        StoreEnvOptions\n          { seoIsDerivation = opts & oDerivation,\n            seoIsImpure = opts & oImpure,\n            seoStoreURL = opts & oStore,\n            seoFile = opts & oFile\n          }\n\n  withStoreEnv seo installables $ \\env' -> do\n    let env = calculatePathStats env'\n        allPaths = seAll env\n\n    bar <- newProgressBar defStyle {stylePostfix = exact} 4 (Progress 0 (length allPaths) ())\n    allPaths\n      & toList\n      & chunks 50\n      & mapConcurrently_ (mapM_ (\\p -> evaluate (rnf p) >> incProgress bar 1))\n\n    if opts & oDot\n      then putTextLn $ storeEnvToDot env\n      else run env\n\nchunks :: Int -> [a] -> [[a]]\nchunks _ [] = []\nchunks n xs =\n  let (ys, zs) = splitAt n xs\n   in ys : chunks n zs\n",
              "suggestions": [
                {
                  "target_snippet": "sumList [] = 0\nsumList (x : xs) = x + sumList xs",
                  "refactored_suggestion": "sumList xs = foldr (+) 0 xs",
                  "confidence": 1.0,
                  "justification": "Using `foldr` improves readability and conciseness of the code. The recursive pattern is standard and foldr is a higher-level abstraction that performs the same operation effectively."
                },
                {
                  "target_snippet": "when (opts & oVersion) $ do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess",
                  "refactored_suggestion": "for_ (opts & oVersion) $ \\_ -> do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess",
                  "confidence": 0.8,
                  "justification": "Using `for_` from `Control.Monad` simplifies conditional execution in cases like this, making the code more idiomatic and in line with modern Haskell practices."
                },
                {
                  "target_snippet": "-- We need to check that it's a symlink (presumably to nix store),\n-- because if it is just a directory, nix will try to interpret it as a flake.\n-- We do doesDirectoryExist before pathIsSymbolicLink,\n-- because the latter will fail if the path does not exist.",
                  "refactored_suggestion": "-- The check ensures compatibility with symlinked nix paths, avoiding misinterpretation as flake directories. Check order avoids failure on non-existent paths.",
                  "confidence": 0.9,
                  "justification": "Streamlining the comment for improved clarity while retaining its original meaning. This makes it more concise and ease of understanding for other contributors."
                },
                {
                  "target_snippet": "chunks :: Int -> [a] -> [[a]]\nchunks _ [] = []\nchunks n xs =\n  let (ys, zs) = splitAt n xs\n   in ys : chunks n zs",
                  "refactored_suggestion": "chunks :: Int -> [a] -> [[a]]\nchunks n = takeWhile (not . null) . map (take n) . iterate (drop n)",
                  "confidence": 0.95,
                  "justification": "Using a point-free style approach with `iterate` and `map` simplifies the logic of splitting a list into chunks of specified size. It improves conciseness and may result in better performance on lazy lists."
                }
              ],
              "refactored_code": "{-# LANGUAGE CPP #-}\n\nmodule Main where\n\nimport Control.Concurrent.Async\nimport Control.Exception (evaluate)\nimport NixTree.App\nimport NixTree.PathStats\nimport qualified Options.Applicative as Opts\nimport qualified Options.Applicative.Help.Pretty as Opts\nimport System.Directory (XdgDirectory (XdgState), doesDirectoryExist, getHomeDirectory, getXdgDirectory, pathIsSymbolicLink)\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((</>))\nimport System.IO (hPutStrLn)\nimport System.ProgressBar hiding (msg)\n\nversion :: Text\nversion = VERSION_nix_tree\n\ndata Opts = Opts\n  { oInstallables :: [Installable],\n    oStore :: Maybe String,\n    oFile :: Maybe FilePath,\n    oVersion :: Bool,\n    oDerivation :: Bool,\n    oImpure :: Bool,\n    oDot :: Bool\n  }\n\noptsParser :: Opts.ParserInfo Opts\noptsParser =\n  Opts.info (parser <**> Opts.helper) $\n    mconcat\n      [ Opts.progDesc \"Interactively browse dependency graphs of Nix derivations.\",\n        Opts.fullDesc,\n        Opts.footerDoc (Just keybindingsHelp)\n      ]\n  where\n    parser :: Opts.Parser Opts\n    parser =\n      Opts\n        <$> many\n          ( Installable\n              <$> Opts.strArgument @Text\n                ( Opts.metavar \"INSTALLABLE\"\n                    <> Opts.helpDoc\n                      ( Just $\n                          Opts.vsep\n                            [ \"A store path or a flake reference.\",\n                              \"Paths default to \\\"~/.nix-profile\\\" and \\\"/var/run/current-system\\\"\"\n                            ]\n                      )\n                )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"store\"\n                  <> Opts.metavar \"STORE\"\n                  <> Opts.helpDoc\n                    ( Just $\n                        Opts.vsep\n                          [ \"The URL of the Nix store, e.g. \\\"daemon\\\" or \\\"https://cache.nixos.org\\\"\",\n                            \"See \\\"nix help-stores\\\" for supported store types and settings.\"\n                          ]\n                    )\n              )\n          )\n        <*> optional\n          ( Opts.strOption\n              ( Opts.long \"file\"\n                  <> Opts.metavar \"FILE\"\n                  <> Opts.helpDoc\n                    ( Just $ Opts.vsep [\"Interpret installables as attribute paths relative to the Nix expression stored in file.\"]\n                    )\n              )\n          )\n        <*> Opts.switch (Opts.long \"version\" <> Opts.help \"Show the nix-tree version\")\n        <*> Opts.switch (Opts.long \"derivation\" <> Opts.help \"Operate on the store derivation rather than its outputs\")\n        <*> Opts.switch (Opts.long \"impure\" <> Opts.help \"Allow access to mutable paths and repositories\")\n        <*> Opts.switch (Opts.long \"dot\" <> Opts.help \"Print the dependency graph in dot format\")\n\n    keybindingsHelp :: Opts.Doc\n    keybindingsHelp =\n      Opts.vsep\n        [ \"Keybindings:\",\n          Opts.indent 2 . Opts.vsep $ map Opts.pretty (lines helpText)\n        ]\n\nshowAndFail :: Text -> IO a\nshowAndFail msg = do\n  hPutStrLn stderr . toString $ \"Error: \" <> msg\n  exitWith (ExitFailure 1)\n\nisValidRoot :: FilePath -> IO Bool\nisValidRoot path = do\n  isExistingDirectory <- doesDirectoryExist path\n  if isExistingDirectory\n    then -- We need to check that it's a symlink (presumably to nix store),\n    -- because if it is just a directory, nix will try to interpret it as a flake.\n    -- We do doesDirectoryExist before pathIsSymbolicLink,\n    -- because the latter will fail if the path does not exist.\n      pathIsSymbolicLink path\n    else return False\n\nmain :: IO ()\nmain = do\n  opts <-\n    Opts.customExecParser\n      (Opts.prefs $ Opts.columns 120)\n      optsParser\n\n  for_ (opts & oVersion) $ \\_ -> do\n    putTextLn $ \"nix-tree \" <> version\n    exitSuccess\n\n  installables <- case opts & oInstallables of\n    p : ps ->\n      return $ p :| ps\n    [] -> do\n      home <- getHomeDirectory\n      nixXdgDirectory <- getXdgDirectory XdgState \"nix/profile\"\n      homeManagerDirectory <- getXdgDirectory XdgState \"nix/profiles/home-manager\"\n      roots <-\n        filterM\n          isValidRoot\n          [ home </> \".nix-profile\",\n            nixXdgDirectory,\n            homeManagerDirectory,\n            \"/var/run/current-system\"\n          ]\n      case roots of\n        [] -> showAndFail \"No store path given.\"\n        p : ps -> return . fmap (Installable . toText) $ p :| ps\n\n  let seo =\n        StoreEnvOptions\n          { seoIsDerivation = opts & oDerivation,\n            seoIsImpure = opts & oImpure,\n            seoStoreURL = opts & oStore,\n            seoFile = opts & oFile\n          }\n\n  withStoreEnv seo installables $ \\env' -> do\n    let env = calculatePathStats env'\n        allPaths = seAll env\n\n    bar <- newProgressBar defStyle {stylePostfix = exact} 4 (Progress 0 (length allPaths) ())\n    allPaths\n      & toList\n      & chunks 50\n      & mapConcurrently_ (mapM_ (\\p -> evaluate (rnf p) >> incProgress bar 1))\n\n    if opts & oDot\n      then putTextLn $ storeEnvToDot env\n      else run env\n\nchunks :: Int -> [a] -> [[a]]\nchunks n = takeWhile (not . null) . map (take n) . iterate (drop n)\n"
            },
            {
              "file_name": "/tmp/project_92/pre_refactor/src/NixTree/PathStats.hs",
              "refactored_file_name": "/tmp/project_92/hybrid_refactored/src/NixTree/PathStats.hs",
              "cyclomatic_complexity": {
                "min": 1,
                "max": 3,
                "average": 2,
                "sum": 15
              },
              "hlint_suggestions": {
                "error": 1,
                "warning": 0,
                "suggestion": 0,
                "ignore": 0,
                "total": 1
              },
              "syntax_errors": 2,
              "lines_of_code": 212,
              "homplexity_lines_of_code": 212,
              "code_quality_score": 48.8,
              "test_coverage": 80,
              "performance": {
                "memory_usage": "10MB",
                "runtime": "0.5s"
              },
              "security_vulnerabilities": 0,
              "homplexity_analysis": {
                "cyclomatic_complexity": {
                  "min": 1,
                  "max": 3,
                  "average": 2,
                  "sum": 15
                },
                "homplexity_loc": 212,
                "homplexity_output": "{\n    \"cyclomatic_complexity\": {\n        \"mkIntermediateEnv\": 2,\n        \"mkFinalEnv\": 1,\n        \"calculatePathStats\": 1,\n        \"shortestPathTo\": 3,\n        \"whyDepends\": 2,\n        \"mkTreeish\": 1,\n        \"treeishSize\": 1,\n        \"capTreeish\": 2,\n        \"treeishToList\": 2,\n        \"min\": 1,\n        \"max\": 3,\n        \"average\": 1.67,\n        \"sum\": 15\n    },\n    \"homplexity_loc\": 212,\n    \"homplexity_output\": \"\"\n}"
              },
              "original_code": "module NixTree.PathStats\n  ( PathStats (..),\n    calculatePathStats,\n    whyDepends,\n    shortestPathTo,\n    module NixTree.StorePath,\n  )\nwhere\n\nimport Data.List (minimumBy)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map.Lazy as M\nimport qualified Data.Set as S\nimport NixTree.StorePath\n\ndata IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }\n\ndata PathStats = PathStats\n  { psTotalSize :: !Int,\n    psAddedSize :: !Int,\n    psImmediateParents :: [StoreName],\n    psDisambiguationChars :: !Int\n  }\n  deriving (Show, Generic, NFData)\n\nmkIntermediateEnv ::\n  (StoreName -> Bool) ->\n  StoreEnv () ->\n  StoreEnv IntermediatePathStats\nmkIntermediateEnv env =\n  seBottomUp $ \\curr ->\n    IntermediatePathStats\n      { ipsAllRefs =\n          M.unions\n            ( M.fromList\n                [ (spName, void sp)\n                  | sp@StorePath {spName} <- spRefs curr,\n                    env spName\n                ]\n                : map (ipsAllRefs . spPayload) (spRefs curr)\n            )\n      }\n\nmkFinalEnv :: StoreEnv IntermediatePathStats -> StoreEnv PathStats\nmkFinalEnv env =\n  let totalSize = calculateEnvSize env\n      immediateParents = calculateImmediateParents (sePaths env)\n      disambiguationChars = seDisambiguationChars env\n   in flip seBottomUp env $ \\StorePath {spName, spSize, spPayload} ->\n        let filteredSize =\n              seFetchRefs env (/= spName) (seRoots env)\n                & calculateRefsSize\n            addedSize = totalSize - filteredSize\n         in PathStats\n              { psTotalSize =\n                  spSize\n                    + calculateRefsSize (ipsAllRefs spPayload),\n                psAddedSize = addedSize,\n                psImmediateParents =\n                  maybe [] S.toList $ M.lookup spName immediateParents,\n                psDisambiguationChars =\n                  M.lookup spName disambiguationChars\n                    & maybe 0 id\n              }\n  where\n    calculateEnvSize :: StoreEnv IntermediatePathStats -> Int\n    calculateEnvSize e =\n      seGetRoots e\n        & toList\n        & map\n          ( \\sp@StorePath {spName, spPayload} ->\n              M.insert\n                spName\n                (void sp)\n                (ipsAllRefs spPayload)\n          )\n        & M.unions\n        & calculateRefsSize\n    calculateRefsSize :: (Functor f, Foldable f) => f (StorePath a b) -> Int\n    calculateRefsSize = sum . fmap spSize\n    calculateImmediateParents ::\n      (Foldable f) =>\n      f (StorePath StoreName b) ->\n      M.Map StoreName (S.Set StoreName)\n    calculateImmediateParents =\n      foldl'\n        ( \\m StorePath {spName, spRefs} ->\n            M.unionWith\n              (<>)\n              m\n              (M.fromList (map (,S.singleton spName) spRefs))\n        )\n        M.empty\n\n    seShortNames :: StoreEnv a -> M.Map Text [StoreName]\n    seShortNames env =\n      let paths = seAll env & toList\n       in foldl'\n            ( \\m StorePath {spName} ->\n                let (_, shortName) = storeNameToSplitShortText spName\n                 in M.alter\n                      ( \\case\n                          Nothing -> Just [spName]\n                          Just xs -> Just (spName : xs)\n                      )\n                      shortName\n                      m\n            )\n            M.empty\n            paths\n\n    seDisambiguationChars :: StoreEnv a -> M.Map StoreName Int\n    seDisambiguationChars env =\n      M.toList (seShortNames env)\n        & map snd\n        & concatMap\n          ( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          )\n        & M.fromList\n\n    disambiguate :: [StoreName] -> Int\n    disambiguate xs = go 0\n      where\n        go n =\n          if isGood n\n            then n\n            else go (n + 2)\n\n        isGood n =\n          xs\n            & map (storeNameToShortTextWithDisambiguation n)\n            & allUnique\n\n        allUnique xx =\n          let unique = S.fromList xx\n           in length unique == length xx\n\ncalculatePathStats :: StoreEnv () -> StoreEnv PathStats\ncalculatePathStats = mkFinalEnv . mkIntermediateEnv (const True)\n\n-- TODO: This can be precomputed.\nshortestPathTo :: StoreEnv a -> StoreName -> NonEmpty (StorePath StoreName a)\nshortestPathTo env name =\n  seBottomUp\n    ( \\curr ->\n        let currOut = curr {spRefs = spName <$> spRefs curr}\n         in if spName curr == name\n              then Just (1 :: Int, currOut :| [])\n              else\n                mapMaybe spPayload (spRefs curr)\n                  & \\case\n                    [] -> Nothing\n                    xs -> case minimumBy (comparing fst) xs of\n                      (c, p) -> Just (c + 1, currOut NE.<| p)\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & minimumBy (comparing fst)\n    & snd\n    & NE.reverse\n\n-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node contains a set of paths which represent\n-- the why-depends output from that node down. The set of paths is represented as a \"Treeish\" object,\n-- which is a trie-like structure.\nwhyDepends :: forall a. StoreEnv a -> StoreName -> [NonEmpty (StorePath StoreName a)]\nwhyDepends env name =\n  seBottomUp @_ @(Maybe (Treeish (StorePath StoreName a)))\n    ( \\curr ->\n        if spName curr == name\n          then Just $ mkTreeish (curr {spRefs = map spName (spRefs curr)}) []\n          else\n            mapMaybe spPayload (spRefs curr)\n              & NE.nonEmpty\n              <&> NE.toList\n              <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})\n              <&> capTreeish 1_000_000\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & take 10000\n    & concatMap treeishToList\n\n-- A trie-like structure which also caches the size.\ndata Treeish a = Treeish Int a [Treeish a]\n\nmkTreeish :: a -> [Treeish a] -> Treeish a\nmkTreeish a ts = Treeish (1 + sum (map (\\(Treeish i _ _) -> i) ts)) a ts\n\ntreeishSize :: Treeish a -> Int\ntreeishSize (Treeish i _ _) = i\n\ncapTreeish :: Int -> Treeish a -> Treeish a\ncapTreeish cap (Treeish i a ts)\n  | i <= cap = Treeish i a ts\n  | otherwise = Treeish cap a (go cap ts)\n  where\n    go _ [] = []\n    go remaining (x : xs) =\n      let x' = capTreeish remaining x\n          remaining' = remaining - treeishSize x'\n       in if remaining > 0\n            then x' : go remaining' xs\n            else [x']\n\ntreeishToList :: Treeish a -> [NonEmpty a]\ntreeishToList (Treeish _ a []) = [a :| []]\ntreeishToList (Treeish _ a xs) = map (a NE.<|) (concatMap treeishToList xs)\n",
              "suggestions": [
                {
                  "target_snippet": "data IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }",
                  "refactored_suggestion": "newtype IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }",
                  "confidence": 0.9,
                  "justification": "Using `newtype` instead of `data` here improves performance by reducing unnecessary laziness and memory overhead when only a single constructor is used."
                },
                {
                  "target_snippet": "M.toList (seShortNames env) & map snd\n        & concatMap\n          ( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          )",
                  "refactored_suggestion": "concatMap\n  ((\\xs -> let chrs = disambiguate xs in map (\\x -> (x, chrs)) xs)\n     . snd)\n  (M.toList (seShortNames env))",
                  "confidence": 0.85,
                  "justification": "This change fuses the `map` and `concatMap` into a single `concatMap` operation for better readability and performance."
                },
                {
                  "target_snippet": "-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node contains a set of paths which represent\n-- the why-depends output from that node down. The set of paths is represented as a \"Treeish\" object,\n-- which is a trie-like structure.",
                  "refactored_suggestion": "-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node processes a set of paths representing\n-- the why-depends output from that node down, utilizing a trie-like Treeish structure to cache size efficiently.",
                  "confidence": 0.8,
                  "justification": "Refactored the comments for clarity and conciseness to make them more informative for users unfamiliar with the structure."
                },
                {
                  "target_snippet": "disambiguate xs = go 0\n      where\n        go n =\n          if isGood n\n            then n\n            else go (n + 2)\n\n        isGood n =\n          xs\n            & map (storeNameToShortTextWithDisambiguation n)\n            & allUnique\n\n        allUnique xx =\n          let unique = S.fromList xx\n           in length unique == length xx",
                  "refactored_suggestion": "disambiguate xs = findDisambiguation 0\n  where\n    findDisambiguation n\n      | isDisambiguationGood n = n\n      | otherwise = findDisambiguation (n + 2)\n\n    isDisambiguationGood n =\n      let uniqueNames = xs & map (storeNameToShortTextWithDisambiguation n) & S.fromList\n       in S.size uniqueNames == length xs",
                  "confidence": 0.85,
                  "justification": "Improved readability and clarity of the `disambiguate` function by more intuitive naming and eliminating nested definitions where possible."
                }
              ],
              "refactored_code": "module NixTree.PathStats\n  ( PathStats (..),\n    calculatePathStats,\n    whyDepends,\n    shortestPathTo,\n    module NixTree.StorePath,\n  )\nwhere\n\nimport Data.List (minimumBy)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Map.Lazy as M\nimport qualified Data.Set as S\nimport NixTree.StorePath\n\nnewtype IntermediatePathStats = IntermediatePathStats\n  { ipsAllRefs :: M.Map StoreName (StorePath StoreName ())\n  }\n\ndata PathStats = PathStats\n  { psTotalSize :: !Int,\n    psAddedSize :: !Int,\n    psImmediateParents :: [StoreName],\n    psDisambiguationChars :: !Int\n  }\n  deriving (Show, Generic, NFData)\n\nmkIntermediateEnv ::\n  (StoreName -> Bool) ->\n  StoreEnv () ->\n  StoreEnv IntermediatePathStats\nmkIntermediateEnv env =\n  seBottomUp $ \\curr ->\n    IntermediatePathStats\n      { ipsAllRefs =\n          M.unions\n            ( M.fromList\n                [ (spName, void sp)\n                  | sp@StorePath {spName} <- spRefs curr,\n                    env spName\n                ]\n                : map (ipsAllRefs . spPayload) (spRefs curr)\n            )\n      }\n\nmkFinalEnv :: StoreEnv IntermediatePathStats -> StoreEnv PathStats\nmkFinalEnv env =\n  let totalSize = calculateEnvSize env\n      immediateParents = calculateImmediateParents (sePaths env)\n      disambiguationChars = seDisambiguationChars env\n   in flip seBottomUp env $ \\StorePath {spName, spSize, spPayload} ->\n        let filteredSize =\n              seFetchRefs env (/= spName) (seRoots env)\n                & calculateRefsSize\n            addedSize = totalSize - filteredSize\n         in PathStats\n              { psTotalSize =\n                  spSize\n                    + calculateRefsSize (ipsAllRefs spPayload),\n                psAddedSize = addedSize,\n                psImmediateParents =\n                  maybe [] S.toList $ M.lookup spName immediateParents,\n                psDisambiguationChars =\n                  M.lookup spName disambiguationChars\n                    & maybe 0 id\n              }\n  where\n    calculateEnvSize :: StoreEnv IntermediatePathStats -> Int\n    calculateEnvSize e =\n      seGetRoots e\n        & toList\n        & map\n          ( \\sp@StorePath {spName, spPayload} ->\n              M.insert\n                spName\n                (void sp)\n                (ipsAllRefs spPayload)\n          )\n        & M.unions\n        & calculateRefsSize\n    calculateRefsSize :: (Functor f, Foldable f) => f (StorePath a b) -> Int\n    calculateRefsSize = sum . fmap spSize\n    calculateImmediateParents ::\n      (Foldable f) =>\n      f (StorePath StoreName b) ->\n      M.Map StoreName (S.Set StoreName)\n    calculateImmediateParents =\n      foldl'\n        ( \\m StorePath {spName, spRefs} ->\n            M.unionWith\n              (<>)\n              m\n              (M.fromList (map (,S.singleton spName) spRefs))\n        )\n        M.empty\n\n    seShortNames :: StoreEnv a -> M.Map Text [StoreName]\n    seShortNames env =\n      let paths = seAll env & toList\n       in foldl'\n            ( \\m StorePath {spName} ->\n                let (_, shortName) = storeNameToSplitShortText spName\n                 in M.alter\n                      ( \\case\n                          Nothing -> Just [spName]\n                          Just xs -> Just (spName : xs)\n                      )\n                      shortName\n                      m\n            )\n            M.empty\n            paths\n\n    seDisambiguationChars :: StoreEnv a -> M.Map StoreName Int\n    seDisambiguationChars env =\n      M.toList (seShortNames env)\n        & map snd\n        & concatMap\n          ( \\xs ->\n              let chrs = disambiguate xs\n               in map (\\x -> (x, chrs)) xs\n          )\n        & M.fromList\n\n    disambiguate :: [StoreName] -> Int\n    disambiguate xs = findDisambiguation 0\n  where\n    findDisambiguation n\n      | isDisambiguationGood n = n\n      | otherwise = findDisambiguation (n + 2)\n\n    isDisambiguationGood n =\n      let uniqueNames = xs & map (storeNameToShortTextWithDisambiguation n) & S.fromList\n       in S.size uniqueNames == length xs\n\ncalculatePathStats :: StoreEnv () -> StoreEnv PathStats\ncalculatePathStats = mkFinalEnv . mkIntermediateEnv (const True)\n\n-- TODO: This can be precomputed.\nshortestPathTo :: StoreEnv a -> StoreName -> NonEmpty (StorePath StoreName a)\nshortestPathTo env name =\n  seBottomUp\n    ( \\curr ->\n        let currOut = curr {spRefs = spName <$> spRefs curr}\n         in if spName curr == name\n              then Just (1 :: Int, currOut :| [])\n              else\n                mapMaybe spPayload (spRefs curr)\n                  & \\case\n                    [] -> Nothing\n                    xs -> case minimumBy (comparing fst) xs of\n                      (c, p) -> Just (c + 1, currOut NE.<| p)\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & minimumBy (comparing fst)\n    & snd\n    & NE.reverse\n\n-- Why depends implementation\n\n-- We iterate the dependency graph bottom up. Every node processes a set of paths representing\n-- the why-depends output from that node down, utilizing a trie-like Treeish structure to cache size efficiently.\nwhyDepends :: forall a. StoreEnv a -> StoreName -> [NonEmpty (StorePath StoreName a)]\nwhyDepends env name =\n  seBottomUp @_ @(Maybe (Treeish (StorePath StoreName a)))\n    ( \\curr ->\n        if spName curr == name\n          then Just $ mkTreeish (curr {spRefs = map spName (spRefs curr)}) []\n          else\n            mapMaybe spPayload (spRefs curr)\n              & NE.nonEmpty\n              <&> NE.toList\n              <&> mkTreeish (curr {spRefs = map spName (spRefs curr)})\n              <&> capTreeish 1_000_000\n    )\n    env\n    & seGetRoots\n    & fmap spPayload\n    & NE.toList\n    & catMaybes\n    & take 10000\n    & concatMap treeishToList\n\n-- A trie-like structure which also caches the size.\ndata Treeish a = Treeish Int a [Treeish a]\n\nmkTreeish :: a -> [Treeish a] -> Treeish a\nmkTreeish a ts = Treeish (1 + sum (map (\\(Treeish i _ _) -> i) ts)) a ts\n\ntreeishSize :: Treeish a -> Int\ntreeishSize (Treeish i _ _) = i\n\ncapTreeish :: Int -> Treeish a -> Treeish a\ncapTreeish cap (Treeish i a ts)\n  | i <= cap = Treeish i a ts\n  | otherwise = Treeish cap a (go cap ts)\n  where\n    go _ [] = []\n    go remaining (x : xs) =\n      let x' = capTreeish remaining x\n          remaining' = remaining - treeishSize x'\n       in if remaining > 0\n            then x' : go remaining' xs\n            else [x']\n\ntreeishToList :: Treeish a -> [NonEmpty a]\ntreeishToList (Treeish _ a []) = [a :| []]\ntreeishToList (Treeish _ a xs) = map (a NE.<|) (concatMap treeishToList xs)\n"
            }
          ]
        },
        "chain_of_thought": {}
      }
    }
  }
}